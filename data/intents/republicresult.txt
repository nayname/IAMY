{
    "messages": [
        {
            "content": "Introduction to Republic\nRepublic is a decentralized blockchain platform designed to securely coordinate a network of compute providers\u2014called validators\u2014who supply verifiable computational resources to power next-generation decentralized applications.\n\nUnlike traditional blockchains that rely solely on transaction validation, Republic elevates compute to a first-class network asset, enabling the permissionless exchange and validation of high-performance compute power. This integration facilitates a novel cryptoeconomic marketplace where computational work is measured, validated, and rewarded transparently.\n\nProtocol Overview\nAt its core, Republic combines a Delegated Proof-of-Stake (DPoS) consensus mechanism with a rigorous compute validation protocol. Validators are selected based on a hybrid metric of delegated stake and verified compute quality, ensuring the network\u2019s security and scalability depend both on economic commitment and demonstrated computational reliability.\n\nValidators execute assigned compute jobs and submit proofs of correct execution based on standardized benchmarks. These benchmarks measure throughput, inference capability, and achieved FLOPS, providing objective metrics that feed into validator reputation and reward calculations.\n\nCryptoeconomic Model\nThe Republic economic design aligns incentives to foster network integrity and performance. Validators stake the native token, REP, to participate in consensus and compute provisioning. In return, they earn rewards proportional to their validated compute contributions and stake.\n\nThe system enforces slashing penalties for validator misbehavior, such as producing incorrect results or exhibiting downtime, reducing their staked tokens and reputation scores. Reputation acts as a persistent measure of validator trustworthiness, influencing future committee selection and rewards.\n\nKey Concepts\nValidators: Network participants who provide compute resources, stake tokens, and secure the network.\nNative Token (REP): Utility token used for staking, paying for compute, and distributing rewards.\nCompute Validation: A set of verifiable benchmarks and proofs ensuring that submitted compute results are correct and performant.\nDelegated Proof-of-Stake (DPoS): Consensus protocol where token holders elect validators weighted by stake and compute quality.\nSlashing and Reputation: Mechanisms to penalize misbehavior and track validator reliability over time.\nDocument Structure\nThis documentation provides a comprehensive understanding of Republic\u2019s architecture and operation, divided into:\n\nGeneral Documentation: Protocol design, compute validation, consensus, incentives, and security.\nValidator Documentation: Tools, best practices, and workflows for validator operation. (Coming soon)\nClient Documentation: APIs and user guides for submitting compute jobs and interacting with the network. (Coming soon)\nThis documentation aims to serve as a reference for developers, validators, researchers, and stakeholders engaged in the Republic ecosystem.\n\nCompute Validation Overview\nIntroduction\nThe Republic compute validation protocol establishes a robust and verifiable mechanism for confirming that computational tasks are performed honestly and efficiently by network validators. Unlike traditional blockchains, which primarily focus on transactional consensus, Republic places compute at the core of its consensus and economic incentives, making the quality and integrity of computation a first-class concern.\n\nThis protocol enables the network to:\n\nSchedule computational jobs securely and transparently.\nValidate the results of these jobs through cryptographic proofs and benchmarks.\nIncentivize reliable and performant compute providers via economic rewards and reputation.\nProtect the network against fraud and degraded performance using slashing and quality controls.\nThe following sections provide an in-depth examination of the components, flow, and cryptoeconomic mechanisms that comprise the compute validation protocol.\n\nJob Scheduling and Execution\nAt the heart of the protocol is the process by which computational tasks (jobs) are scheduled and executed by validators.\n\nJob Definition: Each job specifies a computational workload, such as matrix multiplication benchmarks or neural network inference tasks.\nScheduling: Jobs are delegated to validators through a decentralized scheduler that considers stake, past performance, and compute quality.\nExecution: Validators run the assigned computations within predefined time constraints and generate outputs alongside cryptographic proofs of execution.\nThis process ensures that computation is timely, traceable, and attributable to specific validators.\n\nCryptographic Proofs of Computation\nTo guarantee the authenticity of computation, Republic employs cryptographic proofs tied to the execution of models.\n\nHashedModel Framework: Validators run computations using a HashedModel that generates intermediate checkpoint hashes reflecting the model\u2019s internal state during execution.\nRoot Hash Generation: These checkpoint hashes are aggregated into a root hash, uniquely identifying the entire computation.\nVerification: Validators submit this root hash alongside outputs; verifiers re-execute the computation to reproduce checkpoints and confirm hash correctness.\nThis proof mechanism binds the computation\u2019s correctness and integrity cryptographically, preventing forgery or shortcuts.\n\nBenchmarking for Quality and Performance\nRepublic leverages three complementary benchmarks to objectively measure compute quality:\n\nThroughput Benchmark: Measures the validator's ability to perform large-scale matrix multiplications accurately and rapidly.\nInference Benchmark: Tests the validator\u2019s execution of transformer-based sequence inference models to assess realistic model execution capacity.\nAchieved FLOPs Benchmark: Calculates effective floating-point operations per second (FLOPS) by timing a fixed-complexity model execution, providing a real-world performance metric.\nValidators\u2019 benchmark results determine their reputation and influence their eligibility to participate in consensus committees.\n\nReputation and Economic Incentives\nThe protocol links compute quality to economic incentives:\n\nReputation Scores: Computed from benchmark results and job performance, representing the validator\u2019s reliability and efficiency.\nToken Rewards: Validators earn native tokens (REP) proportionally to their reputation and successful job completion.\nSlashing: Validators who submit incorrect or delayed computations risk token slashing, disincentivizing dishonest or poor-quality work.\nThis framework encourages validators to maintain high standards of compute integrity and throughput.\n\nValidator Selection and Consensus Participation\nValidator reputation and compute benchmarks feed directly into the consensus mechanism:\n\nValidators with higher reputation and benchmark scores have increased probability to be selected for consensus committees.\nThis ensures that blocks and state transitions are secured by participants demonstrating both economic stake and verifiable compute power.\nThe protocol thereby aligns network security with genuine compute contribution.\nFraud Prevention and Quality Assurance\nTo safeguard the network, the protocol implements multiple layers of fraud detection:\n\nRe-execution Verification: Validators\u2019 submitted results and hashes are independently re-executed by verifiers to detect discrepancies.\nSlashing Conditions: Failures in correctness, timing, or proof submission trigger automatic slashing penalties.\nOngoing Benchmark Validation: Validators undergo periodic re-benchmarking to prevent performance degradation over time.\nTogether, these measures preserve the network\u2019s integrity and trustworthiness.\n\nProof of Model Execution\nConcept\nProof of Model Execution (PoME) is the cryptographic mechanism by which Republic verifies that a validator has correctly executed a computational task. This proof is built around a specialized structure called the HashedModel, which captures the state of the model at multiple checkpoints during execution.\n\nHashedModel and Checkpoints\nThe HashedModel enhances a neural network model to:\n\nProduce deterministic intermediate checkpoints during inference or computation.\nCompute cryptographic hashes of these checkpoint states.\nAggregate these checkpoint hashes into a single root hash that uniquely represents the full model execution.\nVerification Process\nTo verify a proof, verifiers re-execute the model on the provided inputs, computing the checkpoint hashes at each step.\nBy reproducing these hashes and combining them, verifiers reconstruct the root hash.\nThe computed root hash is then compared with the submitted proof hash to confirm correctness.\nThis re-execution step is essential; it ensures that the proof corresponds precisely to the computation performed, preventing fraudulent claims without actual compute.\n\nCurrent Status and Future Work\nAt present, the protocol primarily relies on benchmark timing and output correctness for validation. Integration of full checkpoint-based proof verification is planned, which will enable distributed, scalable validation through partial checkpoint verification by multiple parties.\n\nBenefits\nCryptographic integrity: The root hash binds the computation\u2019s entire execution history.\nReproducibility: Verification through re-execution ensures computations are deterministic and honest.\nScalability potential: Checkpoint hashes can be distributed for parallel verification.\n\nProtocol Overview\nIntroduction\nThe Republic protocol is architected to securely and efficiently coordinate a decentralized network of validators that provide high-quality compute resources. At its core, the protocol combines a Delegated Proof-of-Stake (DPoS) consensus mechanism with cryptoeconomic incentives and robust validation techniques, enabling a scalable and trustworthy compute marketplace.\n\nThis section provides a comprehensive overview of the core protocol components, governance structure, and security mechanisms that underpin the network's operation.\n\nCore Components\nDelegated Proof-of-Stake (DPoS)\nRepublic utilizes a Delegated Proof-of-Stake consensus protocol in which token holders elect a committee of validators responsible for producing blocks, validating transactions, and securing the network. This design balances decentralization with high throughput and fast finality, ensuring the network can scale while remaining secure.\n\nValidators are selected based on a combination of their delegated stake and verified compute performance, linking economic commitment with demonstrated computational reliability.\n\nValidator Roles and Responsibilities\nValidators serve as the backbone of the Republic network, performing critical tasks including:\n\nValidating and proposing new blocks\nExecuting and verifying compute jobs submitted by clients\nParticipating in consensus committees\nMaintaining up-to-date software and hardware to meet performance benchmarks\nTheir effective operation directly impacts network security, performance, and user trust.\n\nSlashing and Accountability\nTo safeguard the network against misbehavior and negligence, the protocol incorporates slashing mechanisms that penalize validators for infractions such as downtime, incorrect computations, or equivocation. Slashed tokens are burned or redistributed, ensuring economic consequences for harmful actions.\n\nThe slashing process is complemented by a reputation system that tracks validator reliability over time, influencing future committee selections and reward allocations.\n\nReputation System\nThe reputation system quantifies validator trustworthiness and performance history, aggregating benchmark scores, job success rates, and slashing records. Validators with higher reputation scores gain preferential treatment in consensus participation and reward distribution, incentivizing sustained excellence.\n\nCryptoeconomic Incentives\nRepublic's economic design aligns validator interests with network health through staking rewards, compute performance bonuses, and job completion incentives. These mechanisms encourage validators to invest in superior infrastructure and operate honestly, fostering a competitive yet cooperative ecosystem.\n\nSecurity and Resilience\nRepublic is designed with layered security features to resist common blockchain attacks and ensure continuous operation, including:\n\nCryptographic proof of compute correctness\nValidator selection diversity\nPenalties for misbehavior\nCheckpointing and finality guarantees\nThese elements collectively maintain network integrity and user confidence.\n\nConcensus Mechanism\nOverview\nRepublic employs a Delegated Proof of Stake (DPoS) consensus mechanism to secure the network, finalize blocks, and select validators responsible for consensus committees. This consensus protocol balances security, scalability, and decentralization through token-weighted voting and cryptoeconomic incentives.\n\nToken Holder Delegation\nToken holders participate indirectly in consensus by delegating their staking power to trusted validators:\n\nDelegators select validators based on past performance, reputation, and service quality.\nVoting power is weighted proportionally to the amount of stake delegated.\nValidator sets are dynamically updated each epoch based on accumulated stake.\nThis delegation system enables a scalable and efficient validator election process, preserving decentralization without sacrificing throughput.\n\nValidator Roles and Responsibilities\nValidators in Republic perform critical functions including:\n\nProposing new blocks and transactions.\nVoting on block validity and network state transitions.\nParticipating in cryptographic randomness generation.\nExecuting and verifying computational tasks where required.\nValidators are expected to maintain high uptime, honest behavior, and quality service to earn rewards and maintain their reputation.\n\nConsensus Committees and Epochs\nEpoch selection diagram\n\nThe validator set is partitioned into consensus committees:\n\nCommittees are reshuffled periodically (each epoch) to prevent collusion.\nEach committee validates blocks and finalizes state transitions.\nValidator selection within committees considers both stake and verified compute quality.\nEpoch transitions are marked by checkpoint blocks that record committee composition and stake distributions.\n\nFinality and Security Guarantees\nRepublic\u2019s DPoS consensus provides probabilistic finality with strong security assumptions:\n\nFault tolerance threshold ensures system safety unless a majority of stake is malicious.\nSlashing conditions penalize malicious or negligent validators, deterring attacks.\nCheckpointing and consensus rounds ensure network progress and prevent forks.\nThe consensus design prioritizes liveness and consistency under adversarial conditions.\n\nSummary\nThe DPoS consensus mechanism empowers Republic to maintain a secure, scalable, and decentralized network by combining stake-based voting with compute-weighted validator selection. It underpins the network\u2019s cryptoeconomic security model and aligns incentives for honest participation.\n\nValidator Incentives\nOverview\nRepublic\u2019s validator incentives are designed to motivate honest, high-quality participation while fostering a competitive yet cooperative environment. These incentives align validator economic interests with the network\u2019s long-term security, performance, and decentralization objectives.\n\nValidators earn rewards for contributing compute resources, securing consensus, and providing reliable service, while being subject to penalties for misbehavior.\n\nReward Components\n1. Staking Rewards\nValidators receive staking rewards proportional to their delegated stake and reputation. This traditional proof-of-stake reward compensates validators for staking tokens and securing the network.\n\nStaking rewards serve as a baseline incentive, encouraging sustained participation.\n\n2. Compute Performance Rewards\nA core innovation of Republic is its compute validation protocol, which objectively measures a validator\u2019s computational contributions through rigorous benchmarks. Validators with superior performance earn rewards scaled by:\n\nThroughput benchmark scores\nInference benchmark accuracy\nAchieved FLOPs during jobs\nThis performance-based reward ensures that validators are compensated commensurate with the quality and quantity of compute they deliver, incentivizing investment in better hardware and optimization.\n\n3. Consensus Participation Rewards\nValidators actively involved in consensus committees receive rewards based on their effective participation, including timely voting and proposal submission.\n\nThis mechanism encourages validators to maintain high availability and responsiveness during consensus rounds, directly impacting network reliability.\n\n4. Job Completion Bonuses\nValidators executing client compute jobs successfully and within the required time frames are awarded additional bonuses. This component promotes timely and accurate compute task fulfillment, critical for client satisfaction and network utility.\n\nEconomic Model and Token Flow\nValidators must stake the native token, REP, to participate. Rewards are distributed in REP tokens, creating a positive feedback loop that encourages continued engagement and token utility.\n\nEconomic parameters such as reward rates, slashing amounts, and job fees are periodically reviewed and can be adjusted via governance to maintain optimal incentive alignment.\n\nBalancing Incentives and Penalties\nWhile rewards motivate honest behavior, penalties (including slashing and reputation degradation) ensure accountability. This dual system maintains validator discipline and deters attacks or negligence.\n\nValidators must balance risk and reward by maintaining high performance and adhering to protocol rules.\n\nLong-Term Incentive Effects\nThe combined incentive structure aims to:\n\nPromote hardware and software investment for better compute quality\nEncourage long-term commitment through stake and reputation accumulation\nFoster a secure and decentralized network resistant to centralization pressures\nEnable a thriving marketplace where compute resources are reliably provisioned and compensated\n\nCLI Overview\nRepublic core utils are the internal tooling used to request and execute benchmarks, jobs, etc. for the Republic network. It supports job scheduling and validation, benchmarking, config editing, and more.\n\nUse republic --help to verify installation and get a summary of available commands. The CLI is automatically installed when you install the republic application for validators or clients on your platform.\n\n",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "human",
            "name": null,
            "id": "507c7e32-0678-405f-81cc-74c5eb1c3012"
        },
        {
            "content": "{\n  \"List all validators with their delegated stake, compute benchmark scores, and reputation\": 100,\n  \"Show details for validator {address} including stake, benchmarks, reputation, and slashing history\": 99,\n  \"Sort validators by reputation score\": 98,\n  \"Sort validators by delegated stake and verified compute performance\": 97,\n  \"Show validators sorted by combined score of stake, compute performance, and reputation\": 96,\n  \"List validators ordered by achieved FLOPs benchmark\": 95,\n  \"Compare compute benchmarks across the top 10 validators by stake\": 94,\n  \"Show throughput, inference, and achieved FLOPs benchmark results for validator {address}\": 93,\n  \"View network-wide average throughput, inference, and FLOPs benchmark scores\": 92,\n  \"Show DPoS delegation details for delegator {address}\": 91,\n  \"Show REP balance and staking status for address {address}\": 90,\n  \"Show how much REP is currently staked versus unstaked\": 89,\n  \"Show REP staking, compute performance, and job completion rewards earned by validator {address} over the last 7 days\": 88,\n  \"Estimate expected REP rewards for delegating {amount} REP to validator {address}\": 87,\n  \"Show history of REP rewards and slashes for delegator {address}\": 86,\n  \"List recent slashing events with reasons such as downtime or incorrect computations\": 85,\n  \"Show fraud detection and slashing events related to incorrect computation proofs\": 84,\n  \"List validators that recently failed benchmarks or lost reputation\": 83,\n  \"List validators with downtime incidents in the last 24 hours\": 82,\n  \"List validators that have never been slashed and have the highest long-term reputation\": 81,\n  \"Visualize validator {address} reputation score over time\": 80,\n  \"Show consensus participation rate and uptime for validator {address}\": 79,\n  \"Show blocks proposed by validator {address} in the last 100 blocks\": 78,\n  \"List validators currently eligible for consensus committees based on reputation and compute benchmarks\": 77,\n  \"Show consensus committee members for the latest epoch and their compute quality metrics\": 76,\n  \"Show consensus committee composition for epoch {epoch_id}\": 75,\n  \"Show epochs and their checkpoint blocks with committee composition and stake distribution\": 74,\n  \"Show how validator {address}'s benchmark scores affect their probability of committee selection\": 73,\n  \"Show correlation between validator reputation and frequency of consensus committee selection\": 72,\n  \"Show current parameters for reward rates, slashing amounts, and job fees\": 71,\n  \"Show current configuration of compute validation benchmarks and thresholds\": 70,\n  \"Show ongoing and historical benchmark runs for validator {address}\": 69,\n  \"Show compute validation status and benchmark timing for validator {address}\": 68,\n  \"Search for transactions involving REP staking or unstaking\": 67,\n  \"Search for transactions where validators registered or updated their benchmark results\": 66,\n  \"Filter transactions related to compute job scheduling and validation\": 65,\n  \"List all active compute jobs and their assigned validators\": 64,\n  \"Show execution outputs and proof details for compute job {job_id}\": 63,\n  \"Search for compute jobs submitted by address {address}\": 62,\n  \"Show my pending and completed compute jobs\": 61,\n  \"List compute jobs that violated time constraints or were slashed\": 60,\n  \"Show Proof of Model Execution root hash and verification status for compute job {job_id}\": 59,\n  \"Show cryptographic checkpoint hashes recorded for compute job {job_id}\": 58,\n  \"Show which verifiers re-executed compute job {job_id} and whether they matched the submitted root hash\": 57,\n  \"Show latency distribution for compute job completion times across validators\": 56,\n  \"Display time-series charts of network-wide REP rewards paid for compute performance\": 55,\n  \"Display recent governance proposals that changed incentive or slashing parameters\": 54,\n  \"Show epochs where consensus committee composition changed significantly\": 53,\n  \"Display CLI help information for running Republic core utils benchmarks\": 52,\n  \"Generate the CLI command to run a throughput benchmark on my validator node\": 51,\n  \"Generate the CLI command to submit a compute job to the Republic network\": 50\n}",
            "additional_kwargs": {
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 7944,
                    "prompt_tokens": 3957,
                    "total_tokens": 11901,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 7008,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_provider": "openai",
                "model_name": "gpt-5.1-2025-11-13",
                "system_fingerprint": null,
                "id": "chatcmpl-CfBSXDbwrbbzu4BDppegRpTpGYkfM",
                "service_tier": "default",
                "finish_reason": "stop",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "lc_run--94860f14-3f10-4304-beb5-8511be60c4ca-0",
            "tool_calls": [],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 3957,
                "output_tokens": 7944,
                "total_tokens": 11901,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 7008
                }
            }
        }
    ]
}