{
    "messages": [
        {
            "content": "Learn\n\nCopy page\n\nVersion: v0.53\n\nIntroduction - Dive into the fundamentals of Cosmos SDK with an insightful introduction, laying the groundwork for understanding blockchain development. In this section we provide a High-Level Overview of the SDK, then dive deeper into Core concepts such as Application-Specific Blockchains, Blockchain Architecture, and finally we begin to explore the main components of the SDK.\nBeginner - Start your journey with beginner-friendly resources in the Cosmos SDK\u2019s \u201cLearn\u201d section, providing a gentle entry point for newcomers to blockchain development. Here we focus on a little more detail, covering the Anatomy of a Cosmos SDK Application, Transaction Lifecycles, Accounts and lastly, Gas and Fees.\nAdvanced - Level up your Cosmos SDK expertise with advanced topics, tailored for experienced developers diving into intricate blockchain application development. We cover the Cosmos SDK on a lower level as we dive into the core of the SDK with BaseApp, Transactions, Context, Node Client (Daemon), Store, Encoding, gRPC, REST, and CometBFT Endpoints, CLI, Events, Telemetry, Object-Capability Model, RunTx recovery middleware, Cosmos Blockchain Simulator, Protobuf Documentation, In-Place Store Migrations, Configuration and AutoCLI.\n\nWhat is the Cosmos SDK\n\nCopy page\n\nThe Cosmos SDK is an open-source toolkit for building multi-asset public Proof-of-Stake (PoS) blockchains, like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains.\nThe goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains. We further this modular approach by allowing developers to plug and play with different consensus engines this can range from the CometBFT or Rollkit.\nSDK-based blockchains have the choice to use the predefined modules or to build their own modules. What this means is that developers can build a blockchain that is tailored to their specific use case, without having to worry about the low-level details of building a blockchain from scratch. Predefined modules include staking, governance, and token issuance, among others.\nWhat\u2019s more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model.\nHow you can look at this is if we imagine that the SDK is like a lego kit. You can choose to build the basic house from the instructions or you can choose to modify your house and add more floors, more doors, more windows. The choice is yours.\n\u200b\nWhat are Application-Specific Blockchains\nOne development paradigm in the blockchain world today is that of virtual-machine blockchains like Ethereum, where development generally revolves around building decentralized applications on top of an existing blockchain as a set of smart contracts. While smart contracts can be very good for some use cases like single-use applications (e.g. ICOs), they often fall short for building complex decentralized platforms. More generally, smart contracts can be limiting in terms of flexibility, sovereignty and performance.\nApplication-specific blockchains offer a radically different development paradigm than virtual-machine blockchains. An application-specific blockchain is a blockchain customized to operate a single application: developers have all the freedom to make the design decisions required for the application to run optimally. They can also provide better sovereignty, security and performance.\nLearn more about application-specific blockchains.\n\u200b\nWhat is Modularity\nToday there is a lot of talk around modularity and discussions between monolithic and modular. Originally the Cosmos SDK was built with a vision of modularity in mind. Modularity is derived from splitting a blockchain into customizable layers of execution, consensus, settlement and data availability, which is what the Cosmos SDK enables. This means that developers can plug and play, making their blockchain customisable by using different software for different layers. For example you can choose to build a vanilla chain and use the Cosmos SDK with CometBFT. CometBFT will be your consensus layer and the chain itself would be the settlement and execution layer. Another route could be to use the SDK with Rollkit and Celestia as your consensus and data availability layer. The benefit of modularity is that you can customize your chain to your specific use case.\n\u200b\nWhy the Cosmos SDK\nThe Cosmos SDK is the most advanced framework for building custom modular application-specific blockchains today. Here are a few reasons why you might want to consider building your decentralized application with the Cosmos SDK:\nIt allows you to plug and play and customize your consensus layer. As above you can use Rollkit and Celestia as your consensus and data availability layer. This offers a lot of flexibility and customisation.\nPreviously the default consensus engine available within the Cosmos SDK is CometBFT. CometBFT is the most (and only) mature BFT consensus engine in existence. It is widely used across the industry and is considered the gold standard consensus engine for building Proof-of-Stake systems.\nThe Cosmos SDK is open-source and designed to make it easy to build blockchains out of composable modules. As the ecosystem of open-source Cosmos SDK modules grows, it will become increasingly easier to build complex decentralized platforms with it.\nThe Cosmos SDK is inspired by capabilities-based security, and informed by years of wrestling with blockchain state-machines. This makes the Cosmos SDK a very secure environment to build blockchains.\nMost importantly, the Cosmos SDK has already been used to build many application-specific blockchains that are already in production. Among others, we can cite Cosmos Hub, IRIS Hub, Binance Chain, Terra or Kava. Many more are building on the Cosmos SDK.\n\u200b\nGetting started with the Cosmos SDK\nLearn more about the architecture of a Cosmos SDK application\nLearn how to build an application-specific blockchain from scratch with the Cosmos SDK Tutorial\n\n\nAnatomy of a Cosmos SDK Application\n\nCopy page\n\nSynopsis This document describes the core parts of a Cosmos SDK application, represented throughout the document as a placeholder application named app.\n\u200b\nNode Client\nThe Daemon, or Full-Node Client, is the core process of a Cosmos SDK-based blockchain. Participants in the network run this process to initialize their state-machine, connect with other full-nodes, and update their state-machine as new blocks come in.\n\nCopy\n\nAsk AI\n                ^  +-------------------------------+  ^\n                |  |                               |  |\n                |  |  State-machine = Application  |  |\n                |  |                               |  |   Built with Cosmos SDK\n                |  |            ^      +           |  |\n                |  +----------- | ABCI | ----------+  v\n                |  |            +      v           |  ^\n                |  |                               |  |\nBlockchain Node |  |           Consensus           |  |\n                |  |                               |  |\n                |  +-------------------------------+  |   CometBFT\n                |  |                               |  |\n                |  |           Networking          |  |\n                |  |                               |  |\n                v  +-------------------------------+  v\nSee all 16 lines\nThe blockchain full-node presents itself as a binary, generally suffixed by -d for \u201cdaemon\u201d (e.g. appd for app or gaiad for gaia). This binary is built by running a simple main.go function placed in ./cmd/appd/. This operation usually happens through the Makefile.\nOnce the main binary is built, the node can be started by running the start command. This command function primarily does three things:\nCreate an instance of the state-machine defined in app.go.\nInitialize the state-machine with the latest known state, extracted from the db stored in the ~/.app/data folder. At this point, the state-machine is at height appBlockHeight.\nCreate and start a new CometBFT instance. Among other things, the node performs a handshake with its peers. It gets the latest blockHeight from them and replays blocks to sync to this height if it is greater than the local appBlockHeight. The node starts from genesis and CometBFT sends an InitChain message via the ABCI to the app, which triggers the InitChainer.\nWhen starting a CometBFT instance, the genesis file is the 0 height and the state within the genesis file is committed at block height 1. When querying the state of the node, querying block height 0 will return an error.\n\u200b\nCore Application File\nIn general, the core of the state-machine is defined in a file called app.go. This file mainly contains the type definition of the application and functions to create and initialize it.\n\u200b\nType Definition of the Application\nThe first thing defined in app.go is the type of the application. It is generally comprised of the following parts:\nEmbeding runtime.App The runtime package manages the application\u2019s core components and modules through dependency injection. It provides declarative configuration for module management, state storage, and ABCI handling.\nRuntime wraps BaseApp, meaning when a transaction is relayed by CometBFT to the application, app uses runtime\u2019s methods to route them to the appropriate module. BaseApp implements all the ABCI methods and the routing logic.\nIt automatically configures the module manager based on the app wiring configuration. The module manager facilitates operations related to these modules, like registering their Msg service and gRPC Query service, or setting the order of execution between modules for various functions like InitChainer, PreBlocker and BeginBlocker and EndBlocker.\nAn App Wiring configuration file The app wiring configuration file contains the list of application\u2019s modules that runtime must instantiate. The instantiation of the modules are done using depinject. It also contains the order in which all module\u2019s InitGenesis and Pre/Begin/EndBlocker methods should be executed.\nA reference to an appCodec. The application\u2019s appCodec is used to serialize and deserialize data structures in order to store them, as stores can only persist []bytes. The default codec is Protocol Buffers.\nA reference to a legacyAmino codec. Some parts of the Cosmos SDK have not been migrated to use the appCodec above, and are still hardcoded to use Amino. Other parts explicitly use Amino for backwards compatibility. For these reasons, the application still holds a reference to the legacy Amino codec. Please note that the Amino codec will be removed from the SDK in the upcoming releases.\nSee an example of application type definition from simapp, the Cosmos SDK\u2019s own app used for demo and testing purposes:\n\nCopy\n\nAsk AI\n//go:build !app_v1\n\npackage simapp\n\nimport (\n    \n\t\"io\"\n\n\tdbm \"github.com/cosmos/cosmos-db\"\n\n\tclienthelpers \"cosmossdk.io/client/v2/helpers\"\n    \"cosmossdk.io/depinject\"\n    \"cosmossdk.io/log\"\n\tstoretypes \"cosmossdk.io/store/types\"\n\tcircuitkeeper \"cosmossdk.io/x/circuit/keeper\"\n\tevidencekeeper \"cosmossdk.io/x/evidence/keeper\"\n\tfeegrantkeeper \"cosmossdk.io/x/feegrant/keeper\"\n\tnftkeeper \"cosmossdk.io/x/nft/keeper\"\n\tupgradekeeper \"cosmossdk.io/x/upgrade/keeper\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n\tcodectypes \"github.com/cosmos/cosmos-sdk/codec/types\"\n    \"github.com/cosmos/cosmos-sdk/runtime\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n\ttestdata_pulsar \"github.com/cosmos/cosmos-sdk/testutil/testdata/testpb\"\n    \"github.com/cosmos/cosmos-sdk/types/module\"\n    \"github.com/cosmos/cosmos-sdk/x/auth\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/ante\"\n\tauthkeeper \"github.com/cosmos/cosmos-sdk/x/auth/keeper\"\n\tauthsims \"github.com/cosmos/cosmos-sdk/x/auth/simulation\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n\tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n\tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n\tconsensuskeeper \"github.com/cosmos/cosmos-sdk/x/consensus/keeper\"\n\tdistrkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n\tepochskeeper \"github.com/cosmos/cosmos-sdk/x/epochs/keeper\"\n\tgovkeeper \"github.com/cosmos/cosmos-sdk/x/gov/keeper\"\n\tgroupkeeper \"github.com/cosmos/cosmos-sdk/x/group/keeper\"\n\tmintkeeper \"github.com/cosmos/cosmos-sdk/x/mint/keeper\"\n\tprotocolpoolkeeper \"github.com/cosmos/cosmos-sdk/x/protocolpool/keeper\"\n\tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n)\n\n// DefaultNodeHome default home directories for the application daemon\nvar DefaultNodeHome string\n\nvar (\n\t_ runtime.AppI            = (*SimApp)(nil)\n\t_ servertypes.Application = (*SimApp)(nil)\n)\n\n// SimApp extends an ABCI application, but with most of its parameters exported.\n// They are exported for convenience in creating helper functions, as object\n// capabilities aren't needed for testing.\ntype SimApp struct {\n\t*runtime.App\n\tlegacyAmino       *codec.LegacyAmino\n\tappCodec          codec.Codec\n\ttxConfig          client.TxConfig\n\tinterfaceRegistry codectypes.InterfaceRegistry\n\n\t// essential keepers\n\tAccountKeeper         authkeeper.AccountKeeper\n\tBankKeeper            bankkeeper.BaseKeeper\n\tStakingKeeper         *stakingkeeper.Keeper\n\tSlashingKeeper        slashingkeeper.Keeper\n\tMintKeeper            mintkeeper.Keeper\n\tDistrKeeper           distrkeeper.Keeper\n\tGovKeeper             *govkeeper.Keeper\n\tUpgradeKeeper         *upgradekeeper.Keeper\n\tEvidenceKeeper        evidencekeeper.Keeper\n\tConsensusParamsKeeper consensuskeeper.Keeper\n\tCircuitKeeper         circuitkeeper.Keeper\n\n\t// supplementary keepers\n\tFeeGrantKeeper     feegrantkeeper.Keeper\n\tGroupKeeper        groupkeeper.Keeper\n\tAuthzKeeper        authzkeeper.Keeper\n\tNFTKeeper          nftkeeper.Keeper\n\tEpochsKeeper       epochskeeper.Keeper\n\tProtocolPoolKeeper protocolpoolkeeper.Keeper\n\n\t// simulation manager\n\tsm *module.SimulationManager\n}\n\nfunc init() {\n    var err error\n\tDefaultNodeHome, err = clienthelpers.GetNodeHomeDirectory(\".simapp\")\n    if err != nil {\n    panic(err)\n}\n}\n\n// NewSimApp returns a reference to an initialized SimApp.\nfunc NewSimApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tloadLatest bool,\n\tappOpts servertypes.AppOptions,\n\tbaseAppOptions ...func(*baseapp.BaseApp),\n) *SimApp {\n    var (\n\t\tapp        = &SimApp{\n}\n\nappBuilder *runtime.AppBuilder\n\n\t\t// merge the AppConfig and other configuration in one config\n\t\tappConfig = depinject.Configs(\n\t\t\tAppConfig,\n\t\t\tdepinject.Supply(\n\t\t\t\t// supply the application options\n\t\t\t\tappOpts,\n\t\t\t\t// supply the logger\n\t\t\t\tlogger,\n\n\t\t\t\t// ADVANCED CONFIGURATION\n\n\t\t\t\t//\n\t\t\t\t// AUTH\n\t\t\t\t//\n\t\t\t\t// For providing a custom function required in auth to generate custom account types\n\t\t\t\t// add it below. By default the auth module uses simulation.RandomGenesisAccounts.\n\t\t\t\t//\n\t\t\t\t// authtypes.RandomGenesisAccountsFn(simulation.RandomGenesisAccounts),\n\t\t\t\t//\n\t\t\t\t// For providing a custom a base account type add it below.\n\t\t\t\t// By default the auth module uses authtypes.ProtoBaseAccount().\n\t\t\t\t//\n\t\t\t\t// func()\n\nsdk.AccountI {\n    return authtypes.ProtoBaseAccount()\n},\n\t\t\t\t//\n\t\t\t\t// For providing a different address codec, add it below.\n\t\t\t\t// By default the auth module uses a Bech32 address codec,\n\t\t\t\t// with the prefix defined in the auth module configuration.\n\t\t\t\t//\n\t\t\t\t// func()\n\naddress.Codec {\n    return <- custom address codec type ->\n}\n\t\t\t\t//\n\t\t\t\t// STAKING\n\t\t\t\t//\n\t\t\t\t// For provinding a different validator and consensus address codec, add it below.\n\t\t\t\t// By default the staking module uses the bech32 prefix provided in the auth config,\n\t\t\t\t// and appends \"valoper\" and \"valcons\" for validator and consensus addresses respectively.\n\t\t\t\t// When providing a custom address codec in auth, custom address codecs must be provided here as well.\n\t\t\t\t//\n\t\t\t\t// func()\n\nruntime.ValidatorAddressCodec {\n    return <- custom validator address codec type ->\n}\n\t\t\t\t// func()\n\nruntime.ConsensusAddressCodec {\n    return <- custom consensus address codec type ->\n}\n\n\t\t\t\t//\n\t\t\t\t// MINT\n\t\t\t\t//\n\n\t\t\t\t// For providing a custom inflation function for x/mint add here your\n\t\t\t\t// custom minting function that implements the mintkeeper.MintFn\n\t\t\t\t// interface.\n\t\t\t),\n\t\t)\n\t)\n    if err := depinject.Inject(appConfig,\n\t\t&appBuilder,\n\t\t&app.appCodec,\n\t\t&app.legacyAmino,\n\t\t&app.txConfig,\n\t\t&app.interfaceRegistry,\n\t\t&app.AccountKeeper,\n\t\t&app.BankKeeper,\n\t\t&app.StakingKeeper,\n\t\t&app.SlashingKeeper,\n\t\t&app.MintKeeper,\n\t\t&app.DistrKeeper,\n\t\t&app.GovKeeper,\n\t\t&app.UpgradeKeeper,\n\t\t&app.AuthzKeeper,\n\t\t&app.EvidenceKeeper,\n\t\t&app.FeeGrantKeeper,\n\t\t&app.GroupKeeper,\n\t\t&app.NFTKeeper,\n\t\t&app.ConsensusParamsKeeper,\n\t\t&app.CircuitKeeper,\n\t\t&app.EpochsKeeper,\n\t\t&app.ProtocolPoolKeeper,\n\t); err != nil {\n    panic(err)\n}\n\n\t// Below we could construct and set an application specific mempool and\n\t// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are\n\t// already set in the SDK's BaseApp, this shows an example of how to override\n\t// them.\n\t//\n\t// Example:\n\t//\n\t// app.App = appBuilder.Build(...)\n\t// nonceMempool := mempool.NewSenderNonceMempool()\n\t// abciPropHandler := NewDefaultProposalHandler(nonceMempool, app.App.BaseApp)\n\t//\n\t// app.App.BaseApp.SetMempool(nonceMempool)\n\t// app.App.BaseApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t// app.App.BaseApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())\n\t//\n\t// Alternatively, you can construct BaseApp options, append those to\n\t// baseAppOptions and pass them to the appBuilder.\n\t//\n\t// Example:\n\t//\n\t// prepareOpt = func(app *baseapp.BaseApp) {\n\t// \tabciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)\n\t// \tapp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t//\n}\n\t// baseAppOptions = append(baseAppOptions, prepareOpt)\n\n\t// create and set dummy vote extension handler\n    voteExtOp := func(bApp *baseapp.BaseApp) {\n    voteExtHandler := NewVoteExtensionHandler()\n\nvoteExtHandler.SetHandlers(bApp)\n}\n\nbaseAppOptions = append(baseAppOptions, voteExtOp, baseapp.SetOptimisticExecution())\n\napp.App = appBuilder.Build(db, traceStore, baseAppOptions...)\n\n\t// register streaming services\n    if err := app.RegisterStreamingServices(appOpts, app.kvStoreKeys()); err != nil {\n    panic(err)\n}\n\n\t/****  Module Options ****/\n\n\t// RegisterUpgradeHandlers is used for registering any on-chain upgrades.\n\tapp.RegisterUpgradeHandlers()\n\n\t// add test gRPC service for testing gRPC queries in isolation\n\ttestdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{\n})\n\n\t// create the simulation manager and define the order of the modules for deterministic simulations\n\t//\n\t// NOTE: this is not required apps that don't use the simulator for fuzz testing\n\t// transactions\n    overrideModules := map[string]module.AppModuleSimulation{\n    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n}\n\napp.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)\n\napp.sm.RegisterStoreDecoders()\n\n\t// A custom InitChainer can be set if extra pre-init-genesis logic is required.\n\t// By default, when using app wiring enabled module, this is not required.\n\t// For instance, the upgrade module will set automatically the module version map in its init genesis thanks to app wiring.\n\t// However, when registering a module manually (i.e. that does not support app wiring), the module version map\n\t// must be set manually as follow. The upgrade module will de-duplicate the module version map.\n\t//\n\t// app.SetInitChainer(func(ctx sdk.Context, req *abci.RequestInitChain) (*abci.ResponseInitChain, error) {\n\t// \tapp.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())\n\t// \treturn app.App.InitChainer(ctx, req)\n\t//\n})\n\n\t// set custom ante handler\n\tapp.setAnteHandler(app.txConfig)\n    if err := app.Load(loadLatest); err != nil {\n    panic(err)\n}\n\nreturn app\n}\n\n// setAnteHandler sets custom ante handlers.\n// \"x/auth/tx\" pre-defined ante handler have been disabled in app_config.\nfunc (app *SimApp)\n\nsetAnteHandler(txConfig client.TxConfig) {\n    anteHandler, err := NewAnteHandler(\n\t\tHandlerOptions{\n    ante.HandlerOptions{\n    AccountKeeper:   app.AccountKeeper,\n    BankKeeper:      app.BankKeeper,\n    SignModeHandler: txConfig.SignModeHandler(),\n    FeegrantKeeper:  app.FeeGrantKeeper,\n    SigGasConsumer:  ante.DefaultSigVerificationGasConsumer,\n},\n\t\t\t&app.CircuitKeeper,\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\n\t// Set the AnteHandler for the app\n\tapp.SetAnteHandler(anteHandler)\n}\n\n// LegacyAmino returns SimApp's amino codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nLegacyAmino() *codec.LegacyAmino {\n    return app.legacyAmino\n}\n\n// AppCodec returns SimApp's app codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nAppCodec()\n\ncodec.Codec {\n    return app.appCodec\n}\n\n// InterfaceRegistry returns SimApp's InterfaceRegistry.\nfunc (app *SimApp)\n\nInterfaceRegistry()\n\ncodectypes.InterfaceRegistry {\n    return app.interfaceRegistry\n}\n\n// TxConfig returns SimApp's TxConfig\nfunc (app *SimApp)\n\nTxConfig()\n\nclient.TxConfig {\n    return app.txConfig\n}\n\n// GetKey returns the KVStoreKey for the provided store key.\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc (app *SimApp)\n\nGetKey(storeKey string) *storetypes.KVStoreKey {\n    sk := app.UnsafeFindStoreKey(storeKey)\n\nkvStoreKey, ok := sk.(*storetypes.KVStoreKey)\n    if !ok {\n    return nil\n}\n\nreturn kvStoreKey\n}\n\nfunc (app *SimApp)\n\nkvStoreKeys()\n\nmap[string]*storetypes.KVStoreKey {\n    keys := make(map[string]*storetypes.KVStoreKey)\n    for _, k := range app.GetStoreKeys() {\n    if kv, ok := k.(*storetypes.KVStoreKey); ok {\n    keys[kv.Name()] = kv\n}\n\t\n}\n\nreturn keys\n}\n\n// SimulationManager implements the SimulationApp interface\nfunc (app *SimApp)\n\nSimulationManager() *module.SimulationManager {\n    return app.sm\n}\n\n// RegisterAPIRoutes registers all application module routes with the provided\n// API server.\nfunc (app *SimApp)\n\nRegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {\n    app.App.RegisterAPIRoutes(apiSvr, apiConfig)\n\t// register swagger API in app.go so that other applications can override easily\n    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {\n    panic(err)\n}\n}\n\n// GetMaccPerms returns a copy of the module account permissions\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc GetMaccPerms()\n\nmap[string][]string {\n    dup := make(map[string][]string)\n    for _, perms := range moduleAccPerms {\n    dup[perms.Account] = perms.Permissions\n}\n\nreturn dup\n}\n\n// BlockedAddresses returns all the app's blocked account addresses.\nfunc BlockedAddresses()\n\nmap[string]bool {\n    result := make(map[string]bool)\n    if len(blockAccAddrs) > 0 {\n    for _, addr := range blockAccAddrs {\n    result[addr] = true\n}\n\t\n}\n\nelse {\n    for addr := range GetMaccPerms() {\n    result[addr] = true\n}\n\t\n}\n\nreturn result\n}\nSee all 443 lines\n\u200b\nConstructor Function\nAlso defined in app.go is the constructor function, which constructs a new application of the type defined in the preceding section. The function must fulfill the AppCreator signature in order to be used in the start command of the application\u2019s daemon command.\n\nCopy\n\nAsk AI\npackage types\n\nimport (\n    \n\t\"encoding/json\"\n    \"io\"\n\n\tcmtproto \"github.com/cometbft/cometbft/proto/tendermint/types\"\n\tcmttypes \"github.com/cometbft/cometbft/types\"\n\tdbm \"github.com/cosmos/cosmos-db\"\n    \"github.com/cosmos/gogoproto/grpc\"\n    \"github.com/spf13/cobra\"\n    \"cosmossdk.io/log\"\n    \"cosmossdk.io/store/snapshots\"\n\tstoretypes \"cosmossdk.io/store/types\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n)\n\ntype (\n\t// AppOptions defines an interface that is passed into an application\n\t// constructor, typically used to set BaseApp options that are either supplied\n\t// via config file or through CLI arguments/flags. The underlying implementation\n\t// is defined by the server package and is typically implemented via a Viper\n\t// literal defined on the server Context. Note, casting Get calls may not yield\n\t// the expected types and could result in type assertion errors. It is recommend\n\t// to either use the cast package or perform manual conversion for safety.\n\tAppOptions interface {\n    Get(string)\n\nany\n}\n\n\t// Application defines an application interface that wraps abci.Application.\n\t// The interface defines the necessary contracts to be implemented in order\n\t// to fully bootstrap and start an application.\n\tApplication interface {\n    ABCI\n\n\t\tRegisterAPIRoutes(*api.Server, config.APIConfig)\n\n\t\t// RegisterGRPCServerWithSkipCheckHeader registers gRPC services directly with the gRPC\n\t\t// server and bypass check header flag.\n\t\tRegisterGRPCServerWithSkipCheckHeader(grpc.Server, bool)\n\n\t\t// RegisterTxService registers the gRPC Query service for tx (such as tx\n\t\t// simulation, fetching txs by hash...).\n\t\tRegisterTxService(client.Context)\n\n\t\t// RegisterTendermintService registers the gRPC Query service for CometBFT queries.\n\t\tRegisterTendermintService(client.Context)\n\n\t\t// RegisterNodeService registers the node gRPC Query service.\n\t\tRegisterNodeService(client.Context, config.Config)\n\n\t\t// CommitMultiStore return the multistore instance\n\t\tCommitMultiStore()\n\nstoretypes.CommitMultiStore\n\n\t\t// Return the snapshot manager\n\t\tSnapshotManager() *snapshots.Manager\n\n\t\t// Close is called in start cmd to gracefully cleanup resources.\n\t\t// Must be safe to be called multiple times.\n\t\tClose()\n\nerror\n}\n\n\t// AppCreator is a function that allows us to lazily initialize an\n\t// application using various configurations.\n\tAppCreator func(log.Logger, dbm.DB, io.Writer, AppOptions)\n\nApplication\n\n\t// ModuleInitFlags takes a start command and adds modules specific init flags.\n\tModuleInitFlags func(startCmd *cobra.Command)\n\n\t// ExportedApp represents an exported app state, along with\n\t// validators, consensus params and latest app height.\n\tExportedApp struct {\n\t\t// AppState is the application state as JSON.\n\t\tAppState json.RawMessage\n\t\t// Validators is the exported validator set.\n\t\tValidators []cmttypes.GenesisValidator\n\t\t// Height is the app's latest block height.\n\t\tHeight int64\n\t\t// ConsensusParams are the exported consensus params for ABCI.\n\t\tConsensusParams cmtproto.ConsensusParams\n}\n\n\t// AppExporter is a function that dumps all app state to\n\t// JSON-serializable structure and returns the current validator set.\n\tAppExporter func(\n\t\tlogger log.Logger,\n\t\tdb dbm.DB,\n\t\ttraceWriter io.Writer,\n\t\theight int64,\n    forZeroHeight bool,\n\t\tjailAllowedAddrs []string,\n\t\topts AppOptions,\n\t\tmodulesToExport []string,\n\t) (ExportedApp, error)\n)\nSee all 106 lines\nHere are the main actions performed by this function:\nInstantiate a new codec and initialize the codec of each of the application\u2019s modules using the basic manager.\nInstantiate a new application with a reference to a baseapp instance, a codec, and all the appropriate store keys.\nInstantiate all the keeper objects defined in the application\u2019s type using the NewKeeper function of each of the application\u2019s modules. Note that keepers must be instantiated in the correct order, as the NewKeeper of one module might require a reference to another module\u2019s keeper.\nInstantiate the application\u2019s module manager with the AppModule object of each of the application\u2019s modules.\nWith the module manager, initialize the application\u2019s Msg services, gRPC Query services, legacy Msg routes, and legacy query routes. When a transaction is relayed to the application by CometBFT via the ABCI, it is routed to the appropriate module\u2019s Msg service using the routes defined here. Likewise, when a gRPC query request is received by the application, it is routed to the appropriate module\u2019s gRPC query service using the gRPC routes defined here. The Cosmos SDK still supports legacy Msgs and legacy CometBFT queries, which are routed using the legacy Msg routes and the legacy query routes, respectively.\nWith the module manager, register the application\u2019s modules\u2019 invariants. Invariants are variables (e.g. total supply of a token) that are evaluated at the end of each block. The process of checking invariants is done via a special module called the InvariantsRegistry. The value of the invariant should be equal to a predicted value defined in the module. Should the value be different than the predicted one, special logic defined in the invariant registry is triggered (usually the chain is halted). This is useful to make sure that no critical bug goes unnoticed, producing long-lasting effects that are hard to fix.\nWith the module manager, set the order of execution between the InitGenesis, PreBlocker, BeginBlocker, and EndBlocker functions of each of the application\u2019s modules. Note that not all modules implement these functions.\nSet the remaining application parameters:\nInitChainer: used to initialize the application when it is first started.\nPreBlocker: called before BeginBlock.\nBeginBlocker, EndBlocker: called at the beginning and at the end of every block.\nanteHandler: used to handle fees and signature verification.\nMount the stores.\nReturn the application.\nNote that the constructor function only creates an instance of the app, while the actual state is either carried over from the ~/.app/data folder if the node is restarted, or generated from the genesis file if the node is started for the first time.\nSee an example of application constructor from simapp:\n\nCopy\n\nAsk AI\n//go:build app_v1\n\npackage simapp\n\nimport (\n    \n\t\"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"maps\"\n\n\tabci \"github.com/cometbft/cometbft/abci/types\"\n\tdbm \"github.com/cosmos/cosmos-db\"\n    \"github.com/cosmos/gogoproto/proto\"\n    \"github.com/spf13/cast\"\n\n\tautocliv1 \"cosmossdk.io/api/cosmos/autocli/v1\"\n\treflectionv1 \"cosmossdk.io/api/cosmos/reflection/v1\"\n    \"cosmossdk.io/client/v2/autocli\"\n\tclienthelpers \"cosmossdk.io/client/v2/helpers\"\n    \"cosmossdk.io/core/appmodule\"\n    \"cosmossdk.io/log\"\n\tstoretypes \"cosmossdk.io/store/types\"\n    \"cosmossdk.io/x/circuit\"\n\tcircuitkeeper \"cosmossdk.io/x/circuit/keeper\"\n\tcircuittypes \"cosmossdk.io/x/circuit/types\"\n    \"cosmossdk.io/x/evidence\"\n\tevidencekeeper \"cosmossdk.io/x/evidence/keeper\"\n\tevidencetypes \"cosmossdk.io/x/evidence/types\"\n    \"cosmossdk.io/x/feegrant\"\n\tfeegrantkeeper \"cosmossdk.io/x/feegrant/keeper\"\n\tfeegrantmodule \"cosmossdk.io/x/feegrant/module\"\n    \"cosmossdk.io/x/nft\"\n\tnftkeeper \"cosmossdk.io/x/nft/keeper\"\n\tnftmodule \"cosmossdk.io/x/nft/module\"\n    \"cosmossdk.io/x/tx/signing\"\n    \"cosmossdk.io/x/upgrade\"\n\tupgradekeeper \"cosmossdk.io/x/upgrade/keeper\"\n\tupgradetypes \"cosmossdk.io/x/upgrade/types\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/client/flags\"\n    \"github.com/cosmos/cosmos-sdk/client/grpc/cmtservice\"\n\tnodeservice \"github.com/cosmos/cosmos-sdk/client/grpc/node\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/address\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n    \"github.com/cosmos/cosmos-sdk/runtime\"\n\truntimeservices \"github.com/cosmos/cosmos-sdk/runtime/services\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n    \"github.com/cosmos/cosmos-sdk/std\"\n\ttestdata_pulsar \"github.com/cosmos/cosmos-sdk/testutil/testdata/testpb\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n    \"github.com/cosmos/cosmos-sdk/types/module\"\n\tsigtypes \"github.com/cosmos/cosmos-sdk/types/tx/signing\"\n    \"github.com/cosmos/cosmos-sdk/version\"\n    \"github.com/cosmos/cosmos-sdk/x/auth\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/ante\"\n\tauthcodec \"github.com/cosmos/cosmos-sdk/x/auth/codec\"\n\tauthkeeper \"github.com/cosmos/cosmos-sdk/x/auth/keeper\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/posthandler\"\n\tauthsims \"github.com/cosmos/cosmos-sdk/x/auth/simulation\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\ttxmodule \"github.com/cosmos/cosmos-sdk/x/auth/tx/config\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/vesting\"\n\tvestingtypes \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n    \"github.com/cosmos/cosmos-sdk/x/authz\"\n\tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n\tauthzmodule \"github.com/cosmos/cosmos-sdk/x/authz/module\"\n    \"github.com/cosmos/cosmos-sdk/x/bank\"\n\tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n\tconsensus \"github.com/cosmos/cosmos-sdk/x/consensus\"\n\tconsensusparamkeeper \"github.com/cosmos/cosmos-sdk/x/consensus/keeper\"\n\tconsensusparamtypes \"github.com/cosmos/cosmos-sdk/x/consensus/types\"\n\tdistr \"github.com/cosmos/cosmos-sdk/x/distribution\"\n\tdistrkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n\tdistrtypes \"github.com/cosmos/cosmos-sdk/x/distribution/types\"\n    \"github.com/cosmos/cosmos-sdk/x/epochs\"\n\tepochskeeper \"github.com/cosmos/cosmos-sdk/x/epochs/keeper\"\n\tepochstypes \"github.com/cosmos/cosmos-sdk/x/epochs/types\"\n    \"github.com/cosmos/cosmos-sdk/x/genutil\"\n\tgenutiltypes \"github.com/cosmos/cosmos-sdk/x/genutil/types\"\n    \"github.com/cosmos/cosmos-sdk/x/gov\"\n\tgovclient \"github.com/cosmos/cosmos-sdk/x/gov/client\"\n\tgovkeeper \"github.com/cosmos/cosmos-sdk/x/gov/keeper\"\n\tgovtypes \"github.com/cosmos/cosmos-sdk/x/gov/types\"\n\tgovv1beta1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1\"\n    \"github.com/cosmos/cosmos-sdk/x/group\"\n\tgroupkeeper \"github.com/cosmos/cosmos-sdk/x/group/keeper\"\n\tgroupmodule \"github.com/cosmos/cosmos-sdk/x/group/module\"\n    \"github.com/cosmos/cosmos-sdk/x/mint\"\n\tmintkeeper \"github.com/cosmos/cosmos-sdk/x/mint/keeper\"\n\tminttypes \"github.com/cosmos/cosmos-sdk/x/mint/types\"\n    \"github.com/cosmos/cosmos-sdk/x/protocolpool\"\n\tprotocolpoolkeeper \"github.com/cosmos/cosmos-sdk/x/protocolpool/keeper\"\n\tprotocolpooltypes \"github.com/cosmos/cosmos-sdk/x/protocolpool/types\"\n    \"github.com/cosmos/cosmos-sdk/x/slashing\"\n\tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n\tslashingtypes \"github.com/cosmos/cosmos-sdk/x/slashing/types\"\n    \"github.com/cosmos/cosmos-sdk/x/staking\"\n\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n)\n\nconst appName = \"SimApp\"\n\nvar (\n\t// DefaultNodeHome default home directories for the application daemon\n\tDefaultNodeHome string\n\n\t// module account permissions\n\tmaccPerms = map[string][]string{\n    authtypes.FeeCollectorName:                  nil,\n\t\tdistrtypes.ModuleName:                       nil,\n\t\tminttypes.ModuleName:                        {\n    authtypes.Minter\n},\n\t\tstakingtypes.BondedPoolName:                 {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tstakingtypes.NotBondedPoolName:              {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tgovtypes.ModuleName:                         {\n    authtypes.Burner\n},\n\t\tnft.ModuleName:                              nil,\n\t\tprotocolpooltypes.ModuleName:                nil,\n\t\tprotocolpooltypes.ProtocolPoolEscrowAccount: nil\n}\n)\n\nvar (\n\t_ runtime.AppI            = (*SimApp)(nil)\n\t_ servertypes.Application = (*SimApp)(nil)\n)\n\n// SimApp extends an ABCI application, but with most of its parameters exported.\n// They are exported for convenience in creating helper functions, as object\n// capabilities aren't needed for testing.\ntype SimApp struct {\n\t*baseapp.BaseApp\n\tlegacyAmino       *codec.LegacyAmino\n\tappCodec          codec.Codec\n\ttxConfig          client.TxConfig\n\tinterfaceRegistry types.InterfaceRegistry\n\n\t// keys to access the substores\n\tkeys map[string]*storetypes.KVStoreKey\n\n\t// essential keepers\n\tAccountKeeper         authkeeper.AccountKeeper\n\tBankKeeper            bankkeeper.BaseKeeper\n\tStakingKeeper         *stakingkeeper.Keeper\n\tSlashingKeeper        slashingkeeper.Keeper\n\tMintKeeper            mintkeeper.Keeper\n\tDistrKeeper           distrkeeper.Keeper\n\tGovKeeper             govkeeper.Keeper\n\tUpgradeKeeper         *upgradekeeper.Keeper\n\tEvidenceKeeper        evidencekeeper.Keeper\n\tConsensusParamsKeeper consensusparamkeeper.Keeper\n\tCircuitKeeper         circuitkeeper.Keeper\n\n\t// supplementary keepers\n\tFeeGrantKeeper     feegrantkeeper.Keeper\n\tGroupKeeper        groupkeeper.Keeper\n\tAuthzKeeper        authzkeeper.Keeper\n\tNFTKeeper          nftkeeper.Keeper\n\tEpochsKeeper       epochskeeper.Keeper\n\tProtocolPoolKeeper protocolpoolkeeper.Keeper\n\n\t// the module manager\n\tModuleManager      *module.Manager\n\tBasicModuleManager module.BasicManager\n\n\t// simulation manager\n\tsm *module.SimulationManager\n\n\t// module configurator\n\tconfigurator module.Configurator\n}\n\nfunc init() {\n    var err error\n\tDefaultNodeHome, err = clienthelpers.GetNodeHomeDirectory(\".simapp\")\n    if err != nil {\n    panic(err)\n}\n}\n\n// NewSimApp returns a reference to an initialized SimApp.\nfunc NewSimApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tloadLatest bool,\n\tappOpts servertypes.AppOptions,\n\tbaseAppOptions ...func(*baseapp.BaseApp),\n) *SimApp {\n    interfaceRegistry, _ := types.NewInterfaceRegistryWithOptions(types.InterfaceRegistryOptions{\n    ProtoFiles: proto.HybridResolver,\n    SigningOptions: signing.Options{\n    AddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32AccountAddrPrefix(),\n},\n    ValidatorAddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32ValidatorAddrPrefix(),\n},\n},\n})\n    appCodec := codec.NewProtoCodec(interfaceRegistry)\n    legacyAmino := codec.NewLegacyAmino()\n    txConfig := tx.NewTxConfig(appCodec, tx.DefaultSignModes)\n    if err := interfaceRegistry.SigningContext().Validate(); err != nil {\n    panic(err)\n}\n\nstd.RegisterLegacyAminoCodec(legacyAmino)\n\nstd.RegisterInterfaces(interfaceRegistry)\n\n\t// Below we could construct and set an application specific mempool and\n\t// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are\n\t// already set in the SDK's BaseApp, this shows an example of how to override\n\t// them.\n\t//\n\t// Example:\n\t//\n\t// bApp := baseapp.NewBaseApp(...)\n\t// nonceMempool := mempool.NewSenderNonceMempool()\n\t// abciPropHandler := NewDefaultProposalHandler(nonceMempool, bApp)\n\t//\n\t// bApp.SetMempool(nonceMempool)\n\t// bApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t// bApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())\n\t//\n\t// Alternatively, you can construct BaseApp options, append those to\n\t// baseAppOptions and pass them to NewBaseApp.\n\t//\n\t// Example:\n\t//\n\t// prepareOpt = func(app *baseapp.BaseApp) {\n\t// \tabciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)\n\t// \tapp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t//\n}\n\t// baseAppOptions = append(baseAppOptions, prepareOpt)\n\n\t// create and set dummy vote extension handler\n    voteExtOp := func(bApp *baseapp.BaseApp) {\n    voteExtHandler := NewVoteExtensionHandler()\n\nvoteExtHandler.SetHandlers(bApp)\n}\n\nbaseAppOptions = append(baseAppOptions, voteExtOp, baseapp.SetOptimisticExecution())\n    bApp := baseapp.NewBaseApp(appName, logger, db, txConfig.TxDecoder(), baseAppOptions...)\n\nbApp.SetCommitMultiStoreTracer(traceStore)\n\nbApp.SetVersion(version.Version)\n\nbApp.SetInterfaceRegistry(interfaceRegistry)\n\nbApp.SetTxEncoder(txConfig.TxEncoder())\n    keys := storetypes.NewKVStoreKeys(\n\t\tauthtypes.StoreKey,\n\t\tbanktypes.StoreKey,\n\t\tstakingtypes.StoreKey,\n\t\tminttypes.StoreKey,\n\t\tdistrtypes.StoreKey,\n\t\tslashingtypes.StoreKey,\n\t\tgovtypes.StoreKey,\n\t\tconsensusparamtypes.StoreKey,\n\t\tupgradetypes.StoreKey,\n\t\tfeegrant.StoreKey,\n\t\tevidencetypes.StoreKey,\n\t\tcircuittypes.StoreKey,\n\t\tauthzkeeper.StoreKey,\n\t\tnftkeeper.StoreKey,\n\t\tgroup.StoreKey,\n\t\tepochstypes.StoreKey,\n\t\tprotocolpooltypes.StoreKey,\n\t)\n\n\t// register streaming services\n    if err := bApp.RegisterStreamingServices(appOpts, keys); err != nil {\n    panic(err)\n}\n    app := &SimApp{\n    BaseApp:           bApp,\n\t\tlegacyAmino:       legacyAmino,\n\t\tappCodec:          appCodec,\n\t\ttxConfig:          txConfig,\n\t\tinterfaceRegistry: interfaceRegistry,\n\t\tkeys:              keys,\n}\n\n\t// set the BaseApp's parameter store\n\tapp.ConsensusParamsKeeper = consensusparamkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[consensusparamtypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\truntime.EventService{\n},\n\t)\n\nbApp.SetParamStore(app.ConsensusParamsKeeper.ParamsStore)\n\n\t// add keepers\n\tapp.AccountKeeper = authkeeper.NewAccountKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[authtypes.StoreKey]),\n\t\tauthtypes.ProtoBaseAccount,\n\t\tmaccPerms,\n\t\tauthcodec.NewBech32Codec(sdk.Bech32MainPrefix),\n\t\tsdk.Bech32MainPrefix,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthkeeper.WithUnorderedTransactions(true),\n\t)\n\napp.BankKeeper = bankkeeper.NewBaseKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[banktypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tBlockedAddresses(),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tlogger,\n\t)\n\n\t// optional: enable sign mode textual by overwriting the default tx config (after setting the bank keeper)\n    enabledSignModes := append(tx.DefaultSignModes, sigtypes.SignMode_SIGN_MODE_TEXTUAL)\n    txConfigOpts := tx.ConfigOptions{\n    EnabledSignModes:           enabledSignModes,\n    TextualCoinMetadataQueryFn: txmodule.NewBankKeeperCoinMetadataQueryFn(app.BankKeeper),\n}\n\ntxConfig, err := tx.NewTxConfigWithOptions(\n\t\tappCodec,\n\t\ttxConfigOpts,\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.txConfig = txConfig\n\n\tapp.StakingKeeper = stakingkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[stakingtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixValAddr),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixConsAddr),\n\t)\n\napp.MintKeeper = mintkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[minttypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// mintkeeper.WithMintFn(mintkeeper.DefaultMintFn(minttypes.DefaultInflationCalculationFn)), custom mintFn can be added here\n\t)\n\napp.ProtocolPoolKeeper = protocolpoolkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[protocolpooltypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.DistrKeeper = distrkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[distrtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tdistrkeeper.WithExternalCommunityPool(app.ProtocolPoolKeeper),\n\t)\n\napp.SlashingKeeper = slashingkeeper.NewKeeper(\n\t\tappCodec,\n\t\tlegacyAmino,\n\t\truntime.NewKVStoreService(keys[slashingtypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.FeeGrantKeeper = feegrantkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[feegrant.StoreKey]),\n\t\tapp.AccountKeeper,\n\t)\n\n\t// register the staking hooks\n\t// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks\n\tapp.StakingKeeper.SetHooks(\n\t\tstakingtypes.NewMultiStakingHooks(\n\t\t\tapp.DistrKeeper.Hooks(),\n\t\t\tapp.SlashingKeeper.Hooks(),\n\t\t),\n\t)\n\napp.CircuitKeeper = circuitkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[circuittypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tapp.AccountKeeper.AddressCodec(),\n\t)\n\napp.BaseApp.SetCircuitBreaker(&app.CircuitKeeper)\n\napp.AuthzKeeper = authzkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[authzkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t)\n    groupConfig := group.DefaultConfig()\n\t/*\n\t\tExample of setting group params:\n\t\tgroupConfig.MaxMetadataLen = 1000\n\t*/\n\tapp.GroupKeeper = groupkeeper.NewKeeper(\n\t\tkeys[group.StoreKey],\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t\tgroupConfig,\n\t)\n\n\t// get skipUpgradeHeights from the app options\n    skipUpgradeHeights := map[int64]bool{\n}\n    for _, h := range cast.ToIntSlice(appOpts.Get(server.FlagUnsafeSkipUpgrades)) {\n    skipUpgradeHeights[int64(h)] = true\n}\n    homePath := cast.ToString(appOpts.Get(flags.FlagHome))\n\t// set the governance module account as the authority for conducting upgrades\n\tapp.UpgradeKeeper = upgradekeeper.NewKeeper(\n\t\tskipUpgradeHeights,\n\t\truntime.NewKVStoreService(keys[upgradetypes.StoreKey]),\n\t\tappCodec,\n\t\thomePath,\n\t\tapp.BaseApp,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\n\t// Register the proposal types\n\t// Deprecated: Avoid adding new handlers, instead use the new proposal flow\n\t// by granting the governance module the right to execute the message.\n\t// See: https://docs.cosmos.network/main/modules/gov#proposal-messages\n    govRouter := govv1beta1.NewRouter()\n\ngovRouter.AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler)\n    govConfig := govtypes.DefaultConfig()\n\t/*\n\t\tExample of setting gov params:\n\t\tgovConfig.MaxMetadataLen = 10000\n\t*/\n    govKeeper := govkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[govtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tapp.DistrKeeper,\n\t\tapp.MsgServiceRouter(),\n\t\tgovConfig,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// govkeeper.WithCustomCalculateVoteResultsAndVotingPowerFn(...), // Add if you want to use a custom vote calculation function.\n\t)\n\n\t// Set legacy router for backwards compatibility with gov v1beta1\n\tgovKeeper.SetLegacyRouter(govRouter)\n\napp.GovKeeper = *govKeeper.SetHooks(\n\t\tgovtypes.NewMultiGovHooks(\n\t\t\t// register the governance hooks\n\t\t),\n\t)\n\napp.NFTKeeper = nftkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[nftkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t)\n\n\t// create evidence keeper with router\n    evidenceKeeper := evidencekeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[evidencetypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.SlashingKeeper,\n\t\tapp.AccountKeeper.AddressCodec(),\n\t\truntime.ProvideCometInfoService(),\n\t)\n\t// If evidence needs to be handled for the app, set routes in router here and seal\n\tapp.EvidenceKeeper = *evidenceKeeper\n\n\tapp.EpochsKeeper = epochskeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[epochstypes.StoreKey]),\n\t\tappCodec,\n\t)\n\napp.EpochsKeeper.SetHooks(\n\t\tepochstypes.NewMultiEpochHooks(\n\t\t\t// insert epoch hooks receivers here\n\t\t),\n\t)\n\n\t/****  Module Options ****/\n\n\t// NOTE: Any module instantiated in the module manager that is later modified\n\t// must be passed by reference here.\n\tapp.ModuleManager = module.NewManager(\n\t\tgenutil.NewAppModule(\n\t\t\tapp.AccountKeeper, app.StakingKeeper, app,\n\t\t\ttxConfig,\n\t\t),\n\t\tauth.NewAppModule(appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n\t\tvesting.NewAppModule(app.AccountKeeper, app.BankKeeper),\n\t\tbank.NewAppModule(appCodec, app.BankKeeper, app.AccountKeeper, nil),\n\t\tfeegrantmodule.NewAppModule(appCodec, app.AccountKeeper, app.BankKeeper, app.FeeGrantKeeper, app.interfaceRegistry),\n\t\tgov.NewAppModule(appCodec, &app.GovKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tmint.NewAppModule(appCodec, app.MintKeeper, app.AccountKeeper, nil, nil),\n\t\tslashing.NewAppModule(appCodec, app.SlashingKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil, app.interfaceRegistry),\n\t\tdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil),\n\t\tstaking.NewAppModule(appCodec, app.StakingKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tupgrade.NewAppModule(app.UpgradeKeeper, app.AccountKeeper.AddressCodec()),\n\t\tevidence.NewAppModule(app.EvidenceKeeper),\n\t\tauthzmodule.NewAppModule(appCodec, app.AuthzKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tgroupmodule.NewAppModule(appCodec, app.GroupKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tnftmodule.NewAppModule(appCodec, app.NFTKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tconsensus.NewAppModule(appCodec, app.ConsensusParamsKeeper),\n\t\tcircuit.NewAppModule(appCodec, app.CircuitKeeper),\n\t\tepochs.NewAppModule(app.EpochsKeeper),\n\t\tprotocolpool.NewAppModule(app.ProtocolPoolKeeper, app.AccountKeeper, app.BankKeeper),\n\t)\n\n\t// BasicModuleManager defines the module BasicManager is in charge of setting up basic,\n\t// non-dependant module elements, such as codec registration and genesis verification.\n\t// By default it is composed of all the module from the module manager.\n\t// Additionally, app module basics can be overwritten by passing them as argument.\n\tapp.BasicModuleManager = module.NewBasicManagerFromManager(\n\t\tapp.ModuleManager,\n\t\tmap[string]module.AppModuleBasic{\n    genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),\n\t\t\tgovtypes.ModuleName: gov.NewAppModuleBasic(\n\t\t\t\t[]govclient.ProposalHandler{\n},\n\t\t\t),\n})\n\napp.BasicModuleManager.RegisterLegacyAminoCodec(legacyAmino)\n\napp.BasicModuleManager.RegisterInterfaces(interfaceRegistry)\n\n\t// NOTE: upgrade module is required to be prioritized\n\tapp.ModuleManager.SetOrderPreBlockers(\n\t\tupgradetypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t)\n\t// During begin block slashing happens after distr.BeginBlocker so that\n\t// there is nothing left over in the validator fee pool, so as to keep the\n\t// CanWithdrawInvariant invariant.\n\t// NOTE: staking module is required if HistoricalEntries param > 0\n\tapp.ModuleManager.SetOrderBeginBlockers(\n\t\tminttypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tepochstypes.ModuleName,\n\t)\n\napp.ModuleManager.SetOrderEndBlockers(\n\t\tgovtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tgroup.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t)\n\n\t// NOTE: The genutils module must occur after staking so that pools are\n\t// properly initialized with tokens from genesis accounts.\n\t// NOTE: The genutils module must also occur after auth so that it can access the params from auth.\n    genesisModuleOrder := []string{\n    authtypes.ModuleName,\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tconsensusparamtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n}\n    exportModuleOrder := []string{\n    consensusparamtypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName, // Must be exported before bank\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n}\n\napp.ModuleManager.SetOrderInitGenesis(genesisModuleOrder...)\n\napp.ModuleManager.SetOrderExportGenesis(exportModuleOrder...)\n\n\t// Uncomment if you want to set a custom migration order here.\n\t// app.ModuleManager.SetOrderMigrations(custom order)\n\napp.configurator = module.NewConfigurator(app.appCodec, app.MsgServiceRouter(), app.GRPCQueryRouter())\n\nerr = app.ModuleManager.RegisterServices(app.configurator)\n    if err != nil {\n    panic(err)\n}\n\n\t// RegisterUpgradeHandlers is used for registering any on-chain upgrades.\n\t// Make sure it's called after `app.ModuleManager` and `app.configurator` are set.\n\tapp.RegisterUpgradeHandlers()\n\nautocliv1.RegisterQueryServer(app.GRPCQueryRouter(), runtimeservices.NewAutoCLIQueryService(app.ModuleManager.Modules))\n\nreflectionSvc, err := runtimeservices.NewReflectionService()\n    if err != nil {\n    panic(err)\n}\n\nreflectionv1.RegisterReflectionServiceServer(app.GRPCQueryRouter(), reflectionSvc)\n\n\t// add test gRPC service for testing gRPC queries in isolation\n\ttestdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{\n})\n\n\t// create the simulation manager and define the order of the modules for deterministic simulations\n\t//\n\t// NOTE: this is not required apps that don't use the simulator for fuzz testing\n\t// transactions\n    overrideModules := map[string]module.AppModuleSimulation{\n    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n}\n\napp.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)\n\napp.sm.RegisterStoreDecoders()\n\n\t// initialize stores\n\tapp.MountKVStores(keys)\n\n\t// initialize BaseApp\n\tapp.SetInitChainer(app.InitChainer)\n\napp.SetPreBlocker(app.PreBlocker)\n\napp.SetBeginBlocker(app.BeginBlocker)\n\napp.SetEndBlocker(app.EndBlocker)\n\napp.setAnteHandler(txConfig)\n\n\t// In v0.46, the SDK introduces _postHandlers_. PostHandlers are like\n\t// antehandlers, but are run _after_ the `runMsgs` execution. They are also\n\t// defined as a chain, and have the same signature as antehandlers.\n\t//\n\t// In baseapp, postHandlers are run in the same store branch as `runMsgs`,\n\t// meaning that both `runMsgs` and `postHandler` state will be committed if\n\t// both are successful, and both will be reverted if any of the two fails.\n\t//\n\t// The SDK exposes a default postHandlers chain\n\t//\n\t// Please note that changing any of the anteHandler or postHandler chain is\n\t// likely to be a state-machine breaking change, which needs a coordinated\n\t// upgrade.\n\tapp.setPostHandler()\n    if loadLatest {\n    if err := app.LoadLatestVersion(); err != nil {\n    panic(fmt.Errorf(\"error loading last version: %w\", err))\n}\n\t\n}\n\nreturn app\n}\n\nfunc (app *SimApp)\n\nsetAnteHandler(txConfig client.TxConfig) {\n    anteHandler, err := NewAnteHandler(\n\t\tHandlerOptions{\n    ante.HandlerOptions{\n    AccountKeeper:   app.AccountKeeper,\n    BankKeeper:      app.BankKeeper,\n    SignModeHandler: txConfig.SignModeHandler(),\n    FeegrantKeeper:  app.FeeGrantKeeper,\n    SigGasConsumer:  ante.DefaultSigVerificationGasConsumer,\n    SigVerifyOptions: []ante.SigVerificationDecoratorOption{\n\t\t\t\t\t// change below as needed.\n\t\t\t\t\tante.WithUnorderedTxGasCost(ante.DefaultUnorderedTxGasCost),\n\t\t\t\t\tante.WithMaxUnorderedTxTimeoutDuration(ante.DefaultMaxTimeoutDuration),\n},\n},\n\t\t\t&app.CircuitKeeper,\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\n\t// Set the AnteHandler for the app\n\tapp.SetAnteHandler(anteHandler)\n}\n\nfunc (app *SimApp)\n\nsetPostHandler() {\n    postHandler, err := posthandler.NewPostHandler(\n\t\tposthandler.HandlerOptions{\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.SetPostHandler(postHandler)\n}\n\n// Name returns the name of the App\nfunc (app *SimApp)\n\nName()\n\nstring {\n    return app.BaseApp.Name()\n}\n\n// PreBlocker application updates every pre block\nfunc (app *SimApp)\n\nPreBlocker(ctx sdk.Context, _ *abci.RequestFinalizeBlock) (*sdk.ResponsePreBlock, error) {\n    return app.ModuleManager.PreBlock(ctx)\n}\n\n// BeginBlocker application updates every begin block\nfunc (app *SimApp)\n\nBeginBlocker(ctx sdk.Context) (sdk.BeginBlock, error) {\n    return app.ModuleManager.BeginBlock(ctx)\n}\n\n// EndBlocker application updates every end block\nfunc (app *SimApp)\n\nEndBlocker(ctx sdk.Context) (sdk.EndBlock, error) {\n    return app.ModuleManager.EndBlock(ctx)\n}\n\nfunc (a *SimApp)\n\nConfigurator()\n\nmodule.Configurator {\n    return a.configurator\n}\n\n// InitChainer application update at chain initialization\nfunc (app *SimApp)\n\nInitChainer(ctx sdk.Context, req *abci.RequestInitChain) (*abci.ResponseInitChain, error) {\n    var genesisState GenesisState\n    if err := json.Unmarshal(req.AppStateBytes, &genesisState); err != nil {\n    panic(err)\n}\n\napp.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())\n\nreturn app.ModuleManager.InitGenesis(ctx, app.appCodec, genesisState)\n}\n\n// LoadHeight loads a particular height\nfunc (app *SimApp)\n\nLoadHeight(height int64)\n\nerror {\n    return app.LoadVersion(height)\n}\n\n// LegacyAmino returns SimApp's amino codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nLegacyAmino() *codec.LegacyAmino {\n    return app.legacyAmino\n}\n\n// AppCodec returns SimApp's app codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nAppCodec()\n\ncodec.Codec {\n    return app.appCodec\n}\n\n// InterfaceRegistry returns SimApp's InterfaceRegistry\nfunc (app *SimApp)\n\nInterfaceRegistry()\n\ntypes.InterfaceRegistry {\n    return app.interfaceRegistry\n}\n\n// TxConfig returns SimApp's TxConfig\nfunc (app *SimApp)\n\nTxConfig()\n\nclient.TxConfig {\n    return app.txConfig\n}\n\n// AutoCliOpts returns the autocli options for the app.\nfunc (app *SimApp)\n\nAutoCliOpts()\n\nautocli.AppOptions {\n    modules := make(map[string]appmodule.AppModule, 0)\n    for _, m := range app.ModuleManager.Modules {\n    if moduleWithName, ok := m.(module.HasName); ok {\n    moduleName := moduleWithName.Name()\n    if appModule, ok := moduleWithName.(appmodule.AppModule); ok {\n    modules[moduleName] = appModule\n}\n\t\n}\n\t\n}\n\nreturn autocli.AppOptions{\n    Modules:               modules,\n    ModuleOptions:         runtimeservices.ExtractAutoCLIOptions(app.ModuleManager.Modules),\n    AddressCodec:          authcodec.NewBech32Codec(sdk.GetConfig().GetBech32AccountAddrPrefix()),\n    ValidatorAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()),\n    ConsensusAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()),\n}\n}\n\n// DefaultGenesis returns a default genesis from the registered AppModuleBasic's.\nfunc (a *SimApp)\n\nDefaultGenesis()\n\nmap[string]json.RawMessage {\n    return a.BasicModuleManager.DefaultGenesis(a.appCodec)\n}\n\n// GetKey returns the KVStoreKey for the provided store key.\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc (app *SimApp)\n\nGetKey(storeKey string) *storetypes.KVStoreKey {\n    return app.keys[storeKey]\n}\n\n// GetStoreKeys returns all the stored store keys.\nfunc (app *SimApp)\n\nGetStoreKeys() []storetypes.StoreKey {\n    keys := make([]storetypes.StoreKey, 0, len(app.keys))\n    for _, key := range app.keys {\n    keys = append(keys, key)\n}\n\nreturn keys\n}\n\n// SimulationManager implements the SimulationApp interface\nfunc (app *SimApp)\n\nSimulationManager() *module.SimulationManager {\n    return app.sm\n}\n\n// RegisterAPIRoutes registers all application module routes with the provided\n// API server.\nfunc (app *SimApp)\n\nRegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {\n    clientCtx := apiSvr.ClientCtx\n\t// Register new tx routes from grpc-gateway.\n\tauthtx.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register new CometBFT queries routes from grpc-gateway.\n\tcmtservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register node gRPC service for grpc-gateway.\n\tnodeservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register grpc-gateway routes for all modules.\n\tapp.BasicModuleManager.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// register swagger API from root so that other applications can override easily\n    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {\n    panic(err)\n}\n}\n\n// RegisterTxService implements the Application.RegisterTxService method.\nfunc (app *SimApp)\n\nRegisterTxService(clientCtx client.Context) {\n    authtx.RegisterTxService(app.BaseApp.GRPCQueryRouter(), clientCtx, app.BaseApp.Simulate, app.interfaceRegistry)\n}\n\n// RegisterTendermintService implements the Application.RegisterTendermintService method.\nfunc (app *SimApp)\n\nRegisterTendermintService(clientCtx client.Context) {\n    cmtApp := server.NewCometABCIWrapper(app)\n\ncmtservice.RegisterTendermintService(\n\t\tclientCtx,\n\t\tapp.BaseApp.GRPCQueryRouter(),\n\t\tapp.interfaceRegistry,\n\t\tcmtApp.Query,\n\t)\n}\n\nfunc (app *SimApp)\n\nRegisterNodeService(clientCtx client.Context, cfg config.Config) {\n    nodeservice.RegisterNodeService(clientCtx, app.GRPCQueryRouter(), cfg)\n}\n\n// GetMaccPerms returns a copy of the module account permissions\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc GetMaccPerms()\n\nmap[string][]string {\n    return maps.Clone(maccPerms)\n}\n\n// BlockedAddresses returns all the app's blocked account addresses.\nfunc BlockedAddresses()\n\nmap[string]bool {\n    modAccAddrs := make(map[string]bool)\n    for acc := range GetMaccPerms() {\n    modAccAddrs[authtypes.NewModuleAddress(acc).String()] = true\n}\n\n\t// allow the following addresses to receive funds\n\tdelete(modAccAddrs, authtypes.NewModuleAddress(govtypes.ModuleName).String())\n\nreturn modAccAddrs\n}\nSee all 1010 lines\n\u200b\nInitChainer\nThe InitChainer is a function that initializes the state of the application from a genesis file (i.e. token balances of genesis accounts). It is called when the application receives the InitChain message from the CometBFT engine, which happens when the node is started at appBlockHeight == 0 (i.e. on genesis). The application must set the InitChainer in its constructor via the SetInitChainer method.\nIn general, the InitChainer is mostly composed of the InitGenesis function of each of the application\u2019s modules. This is done by calling the InitGenesis function of the module manager, which in turn calls the InitGenesis function of each of the modules it contains. Note that the order in which the modules\u2019 InitGenesis functions must be called has to be set in the module manager using the module manager\u2019s SetOrderInitGenesis method. This is done in the application\u2019s constructor, and the SetOrderInitGenesis has to be called before the SetInitChainer.\nSee an example of an InitChainer from simapp:\n\nCopy\n\nAsk AI\n//go:build app_v1\n\npackage simapp\n\nimport (\n    \n\t\"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"maps\"\n\n\tabci \"github.com/cometbft/cometbft/abci/types\"\n\tdbm \"github.com/cosmos/cosmos-db\"\n    \"github.com/cosmos/gogoproto/proto\"\n    \"github.com/spf13/cast\"\n\n\tautocliv1 \"cosmossdk.io/api/cosmos/autocli/v1\"\n\treflectionv1 \"cosmossdk.io/api/cosmos/reflection/v1\"\n    \"cosmossdk.io/client/v2/autocli\"\n\tclienthelpers \"cosmossdk.io/client/v2/helpers\"\n    \"cosmossdk.io/core/appmodule\"\n    \"cosmossdk.io/log\"\n\tstoretypes \"cosmossdk.io/store/types\"\n    \"cosmossdk.io/x/circuit\"\n\tcircuitkeeper \"cosmossdk.io/x/circuit/keeper\"\n\tcircuittypes \"cosmossdk.io/x/circuit/types\"\n    \"cosmossdk.io/x/evidence\"\n\tevidencekeeper \"cosmossdk.io/x/evidence/keeper\"\n\tevidencetypes \"cosmossdk.io/x/evidence/types\"\n    \"cosmossdk.io/x/feegrant\"\n\tfeegrantkeeper \"cosmossdk.io/x/feegrant/keeper\"\n\tfeegrantmodule \"cosmossdk.io/x/feegrant/module\"\n    \"cosmossdk.io/x/nft\"\n\tnftkeeper \"cosmossdk.io/x/nft/keeper\"\n\tnftmodule \"cosmossdk.io/x/nft/module\"\n    \"cosmossdk.io/x/tx/signing\"\n    \"cosmossdk.io/x/upgrade\"\n\tupgradekeeper \"cosmossdk.io/x/upgrade/keeper\"\n\tupgradetypes \"cosmossdk.io/x/upgrade/types\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/client/flags\"\n    \"github.com/cosmos/cosmos-sdk/client/grpc/cmtservice\"\n\tnodeservice \"github.com/cosmos/cosmos-sdk/client/grpc/node\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/address\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n    \"github.com/cosmos/cosmos-sdk/runtime\"\n\truntimeservices \"github.com/cosmos/cosmos-sdk/runtime/services\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n    \"github.com/cosmos/cosmos-sdk/std\"\n\ttestdata_pulsar \"github.com/cosmos/cosmos-sdk/testutil/testdata/testpb\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n    \"github.com/cosmos/cosmos-sdk/types/module\"\n\tsigtypes \"github.com/cosmos/cosmos-sdk/types/tx/signing\"\n    \"github.com/cosmos/cosmos-sdk/version\"\n    \"github.com/cosmos/cosmos-sdk/x/auth\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/ante\"\n\tauthcodec \"github.com/cosmos/cosmos-sdk/x/auth/codec\"\n\tauthkeeper \"github.com/cosmos/cosmos-sdk/x/auth/keeper\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/posthandler\"\n\tauthsims \"github.com/cosmos/cosmos-sdk/x/auth/simulation\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\ttxmodule \"github.com/cosmos/cosmos-sdk/x/auth/tx/config\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/vesting\"\n\tvestingtypes \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n    \"github.com/cosmos/cosmos-sdk/x/authz\"\n\tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n\tauthzmodule \"github.com/cosmos/cosmos-sdk/x/authz/module\"\n    \"github.com/cosmos/cosmos-sdk/x/bank\"\n\tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n\tconsensus \"github.com/cosmos/cosmos-sdk/x/consensus\"\n\tconsensusparamkeeper \"github.com/cosmos/cosmos-sdk/x/consensus/keeper\"\n\tconsensusparamtypes \"github.com/cosmos/cosmos-sdk/x/consensus/types\"\n\tdistr \"github.com/cosmos/cosmos-sdk/x/distribution\"\n\tdistrkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n\tdistrtypes \"github.com/cosmos/cosmos-sdk/x/distribution/types\"\n    \"github.com/cosmos/cosmos-sdk/x/epochs\"\n\tepochskeeper \"github.com/cosmos/cosmos-sdk/x/epochs/keeper\"\n\tepochstypes \"github.com/cosmos/cosmos-sdk/x/epochs/types\"\n    \"github.com/cosmos/cosmos-sdk/x/genutil\"\n\tgenutiltypes \"github.com/cosmos/cosmos-sdk/x/genutil/types\"\n    \"github.com/cosmos/cosmos-sdk/x/gov\"\n\tgovclient \"github.com/cosmos/cosmos-sdk/x/gov/client\"\n\tgovkeeper \"github.com/cosmos/cosmos-sdk/x/gov/keeper\"\n\tgovtypes \"github.com/cosmos/cosmos-sdk/x/gov/types\"\n\tgovv1beta1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1\"\n    \"github.com/cosmos/cosmos-sdk/x/group\"\n\tgroupkeeper \"github.com/cosmos/cosmos-sdk/x/group/keeper\"\n\tgroupmodule \"github.com/cosmos/cosmos-sdk/x/group/module\"\n    \"github.com/cosmos/cosmos-sdk/x/mint\"\n\tmintkeeper \"github.com/cosmos/cosmos-sdk/x/mint/keeper\"\n\tminttypes \"github.com/cosmos/cosmos-sdk/x/mint/types\"\n    \"github.com/cosmos/cosmos-sdk/x/protocolpool\"\n\tprotocolpoolkeeper \"github.com/cosmos/cosmos-sdk/x/protocolpool/keeper\"\n\tprotocolpooltypes \"github.com/cosmos/cosmos-sdk/x/protocolpool/types\"\n    \"github.com/cosmos/cosmos-sdk/x/slashing\"\n\tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n\tslashingtypes \"github.com/cosmos/cosmos-sdk/x/slashing/types\"\n    \"github.com/cosmos/cosmos-sdk/x/staking\"\n\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n)\n\nconst appName = \"SimApp\"\n\nvar (\n\t// DefaultNodeHome default home directories for the application daemon\n\tDefaultNodeHome string\n\n\t// module account permissions\n\tmaccPerms = map[string][]string{\n    authtypes.FeeCollectorName:                  nil,\n\t\tdistrtypes.ModuleName:                       nil,\n\t\tminttypes.ModuleName:                        {\n    authtypes.Minter\n},\n\t\tstakingtypes.BondedPoolName:                 {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tstakingtypes.NotBondedPoolName:              {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tgovtypes.ModuleName:                         {\n    authtypes.Burner\n},\n\t\tnft.ModuleName:                              nil,\n\t\tprotocolpooltypes.ModuleName:                nil,\n\t\tprotocolpooltypes.ProtocolPoolEscrowAccount: nil\n}\n)\n\nvar (\n\t_ runtime.AppI            = (*SimApp)(nil)\n\t_ servertypes.Application = (*SimApp)(nil)\n)\n\n// SimApp extends an ABCI application, but with most of its parameters exported.\n// They are exported for convenience in creating helper functions, as object\n// capabilities aren't needed for testing.\ntype SimApp struct {\n\t*baseapp.BaseApp\n\tlegacyAmino       *codec.LegacyAmino\n\tappCodec          codec.Codec\n\ttxConfig          client.TxConfig\n\tinterfaceRegistry types.InterfaceRegistry\n\n\t// keys to access the substores\n\tkeys map[string]*storetypes.KVStoreKey\n\n\t// essential keepers\n\tAccountKeeper         authkeeper.AccountKeeper\n\tBankKeeper            bankkeeper.BaseKeeper\n\tStakingKeeper         *stakingkeeper.Keeper\n\tSlashingKeeper        slashingkeeper.Keeper\n\tMintKeeper            mintkeeper.Keeper\n\tDistrKeeper           distrkeeper.Keeper\n\tGovKeeper             govkeeper.Keeper\n\tUpgradeKeeper         *upgradekeeper.Keeper\n\tEvidenceKeeper        evidencekeeper.Keeper\n\tConsensusParamsKeeper consensusparamkeeper.Keeper\n\tCircuitKeeper         circuitkeeper.Keeper\n\n\t// supplementary keepers\n\tFeeGrantKeeper     feegrantkeeper.Keeper\n\tGroupKeeper        groupkeeper.Keeper\n\tAuthzKeeper        authzkeeper.Keeper\n\tNFTKeeper          nftkeeper.Keeper\n\tEpochsKeeper       epochskeeper.Keeper\n\tProtocolPoolKeeper protocolpoolkeeper.Keeper\n\n\t// the module manager\n\tModuleManager      *module.Manager\n\tBasicModuleManager module.BasicManager\n\n\t// simulation manager\n\tsm *module.SimulationManager\n\n\t// module configurator\n\tconfigurator module.Configurator\n}\n\nfunc init() {\n    var err error\n\tDefaultNodeHome, err = clienthelpers.GetNodeHomeDirectory(\".simapp\")\n    if err != nil {\n    panic(err)\n}\n}\n\n// NewSimApp returns a reference to an initialized SimApp.\nfunc NewSimApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tloadLatest bool,\n\tappOpts servertypes.AppOptions,\n\tbaseAppOptions ...func(*baseapp.BaseApp),\n) *SimApp {\n    interfaceRegistry, _ := types.NewInterfaceRegistryWithOptions(types.InterfaceRegistryOptions{\n    ProtoFiles: proto.HybridResolver,\n    SigningOptions: signing.Options{\n    AddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32AccountAddrPrefix(),\n},\n    ValidatorAddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32ValidatorAddrPrefix(),\n},\n},\n})\n    appCodec := codec.NewProtoCodec(interfaceRegistry)\n    legacyAmino := codec.NewLegacyAmino()\n    txConfig := tx.NewTxConfig(appCodec, tx.DefaultSignModes)\n    if err := interfaceRegistry.SigningContext().Validate(); err != nil {\n    panic(err)\n}\n\nstd.RegisterLegacyAminoCodec(legacyAmino)\n\nstd.RegisterInterfaces(interfaceRegistry)\n\n\t// Below we could construct and set an application specific mempool and\n\t// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are\n\t// already set in the SDK's BaseApp, this shows an example of how to override\n\t// them.\n\t//\n\t// Example:\n\t//\n\t// bApp := baseapp.NewBaseApp(...)\n\t// nonceMempool := mempool.NewSenderNonceMempool()\n\t// abciPropHandler := NewDefaultProposalHandler(nonceMempool, bApp)\n\t//\n\t// bApp.SetMempool(nonceMempool)\n\t// bApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t// bApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())\n\t//\n\t// Alternatively, you can construct BaseApp options, append those to\n\t// baseAppOptions and pass them to NewBaseApp.\n\t//\n\t// Example:\n\t//\n\t// prepareOpt = func(app *baseapp.BaseApp) {\n\t// \tabciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)\n\t// \tapp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t//\n}\n\t// baseAppOptions = append(baseAppOptions, prepareOpt)\n\n\t// create and set dummy vote extension handler\n    voteExtOp := func(bApp *baseapp.BaseApp) {\n    voteExtHandler := NewVoteExtensionHandler()\n\nvoteExtHandler.SetHandlers(bApp)\n}\n\nbaseAppOptions = append(baseAppOptions, voteExtOp, baseapp.SetOptimisticExecution())\n    bApp := baseapp.NewBaseApp(appName, logger, db, txConfig.TxDecoder(), baseAppOptions...)\n\nbApp.SetCommitMultiStoreTracer(traceStore)\n\nbApp.SetVersion(version.Version)\n\nbApp.SetInterfaceRegistry(interfaceRegistry)\n\nbApp.SetTxEncoder(txConfig.TxEncoder())\n    keys := storetypes.NewKVStoreKeys(\n\t\tauthtypes.StoreKey,\n\t\tbanktypes.StoreKey,\n\t\tstakingtypes.StoreKey,\n\t\tminttypes.StoreKey,\n\t\tdistrtypes.StoreKey,\n\t\tslashingtypes.StoreKey,\n\t\tgovtypes.StoreKey,\n\t\tconsensusparamtypes.StoreKey,\n\t\tupgradetypes.StoreKey,\n\t\tfeegrant.StoreKey,\n\t\tevidencetypes.StoreKey,\n\t\tcircuittypes.StoreKey,\n\t\tauthzkeeper.StoreKey,\n\t\tnftkeeper.StoreKey,\n\t\tgroup.StoreKey,\n\t\tepochstypes.StoreKey,\n\t\tprotocolpooltypes.StoreKey,\n\t)\n\n\t// register streaming services\n    if err := bApp.RegisterStreamingServices(appOpts, keys); err != nil {\n    panic(err)\n}\n    app := &SimApp{\n    BaseApp:           bApp,\n\t\tlegacyAmino:       legacyAmino,\n\t\tappCodec:          appCodec,\n\t\ttxConfig:          txConfig,\n\t\tinterfaceRegistry: interfaceRegistry,\n\t\tkeys:              keys,\n}\n\n\t// set the BaseApp's parameter store\n\tapp.ConsensusParamsKeeper = consensusparamkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[consensusparamtypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\truntime.EventService{\n},\n\t)\n\nbApp.SetParamStore(app.ConsensusParamsKeeper.ParamsStore)\n\n\t// add keepers\n\tapp.AccountKeeper = authkeeper.NewAccountKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[authtypes.StoreKey]),\n\t\tauthtypes.ProtoBaseAccount,\n\t\tmaccPerms,\n\t\tauthcodec.NewBech32Codec(sdk.Bech32MainPrefix),\n\t\tsdk.Bech32MainPrefix,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthkeeper.WithUnorderedTransactions(true),\n\t)\n\napp.BankKeeper = bankkeeper.NewBaseKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[banktypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tBlockedAddresses(),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tlogger,\n\t)\n\n\t// optional: enable sign mode textual by overwriting the default tx config (after setting the bank keeper)\n    enabledSignModes := append(tx.DefaultSignModes, sigtypes.SignMode_SIGN_MODE_TEXTUAL)\n    txConfigOpts := tx.ConfigOptions{\n    EnabledSignModes:           enabledSignModes,\n    TextualCoinMetadataQueryFn: txmodule.NewBankKeeperCoinMetadataQueryFn(app.BankKeeper),\n}\n\ntxConfig, err := tx.NewTxConfigWithOptions(\n\t\tappCodec,\n\t\ttxConfigOpts,\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.txConfig = txConfig\n\n\tapp.StakingKeeper = stakingkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[stakingtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixValAddr),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixConsAddr),\n\t)\n\napp.MintKeeper = mintkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[minttypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// mintkeeper.WithMintFn(mintkeeper.DefaultMintFn(minttypes.DefaultInflationCalculationFn)), custom mintFn can be added here\n\t)\n\napp.ProtocolPoolKeeper = protocolpoolkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[protocolpooltypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.DistrKeeper = distrkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[distrtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tdistrkeeper.WithExternalCommunityPool(app.ProtocolPoolKeeper),\n\t)\n\napp.SlashingKeeper = slashingkeeper.NewKeeper(\n\t\tappCodec,\n\t\tlegacyAmino,\n\t\truntime.NewKVStoreService(keys[slashingtypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.FeeGrantKeeper = feegrantkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[feegrant.StoreKey]),\n\t\tapp.AccountKeeper,\n\t)\n\n\t// register the staking hooks\n\t// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks\n\tapp.StakingKeeper.SetHooks(\n\t\tstakingtypes.NewMultiStakingHooks(\n\t\t\tapp.DistrKeeper.Hooks(),\n\t\t\tapp.SlashingKeeper.Hooks(),\n\t\t),\n\t)\n\napp.CircuitKeeper = circuitkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[circuittypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tapp.AccountKeeper.AddressCodec(),\n\t)\n\napp.BaseApp.SetCircuitBreaker(&app.CircuitKeeper)\n\napp.AuthzKeeper = authzkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[authzkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t)\n    groupConfig := group.DefaultConfig()\n\t/*\n\t\tExample of setting group params:\n\t\tgroupConfig.MaxMetadataLen = 1000\n\t*/\n\tapp.GroupKeeper = groupkeeper.NewKeeper(\n\t\tkeys[group.StoreKey],\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t\tgroupConfig,\n\t)\n\n\t// get skipUpgradeHeights from the app options\n    skipUpgradeHeights := map[int64]bool{\n}\n    for _, h := range cast.ToIntSlice(appOpts.Get(server.FlagUnsafeSkipUpgrades)) {\n    skipUpgradeHeights[int64(h)] = true\n}\n    homePath := cast.ToString(appOpts.Get(flags.FlagHome))\n\t// set the governance module account as the authority for conducting upgrades\n\tapp.UpgradeKeeper = upgradekeeper.NewKeeper(\n\t\tskipUpgradeHeights,\n\t\truntime.NewKVStoreService(keys[upgradetypes.StoreKey]),\n\t\tappCodec,\n\t\thomePath,\n\t\tapp.BaseApp,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\n\t// Register the proposal types\n\t// Deprecated: Avoid adding new handlers, instead use the new proposal flow\n\t// by granting the governance module the right to execute the message.\n\t// See: https://docs.cosmos.network/main/modules/gov#proposal-messages\n    govRouter := govv1beta1.NewRouter()\n\ngovRouter.AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler)\n    govConfig := govtypes.DefaultConfig()\n\t/*\n\t\tExample of setting gov params:\n\t\tgovConfig.MaxMetadataLen = 10000\n\t*/\n    govKeeper := govkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[govtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tapp.DistrKeeper,\n\t\tapp.MsgServiceRouter(),\n\t\tgovConfig,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// govkeeper.WithCustomCalculateVoteResultsAndVotingPowerFn(...), // Add if you want to use a custom vote calculation function.\n\t)\n\n\t// Set legacy router for backwards compatibility with gov v1beta1\n\tgovKeeper.SetLegacyRouter(govRouter)\n\napp.GovKeeper = *govKeeper.SetHooks(\n\t\tgovtypes.NewMultiGovHooks(\n\t\t\t// register the governance hooks\n\t\t),\n\t)\n\napp.NFTKeeper = nftkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[nftkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t)\n\n\t// create evidence keeper with router\n    evidenceKeeper := evidencekeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[evidencetypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.SlashingKeeper,\n\t\tapp.AccountKeeper.AddressCodec(),\n\t\truntime.ProvideCometInfoService(),\n\t)\n\t// If evidence needs to be handled for the app, set routes in router here and seal\n\tapp.EvidenceKeeper = *evidenceKeeper\n\n\tapp.EpochsKeeper = epochskeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[epochstypes.StoreKey]),\n\t\tappCodec,\n\t)\n\napp.EpochsKeeper.SetHooks(\n\t\tepochstypes.NewMultiEpochHooks(\n\t\t\t// insert epoch hooks receivers here\n\t\t),\n\t)\n\n\t/****  Module Options ****/\n\n\t// NOTE: Any module instantiated in the module manager that is later modified\n\t// must be passed by reference here.\n\tapp.ModuleManager = module.NewManager(\n\t\tgenutil.NewAppModule(\n\t\t\tapp.AccountKeeper, app.StakingKeeper, app,\n\t\t\ttxConfig,\n\t\t),\n\t\tauth.NewAppModule(appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n\t\tvesting.NewAppModule(app.AccountKeeper, app.BankKeeper),\n\t\tbank.NewAppModule(appCodec, app.BankKeeper, app.AccountKeeper, nil),\n\t\tfeegrantmodule.NewAppModule(appCodec, app.AccountKeeper, app.BankKeeper, app.FeeGrantKeeper, app.interfaceRegistry),\n\t\tgov.NewAppModule(appCodec, &app.GovKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tmint.NewAppModule(appCodec, app.MintKeeper, app.AccountKeeper, nil, nil),\n\t\tslashing.NewAppModule(appCodec, app.SlashingKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil, app.interfaceRegistry),\n\t\tdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil),\n\t\tstaking.NewAppModule(appCodec, app.StakingKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tupgrade.NewAppModule(app.UpgradeKeeper, app.AccountKeeper.AddressCodec()),\n\t\tevidence.NewAppModule(app.EvidenceKeeper),\n\t\tauthzmodule.NewAppModule(appCodec, app.AuthzKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tgroupmodule.NewAppModule(appCodec, app.GroupKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tnftmodule.NewAppModule(appCodec, app.NFTKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tconsensus.NewAppModule(appCodec, app.ConsensusParamsKeeper),\n\t\tcircuit.NewAppModule(appCodec, app.CircuitKeeper),\n\t\tepochs.NewAppModule(app.EpochsKeeper),\n\t\tprotocolpool.NewAppModule(app.ProtocolPoolKeeper, app.AccountKeeper, app.BankKeeper),\n\t)\n\n\t// BasicModuleManager defines the module BasicManager is in charge of setting up basic,\n\t// non-dependant module elements, such as codec registration and genesis verification.\n\t// By default it is composed of all the module from the module manager.\n\t// Additionally, app module basics can be overwritten by passing them as argument.\n\tapp.BasicModuleManager = module.NewBasicManagerFromManager(\n\t\tapp.ModuleManager,\n\t\tmap[string]module.AppModuleBasic{\n    genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),\n\t\t\tgovtypes.ModuleName: gov.NewAppModuleBasic(\n\t\t\t\t[]govclient.ProposalHandler{\n},\n\t\t\t),\n})\n\napp.BasicModuleManager.RegisterLegacyAminoCodec(legacyAmino)\n\napp.BasicModuleManager.RegisterInterfaces(interfaceRegistry)\n\n\t// NOTE: upgrade module is required to be prioritized\n\tapp.ModuleManager.SetOrderPreBlockers(\n\t\tupgradetypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t)\n\t// During begin block slashing happens after distr.BeginBlocker so that\n\t// there is nothing left over in the validator fee pool, so as to keep the\n\t// CanWithdrawInvariant invariant.\n\t// NOTE: staking module is required if HistoricalEntries param > 0\n\tapp.ModuleManager.SetOrderBeginBlockers(\n\t\tminttypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tepochstypes.ModuleName,\n\t)\n\napp.ModuleManager.SetOrderEndBlockers(\n\t\tgovtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tgroup.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t)\n\n\t// NOTE: The genutils module must occur after staking so that pools are\n\t// properly initialized with tokens from genesis accounts.\n\t// NOTE: The genutils module must also occur after auth so that it can access the params from auth.\n    genesisModuleOrder := []string{\n    authtypes.ModuleName,\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tconsensusparamtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n}\n    exportModuleOrder := []string{\n    consensusparamtypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName, // Must be exported before bank\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n}\n\napp.ModuleManager.SetOrderInitGenesis(genesisModuleOrder...)\n\napp.ModuleManager.SetOrderExportGenesis(exportModuleOrder...)\n\n\t// Uncomment if you want to set a custom migration order here.\n\t// app.ModuleManager.SetOrderMigrations(custom order)\n\napp.configurator = module.NewConfigurator(app.appCodec, app.MsgServiceRouter(), app.GRPCQueryRouter())\n\nerr = app.ModuleManager.RegisterServices(app.configurator)\n    if err != nil {\n    panic(err)\n}\n\n\t// RegisterUpgradeHandlers is used for registering any on-chain upgrades.\n\t// Make sure it's called after `app.ModuleManager` and `app.configurator` are set.\n\tapp.RegisterUpgradeHandlers()\n\nautocliv1.RegisterQueryServer(app.GRPCQueryRouter(), runtimeservices.NewAutoCLIQueryService(app.ModuleManager.Modules))\n\nreflectionSvc, err := runtimeservices.NewReflectionService()\n    if err != nil {\n    panic(err)\n}\n\nreflectionv1.RegisterReflectionServiceServer(app.GRPCQueryRouter(), reflectionSvc)\n\n\t// add test gRPC service for testing gRPC queries in isolation\n\ttestdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{\n})\n\n\t// create the simulation manager and define the order of the modules for deterministic simulations\n\t//\n\t// NOTE: this is not required apps that don't use the simulator for fuzz testing\n\t// transactions\n    overrideModules := map[string]module.AppModuleSimulation{\n    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n}\n\napp.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)\n\napp.sm.RegisterStoreDecoders()\n\n\t// initialize stores\n\tapp.MountKVStores(keys)\n\n\t// initialize BaseApp\n\tapp.SetInitChainer(app.InitChainer)\n\napp.SetPreBlocker(app.PreBlocker)\n\napp.SetBeginBlocker(app.BeginBlocker)\n\napp.SetEndBlocker(app.EndBlocker)\n\napp.setAnteHandler(txConfig)\n\n\t// In v0.46, the SDK introduces _postHandlers_. PostHandlers are like\n\t// antehandlers, but are run _after_ the `runMsgs` execution. They are also\n\t// defined as a chain, and have the same signature as antehandlers.\n\t//\n\t// In baseapp, postHandlers are run in the same store branch as `runMsgs`,\n\t// meaning that both `runMsgs` and `postHandler` state will be committed if\n\t// both are successful, and both will be reverted if any of the two fails.\n\t//\n\t// The SDK exposes a default postHandlers chain\n\t//\n\t// Please note that changing any of the anteHandler or postHandler chain is\n\t// likely to be a state-machine breaking change, which needs a coordinated\n\t// upgrade.\n\tapp.setPostHandler()\n    if loadLatest {\n    if err := app.LoadLatestVersion(); err != nil {\n    panic(fmt.Errorf(\"error loading last version: %w\", err))\n}\n\t\n}\n\nreturn app\n}\n\nfunc (app *SimApp)\n\nsetAnteHandler(txConfig client.TxConfig) {\n    anteHandler, err := NewAnteHandler(\n\t\tHandlerOptions{\n    ante.HandlerOptions{\n    AccountKeeper:   app.AccountKeeper,\n    BankKeeper:      app.BankKeeper,\n    SignModeHandler: txConfig.SignModeHandler(),\n    FeegrantKeeper:  app.FeeGrantKeeper,\n    SigGasConsumer:  ante.DefaultSigVerificationGasConsumer,\n    SigVerifyOptions: []ante.SigVerificationDecoratorOption{\n\t\t\t\t\t// change below as needed.\n\t\t\t\t\tante.WithUnorderedTxGasCost(ante.DefaultUnorderedTxGasCost),\n\t\t\t\t\tante.WithMaxUnorderedTxTimeoutDuration(ante.DefaultMaxTimeoutDuration),\n},\n},\n\t\t\t&app.CircuitKeeper,\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\n\t// Set the AnteHandler for the app\n\tapp.SetAnteHandler(anteHandler)\n}\n\nfunc (app *SimApp)\n\nsetPostHandler() {\n    postHandler, err := posthandler.NewPostHandler(\n\t\tposthandler.HandlerOptions{\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.SetPostHandler(postHandler)\n}\n\n// Name returns the name of the App\nfunc (app *SimApp)\n\nName()\n\nstring {\n    return app.BaseApp.Name()\n}\n\n// PreBlocker application updates every pre block\nfunc (app *SimApp)\n\nPreBlocker(ctx sdk.Context, _ *abci.RequestFinalizeBlock) (*sdk.ResponsePreBlock, error) {\n    return app.ModuleManager.PreBlock(ctx)\n}\n\n// BeginBlocker application updates every begin block\nfunc (app *SimApp)\n\nBeginBlocker(ctx sdk.Context) (sdk.BeginBlock, error) {\n    return app.ModuleManager.BeginBlock(ctx)\n}\n\n// EndBlocker application updates every end block\nfunc (app *SimApp)\n\nEndBlocker(ctx sdk.Context) (sdk.EndBlock, error) {\n    return app.ModuleManager.EndBlock(ctx)\n}\n\nfunc (a *SimApp)\n\nConfigurator()\n\nmodule.Configurator {\n    return a.configurator\n}\n\n// InitChainer application update at chain initialization\nfunc (app *SimApp)\n\nInitChainer(ctx sdk.Context, req *abci.RequestInitChain) (*abci.ResponseInitChain, error) {\n    var genesisState GenesisState\n    if err := json.Unmarshal(req.AppStateBytes, &genesisState); err != nil {\n    panic(err)\n}\n\napp.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())\n\nreturn app.ModuleManager.InitGenesis(ctx, app.appCodec, genesisState)\n}\n\n// LoadHeight loads a particular height\nfunc (app *SimApp)\n\nLoadHeight(height int64)\n\nerror {\n    return app.LoadVersion(height)\n}\n\n// LegacyAmino returns SimApp's amino codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nLegacyAmino() *codec.LegacyAmino {\n    return app.legacyAmino\n}\n\n// AppCodec returns SimApp's app codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nAppCodec()\n\ncodec.Codec {\n    return app.appCodec\n}\n\n// InterfaceRegistry returns SimApp's InterfaceRegistry\nfunc (app *SimApp)\n\nInterfaceRegistry()\n\ntypes.InterfaceRegistry {\n    return app.interfaceRegistry\n}\n\n// TxConfig returns SimApp's TxConfig\nfunc (app *SimApp)\n\nTxConfig()\n\nclient.TxConfig {\n    return app.txConfig\n}\n\n// AutoCliOpts returns the autocli options for the app.\nfunc (app *SimApp)\n\nAutoCliOpts()\n\nautocli.AppOptions {\n    modules := make(map[string]appmodule.AppModule, 0)\n    for _, m := range app.ModuleManager.Modules {\n    if moduleWithName, ok := m.(module.HasName); ok {\n    moduleName := moduleWithName.Name()\n    if appModule, ok := moduleWithName.(appmodule.AppModule); ok {\n    modules[moduleName] = appModule\n}\n\t\n}\n\t\n}\n\nreturn autocli.AppOptions{\n    Modules:               modules,\n    ModuleOptions:         runtimeservices.ExtractAutoCLIOptions(app.ModuleManager.Modules),\n    AddressCodec:          authcodec.NewBech32Codec(sdk.GetConfig().GetBech32AccountAddrPrefix()),\n    ValidatorAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()),\n    ConsensusAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()),\n}\n}\n\n// DefaultGenesis returns a default genesis from the registered AppModuleBasic's.\nfunc (a *SimApp)\n\nDefaultGenesis()\n\nmap[string]json.RawMessage {\n    return a.BasicModuleManager.DefaultGenesis(a.appCodec)\n}\n\n// GetKey returns the KVStoreKey for the provided store key.\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc (app *SimApp)\n\nGetKey(storeKey string) *storetypes.KVStoreKey {\n    return app.keys[storeKey]\n}\n\n// GetStoreKeys returns all the stored store keys.\nfunc (app *SimApp)\n\nGetStoreKeys() []storetypes.StoreKey {\n    keys := make([]storetypes.StoreKey, 0, len(app.keys))\n    for _, key := range app.keys {\n    keys = append(keys, key)\n}\n\nreturn keys\n}\n\n// SimulationManager implements the SimulationApp interface\nfunc (app *SimApp)\n\nSimulationManager() *module.SimulationManager {\n    return app.sm\n}\n\n// RegisterAPIRoutes registers all application module routes with the provided\n// API server.\nfunc (app *SimApp)\n\nRegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {\n    clientCtx := apiSvr.ClientCtx\n\t// Register new tx routes from grpc-gateway.\n\tauthtx.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register new CometBFT queries routes from grpc-gateway.\n\tcmtservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register node gRPC service for grpc-gateway.\n\tnodeservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register grpc-gateway routes for all modules.\n\tapp.BasicModuleManager.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// register swagger API from root so that other applications can override easily\n    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {\n    panic(err)\n}\n}\n\n// RegisterTxService implements the Application.RegisterTxService method.\nfunc (app *SimApp)\n\nRegisterTxService(clientCtx client.Context) {\n    authtx.RegisterTxService(app.BaseApp.GRPCQueryRouter(), clientCtx, app.BaseApp.Simulate, app.interfaceRegistry)\n}\n\n// RegisterTendermintService implements the Application.RegisterTendermintService method.\nfunc (app *SimApp)\n\nRegisterTendermintService(clientCtx client.Context) {\n    cmtApp := server.NewCometABCIWrapper(app)\n\ncmtservice.RegisterTendermintService(\n\t\tclientCtx,\n\t\tapp.BaseApp.GRPCQueryRouter(),\n\t\tapp.interfaceRegistry,\n\t\tcmtApp.Query,\n\t)\n}\n\nfunc (app *SimApp)\n\nRegisterNodeService(clientCtx client.Context, cfg config.Config) {\n    nodeservice.RegisterNodeService(clientCtx, app.GRPCQueryRouter(), cfg)\n}\n\n// GetMaccPerms returns a copy of the module account permissions\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc GetMaccPerms()\n\nmap[string][]string {\n    return maps.Clone(maccPerms)\n}\n\n// BlockedAddresses returns all the app's blocked account addresses.\nfunc BlockedAddresses()\n\nmap[string]bool {\n    modAccAddrs := make(map[string]bool)\n    for acc := range GetMaccPerms() {\n    modAccAddrs[authtypes.NewModuleAddress(acc).String()] = true\n}\n\n\t// allow the following addresses to receive funds\n\tdelete(modAccAddrs, authtypes.NewModuleAddress(govtypes.ModuleName).String())\n\nreturn modAccAddrs\n}\nSee all 1010 lines\n\u200b\nPreBlocker\nThere are two semantics around the new lifecycle method:\nIt runs before the BeginBlocker of all modules\nIt can modify consensus parameters in storage, and signal the caller through the return value.\nWhen it returns ConsensusParamsChanged=true, the caller must refresh the consensus parameter in the finalize context:\n\nCopy\n\nAsk AI\napp.finalizeBlockState.ctx = app.finalizeBlockState.ctx.WithConsensusParams(app.GetConsensusParams())\nThe new ctx must be passed to all the other lifecycle methods.\n\u200b\nBeginBlocker and EndBlocker\nThe Cosmos SDK offers developers the possibility to implement automatic execution of code as part of their application. This is implemented through two functions called BeginBlocker and EndBlocker. They are called when the application receives the FinalizeBlock messages from the CometBFT consensus engine, which happens respectively at the beginning and at the end of each block. The application must set the BeginBlocker and EndBlocker in its constructor via the SetBeginBlocker and SetEndBlocker methods.\nIn general, the BeginBlocker and EndBlocker functions are mostly composed of the BeginBlock and EndBlock functions of each of the application\u2019s modules. This is done by calling the BeginBlock and EndBlock functions of the module manager, which in turn calls the BeginBlock and EndBlock functions of each of the modules it contains. Note that the order in which the modules\u2019 BeginBlock and EndBlock functions must be called has to be set in the module manager using the SetOrderBeginBlockers and SetOrderEndBlockers methods, respectively. This is done via the module manager in the application\u2019s constructor, and the SetOrderBeginBlockers and SetOrderEndBlockers methods have to be called before the SetBeginBlocker and SetEndBlocker functions.\nAs a sidenote, it is important to remember that application-specific blockchains are deterministic. Developers must be careful not to introduce non-determinism in BeginBlocker or EndBlocker, and must also be careful not to make them too computationally expensive, as gas does not constrain the cost of BeginBlocker and EndBlocker execution.\nSee an example of BeginBlocker and EndBlocker functions from simapp\n\nCopy\n\nAsk AI\n//go:build app_v1\n\npackage simapp\n\nimport (\n    \n\t\"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"maps\"\n\n\tabci \"github.com/cometbft/cometbft/abci/types\"\n\tdbm \"github.com/cosmos/cosmos-db\"\n    \"github.com/cosmos/gogoproto/proto\"\n    \"github.com/spf13/cast\"\n\n\tautocliv1 \"cosmossdk.io/api/cosmos/autocli/v1\"\n\treflectionv1 \"cosmossdk.io/api/cosmos/reflection/v1\"\n    \"cosmossdk.io/client/v2/autocli\"\n\tclienthelpers \"cosmossdk.io/client/v2/helpers\"\n    \"cosmossdk.io/core/appmodule\"\n    \"cosmossdk.io/log\"\n\tstoretypes \"cosmossdk.io/store/types\"\n    \"cosmossdk.io/x/circuit\"\n\tcircuitkeeper \"cosmossdk.io/x/circuit/keeper\"\n\tcircuittypes \"cosmossdk.io/x/circuit/types\"\n    \"cosmossdk.io/x/evidence\"\n\tevidencekeeper \"cosmossdk.io/x/evidence/keeper\"\n\tevidencetypes \"cosmossdk.io/x/evidence/types\"\n    \"cosmossdk.io/x/feegrant\"\n\tfeegrantkeeper \"cosmossdk.io/x/feegrant/keeper\"\n\tfeegrantmodule \"cosmossdk.io/x/feegrant/module\"\n    \"cosmossdk.io/x/nft\"\n\tnftkeeper \"cosmossdk.io/x/nft/keeper\"\n\tnftmodule \"cosmossdk.io/x/nft/module\"\n    \"cosmossdk.io/x/tx/signing\"\n    \"cosmossdk.io/x/upgrade\"\n\tupgradekeeper \"cosmossdk.io/x/upgrade/keeper\"\n\tupgradetypes \"cosmossdk.io/x/upgrade/types\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/client/flags\"\n    \"github.com/cosmos/cosmos-sdk/client/grpc/cmtservice\"\n\tnodeservice \"github.com/cosmos/cosmos-sdk/client/grpc/node\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/address\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n    \"github.com/cosmos/cosmos-sdk/runtime\"\n\truntimeservices \"github.com/cosmos/cosmos-sdk/runtime/services\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n    \"github.com/cosmos/cosmos-sdk/std\"\n\ttestdata_pulsar \"github.com/cosmos/cosmos-sdk/testutil/testdata/testpb\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n    \"github.com/cosmos/cosmos-sdk/types/module\"\n\tsigtypes \"github.com/cosmos/cosmos-sdk/types/tx/signing\"\n    \"github.com/cosmos/cosmos-sdk/version\"\n    \"github.com/cosmos/cosmos-sdk/x/auth\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/ante\"\n\tauthcodec \"github.com/cosmos/cosmos-sdk/x/auth/codec\"\n\tauthkeeper \"github.com/cosmos/cosmos-sdk/x/auth/keeper\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/posthandler\"\n\tauthsims \"github.com/cosmos/cosmos-sdk/x/auth/simulation\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\ttxmodule \"github.com/cosmos/cosmos-sdk/x/auth/tx/config\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/vesting\"\n\tvestingtypes \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n    \"github.com/cosmos/cosmos-sdk/x/authz\"\n\tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n\tauthzmodule \"github.com/cosmos/cosmos-sdk/x/authz/module\"\n    \"github.com/cosmos/cosmos-sdk/x/bank\"\n\tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n\tconsensus \"github.com/cosmos/cosmos-sdk/x/consensus\"\n\tconsensusparamkeeper \"github.com/cosmos/cosmos-sdk/x/consensus/keeper\"\n\tconsensusparamtypes \"github.com/cosmos/cosmos-sdk/x/consensus/types\"\n\tdistr \"github.com/cosmos/cosmos-sdk/x/distribution\"\n\tdistrkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n\tdistrtypes \"github.com/cosmos/cosmos-sdk/x/distribution/types\"\n    \"github.com/cosmos/cosmos-sdk/x/epochs\"\n\tepochskeeper \"github.com/cosmos/cosmos-sdk/x/epochs/keeper\"\n\tepochstypes \"github.com/cosmos/cosmos-sdk/x/epochs/types\"\n    \"github.com/cosmos/cosmos-sdk/x/genutil\"\n\tgenutiltypes \"github.com/cosmos/cosmos-sdk/x/genutil/types\"\n    \"github.com/cosmos/cosmos-sdk/x/gov\"\n\tgovclient \"github.com/cosmos/cosmos-sdk/x/gov/client\"\n\tgovkeeper \"github.com/cosmos/cosmos-sdk/x/gov/keeper\"\n\tgovtypes \"github.com/cosmos/cosmos-sdk/x/gov/types\"\n\tgovv1beta1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1\"\n    \"github.com/cosmos/cosmos-sdk/x/group\"\n\tgroupkeeper \"github.com/cosmos/cosmos-sdk/x/group/keeper\"\n\tgroupmodule \"github.com/cosmos/cosmos-sdk/x/group/module\"\n    \"github.com/cosmos/cosmos-sdk/x/mint\"\n\tmintkeeper \"github.com/cosmos/cosmos-sdk/x/mint/keeper\"\n\tminttypes \"github.com/cosmos/cosmos-sdk/x/mint/types\"\n    \"github.com/cosmos/cosmos-sdk/x/protocolpool\"\n\tprotocolpoolkeeper \"github.com/cosmos/cosmos-sdk/x/protocolpool/keeper\"\n\tprotocolpooltypes \"github.com/cosmos/cosmos-sdk/x/protocolpool/types\"\n    \"github.com/cosmos/cosmos-sdk/x/slashing\"\n\tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n\tslashingtypes \"github.com/cosmos/cosmos-sdk/x/slashing/types\"\n    \"github.com/cosmos/cosmos-sdk/x/staking\"\n\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n)\n\nconst appName = \"SimApp\"\n\nvar (\n\t// DefaultNodeHome default home directories for the application daemon\n\tDefaultNodeHome string\n\n\t// module account permissions\n\tmaccPerms = map[string][]string{\n    authtypes.FeeCollectorName:                  nil,\n\t\tdistrtypes.ModuleName:                       nil,\n\t\tminttypes.ModuleName:                        {\n    authtypes.Minter\n},\n\t\tstakingtypes.BondedPoolName:                 {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tstakingtypes.NotBondedPoolName:              {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tgovtypes.ModuleName:                         {\n    authtypes.Burner\n},\n\t\tnft.ModuleName:                              nil,\n\t\tprotocolpooltypes.ModuleName:                nil,\n\t\tprotocolpooltypes.ProtocolPoolEscrowAccount: nil\n}\n)\n\nvar (\n\t_ runtime.AppI            = (*SimApp)(nil)\n\t_ servertypes.Application = (*SimApp)(nil)\n)\n\n// SimApp extends an ABCI application, but with most of its parameters exported.\n// They are exported for convenience in creating helper functions, as object\n// capabilities aren't needed for testing.\ntype SimApp struct {\n\t*baseapp.BaseApp\n\tlegacyAmino       *codec.LegacyAmino\n\tappCodec          codec.Codec\n\ttxConfig          client.TxConfig\n\tinterfaceRegistry types.InterfaceRegistry\n\n\t// keys to access the substores\n\tkeys map[string]*storetypes.KVStoreKey\n\n\t// essential keepers\n\tAccountKeeper         authkeeper.AccountKeeper\n\tBankKeeper            bankkeeper.BaseKeeper\n\tStakingKeeper         *stakingkeeper.Keeper\n\tSlashingKeeper        slashingkeeper.Keeper\n\tMintKeeper            mintkeeper.Keeper\n\tDistrKeeper           distrkeeper.Keeper\n\tGovKeeper             govkeeper.Keeper\n\tUpgradeKeeper         *upgradekeeper.Keeper\n\tEvidenceKeeper        evidencekeeper.Keeper\n\tConsensusParamsKeeper consensusparamkeeper.Keeper\n\tCircuitKeeper         circuitkeeper.Keeper\n\n\t// supplementary keepers\n\tFeeGrantKeeper     feegrantkeeper.Keeper\n\tGroupKeeper        groupkeeper.Keeper\n\tAuthzKeeper        authzkeeper.Keeper\n\tNFTKeeper          nftkeeper.Keeper\n\tEpochsKeeper       epochskeeper.Keeper\n\tProtocolPoolKeeper protocolpoolkeeper.Keeper\n\n\t// the module manager\n\tModuleManager      *module.Manager\n\tBasicModuleManager module.BasicManager\n\n\t// simulation manager\n\tsm *module.SimulationManager\n\n\t// module configurator\n\tconfigurator module.Configurator\n}\n\nfunc init() {\n    var err error\n\tDefaultNodeHome, err = clienthelpers.GetNodeHomeDirectory(\".simapp\")\n    if err != nil {\n    panic(err)\n}\n}\n\n// NewSimApp returns a reference to an initialized SimApp.\nfunc NewSimApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tloadLatest bool,\n\tappOpts servertypes.AppOptions,\n\tbaseAppOptions ...func(*baseapp.BaseApp),\n) *SimApp {\n    interfaceRegistry, _ := types.NewInterfaceRegistryWithOptions(types.InterfaceRegistryOptions{\n    ProtoFiles: proto.HybridResolver,\n    SigningOptions: signing.Options{\n    AddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32AccountAddrPrefix(),\n},\n    ValidatorAddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32ValidatorAddrPrefix(),\n},\n},\n})\n    appCodec := codec.NewProtoCodec(interfaceRegistry)\n    legacyAmino := codec.NewLegacyAmino()\n    txConfig := tx.NewTxConfig(appCodec, tx.DefaultSignModes)\n    if err := interfaceRegistry.SigningContext().Validate(); err != nil {\n    panic(err)\n}\n\nstd.RegisterLegacyAminoCodec(legacyAmino)\n\nstd.RegisterInterfaces(interfaceRegistry)\n\n\t// Below we could construct and set an application specific mempool and\n\t// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are\n\t// already set in the SDK's BaseApp, this shows an example of how to override\n\t// them.\n\t//\n\t// Example:\n\t//\n\t// bApp := baseapp.NewBaseApp(...)\n\t// nonceMempool := mempool.NewSenderNonceMempool()\n\t// abciPropHandler := NewDefaultProposalHandler(nonceMempool, bApp)\n\t//\n\t// bApp.SetMempool(nonceMempool)\n\t// bApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t// bApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())\n\t//\n\t// Alternatively, you can construct BaseApp options, append those to\n\t// baseAppOptions and pass them to NewBaseApp.\n\t//\n\t// Example:\n\t//\n\t// prepareOpt = func(app *baseapp.BaseApp) {\n\t// \tabciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)\n\t// \tapp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t//\n}\n\t// baseAppOptions = append(baseAppOptions, prepareOpt)\n\n\t// create and set dummy vote extension handler\n    voteExtOp := func(bApp *baseapp.BaseApp) {\n    voteExtHandler := NewVoteExtensionHandler()\n\nvoteExtHandler.SetHandlers(bApp)\n}\n\nbaseAppOptions = append(baseAppOptions, voteExtOp, baseapp.SetOptimisticExecution())\n    bApp := baseapp.NewBaseApp(appName, logger, db, txConfig.TxDecoder(), baseAppOptions...)\n\nbApp.SetCommitMultiStoreTracer(traceStore)\n\nbApp.SetVersion(version.Version)\n\nbApp.SetInterfaceRegistry(interfaceRegistry)\n\nbApp.SetTxEncoder(txConfig.TxEncoder())\n    keys := storetypes.NewKVStoreKeys(\n\t\tauthtypes.StoreKey,\n\t\tbanktypes.StoreKey,\n\t\tstakingtypes.StoreKey,\n\t\tminttypes.StoreKey,\n\t\tdistrtypes.StoreKey,\n\t\tslashingtypes.StoreKey,\n\t\tgovtypes.StoreKey,\n\t\tconsensusparamtypes.StoreKey,\n\t\tupgradetypes.StoreKey,\n\t\tfeegrant.StoreKey,\n\t\tevidencetypes.StoreKey,\n\t\tcircuittypes.StoreKey,\n\t\tauthzkeeper.StoreKey,\n\t\tnftkeeper.StoreKey,\n\t\tgroup.StoreKey,\n\t\tepochstypes.StoreKey,\n\t\tprotocolpooltypes.StoreKey,\n\t)\n\n\t// register streaming services\n    if err := bApp.RegisterStreamingServices(appOpts, keys); err != nil {\n    panic(err)\n}\n    app := &SimApp{\n    BaseApp:           bApp,\n\t\tlegacyAmino:       legacyAmino,\n\t\tappCodec:          appCodec,\n\t\ttxConfig:          txConfig,\n\t\tinterfaceRegistry: interfaceRegistry,\n\t\tkeys:              keys,\n}\n\n\t// set the BaseApp's parameter store\n\tapp.ConsensusParamsKeeper = consensusparamkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[consensusparamtypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\truntime.EventService{\n},\n\t)\n\nbApp.SetParamStore(app.ConsensusParamsKeeper.ParamsStore)\n\n\t// add keepers\n\tapp.AccountKeeper = authkeeper.NewAccountKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[authtypes.StoreKey]),\n\t\tauthtypes.ProtoBaseAccount,\n\t\tmaccPerms,\n\t\tauthcodec.NewBech32Codec(sdk.Bech32MainPrefix),\n\t\tsdk.Bech32MainPrefix,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthkeeper.WithUnorderedTransactions(true),\n\t)\n\napp.BankKeeper = bankkeeper.NewBaseKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[banktypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tBlockedAddresses(),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tlogger,\n\t)\n\n\t// optional: enable sign mode textual by overwriting the default tx config (after setting the bank keeper)\n    enabledSignModes := append(tx.DefaultSignModes, sigtypes.SignMode_SIGN_MODE_TEXTUAL)\n    txConfigOpts := tx.ConfigOptions{\n    EnabledSignModes:           enabledSignModes,\n    TextualCoinMetadataQueryFn: txmodule.NewBankKeeperCoinMetadataQueryFn(app.BankKeeper),\n}\n\ntxConfig, err := tx.NewTxConfigWithOptions(\n\t\tappCodec,\n\t\ttxConfigOpts,\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.txConfig = txConfig\n\n\tapp.StakingKeeper = stakingkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[stakingtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixValAddr),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixConsAddr),\n\t)\n\napp.MintKeeper = mintkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[minttypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// mintkeeper.WithMintFn(mintkeeper.DefaultMintFn(minttypes.DefaultInflationCalculationFn)), custom mintFn can be added here\n\t)\n\napp.ProtocolPoolKeeper = protocolpoolkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[protocolpooltypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.DistrKeeper = distrkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[distrtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tdistrkeeper.WithExternalCommunityPool(app.ProtocolPoolKeeper),\n\t)\n\napp.SlashingKeeper = slashingkeeper.NewKeeper(\n\t\tappCodec,\n\t\tlegacyAmino,\n\t\truntime.NewKVStoreService(keys[slashingtypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.FeeGrantKeeper = feegrantkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[feegrant.StoreKey]),\n\t\tapp.AccountKeeper,\n\t)\n\n\t// register the staking hooks\n\t// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks\n\tapp.StakingKeeper.SetHooks(\n\t\tstakingtypes.NewMultiStakingHooks(\n\t\t\tapp.DistrKeeper.Hooks(),\n\t\t\tapp.SlashingKeeper.Hooks(),\n\t\t),\n\t)\n\napp.CircuitKeeper = circuitkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[circuittypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tapp.AccountKeeper.AddressCodec(),\n\t)\n\napp.BaseApp.SetCircuitBreaker(&app.CircuitKeeper)\n\napp.AuthzKeeper = authzkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[authzkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t)\n    groupConfig := group.DefaultConfig()\n\t/*\n\t\tExample of setting group params:\n\t\tgroupConfig.MaxMetadataLen = 1000\n\t*/\n\tapp.GroupKeeper = groupkeeper.NewKeeper(\n\t\tkeys[group.StoreKey],\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t\tgroupConfig,\n\t)\n\n\t// get skipUpgradeHeights from the app options\n    skipUpgradeHeights := map[int64]bool{\n}\n    for _, h := range cast.ToIntSlice(appOpts.Get(server.FlagUnsafeSkipUpgrades)) {\n    skipUpgradeHeights[int64(h)] = true\n}\n    homePath := cast.ToString(appOpts.Get(flags.FlagHome))\n\t// set the governance module account as the authority for conducting upgrades\n\tapp.UpgradeKeeper = upgradekeeper.NewKeeper(\n\t\tskipUpgradeHeights,\n\t\truntime.NewKVStoreService(keys[upgradetypes.StoreKey]),\n\t\tappCodec,\n\t\thomePath,\n\t\tapp.BaseApp,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\n\t// Register the proposal types\n\t// Deprecated: Avoid adding new handlers, instead use the new proposal flow\n\t// by granting the governance module the right to execute the message.\n\t// See: https://docs.cosmos.network/main/modules/gov#proposal-messages\n    govRouter := govv1beta1.NewRouter()\n\ngovRouter.AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler)\n    govConfig := govtypes.DefaultConfig()\n\t/*\n\t\tExample of setting gov params:\n\t\tgovConfig.MaxMetadataLen = 10000\n\t*/\n    govKeeper := govkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[govtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tapp.DistrKeeper,\n\t\tapp.MsgServiceRouter(),\n\t\tgovConfig,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// govkeeper.WithCustomCalculateVoteResultsAndVotingPowerFn(...), // Add if you want to use a custom vote calculation function.\n\t)\n\n\t// Set legacy router for backwards compatibility with gov v1beta1\n\tgovKeeper.SetLegacyRouter(govRouter)\n\napp.GovKeeper = *govKeeper.SetHooks(\n\t\tgovtypes.NewMultiGovHooks(\n\t\t\t// register the governance hooks\n\t\t),\n\t)\n\napp.NFTKeeper = nftkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[nftkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t)\n\n\t// create evidence keeper with router\n    evidenceKeeper := evidencekeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[evidencetypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.SlashingKeeper,\n\t\tapp.AccountKeeper.AddressCodec(),\n\t\truntime.ProvideCometInfoService(),\n\t)\n\t// If evidence needs to be handled for the app, set routes in router here and seal\n\tapp.EvidenceKeeper = *evidenceKeeper\n\n\tapp.EpochsKeeper = epochskeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[epochstypes.StoreKey]),\n\t\tappCodec,\n\t)\n\napp.EpochsKeeper.SetHooks(\n\t\tepochstypes.NewMultiEpochHooks(\n\t\t\t// insert epoch hooks receivers here\n\t\t),\n\t)\n\n\t/****  Module Options ****/\n\n\t// NOTE: Any module instantiated in the module manager that is later modified\n\t// must be passed by reference here.\n\tapp.ModuleManager = module.NewManager(\n\t\tgenutil.NewAppModule(\n\t\t\tapp.AccountKeeper, app.StakingKeeper, app,\n\t\t\ttxConfig,\n\t\t),\n\t\tauth.NewAppModule(appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n\t\tvesting.NewAppModule(app.AccountKeeper, app.BankKeeper),\n\t\tbank.NewAppModule(appCodec, app.BankKeeper, app.AccountKeeper, nil),\n\t\tfeegrantmodule.NewAppModule(appCodec, app.AccountKeeper, app.BankKeeper, app.FeeGrantKeeper, app.interfaceRegistry),\n\t\tgov.NewAppModule(appCodec, &app.GovKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tmint.NewAppModule(appCodec, app.MintKeeper, app.AccountKeeper, nil, nil),\n\t\tslashing.NewAppModule(appCodec, app.SlashingKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil, app.interfaceRegistry),\n\t\tdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil),\n\t\tstaking.NewAppModule(appCodec, app.StakingKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tupgrade.NewAppModule(app.UpgradeKeeper, app.AccountKeeper.AddressCodec()),\n\t\tevidence.NewAppModule(app.EvidenceKeeper),\n\t\tauthzmodule.NewAppModule(appCodec, app.AuthzKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tgroupmodule.NewAppModule(appCodec, app.GroupKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tnftmodule.NewAppModule(appCodec, app.NFTKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tconsensus.NewAppModule(appCodec, app.ConsensusParamsKeeper),\n\t\tcircuit.NewAppModule(appCodec, app.CircuitKeeper),\n\t\tepochs.NewAppModule(app.EpochsKeeper),\n\t\tprotocolpool.NewAppModule(app.ProtocolPoolKeeper, app.AccountKeeper, app.BankKeeper),\n\t)\n\n\t// BasicModuleManager defines the module BasicManager is in charge of setting up basic,\n\t// non-dependant module elements, such as codec registration and genesis verification.\n\t// By default it is composed of all the module from the module manager.\n\t// Additionally, app module basics can be overwritten by passing them as argument.\n\tapp.BasicModuleManager = module.NewBasicManagerFromManager(\n\t\tapp.ModuleManager,\n\t\tmap[string]module.AppModuleBasic{\n    genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),\n\t\t\tgovtypes.ModuleName: gov.NewAppModuleBasic(\n\t\t\t\t[]govclient.ProposalHandler{\n},\n\t\t\t),\n})\n\napp.BasicModuleManager.RegisterLegacyAminoCodec(legacyAmino)\n\napp.BasicModuleManager.RegisterInterfaces(interfaceRegistry)\n\n\t// NOTE: upgrade module is required to be prioritized\n\tapp.ModuleManager.SetOrderPreBlockers(\n\t\tupgradetypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t)\n\t// During begin block slashing happens after distr.BeginBlocker so that\n\t// there is nothing left over in the validator fee pool, so as to keep the\n\t// CanWithdrawInvariant invariant.\n\t// NOTE: staking module is required if HistoricalEntries param > 0\n\tapp.ModuleManager.SetOrderBeginBlockers(\n\t\tminttypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tepochstypes.ModuleName,\n\t)\n\napp.ModuleManager.SetOrderEndBlockers(\n\t\tgovtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tgroup.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t)\n\n\t// NOTE: The genutils module must occur after staking so that pools are\n\t// properly initialized with tokens from genesis accounts.\n\t// NOTE: The genutils module must also occur after auth so that it can access the params from auth.\n    genesisModuleOrder := []string{\n    authtypes.ModuleName,\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tconsensusparamtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n}\n    exportModuleOrder := []string{\n    consensusparamtypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName, // Must be exported before bank\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n}\n\napp.ModuleManager.SetOrderInitGenesis(genesisModuleOrder...)\n\napp.ModuleManager.SetOrderExportGenesis(exportModuleOrder...)\n\n\t// Uncomment if you want to set a custom migration order here.\n\t// app.ModuleManager.SetOrderMigrations(custom order)\n\napp.configurator = module.NewConfigurator(app.appCodec, app.MsgServiceRouter(), app.GRPCQueryRouter())\n\nerr = app.ModuleManager.RegisterServices(app.configurator)\n    if err != nil {\n    panic(err)\n}\n\n\t// RegisterUpgradeHandlers is used for registering any on-chain upgrades.\n\t// Make sure it's called after `app.ModuleManager` and `app.configurator` are set.\n\tapp.RegisterUpgradeHandlers()\n\nautocliv1.RegisterQueryServer(app.GRPCQueryRouter(), runtimeservices.NewAutoCLIQueryService(app.ModuleManager.Modules))\n\nreflectionSvc, err := runtimeservices.NewReflectionService()\n    if err != nil {\n    panic(err)\n}\n\nreflectionv1.RegisterReflectionServiceServer(app.GRPCQueryRouter(), reflectionSvc)\n\n\t// add test gRPC service for testing gRPC queries in isolation\n\ttestdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{\n})\n\n\t// create the simulation manager and define the order of the modules for deterministic simulations\n\t//\n\t// NOTE: this is not required apps that don't use the simulator for fuzz testing\n\t// transactions\n    overrideModules := map[string]module.AppModuleSimulation{\n    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n}\n\napp.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)\n\napp.sm.RegisterStoreDecoders()\n\n\t// initialize stores\n\tapp.MountKVStores(keys)\n\n\t// initialize BaseApp\n\tapp.SetInitChainer(app.InitChainer)\n\napp.SetPreBlocker(app.PreBlocker)\n\napp.SetBeginBlocker(app.BeginBlocker)\n\napp.SetEndBlocker(app.EndBlocker)\n\napp.setAnteHandler(txConfig)\n\n\t// In v0.46, the SDK introduces _postHandlers_. PostHandlers are like\n\t// antehandlers, but are run _after_ the `runMsgs` execution. They are also\n\t// defined as a chain, and have the same signature as antehandlers.\n\t//\n\t// In baseapp, postHandlers are run in the same store branch as `runMsgs`,\n\t// meaning that both `runMsgs` and `postHandler` state will be committed if\n\t// both are successful, and both will be reverted if any of the two fails.\n\t//\n\t// The SDK exposes a default postHandlers chain\n\t//\n\t// Please note that changing any of the anteHandler or postHandler chain is\n\t// likely to be a state-machine breaking change, which needs a coordinated\n\t// upgrade.\n\tapp.setPostHandler()\n    if loadLatest {\n    if err := app.LoadLatestVersion(); err != nil {\n    panic(fmt.Errorf(\"error loading last version: %w\", err))\n}\n\t\n}\n\nreturn app\n}\n\nfunc (app *SimApp)\n\nsetAnteHandler(txConfig client.TxConfig) {\n    anteHandler, err := NewAnteHandler(\n\t\tHandlerOptions{\n    ante.HandlerOptions{\n    AccountKeeper:   app.AccountKeeper,\n    BankKeeper:      app.BankKeeper,\n    SignModeHandler: txConfig.SignModeHandler(),\n    FeegrantKeeper:  app.FeeGrantKeeper,\n    SigGasConsumer:  ante.DefaultSigVerificationGasConsumer,\n    SigVerifyOptions: []ante.SigVerificationDecoratorOption{\n\t\t\t\t\t// change below as needed.\n\t\t\t\t\tante.WithUnorderedTxGasCost(ante.DefaultUnorderedTxGasCost),\n\t\t\t\t\tante.WithMaxUnorderedTxTimeoutDuration(ante.DefaultMaxTimeoutDuration),\n},\n},\n\t\t\t&app.CircuitKeeper,\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\n\t// Set the AnteHandler for the app\n\tapp.SetAnteHandler(anteHandler)\n}\n\nfunc (app *SimApp)\n\nsetPostHandler() {\n    postHandler, err := posthandler.NewPostHandler(\n\t\tposthandler.HandlerOptions{\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.SetPostHandler(postHandler)\n}\n\n// Name returns the name of the App\nfunc (app *SimApp)\n\nName()\n\nstring {\n    return app.BaseApp.Name()\n}\n\n// PreBlocker application updates every pre block\nfunc (app *SimApp)\n\nPreBlocker(ctx sdk.Context, _ *abci.RequestFinalizeBlock) (*sdk.ResponsePreBlock, error) {\n    return app.ModuleManager.PreBlock(ctx)\n}\n\n// BeginBlocker application updates every begin block\nfunc (app *SimApp)\n\nBeginBlocker(ctx sdk.Context) (sdk.BeginBlock, error) {\n    return app.ModuleManager.BeginBlock(ctx)\n}\n\n// EndBlocker application updates every end block\nfunc (app *SimApp)\n\nEndBlocker(ctx sdk.Context) (sdk.EndBlock, error) {\n    return app.ModuleManager.EndBlock(ctx)\n}\n\nfunc (a *SimApp)\n\nConfigurator()\n\nmodule.Configurator {\n    return a.configurator\n}\n\n// InitChainer application update at chain initialization\nfunc (app *SimApp)\n\nInitChainer(ctx sdk.Context, req *abci.RequestInitChain) (*abci.ResponseInitChain, error) {\n    var genesisState GenesisState\n    if err := json.Unmarshal(req.AppStateBytes, &genesisState); err != nil {\n    panic(err)\n}\n\napp.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())\n\nreturn app.ModuleManager.InitGenesis(ctx, app.appCodec, genesisState)\n}\n\n// LoadHeight loads a particular height\nfunc (app *SimApp)\n\nLoadHeight(height int64)\n\nerror {\n    return app.LoadVersion(height)\n}\n\n// LegacyAmino returns SimApp's amino codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nLegacyAmino() *codec.LegacyAmino {\n    return app.legacyAmino\n}\n\n// AppCodec returns SimApp's app codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nAppCodec()\n\ncodec.Codec {\n    return app.appCodec\n}\n\n// InterfaceRegistry returns SimApp's InterfaceRegistry\nfunc (app *SimApp)\n\nInterfaceRegistry()\n\ntypes.InterfaceRegistry {\n    return app.interfaceRegistry\n}\n\n// TxConfig returns SimApp's TxConfig\nfunc (app *SimApp)\n\nTxConfig()\n\nclient.TxConfig {\n    return app.txConfig\n}\n\n// AutoCliOpts returns the autocli options for the app.\nfunc (app *SimApp)\n\nAutoCliOpts()\n\nautocli.AppOptions {\n    modules := make(map[string]appmodule.AppModule, 0)\n    for _, m := range app.ModuleManager.Modules {\n    if moduleWithName, ok := m.(module.HasName); ok {\n    moduleName := moduleWithName.Name()\n    if appModule, ok := moduleWithName.(appmodule.AppModule); ok {\n    modules[moduleName] = appModule\n}\n\t\n}\n\t\n}\n\nreturn autocli.AppOptions{\n    Modules:               modules,\n    ModuleOptions:         runtimeservices.ExtractAutoCLIOptions(app.ModuleManager.Modules),\n    AddressCodec:          authcodec.NewBech32Codec(sdk.GetConfig().GetBech32AccountAddrPrefix()),\n    ValidatorAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()),\n    ConsensusAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()),\n}\n}\n\n// DefaultGenesis returns a default genesis from the registered AppModuleBasic's.\nfunc (a *SimApp)\n\nDefaultGenesis()\n\nmap[string]json.RawMessage {\n    return a.BasicModuleManager.DefaultGenesis(a.appCodec)\n}\n\n// GetKey returns the KVStoreKey for the provided store key.\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc (app *SimApp)\n\nGetKey(storeKey string) *storetypes.KVStoreKey {\n    return app.keys[storeKey]\n}\n\n// GetStoreKeys returns all the stored store keys.\nfunc (app *SimApp)\n\nGetStoreKeys() []storetypes.StoreKey {\n    keys := make([]storetypes.StoreKey, 0, len(app.keys))\n    for _, key := range app.keys {\n    keys = append(keys, key)\n}\n\nreturn keys\n}\n\n// SimulationManager implements the SimulationApp interface\nfunc (app *SimApp)\n\nSimulationManager() *module.SimulationManager {\n    return app.sm\n}\n\n// RegisterAPIRoutes registers all application module routes with the provided\n// API server.\nfunc (app *SimApp)\n\nRegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {\n    clientCtx := apiSvr.ClientCtx\n\t// Register new tx routes from grpc-gateway.\n\tauthtx.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register new CometBFT queries routes from grpc-gateway.\n\tcmtservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register node gRPC service for grpc-gateway.\n\tnodeservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register grpc-gateway routes for all modules.\n\tapp.BasicModuleManager.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// register swagger API from root so that other applications can override easily\n    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {\n    panic(err)\n}\n}\n\n// RegisterTxService implements the Application.RegisterTxService method.\nfunc (app *SimApp)\n\nRegisterTxService(clientCtx client.Context) {\n    authtx.RegisterTxService(app.BaseApp.GRPCQueryRouter(), clientCtx, app.BaseApp.Simulate, app.interfaceRegistry)\n}\n\n// RegisterTendermintService implements the Application.RegisterTendermintService method.\nfunc (app *SimApp)\n\nRegisterTendermintService(clientCtx client.Context) {\n    cmtApp := server.NewCometABCIWrapper(app)\n\ncmtservice.RegisterTendermintService(\n\t\tclientCtx,\n\t\tapp.BaseApp.GRPCQueryRouter(),\n\t\tapp.interfaceRegistry,\n\t\tcmtApp.Query,\n\t)\n}\n\nfunc (app *SimApp)\n\nRegisterNodeService(clientCtx client.Context, cfg config.Config) {\n    nodeservice.RegisterNodeService(clientCtx, app.GRPCQueryRouter(), cfg)\n}\n\n// GetMaccPerms returns a copy of the module account permissions\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc GetMaccPerms()\n\nmap[string][]string {\n    return maps.Clone(maccPerms)\n}\n\n// BlockedAddresses returns all the app's blocked account addresses.\nfunc BlockedAddresses()\n\nmap[string]bool {\n    modAccAddrs := make(map[string]bool)\n    for acc := range GetMaccPerms() {\n    modAccAddrs[authtypes.NewModuleAddress(acc).String()] = true\n}\n\n\t// allow the following addresses to receive funds\n\tdelete(modAccAddrs, authtypes.NewModuleAddress(govtypes.ModuleName).String())\n\nreturn modAccAddrs\n}\nSee all 1010 lines\n\u200b\nRegister Codec\nThe EncodingConfig structure is the last important part of the app.go file. The goal of this structure is to define the codecs that will be used throughout the app.\n\nCopy\n\nAsk AI\npackage params\n\nimport (\n    \n\t\"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n)\n\n// EncodingConfig specifies the concrete encoding types to use for a given app.\n// This is provided for compatibility between protobuf and amino implementations.\ntype EncodingConfig struct {\n    InterfaceRegistry types.InterfaceRegistry\n\tCodec             codec.Codec\n\tTxConfig          client.TxConfig\n\tAmino             *codec.LegacyAmino\n}\nSee all 17 lines\nHere are descriptions of what each of the four fields means:\nInterfaceRegistry: The InterfaceRegistry is used by the Protobuf codec to handle interfaces that are encoded and decoded (we also say \u201cunpacked\u201d) using google.protobuf.Any. Any could be thought as a struct that contains a type_url (name of a concrete type implementing the interface) and a value (its encoded bytes). InterfaceRegistry provides a mechanism for registering interfaces and implementations that can be safely unpacked from Any. Each application module implements the RegisterInterfaces method that can be used to register the module\u2019s own interfaces and implementations.\nYou can read more about Any in ADR-019.\nTo go more into details, the Cosmos SDK uses an implementation of the Protobuf specification called gogoprotobuf. By default, the gogo protobuf implementation of Any uses global type registration to decode values packed in Any into concrete Go types. This introduces a vulnerability where any malicious module in the dependency tree could register a type with the global protobuf registry and cause it to be loaded and unmarshaled by a transaction that referenced it in the type_url field. For more information, please refer to ADR-019.\nCodec: The default codec used throughout the Cosmos SDK. It is composed of a BinaryCodec used to encode and decode state, and a JSONCodec used to output data to the users (for example, in the CLI). By default, the SDK uses Protobuf as Codec.\nTxConfig: TxConfig defines an interface a client can utilize to generate an application-defined concrete transaction type. Currently, the SDK handles two transaction types: SIGN_MODE_DIRECT (which uses Protobuf binary as over-the-wire encoding) and SIGN_MODE_LEGACY_AMINO_JSON (which depends on Amino). Read more about transactions here.\nAmino: Some legacy parts of the Cosmos SDK still use Amino for backwards-compatibility. Each module exposes a RegisterLegacyAmino method to register the module\u2019s specific types within Amino. This Amino codec should not be used by app developers anymore, and will be removed in future releases.\nAn application should create its own encoding config. See an example of a simappparams.EncodingConfig from simapp:\n\nCopy\n\nAsk AI\npackage params\n\nimport (\n    \n\t\"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n)\n\n// EncodingConfig specifies the concrete encoding types to use for a given app.\n// This is provided for compatibility between protobuf and amino implementations.\ntype EncodingConfig struct {\n    InterfaceRegistry types.InterfaceRegistry\n\tCodec             codec.Codec\n\tTxConfig          client.TxConfig\n\tAmino             *codec.LegacyAmino\n}\nSee all 17 lines\n\u200b\nModules\nModules are the heart and soul of Cosmos SDK applications. They can be considered as state-machines nested within the state-machine. When a transaction is relayed from the underlying CometBFT engine via the ABCI to the application, it is routed by baseapp to the appropriate module in order to be processed. This paradigm enables developers to easily build complex state-machines, as most of the modules they need often already exist. For developers, most of the work involved in building a Cosmos SDK application revolves around building custom modules required by their application that do not exist yet, and integrating them with modules that do already exist into one coherent application. In the application directory, the standard practice is to store modules in the x/ folder (not to be confused with the Cosmos SDK\u2019s x/ folder, which contains already-built modules).\n\u200b\nApplication Module Interface\nModules must implement interfaces defined in the Cosmos SDK, AppModuleBasic and AppModule. The former implements basic non-dependent elements of the module, such as the codec, while the latter handles the bulk of the module methods (including methods that require references to other modules\u2019 keepers). Both the AppModule and AppModuleBasic types are, by convention, defined in a file called module.go.\nAppModule exposes a collection of useful methods on the module that facilitates the composition of modules into a coherent application. These methods are called from the module manager, which manages the application\u2019s collection of modules.\n\u200b\nMsg Services\nEach application module defines two Protobuf services: one Msg service to handle messages, and one gRPC Query service to handle queries. If we consider the module as a state-machine, then a Msg service is a set of state transition RPC methods. Each Protobuf Msg service method is 1:1 related to a Protobuf request type, which must implement sdk.Msg interface. Note that sdk.Msgs are bundled in transactions, and each transaction contains one or multiple messages.\nWhen a valid block of transactions is received by the full-node, CometBFT relays each one to the application via DeliverTx. Then, the application handles the transaction:\nUpon receiving the transaction, the application first unmarshalls it from []byte.\nThen, it verifies a few things about the transaction like fee payment and signatures before extracting the Msg(s) contained in the transaction.\nsdk.Msgs are encoded using Protobuf Anys. By analyzing each Any\u2019s type_url, baseapp\u2019s msgServiceRouter routes the sdk.Msg to the corresponding module\u2019s Msg service.\nIf the message is successfully processed, the state is updated.\nFor more details, see transaction lifecycle.\nModule developers create custom Msg services when they build their own module. The general practice is to define the Msg Protobuf service in a tx.proto file. For example, the x/bank module defines a service with two methods to transfer tokens:\n\nCopy\n\nAsk AI\n// Reference: https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/proto/cosmos/bank/v1beta1/tx.proto#L13-L36\nService methods use keeper in order to update the module state.\nEach module should also implement the RegisterServices method as part of the AppModule interface. This method should call the RegisterMsgServer function provided by the generated Protobuf code.\n\u200b\ngRPC Query Services\ngRPC Query services allow users to query the state using gRPC. They are enabled by default, and can be configured under the grpc.enable and grpc.address fields inside app.toml.\ngRPC Query services are defined in the module\u2019s Protobuf definition files, specifically inside query.proto. The query.proto definition file exposes a single Query Protobuf service. Each gRPC query endpoint corresponds to a service method, starting with the rpc keyword, inside the Query service.\nProtobuf generates a QueryServer interface for each module, containing all the service methods. A module\u2019s keeper then needs to implement this QueryServer interface, by providing the concrete implementation of each service method. This concrete implementation is the handler of the corresponding gRPC query endpoint.\nFinally, each module should also implement the RegisterServices method as part of the AppModule interface. This method should call the RegisterQueryServer function provided by the generated Protobuf code.\n\u200b\nKeeper\nKeepers are the gatekeepers of their module\u2019s store(s). To read or write in a module\u2019s store, it is mandatory to go through one of its keeper\u2019s methods. This is ensured by the object-capabilities model of the Cosmos SDK. Only objects that hold the key to a store can access it, and only the module\u2019s keeper should hold the key(s) to the module\u2019s store(s).\nKeepers are generally defined in a file called keeper.go. It contains the keeper\u2019s type definition and methods.\nThe keeper type definition generally consists of the following:\nKey(s) to the module\u2019s store(s) in the multistore.\nReference to other module\u2019s keepers. Only needed if the keeper needs to access other module\u2019s store(s) (either to read or write from them).\nA reference to the application\u2019s codec. The keeper needs it to marshal structs before storing them, or to unmarshal them when it retrieves them, because stores only accept []bytes as value.\nAlong with the type definition, the next important component of the keeper.go file is the keeper\u2019s constructor function, NewKeeper. This function instantiates a new keeper of the type defined above with a codec, stores keys and potentially references other modules\u2019 keepers as parameters. The NewKeeper function is called from the application\u2019s constructor. The rest of the file defines the keeper\u2019s methods, which are primarily getters and setters.\n\u200b\nCommand-Line, gRPC Services and REST Interfaces\nEach module defines command-line commands, gRPC services, and REST routes to be exposed to the end-user via the application\u2019s interfaces. This enables end-users to create messages of the types defined in the module, or to query the subset of the state managed by the module.\n\u200b\nCLI\nGenerally, the commands related to a module are defined in a folder called client/cli in the module\u2019s folder. The CLI divides commands into two categories, transactions and queries, defined in client/cli/tx.go and client/cli/query.go, respectively. Both commands are built on top of the Cobra Library:\nTransactions commands let users generate new transactions so that they can be included in a block and eventually update the state. One command should be created for each message type defined in the module. The command calls the constructor of the message with the parameters provided by the end-user, and wraps it into a transaction. The Cosmos SDK handles signing and the addition of other transaction metadata.\nQueries let users query the subset of the state defined by the module. Query commands forward queries to the application\u2019s query router, which routes them to the appropriate querier the queryRoute parameter supplied.\n\u200b\ngRPC\ngRPC is a modern open-source high performance RPC framework that has support in multiple languages. It is the recommended way for external clients (such as wallets, browsers and other backend services) to interact with a node.\nEach module can expose gRPC endpoints called service methods, which are defined in the module\u2019s Protobuf query.proto file. A service method is defined by its name, input arguments, and output response. The module then needs to perform the following actions:\nDefine a RegisterGRPCGatewayRoutes method on AppModuleBasic to wire the client gRPC requests to the correct handler inside the module.\nFor each service method, define a corresponding handler. The handler implements the core logic necessary to serve the gRPC request, and is located in the keeper/grpc_query.go file.\n\u200b\ngRPC-gateway REST Endpoints\nSome external clients may not wish to use gRPC. In this case, the Cosmos SDK provides a gRPC gateway service, which exposes each gRPC service as a corresponding REST endpoint. Please refer to the grpc-gateway documentation to learn more.\nThe REST endpoints are defined in the Protobuf files, along with the gRPC services, using Protobuf annotations. Modules that want to expose REST queries should add google.api.http annotations to their rpc methods. By default, all REST endpoints defined in the SDK have a URL starting with the /cosmos/ prefix.\nThe Cosmos SDK also provides a development endpoint to generate Swagger definition files for these REST endpoints. This endpoint can be enabled inside the app.toml config file, under the api.swagger key.\n\u200b\nApplication Interface\nInterfaces let end-users interact with full-node clients. This means querying data from the full-node or creating and sending new transactions to be relayed by the full-node and eventually included in a block.\nThe main interface is the Command-Line Interface. The CLI of a Cosmos SDK application is built by aggregating CLI commands defined in each of the modules used by the application. The CLI of an application is the same as the daemon (e.g. appd), and is defined in a file called appd/main.go. The file contains the following:\nA main() function, which is executed to build the appd interface client. This function prepares each command and adds them to the rootCmd before building them. At the root of appd, the function adds generic commands like status, keys, and config, query commands, tx commands, and rest-server.\nQuery commands, which are added by calling the queryCmd function. This function returns a Cobra command that contains the query commands defined in each of the application\u2019s modules (passed as an array of sdk.ModuleClients from the main() function), as well as some other lower level query commands such as block or validator queries. Query command are called by using the command appd query [query] of the CLI.\nTransaction commands, which are added by calling the txCmd function. Similar to queryCmd, the function returns a Cobra command that contains the tx commands defined in each of the application\u2019s modules, as well as lower level tx commands like transaction signing or broadcasting. Tx commands are called by using the command appd tx [tx] of the CLI.\nSee an example of an application\u2019s main command-line file from the Cosmos Hub.\n\nCopy\n\nAsk AI\npackage cmd\n\nimport (\n    \n\t\"errors\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/client/config\"\n    \"github.com/cosmos/cosmos-sdk/client/debug\"\n    \"github.com/cosmos/cosmos-sdk/client/flags\"\n    \"github.com/cosmos/cosmos-sdk/client/keys\"\n    \"github.com/cosmos/cosmos-sdk/client/rpc\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n\tserverconfig \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n    \"github.com/cosmos/cosmos-sdk/snapshots\"\n\tsnapshottypes \"github.com/cosmos/cosmos-sdk/snapshots/types\"\n    \"github.com/cosmos/cosmos-sdk/store\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tauthcmd \"github.com/cosmos/cosmos-sdk/x/auth/client/cli\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n    \"github.com/cosmos/cosmos-sdk/x/crisis\"\n\tgenutilcli \"github.com/cosmos/cosmos-sdk/x/genutil/client/cli\"\n    \"github.com/spf13/cast\"\n    \"github.com/spf13/cobra\"\n\ttmcfg \"github.com/tendermint/tendermint/config\"\n\ttmcli \"github.com/tendermint/tendermint/libs/cli\"\n    \"github.com/tendermint/tendermint/libs/log\"\n\tdbm \"github.com/tendermint/tm-db\"\n\n\tgaia \"github.com/cosmos/gaia/v8/app\"\n    \"github.com/cosmos/gaia/v8/app/params\"\n)\n\n// NewRootCmd creates a new root command for simd. It is called once in the\n// main function.\nfunc NewRootCmd() (*cobra.Command, params.EncodingConfig) {\n    encodingConfig := gaia.MakeTestEncodingConfig()\n    initClientCtx := client.Context{\n}.\n\t\tWithCodec(encodingConfig.Codec).\n\t\tWithInterfaceRegistry(encodingConfig.InterfaceRegistry).\n\t\tWithTxConfig(encodingConfig.TxConfig).\n\t\tWithLegacyAmino(encodingConfig.Amino).\n\t\tWithInput(os.Stdin).\n\t\tWithAccountRetriever(types.AccountRetriever{\n}).\n\t\tWithHomeDir(gaia.DefaultNodeHome).\n\t\tWithViper(\"\")\n    rootCmd := &cobra.Command{\n    Use:   \"gaiad\",\n    Short: \"Stargate Cosmos Hub App\",\n    PersistentPreRunE: func(cmd *cobra.Command, _ []string)\n\nerror {\n    initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())\n    if err != nil {\n    return err\n}\n\ninitClientCtx, err = config.ReadFromClientConfig(initClientCtx)\n    if err != nil {\n    return err\n}\n    if err = client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {\n    return err\n}\n\ncustomTemplate, customGaiaConfig := initAppConfig()\n    customTMConfig := initTendermintConfig()\n\nreturn server.InterceptConfigsPreRunHandler(cmd, customTemplate, customGaiaConfig, customTMConfig)\n},\n}\n\ninitRootCmd(rootCmd, encodingConfig)\n\nreturn rootCmd, encodingConfig\n}\n\n// initTendermintConfig helps to override default Tendermint Config values.\n// return tmcfg.DefaultConfig if no custom configuration is required for the application.\nfunc initTendermintConfig() *tmcfg.Config {\n    cfg := tmcfg.DefaultConfig()\n\n\t// these values put a higher strain on node memory\n\t// cfg.P2P.MaxNumInboundPeers = 100\n\t// cfg.P2P.MaxNumOutboundPeers = 40\n\n\treturn cfg\n}\n\nfunc initAppConfig() (string, interface{\n}) {\n    srvCfg := serverconfig.DefaultConfig()\n\nsrvCfg.StateSync.SnapshotInterval = 1000\n\tsrvCfg.StateSync.SnapshotKeepRecent = 10\n\n\treturn params.CustomConfigTemplate(), params.CustomAppConfig{\n    Config:               *srvCfg,\n    BypassMinFeeMsgTypes: gaia.GetDefaultBypassFeeMessages(),\n}\n}\n\nfunc initRootCmd(rootCmd *cobra.Command, encodingConfig params.EncodingConfig) {\n    cfg := sdk.GetConfig()\n\ncfg.Seal()\n\nrootCmd.AddCommand(\n\t\tgenutilcli.InitCmd(gaia.ModuleBasics, gaia.DefaultNodeHome),\n\t\tgenutilcli.CollectGenTxsCmd(banktypes.GenesisBalancesIterator{\n}, gaia.DefaultNodeHome),\n\t\tgenutilcli.GenTxCmd(gaia.ModuleBasics, encodingConfig.TxConfig, banktypes.GenesisBalancesIterator{\n}, gaia.DefaultNodeHome),\n\t\tgenutilcli.ValidateGenesisCmd(gaia.ModuleBasics),\n\t\tAddGenesisAccountCmd(gaia.DefaultNodeHome),\n\t\ttmcli.NewCompletionCmd(rootCmd, true),\n\t\ttestnetCmd(gaia.ModuleBasics, banktypes.GenesisBalancesIterator{\n}),\n\t\tdebug.Cmd(),\n\t\tconfig.Cmd(),\n\t)\n    ac := appCreator{\n    encCfg: encodingConfig,\n}\n\nserver.AddCommands(rootCmd, gaia.DefaultNodeHome, ac.newApp, ac.appExport, addModuleInitFlags)\n\n\t// add keybase, auxiliary RPC, query, and tx child commands\n\trootCmd.AddCommand(\n\t\trpc.StatusCommand(),\n\t\tqueryCommand(),\n\t\ttxCommand(),\n\t\tkeys.Commands(gaia.DefaultNodeHome),\n\t)\n\nrootCmd.AddCommand(server.RosettaCommand(encodingConfig.InterfaceRegistry, encodingConfig.Codec))\n}\n\nfunc addModuleInitFlags(startCmd *cobra.Command) {\n    crisis.AddModuleInitFlags(startCmd)\n}\n\nfunc queryCommand() *cobra.Command {\n    cmd := &cobra.Command{\n    Use:                        \"query\",\n    Aliases:                    []string{\"q\"\n},\n    Short:                      \"Querying subcommands\",\n    DisableFlagParsing:         true,\n    SuggestionsMinimumDistance: 2,\n    RunE:                       client.ValidateCmd,\n}\n\ncmd.AddCommand(\n\t\tauthcmd.GetAccountCmd(),\n\t\trpc.ValidatorCommand(),\n\t\trpc.BlockCommand(),\n\t\tauthcmd.QueryTxsByEventsCmd(),\n\t\tauthcmd.QueryTxCmd(),\n\t)\n\ngaia.ModuleBasics.AddQueryCommands(cmd)\n\ncmd.PersistentFlags().String(flags.FlagChainID, \"\", \"The network chain ID\")\n\nreturn cmd\n}\n\nfunc txCommand() *cobra.Command {\n    cmd := &cobra.Command{\n    Use:                        \"tx\",\n    Short:                      \"Transactions subcommands\",\n    DisableFlagParsing:         true,\n    SuggestionsMinimumDistance: 2,\n    RunE:                       client.ValidateCmd,\n}\n\ncmd.AddCommand(\n\t\tauthcmd.GetSignCommand(),\n\t\tauthcmd.GetSignBatchCommand(),\n\t\tauthcmd.GetMultiSignCommand(),\n\t\tauthcmd.GetMultiSignBatchCmd(),\n\t\tauthcmd.GetValidateSignaturesCommand(),\n\t\tflags.LineBreak,\n\t\tauthcmd.GetBroadcastCommand(),\n\t\tauthcmd.GetEncodeCommand(),\n\t\tauthcmd.GetDecodeCommand(),\n\t\tauthcmd.GetAuxToFeeCommand(),\n\t)\n\ngaia.ModuleBasics.AddTxCommands(cmd)\n\ncmd.PersistentFlags().String(flags.FlagChainID, \"\", \"The network chain ID\")\n\nreturn cmd\n}\n\ntype appCreator struct {\n    encCfg params.EncodingConfig\n}\n\nfunc (ac appCreator)\n\nnewApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tappOpts servertypes.AppOptions,\n)\n\nservertypes.Application {\n    var cache sdk.MultiStorePersistentCache\n    if cast.ToBool(appOpts.Get(server.FlagInterBlockCache)) {\n    cache = store.NewCommitKVStoreCacheManager()\n}\n    skipUpgradeHeights := make(map[int64]bool)\n    for _, h := range cast.ToIntSlice(appOpts.Get(server.FlagUnsafeSkipUpgrades)) {\n    skipUpgradeHeights[int64(h)] = true\n}\n\npruningOpts, err := server.GetPruningOptionsFromFlags(appOpts)\n    if err != nil {\n    panic(err)\n}\n    snapshotDir := filepath.Join(cast.ToString(appOpts.Get(flags.FlagHome)), \"data\", \"snapshots\")\n\nsnapshotDB, err := dbm.NewDB(\"metadata\", server.GetAppDBBackend(appOpts), snapshotDir)\n    if err != nil {\n    panic(err)\n}\n\nsnapshotStore, err := snapshots.NewStore(snapshotDB, snapshotDir)\n    if err != nil {\n    panic(err)\n}\n    snapshotOptions := snapshottypes.NewSnapshotOptions(\n\t\tcast.ToUint64(appOpts.Get(server.FlagStateSyncSnapshotInterval)),\n\t\tcast.ToUint32(appOpts.Get(server.FlagStateSyncSnapshotKeepRecent)),\n\t)\n\nreturn gaia.NewGaiaApp(\n\t\tlogger, db, traceStore, true, skipUpgradeHeights,\n\t\tcast.ToString(appOpts.Get(flags.FlagHome)),\n\t\tcast.ToUint(appOpts.Get(server.FlagInvCheckPeriod)),\n\t\tac.encCfg,\n\t\tappOpts,\n\t\tbaseapp.SetPruning(pruningOpts),\n\t\tbaseapp.SetMinGasPrices(cast.ToString(appOpts.Get(server.FlagMinGasPrices))),\n\t\tbaseapp.SetHaltHeight(cast.ToUint64(appOpts.Get(server.FlagHaltHeight))),\n\t\tbaseapp.SetHaltTime(cast.ToUint64(appOpts.Get(server.FlagHaltTime))),\n\t\tbaseapp.SetMinRetainBlocks(cast.ToUint64(appOpts.Get(server.FlagMinRetainBlocks))),\n\t\tbaseapp.SetInterBlockCache(cache),\n\t\tbaseapp.SetTrace(cast.ToBool(appOpts.Get(server.FlagTrace))),\n\t\tbaseapp.SetIndexEvents(cast.ToStringSlice(appOpts.Get(server.FlagIndexEvents))),\n\t\tbaseapp.SetSnapshot(snapshotStore, snapshotOptions),\n\t)\n}\n\nfunc (ac appCreator)\n\nappExport(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\theight int64,\n    forZeroHeight bool,\n\tjailAllowedAddrs []string,\n\tappOpts servertypes.AppOptions,\n) (servertypes.ExportedApp, error) {\n    homePath, ok := appOpts.Get(flags.FlagHome).(string)\n    if !ok || homePath == \"\" {\n    return servertypes.ExportedApp{\n}, errors.New(\"application home is not set\")\n}\n\nvar loadLatest bool\n    if height == -1 {\n    loadLatest = true\n}\n    gaiaApp := gaia.NewGaiaApp(\n\t\tlogger,\n\t\tdb,\n\t\ttraceStore,\n\t\tloadLatest,\n\t\tmap[int64]bool{\n},\n\t\thomePath,\n\t\tcast.ToUint(appOpts.Get(server.FlagInvCheckPeriod)),\n\t\tac.encCfg,\n\t\tappOpts,\n\t)\n    if height != -1 {\n    if err := gaiaApp.LoadHeight(height); err != nil {\n    return servertypes.ExportedApp{\n}, err\n}\n\t\n}\n\nreturn gaiaApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs)\n}\nSee all 308 lines\n\u200b\nDependencies and Makefile\nThis section is optional, as developers are free to choose their dependency manager and project building method. That said, the current most used framework for versioning control is go.mod. It ensures each of the libraries used throughout the application are imported with the correct version.\nThe following is the go.mod of the Cosmos Hub, provided as an example.\n\nCopy\n\nAsk AI\nmodule github.com/cosmos/gaia/v8\n\ngo 1.18\n\nrequire (\n\tcosmossdk.io/math v1.0.0-beta.3\n\tgithub.com/cosmos/cosmos-sdk v0.46.2\n\tgithub.com/cosmos/go-bip39 v1.0.0 // indirect\n\tgithub.com/cosmos/ibc-go/v5 v5.0.0\n\tgithub.com/gogo/protobuf v1.3.3\n\tgithub.com/golang/protobuf v1.5.2\n\tgithub.com/golangci/golangci-lint v1.50.0\n\tgithub.com/gorilla/mux v1.8.0\n\tgithub.com/gravity-devs/liquidity/v2 v2.0.0\n\tgithub.com/grpc-ecosystem/grpc-gateway v1.16.0\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/rakyll/statik v0.1.7\n\tgithub.com/spf13/cast v1.5.0\n\tgithub.com/spf13/cobra v1.6.0\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/spf13/viper v1.13.0\n\tgithub.com/strangelove-ventures/packet-forward-middleware/v2 v2.1.4-0.20220802012200-5a62a55a7f1d\n\tgithub.com/stretchr/testify v1.8.0\n\tgithub.com/tendermint/tendermint v0.34.21\n\tgithub.com/tendermint/tm-db v0.6.7\n\tgoogle.golang.org/genproto v0.0.0-20220815135757-37a418bb8959\n\tgoogle.golang.org/grpc v1.50.0\n)\n\nrequire (\n\t4d63.com/gochecknoglobals v0.1.0 // indirect\n\tcloud.google.com/go v0.102.1 // indirect\n\tcloud.google.com/go/compute v1.7.0 // indirect\n\tcloud.google.com/go/iam v0.4.0 // indirect\n\tcloud.google.com/go/storage v1.22.1 // indirect\n\tcosmossdk.io/errors v1.0.0-beta.7 // indirect\n\tfilippo.io/edwards25519 v1.0.0-rc.1 // indirect\n\tgithub.com/99designs/go-keychain v0.0.0-20191008050251-8e49817e8af4 // indirect\n\tgithub.com/99designs/keyring v1.2.1 // indirect\n\tgithub.com/Abirdcfly/dupword v0.0.7 // indirect\n\tgithub.com/Antonboom/errname v0.1.7 // indirect\n\tgithub.com/Antonboom/nilnil v0.1.1 // indirect\n\tgithub.com/BurntSushi/toml v1.2.0 // indirect\n\tgithub.com/ChainSafe/go-schnorrkel v0.0.0-20200405005733-88cbf1b4c40d // indirect\n\tgithub.com/Djarvur/go-err113 v0.0.0-20210108212216-aea10b59be24 // indirect\n\tgithub.com/GaijinEntertainment/go-exhaustruct/v2 v2.3.0 // indirect\n\tgithub.com/Masterminds/semver v1.5.0 // indirect\n\tgithub.com/OpenPeeDeeP/depguard v1.1.1 // indirect\n\tgithub.com/Workiva/go-datastructures v1.0.53 // indirect\n\tgithub.com/alexkohler/prealloc v1.0.0 // indirect\n\tgithub.com/alingse/asasalint v0.0.11 // indirect\n\tgithub.com/armon/go-metrics v0.4.0 // indirect\n\tgithub.com/ashanbrown/forbidigo v1.3.0 // indirect\n\tgithub.com/ashanbrown/makezero v1.1.1 // indirect\n\tgithub.com/aws/aws-sdk-go v1.40.45 // indirect\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/bgentry/go-netrc v0.0.0-20140422174119-9fd32a8b3d3d // indirect\n\tgithub.com/bgentry/speakeasy v0.1.0 // indirect\n\tgithub.com/bkielbasa/cyclop v1.2.0 // indirect\n\tgithub.com/blizzy78/varnamelen v0.8.0 // indirect\n\tgithub.com/bombsimon/wsl/v3 v3.3.0 // indirect\n\tgithub.com/breml/bidichk v0.2.3 // indirect\n\tgithub.com/breml/errchkjson v0.3.0 // indirect\n\tgithub.com/btcsuite/btcd v0.22.1 // indirect\n\tgithub.com/butuzov/ireturn v0.1.1 // indirect\n\tgithub.com/cenkalti/backoff/v4 v4.1.3 // indirect\n\tgithub.com/cespare/xxhash v1.1.0 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.1.2 // indirect\n\tgithub.com/charithe/durationcheck v0.0.9 // indirect\n\tgithub.com/chavacava/garif v0.0.0-20220630083739-93517212f375 // indirect\n\tgithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e // indirect\n\tgithub.com/cockroachdb/apd/v2 v2.0.2 // indirect\n\tgithub.com/coinbase/rosetta-sdk-go v0.7.9 // indirect\n\tgithub.com/confio/ics23/go v0.7.0 // indirect\n\tgithub.com/cosmos/btcutil v1.0.4 // indirect\n\tgithub.com/cosmos/cosmos-proto v1.0.0-alpha7 // indirect\n\tgithub.com/cosmos/gorocksdb v1.2.0 // indirect\n\tgithub.com/cosmos/iavl v0.19.2-0.20220916140702-9b6be3095313 // indirect\n\tgithub.com/cosmos/ledger-cosmos-go v0.11.1 // indirect\n\tgithub.com/cosmos/ledger-go v0.9.3 // indirect\n\tgithub.com/creachadair/taskgroup v0.3.2 // indirect\n\tgithub.com/curioswitch/go-reassign v0.2.0 // indirect\n\tgithub.com/daixiang0/gci v0.8.0 // indirect\n\tgithub.com/danieljoos/wincred v1.1.2 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/denis-tingaikin/go-header v0.4.3 // indirect\n\tgithub.com/desertbit/timer v0.0.0-20180107155436-c41aec40b27f // indirect\n\tgithub.com/dgraph-io/badger/v2 v2.2007.4 // indirect\n\tgithub.com/dgraph-io/ristretto v0.1.0 // indirect\n\tgithub.com/dgryski/go-farm v0.0.0-20200201041132-a6ae2369ad13 // indirect\n\tgithub.com/dustin/go-humanize v1.0.0 // indirect\n\tgithub.com/dvsekhvalnov/jose2go v1.5.0 // indirect\n\tgithub.com/esimonov/ifshort v1.0.4 // indirect\n\tgithub.com/ettle/strcase v0.1.1 // indirect\n\tgithub.com/fatih/color v1.13.0 // indirect\n\tgithub.com/fatih/structtag v1.2.0 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.1 // indirect\n\tgithub.com/firefart/nonamedreturns v1.0.4 // indirect\n\tgithub.com/fsnotify/fsnotify v1.5.4 // indirect\n\tgithub.com/fzipp/gocyclo v0.6.0 // indirect\n\tgithub.com/go-critic/go-critic v0.6.5 // indirect\n\tgithub.com/go-kit/kit v0.12.0 // indirect\n\tgithub.com/go-kit/log v0.2.1 // indirect\n\tgithub.com/go-logfmt/logfmt v0.5.1 // indirect\n\tgithub.com/go-playground/validator/v10 v10.4.1 // indirect\n\tgithub.com/go-toolsmith/astcast v1.0.0 // indirect\n\tgithub.com/go-toolsmith/astcopy v1.0.2 // indirect\n\tgithub.com/go-toolsmith/astequal v1.0.3 // indirect\n\tgithub.com/go-toolsmith/astfmt v1.0.0 // indirect\n\tgithub.com/go-toolsmith/astp v1.0.0 // indirect\n\tgithub.com/go-toolsmith/strparse v1.0.0 // indirect\n\tgithub.com/go-toolsmith/typep v1.0.2 // indirect\n\tgithub.com/go-xmlfmt/xmlfmt v0.0.0-20191208150333-d5b6f63a941b // indirect\n\tgithub.com/gobwas/glob v0.2.3 // indirect\n\tgithub.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 // indirect\n\tgithub.com/gofrs/flock v0.8.1 // indirect\n\tgithub.com/gogo/gateway v1.1.0 // indirect\n\tgithub.com/golang/glog v1.0.0 // indirect\n\tgithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect\n\tgithub.com/golang/snappy v0.0.4 // indirect\n\tgithub.com/golangci/check v0.0.0-20180506172741-cfe4005ccda2 // indirect\n\tgithub.com/golangci/dupl v0.0.0-20180902072040-3e9179ac440a // indirect\n\tgithub.com/golangci/go-misc v0.0.0-20220329215616-d24fe342adfe // indirect\n\tgithub.com/golangci/gofmt v0.0.0-20220901101216-f2edd75033f2 // indirect\n\tgithub.com/golangci/lint-1 v0.0.0-20191013205115-297bf364a8e0 // indirect\n\tgithub.com/golangci/maligned v0.0.0-20180506175553-b1d89398deca // indirect\n\tgithub.com/golangci/misspell v0.3.5 // indirect\n\tgithub.com/golangci/revgrep v0.0.0-20220804021717-745bb2f7c2e6 // indirect\n\tgithub.com/golangci/unconvert v0.0.0-20180507085042-28b1c447d1f4 // indirect\n\tgithub.com/google/btree v1.0.1 // indirect\n\tgithub.com/google/go-cmp v0.5.9 // indirect\n\tgithub.com/google/orderedcode v0.0.1 // indirect\n\tgithub.com/google/uuid v1.3.0 // indirect\n\tgithub.com/googleapis/enterprise-certificate-proxy v0.1.0 // indirect\n\tgithub.com/googleapis/gax-go/v2 v2.4.0 // indirect\n\tgithub.com/googleapis/go-type-adapters v1.0.0 // indirect\n\tgithub.com/gordonklaus/ineffassign v0.0.0-20210914165742-4cc7213b9bc8 // indirect\n\tgithub.com/gorilla/handlers v1.5.1 // indirect\n\tgithub.com/gorilla/websocket v1.5.0 // indirect\n\tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n\tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n\tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n\tgithub.com/gostaticanalysis/nilerr v0.1.1 // indirect\n\tgithub.com/grpc-ecosystem/go-grpc-middleware v1.3.0 // indirect\n\tgithub.com/grpc-ecosystem/grpc-gateway/v2 v2.0.1 // indirect\n\tgithub.com/gsterjov/go-libsecret v0.0.0-20161001094733-a6f4afe4910c // indirect\n\tgithub.com/gtank/merlin v0.1.1 // indirect\n\tgithub.com/gtank/ristretto255 v0.1.2 // indirect\n\tgithub.com/hashicorp/errwrap v1.1.0 // indirect\n\tgithub.com/hashicorp/go-cleanhttp v0.5.2 // indirect\n\tgithub.com/hashicorp/go-getter v1.6.1 // indirect\n\tgithub.com/hashicorp/go-immutable-radix v1.3.1 // indirect\n\tgithub.com/hashicorp/go-multierror v1.1.1 // indirect\n\tgithub.com/hashicorp/go-safetemp v1.0.0 // indirect\n\tgithub.com/hashicorp/go-version v1.6.0 // indirect\n\tgithub.com/hashicorp/golang-lru v0.5.5-0.20210104140557-80c98217689d // indirect\n\tgithub.com/hashicorp/hcl v1.0.0 // indirect\n\tgithub.com/hdevalence/ed25519consensus v0.0.0-20220222234857-c00d1f31bab3 // indirect\n\tgithub.com/hexops/gotextdiff v1.0.3 // indirect\n\tgithub.com/improbable-eng/grpc-web v0.15.0 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.0.1 // indirect\n\tgithub.com/jgautheron/goconst v1.5.1 // indirect\n\tgithub.com/jingyugao/rowserrcheck v1.1.1 // indirect\n\tgithub.com/jirfag/go-printf-func-name v0.0.0-20200119135958-7558a9eaa5af // indirect\n\tgithub.com/jmespath/go-jmespath v0.4.0 // indirect\n\tgithub.com/jmhodges/levigo v1.0.0 // indirect\n\tgithub.com/julz/importas v0.1.0 // indirect\n\tgithub.com/kisielk/errcheck v1.6.2 // indirect\n\tgithub.com/kisielk/gotool v1.0.0 // indirect\n\tgithub.com/kkHAIKE/contextcheck v1.1.2 // indirect\n\tgithub.com/klauspost/compress v1.15.9 // indirect\n\tgithub.com/kulti/thelper v0.6.3 // indirect\n\tgithub.com/kunwardeep/paralleltest v1.0.6 // indirect\n\tgithub.com/kyoh86/exportloopref v0.1.8 // indirect\n\tgithub.com/ldez/gomoddirectives v0.2.3 // indirect\n\tgithub.com/ldez/tagliatelle v0.3.1 // indirect\n\tgithub.com/leonklingele/grouper v1.1.0 // indirect\n\tgithub.com/lib/pq v1.10.6 // indirect\n\tgithub.com/libp2p/go-buffer-pool v0.1.0 // indirect\n\tgithub.com/lufeee/execinquery v1.2.1 // indirect\n\tgithub.com/magiconair/properties v1.8.6 // indirect\n\tgithub.com/manifoldco/promptui v0.9.0 // indirect\n\tgithub.com/maratori/testableexamples v1.0.0 // indirect\n\tgithub.com/maratori/testpackage v1.1.0 // indirect\n\tgithub.com/matoous/godox v0.0.0-20210227103229-6504466cf951 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.16 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.9 // indirect\n\tgithub.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369 // indirect\n\tgithub.com/mbilski/exhaustivestruct v1.2.0 // indirect\n\tgithub.com/mgechev/revive v1.2.4 // indirect\n\tgithub.com/mimoo/StrobeGo v0.0.0-20181016162300-f8f6d4d2b643 // indirect\n\tgithub.com/minio/highwayhash v1.0.2 // indirect\n\tgithub.com/mitchellh/go-homedir v1.1.0 // indirect\n\tgithub.com/mitchellh/go-testing-interface v1.0.0 // indirect\n\tgithub.com/mitchellh/mapstructure v1.5.0 // indirect\n\tgithub.com/moricho/tparallel v0.2.1 // indirect\n\tgithub.com/mtibben/percent v0.2.1 // indirect\n\tgithub.com/nakabonne/nestif v0.3.1 // indirect\n\tgithub.com/nbutton23/zxcvbn-go v0.0.0-20210217022336-fa2cb2858354 // indirect\n\tgithub.com/nishanths/exhaustive v0.8.3 // indirect\n\tgithub.com/nishanths/predeclared v0.2.2 // indirect\n\tgithub.com/olekukonko/tablewriter v0.0.5 // indirect\n\tgithub.com/pelletier/go-toml v1.9.5 // indirect\n\tgithub.com/pelletier/go-toml/v2 v2.0.5 // indirect\n\tgithub.com/petermattis/goid v0.0.0-20180202154549-b0b1615b78e5 // indirect\n\tgithub.com/phayes/checkstyle v0.0.0-20170904204023-bfd46e6a821d // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/polyfloyd/go-errorlint v1.0.5 // indirect\n\tgithub.com/prometheus/client_golang v1.12.2 // indirect\n\tgithub.com/prometheus/client_model v0.2.0 // indirect\n\tgithub.com/prometheus/common v0.34.0 // indirect\n\tgithub.com/prometheus/procfs v0.7.3 // indirect\n\tgithub.com/quasilyte/go-ruleguard v0.3.18 // indirect\n\tgithub.com/quasilyte/gogrep v0.0.0-20220828223005-86e4605de09f // indirect\n\tgithub.com/quasilyte/regex/syntax v0.0.0-20200407221936-30656e2c4a95 // indirect\n\tgithub.com/quasilyte/stdinfo v0.0.0-20220114132959-f7386bf02567 // indirect\n\tgithub.com/rcrowley/go-metrics v0.0.0-20200313005456-10cdbea86bc0 // indirect\n\tgithub.com/regen-network/cosmos-proto v0.3.1 // indirect\n\tgithub.com/rs/cors v1.8.2 // indirect\n\tgithub.com/rs/zerolog v1.27.0 // indirect\n\tgithub.com/ryancurrah/gomodguard v1.2.4 // indirect\n\tgithub.com/ryanrolds/sqlclosecheck v0.3.0 // indirect\n\tgithub.com/sanposhiho/wastedassign/v2 v2.0.6 // indirect\n\tgithub.com/sasha-s/go-deadlock v0.2.1-0.20190427202633-1595213edefa // indirect\n\tgithub.com/sashamelentyev/interfacebloat v1.1.0 // indirect\n\tgithub.com/sashamelentyev/usestdlibvars v1.20.0 // indirect\n\tgithub.com/securego/gosec/v2 v2.13.1 // indirect\n\tgithub.com/shazow/go-diff v0.0.0-20160112020656-b6b7b6733b8c // indirect\n\tgithub.com/sirupsen/logrus v1.9.0 // indirect\n\tgithub.com/sivchari/containedctx v1.0.2 // indirect\n\tgithub.com/sivchari/nosnakecase v1.7.0 // indirect\n\tgithub.com/sivchari/tenv v1.7.0 // indirect\n\tgithub.com/sonatard/noctx v0.0.1 // indirect\n\tgithub.com/sourcegraph/go-diff v0.6.1 // indirect\n\tgithub.com/spf13/afero v1.8.2 // indirect\n\tgithub.com/spf13/jwalterweatherman v1.1.0 // indirect\n\tgithub.com/ssgreg/nlreturn/v2 v2.2.1 // indirect\n\tgithub.com/stbenjam/no-sprintf-host-port v0.1.1 // indirect\n\tgithub.com/stretchr/objx v0.4.0 // indirect\n\tgithub.com/subosito/gotenv v1.4.1 // indirect\n\tgithub.com/syndtr/goleveldb v1.0.1-0.20210819022825-2ae1ddf74ef7 // indirect\n\tgithub.com/tdakkota/asciicheck v0.1.1 // indirect\n\tgithub.com/tendermint/btcd v0.1.1 // indirect\n\tgithub.com/tendermint/crypto v0.0.0-20191022145703-50d29ede1e15 // indirect\n\tgithub.com/tendermint/go-amino v0.16.0 // indirect\n\tgithub.com/tetafro/godot v1.4.11 // indirect\n\tgithub.com/timakin/bodyclose v0.0.0-20210704033933-f49887972144 // indirect\n\tgithub.com/timonwong/loggercheck v0.9.3 // indirect\n\tgithub.com/tomarrell/wrapcheck/v2 v2.6.2 // indirect\n\tgithub.com/tommy-muehle/go-mnd/v2 v2.5.0 // indirect\n\tgithub.com/ulikunitz/xz v0.5.8 // indirect\n\tgithub.com/ultraware/funlen v0.0.3 // indirect\n\tgithub.com/ultraware/whitespace v0.0.5 // indirect\n\tgithub.com/uudashr/gocognit v1.0.6 // indirect\n\tgithub.com/yagipy/maintidx v1.0.0 // indirect\n\tgithub.com/yeya24/promlinter v0.2.0 // indirect\n\tgithub.com/zondax/hid v0.9.1-0.20220302062450-5552068d2266 // indirect\n\tgitlab.com/bosi/decorder v0.2.3 // indirect\n\tgo.etcd.io/bbolt v1.3.6 // indirect\n\tgo.opencensus.io v0.23.0 // indirect\n\tgo.uber.org/atomic v1.9.0 // indirect\n\tgo.uber.org/multierr v1.8.0 // indirect\n\tgo.uber.org/zap v1.21.0 // indirect\n\tgolang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa // indirect\n\tgolang.org/x/exp v0.0.0-20220722155223-a9213eeb770e // indirect\n\tgolang.org/x/exp/typeparams v0.0.0-20220827204233-334a2380cb91 // indirect\n\tgolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4 // indirect\n\tgolang.org/x/net v0.0.0-20220726230323-06994584191e // indirect\n\tgolang.org/x/oauth2 v0.0.0-20220622183110-fd043fe589d2 // indirect\n\tgolang.org/x/sync v0.0.0-20220819030929-7fc1605a5dde // indirect\n\tgolang.org/x/sys v0.0.0-20220915200043-7b5979e65e41 // indirect\n\tgolang.org/x/term v0.0.0-20220722155259-a9ba230a4035 // indirect\n\tgolang.org/x/text v0.3.7 // indirect\n\tgolang.org/x/tools v0.1.12 // indirect\n\tgolang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f // indirect\n\tgoogle.golang.org/api v0.93.0 // indirect\n\tgoogle.golang.org/appengine v1.6.7 // indirect\n\tgoogle.golang.org/protobuf v1.28.1 // indirect\n\tgopkg.in/ini.v1 v1.67.0 // indirect\n\tgopkg.in/yaml.v2 v2.4.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n\thonnef.co/go/tools v0.3.3 // indirect\n\tmvdan.cc/gofumpt v0.4.0 // indirect\n\tmvdan.cc/interfacer v0.0.0-20180901003855-c20040233aed // indirect\n\tmvdan.cc/lint v0.0.0-20170908181259-adc824a0674b // indirect\n\tmvdan.cc/unparam v0.0.0-20220706161116-678bad134442 // indirect\n\tnhooyr.io/websocket v1.8.6 // indirect\n\tsigs.k8s.io/yaml v1.3.0 // indirect\n)\n\nreplace (\n\tgithub.com/gogo/protobuf => github.com/regen-network/protobuf v1.3.3-alpha.regen.1\n\tgithub.com/zondax/hid => github.com/zondax/hid v0.9.0\n)\nSee all 295 lines\nFor building the application, a Makefile is generally used. The Makefile primarily ensures that the go.mod is run before building the two entrypoints to the application, Node Client and Application Interface.\nHere is an example of the Cosmos Hub Makefile.\n\n\nAnatomy of a Cosmos SDK Application\n\nCopy page\n\nSynopsis This document describes the core parts of a Cosmos SDK application, represented throughout the document as a placeholder application named app.\n\u200b\nNode Client\nThe Daemon, or Full-Node Client, is the core process of a Cosmos SDK-based blockchain. Participants in the network run this process to initialize their state-machine, connect with other full-nodes, and update their state-machine as new blocks come in.\n\nCopy\n\nAsk AI\n                ^  +-------------------------------+  ^\n                |  |                               |  |\n                |  |  State-machine = Application  |  |\n                |  |                               |  |   Built with Cosmos SDK\n                |  |            ^      +           |  |\n                |  +----------- | ABCI | ----------+  v\n                |  |            +      v           |  ^\n                |  |                               |  |\nBlockchain Node |  |           Consensus           |  |\n                |  |                               |  |\n                |  +-------------------------------+  |   CometBFT\n                |  |                               |  |\n                |  |           Networking          |  |\n                |  |                               |  |\n                v  +-------------------------------+  v\nSee all 16 lines\nThe blockchain full-node presents itself as a binary, generally suffixed by -d for \u201cdaemon\u201d (e.g. appd for app or gaiad for gaia). This binary is built by running a simple main.go function placed in ./cmd/appd/. This operation usually happens through the Makefile.\nOnce the main binary is built, the node can be started by running the start command. This command function primarily does three things:\nCreate an instance of the state-machine defined in app.go.\nInitialize the state-machine with the latest known state, extracted from the db stored in the ~/.app/data folder. At this point, the state-machine is at height appBlockHeight.\nCreate and start a new CometBFT instance. Among other things, the node performs a handshake with its peers. It gets the latest blockHeight from them and replays blocks to sync to this height if it is greater than the local appBlockHeight. The node starts from genesis and CometBFT sends an InitChain message via the ABCI to the app, which triggers the InitChainer.\nWhen starting a CometBFT instance, the genesis file is the 0 height and the state within the genesis file is committed at block height 1. When querying the state of the node, querying block height 0 will return an error.\n\u200b\nCore Application File\nIn general, the core of the state-machine is defined in a file called app.go. This file mainly contains the type definition of the application and functions to create and initialize it.\n\u200b\nType Definition of the Application\nThe first thing defined in app.go is the type of the application. It is generally comprised of the following parts:\nEmbeding runtime.App The runtime package manages the application\u2019s core components and modules through dependency injection. It provides declarative configuration for module management, state storage, and ABCI handling.\nRuntime wraps BaseApp, meaning when a transaction is relayed by CometBFT to the application, app uses runtime\u2019s methods to route them to the appropriate module. BaseApp implements all the ABCI methods and the routing logic.\nIt automatically configures the module manager based on the app wiring configuration. The module manager facilitates operations related to these modules, like registering their Msg service and gRPC Query service, or setting the order of execution between modules for various functions like InitChainer, PreBlocker and BeginBlocker and EndBlocker.\nAn App Wiring configuration file The app wiring configuration file contains the list of application\u2019s modules that runtime must instantiate. The instantiation of the modules are done using depinject. It also contains the order in which all module\u2019s InitGenesis and Pre/Begin/EndBlocker methods should be executed.\nA reference to an appCodec. The application\u2019s appCodec is used to serialize and deserialize data structures in order to store them, as stores can only persist []bytes. The default codec is Protocol Buffers.\nA reference to a legacyAmino codec. Some parts of the Cosmos SDK have not been migrated to use the appCodec above, and are still hardcoded to use Amino. Other parts explicitly use Amino for backwards compatibility. For these reasons, the application still holds a reference to the legacy Amino codec. Please note that the Amino codec will be removed from the SDK in the upcoming releases.\nSee an example of application type definition from simapp, the Cosmos SDK\u2019s own app used for demo and testing purposes:\n\nCopy\n\nAsk AI\n//go:build !app_v1\n\npackage simapp\n\nimport (\n    \n\t\"io\"\n\n\tdbm \"github.com/cosmos/cosmos-db\"\n\n\tclienthelpers \"cosmossdk.io/client/v2/helpers\"\n    \"cosmossdk.io/depinject\"\n    \"cosmossdk.io/log\"\n\tstoretypes \"cosmossdk.io/store/types\"\n\tcircuitkeeper \"cosmossdk.io/x/circuit/keeper\"\n\tevidencekeeper \"cosmossdk.io/x/evidence/keeper\"\n\tfeegrantkeeper \"cosmossdk.io/x/feegrant/keeper\"\n\tnftkeeper \"cosmossdk.io/x/nft/keeper\"\n\tupgradekeeper \"cosmossdk.io/x/upgrade/keeper\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n\tcodectypes \"github.com/cosmos/cosmos-sdk/codec/types\"\n    \"github.com/cosmos/cosmos-sdk/runtime\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n\ttestdata_pulsar \"github.com/cosmos/cosmos-sdk/testutil/testdata/testpb\"\n    \"github.com/cosmos/cosmos-sdk/types/module\"\n    \"github.com/cosmos/cosmos-sdk/x/auth\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/ante\"\n\tauthkeeper \"github.com/cosmos/cosmos-sdk/x/auth/keeper\"\n\tauthsims \"github.com/cosmos/cosmos-sdk/x/auth/simulation\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n\tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n\tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n\tconsensuskeeper \"github.com/cosmos/cosmos-sdk/x/consensus/keeper\"\n\tdistrkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n\tepochskeeper \"github.com/cosmos/cosmos-sdk/x/epochs/keeper\"\n\tgovkeeper \"github.com/cosmos/cosmos-sdk/x/gov/keeper\"\n\tgroupkeeper \"github.com/cosmos/cosmos-sdk/x/group/keeper\"\n\tmintkeeper \"github.com/cosmos/cosmos-sdk/x/mint/keeper\"\n\tprotocolpoolkeeper \"github.com/cosmos/cosmos-sdk/x/protocolpool/keeper\"\n\tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n)\n\n// DefaultNodeHome default home directories for the application daemon\nvar DefaultNodeHome string\n\nvar (\n\t_ runtime.AppI            = (*SimApp)(nil)\n\t_ servertypes.Application = (*SimApp)(nil)\n)\n\n// SimApp extends an ABCI application, but with most of its parameters exported.\n// They are exported for convenience in creating helper functions, as object\n// capabilities aren't needed for testing.\ntype SimApp struct {\n\t*runtime.App\n\tlegacyAmino       *codec.LegacyAmino\n\tappCodec          codec.Codec\n\ttxConfig          client.TxConfig\n\tinterfaceRegistry codectypes.InterfaceRegistry\n\n\t// essential keepers\n\tAccountKeeper         authkeeper.AccountKeeper\n\tBankKeeper            bankkeeper.BaseKeeper\n\tStakingKeeper         *stakingkeeper.Keeper\n\tSlashingKeeper        slashingkeeper.Keeper\n\tMintKeeper            mintkeeper.Keeper\n\tDistrKeeper           distrkeeper.Keeper\n\tGovKeeper             *govkeeper.Keeper\n\tUpgradeKeeper         *upgradekeeper.Keeper\n\tEvidenceKeeper        evidencekeeper.Keeper\n\tConsensusParamsKeeper consensuskeeper.Keeper\n\tCircuitKeeper         circuitkeeper.Keeper\n\n\t// supplementary keepers\n\tFeeGrantKeeper     feegrantkeeper.Keeper\n\tGroupKeeper        groupkeeper.Keeper\n\tAuthzKeeper        authzkeeper.Keeper\n\tNFTKeeper          nftkeeper.Keeper\n\tEpochsKeeper       epochskeeper.Keeper\n\tProtocolPoolKeeper protocolpoolkeeper.Keeper\n\n\t// simulation manager\n\tsm *module.SimulationManager\n}\n\nfunc init() {\n    var err error\n\tDefaultNodeHome, err = clienthelpers.GetNodeHomeDirectory(\".simapp\")\n    if err != nil {\n    panic(err)\n}\n}\n\n// NewSimApp returns a reference to an initialized SimApp.\nfunc NewSimApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tloadLatest bool,\n\tappOpts servertypes.AppOptions,\n\tbaseAppOptions ...func(*baseapp.BaseApp),\n) *SimApp {\n    var (\n\t\tapp        = &SimApp{\n}\n\nappBuilder *runtime.AppBuilder\n\n\t\t// merge the AppConfig and other configuration in one config\n\t\tappConfig = depinject.Configs(\n\t\t\tAppConfig,\n\t\t\tdepinject.Supply(\n\t\t\t\t// supply the application options\n\t\t\t\tappOpts,\n\t\t\t\t// supply the logger\n\t\t\t\tlogger,\n\n\t\t\t\t// ADVANCED CONFIGURATION\n\n\t\t\t\t//\n\t\t\t\t// AUTH\n\t\t\t\t//\n\t\t\t\t// For providing a custom function required in auth to generate custom account types\n\t\t\t\t// add it below. By default the auth module uses simulation.RandomGenesisAccounts.\n\t\t\t\t//\n\t\t\t\t// authtypes.RandomGenesisAccountsFn(simulation.RandomGenesisAccounts),\n\t\t\t\t//\n\t\t\t\t// For providing a custom a base account type add it below.\n\t\t\t\t// By default the auth module uses authtypes.ProtoBaseAccount().\n\t\t\t\t//\n\t\t\t\t// func()\n\nsdk.AccountI {\n    return authtypes.ProtoBaseAccount()\n},\n\t\t\t\t//\n\t\t\t\t// For providing a different address codec, add it below.\n\t\t\t\t// By default the auth module uses a Bech32 address codec,\n\t\t\t\t// with the prefix defined in the auth module configuration.\n\t\t\t\t//\n\t\t\t\t// func()\n\naddress.Codec {\n    return <- custom address codec type ->\n}\n\t\t\t\t//\n\t\t\t\t// STAKING\n\t\t\t\t//\n\t\t\t\t// For provinding a different validator and consensus address codec, add it below.\n\t\t\t\t// By default the staking module uses the bech32 prefix provided in the auth config,\n\t\t\t\t// and appends \"valoper\" and \"valcons\" for validator and consensus addresses respectively.\n\t\t\t\t// When providing a custom address codec in auth, custom address codecs must be provided here as well.\n\t\t\t\t//\n\t\t\t\t// func()\n\nruntime.ValidatorAddressCodec {\n    return <- custom validator address codec type ->\n}\n\t\t\t\t// func()\n\nruntime.ConsensusAddressCodec {\n    return <- custom consensus address codec type ->\n}\n\n\t\t\t\t//\n\t\t\t\t// MINT\n\t\t\t\t//\n\n\t\t\t\t// For providing a custom inflation function for x/mint add here your\n\t\t\t\t// custom minting function that implements the mintkeeper.MintFn\n\t\t\t\t// interface.\n\t\t\t),\n\t\t)\n\t)\n    if err := depinject.Inject(appConfig,\n\t\t&appBuilder,\n\t\t&app.appCodec,\n\t\t&app.legacyAmino,\n\t\t&app.txConfig,\n\t\t&app.interfaceRegistry,\n\t\t&app.AccountKeeper,\n\t\t&app.BankKeeper,\n\t\t&app.StakingKeeper,\n\t\t&app.SlashingKeeper,\n\t\t&app.MintKeeper,\n\t\t&app.DistrKeeper,\n\t\t&app.GovKeeper,\n\t\t&app.UpgradeKeeper,\n\t\t&app.AuthzKeeper,\n\t\t&app.EvidenceKeeper,\n\t\t&app.FeeGrantKeeper,\n\t\t&app.GroupKeeper,\n\t\t&app.NFTKeeper,\n\t\t&app.ConsensusParamsKeeper,\n\t\t&app.CircuitKeeper,\n\t\t&app.EpochsKeeper,\n\t\t&app.ProtocolPoolKeeper,\n\t); err != nil {\n    panic(err)\n}\n\n\t// Below we could construct and set an application specific mempool and\n\t// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are\n\t// already set in the SDK's BaseApp, this shows an example of how to override\n\t// them.\n\t//\n\t// Example:\n\t//\n\t// app.App = appBuilder.Build(...)\n\t// nonceMempool := mempool.NewSenderNonceMempool()\n\t// abciPropHandler := NewDefaultProposalHandler(nonceMempool, app.App.BaseApp)\n\t//\n\t// app.App.BaseApp.SetMempool(nonceMempool)\n\t// app.App.BaseApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t// app.App.BaseApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())\n\t//\n\t// Alternatively, you can construct BaseApp options, append those to\n\t// baseAppOptions and pass them to the appBuilder.\n\t//\n\t// Example:\n\t//\n\t// prepareOpt = func(app *baseapp.BaseApp) {\n\t// \tabciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)\n\t// \tapp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t//\n}\n\t// baseAppOptions = append(baseAppOptions, prepareOpt)\n\n\t// create and set dummy vote extension handler\n    voteExtOp := func(bApp *baseapp.BaseApp) {\n    voteExtHandler := NewVoteExtensionHandler()\n\nvoteExtHandler.SetHandlers(bApp)\n}\n\nbaseAppOptions = append(baseAppOptions, voteExtOp, baseapp.SetOptimisticExecution())\n\napp.App = appBuilder.Build(db, traceStore, baseAppOptions...)\n\n\t// register streaming services\n    if err := app.RegisterStreamingServices(appOpts, app.kvStoreKeys()); err != nil {\n    panic(err)\n}\n\n\t/****  Module Options ****/\n\n\t// RegisterUpgradeHandlers is used for registering any on-chain upgrades.\n\tapp.RegisterUpgradeHandlers()\n\n\t// add test gRPC service for testing gRPC queries in isolation\n\ttestdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{\n})\n\n\t// create the simulation manager and define the order of the modules for deterministic simulations\n\t//\n\t// NOTE: this is not required apps that don't use the simulator for fuzz testing\n\t// transactions\n    overrideModules := map[string]module.AppModuleSimulation{\n    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n}\n\napp.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)\n\napp.sm.RegisterStoreDecoders()\n\n\t// A custom InitChainer can be set if extra pre-init-genesis logic is required.\n\t// By default, when using app wiring enabled module, this is not required.\n\t// For instance, the upgrade module will set automatically the module version map in its init genesis thanks to app wiring.\n\t// However, when registering a module manually (i.e. that does not support app wiring), the module version map\n\t// must be set manually as follow. The upgrade module will de-duplicate the module version map.\n\t//\n\t// app.SetInitChainer(func(ctx sdk.Context, req *abci.RequestInitChain) (*abci.ResponseInitChain, error) {\n\t// \tapp.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())\n\t// \treturn app.App.InitChainer(ctx, req)\n\t//\n})\n\n\t// set custom ante handler\n\tapp.setAnteHandler(app.txConfig)\n    if err := app.Load(loadLatest); err != nil {\n    panic(err)\n}\n\nreturn app\n}\n\n// setAnteHandler sets custom ante handlers.\n// \"x/auth/tx\" pre-defined ante handler have been disabled in app_config.\nfunc (app *SimApp)\n\nsetAnteHandler(txConfig client.TxConfig) {\n    anteHandler, err := NewAnteHandler(\n\t\tHandlerOptions{\n    ante.HandlerOptions{\n    AccountKeeper:   app.AccountKeeper,\n    BankKeeper:      app.BankKeeper,\n    SignModeHandler: txConfig.SignModeHandler(),\n    FeegrantKeeper:  app.FeeGrantKeeper,\n    SigGasConsumer:  ante.DefaultSigVerificationGasConsumer,\n},\n\t\t\t&app.CircuitKeeper,\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\n\t// Set the AnteHandler for the app\n\tapp.SetAnteHandler(anteHandler)\n}\n\n// LegacyAmino returns SimApp's amino codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nLegacyAmino() *codec.LegacyAmino {\n    return app.legacyAmino\n}\n\n// AppCodec returns SimApp's app codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nAppCodec()\n\ncodec.Codec {\n    return app.appCodec\n}\n\n// InterfaceRegistry returns SimApp's InterfaceRegistry.\nfunc (app *SimApp)\n\nInterfaceRegistry()\n\ncodectypes.InterfaceRegistry {\n    return app.interfaceRegistry\n}\n\n// TxConfig returns SimApp's TxConfig\nfunc (app *SimApp)\n\nTxConfig()\n\nclient.TxConfig {\n    return app.txConfig\n}\n\n// GetKey returns the KVStoreKey for the provided store key.\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc (app *SimApp)\n\nGetKey(storeKey string) *storetypes.KVStoreKey {\n    sk := app.UnsafeFindStoreKey(storeKey)\n\nkvStoreKey, ok := sk.(*storetypes.KVStoreKey)\n    if !ok {\n    return nil\n}\n\nreturn kvStoreKey\n}\n\nfunc (app *SimApp)\n\nkvStoreKeys()\n\nmap[string]*storetypes.KVStoreKey {\n    keys := make(map[string]*storetypes.KVStoreKey)\n    for _, k := range app.GetStoreKeys() {\n    if kv, ok := k.(*storetypes.KVStoreKey); ok {\n    keys[kv.Name()] = kv\n}\n\t\n}\n\nreturn keys\n}\n\n// SimulationManager implements the SimulationApp interface\nfunc (app *SimApp)\n\nSimulationManager() *module.SimulationManager {\n    return app.sm\n}\n\n// RegisterAPIRoutes registers all application module routes with the provided\n// API server.\nfunc (app *SimApp)\n\nRegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {\n    app.App.RegisterAPIRoutes(apiSvr, apiConfig)\n\t// register swagger API in app.go so that other applications can override easily\n    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {\n    panic(err)\n}\n}\n\n// GetMaccPerms returns a copy of the module account permissions\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc GetMaccPerms()\n\nmap[string][]string {\n    dup := make(map[string][]string)\n    for _, perms := range moduleAccPerms {\n    dup[perms.Account] = perms.Permissions\n}\n\nreturn dup\n}\n\n// BlockedAddresses returns all the app's blocked account addresses.\nfunc BlockedAddresses()\n\nmap[string]bool {\n    result := make(map[string]bool)\n    if len(blockAccAddrs) > 0 {\n    for _, addr := range blockAccAddrs {\n    result[addr] = true\n}\n\t\n}\n\nelse {\n    for addr := range GetMaccPerms() {\n    result[addr] = true\n}\n\t\n}\n\nreturn result\n}\nSee all 443 lines\n\u200b\nConstructor Function\nAlso defined in app.go is the constructor function, which constructs a new application of the type defined in the preceding section. The function must fulfill the AppCreator signature in order to be used in the start command of the application\u2019s daemon command.\n\nCopy\n\nAsk AI\npackage types\n\nimport (\n    \n\t\"encoding/json\"\n    \"io\"\n\n\tcmtproto \"github.com/cometbft/cometbft/proto/tendermint/types\"\n\tcmttypes \"github.com/cometbft/cometbft/types\"\n\tdbm \"github.com/cosmos/cosmos-db\"\n    \"github.com/cosmos/gogoproto/grpc\"\n    \"github.com/spf13/cobra\"\n    \"cosmossdk.io/log\"\n    \"cosmossdk.io/store/snapshots\"\n\tstoretypes \"cosmossdk.io/store/types\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n)\n\ntype (\n\t// AppOptions defines an interface that is passed into an application\n\t// constructor, typically used to set BaseApp options that are either supplied\n\t// via config file or through CLI arguments/flags. The underlying implementation\n\t// is defined by the server package and is typically implemented via a Viper\n\t// literal defined on the server Context. Note, casting Get calls may not yield\n\t// the expected types and could result in type assertion errors. It is recommend\n\t// to either use the cast package or perform manual conversion for safety.\n\tAppOptions interface {\n    Get(string)\n\nany\n}\n\n\t// Application defines an application interface that wraps abci.Application.\n\t// The interface defines the necessary contracts to be implemented in order\n\t// to fully bootstrap and start an application.\n\tApplication interface {\n    ABCI\n\n\t\tRegisterAPIRoutes(*api.Server, config.APIConfig)\n\n\t\t// RegisterGRPCServerWithSkipCheckHeader registers gRPC services directly with the gRPC\n\t\t// server and bypass check header flag.\n\t\tRegisterGRPCServerWithSkipCheckHeader(grpc.Server, bool)\n\n\t\t// RegisterTxService registers the gRPC Query service for tx (such as tx\n\t\t// simulation, fetching txs by hash...).\n\t\tRegisterTxService(client.Context)\n\n\t\t// RegisterTendermintService registers the gRPC Query service for CometBFT queries.\n\t\tRegisterTendermintService(client.Context)\n\n\t\t// RegisterNodeService registers the node gRPC Query service.\n\t\tRegisterNodeService(client.Context, config.Config)\n\n\t\t// CommitMultiStore return the multistore instance\n\t\tCommitMultiStore()\n\nstoretypes.CommitMultiStore\n\n\t\t// Return the snapshot manager\n\t\tSnapshotManager() *snapshots.Manager\n\n\t\t// Close is called in start cmd to gracefully cleanup resources.\n\t\t// Must be safe to be called multiple times.\n\t\tClose()\n\nerror\n}\n\n\t// AppCreator is a function that allows us to lazily initialize an\n\t// application using various configurations.\n\tAppCreator func(log.Logger, dbm.DB, io.Writer, AppOptions)\n\nApplication\n\n\t// ModuleInitFlags takes a start command and adds modules specific init flags.\n\tModuleInitFlags func(startCmd *cobra.Command)\n\n\t// ExportedApp represents an exported app state, along with\n\t// validators, consensus params and latest app height.\n\tExportedApp struct {\n\t\t// AppState is the application state as JSON.\n\t\tAppState json.RawMessage\n\t\t// Validators is the exported validator set.\n\t\tValidators []cmttypes.GenesisValidator\n\t\t// Height is the app's latest block height.\n\t\tHeight int64\n\t\t// ConsensusParams are the exported consensus params for ABCI.\n\t\tConsensusParams cmtproto.ConsensusParams\n}\n\n\t// AppExporter is a function that dumps all app state to\n\t// JSON-serializable structure and returns the current validator set.\n\tAppExporter func(\n\t\tlogger log.Logger,\n\t\tdb dbm.DB,\n\t\ttraceWriter io.Writer,\n\t\theight int64,\n    forZeroHeight bool,\n\t\tjailAllowedAddrs []string,\n\t\topts AppOptions,\n\t\tmodulesToExport []string,\n\t) (ExportedApp, error)\n)\nSee all 106 lines\nHere are the main actions performed by this function:\nInstantiate a new codec and initialize the codec of each of the application\u2019s modules using the basic manager.\nInstantiate a new application with a reference to a baseapp instance, a codec, and all the appropriate store keys.\nInstantiate all the keeper objects defined in the application\u2019s type using the NewKeeper function of each of the application\u2019s modules. Note that keepers must be instantiated in the correct order, as the NewKeeper of one module might require a reference to another module\u2019s keeper.\nInstantiate the application\u2019s module manager with the AppModule object of each of the application\u2019s modules.\nWith the module manager, initialize the application\u2019s Msg services, gRPC Query services, legacy Msg routes, and legacy query routes. When a transaction is relayed to the application by CometBFT via the ABCI, it is routed to the appropriate module\u2019s Msg service using the routes defined here. Likewise, when a gRPC query request is received by the application, it is routed to the appropriate module\u2019s gRPC query service using the gRPC routes defined here. The Cosmos SDK still supports legacy Msgs and legacy CometBFT queries, which are routed using the legacy Msg routes and the legacy query routes, respectively.\nWith the module manager, register the application\u2019s modules\u2019 invariants. Invariants are variables (e.g. total supply of a token) that are evaluated at the end of each block. The process of checking invariants is done via a special module called the InvariantsRegistry. The value of the invariant should be equal to a predicted value defined in the module. Should the value be different than the predicted one, special logic defined in the invariant registry is triggered (usually the chain is halted). This is useful to make sure that no critical bug goes unnoticed, producing long-lasting effects that are hard to fix.\nWith the module manager, set the order of execution between the InitGenesis, PreBlocker, BeginBlocker, and EndBlocker functions of each of the application\u2019s modules. Note that not all modules implement these functions.\nSet the remaining application parameters:\nInitChainer: used to initialize the application when it is first started.\nPreBlocker: called before BeginBlock.\nBeginBlocker, EndBlocker: called at the beginning and at the end of every block.\nanteHandler: used to handle fees and signature verification.\nMount the stores.\nReturn the application.\nNote that the constructor function only creates an instance of the app, while the actual state is either carried over from the ~/.app/data folder if the node is restarted, or generated from the genesis file if the node is started for the first time.\nSee an example of application constructor from simapp:\n\nCopy\n\nAsk AI\n//go:build app_v1\n\npackage simapp\n\nimport (\n    \n\t\"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"maps\"\n\n\tabci \"github.com/cometbft/cometbft/abci/types\"\n\tdbm \"github.com/cosmos/cosmos-db\"\n    \"github.com/cosmos/gogoproto/proto\"\n    \"github.com/spf13/cast\"\n\n\tautocliv1 \"cosmossdk.io/api/cosmos/autocli/v1\"\n\treflectionv1 \"cosmossdk.io/api/cosmos/reflection/v1\"\n    \"cosmossdk.io/client/v2/autocli\"\n\tclienthelpers \"cosmossdk.io/client/v2/helpers\"\n    \"cosmossdk.io/core/appmodule\"\n    \"cosmossdk.io/log\"\n\tstoretypes \"cosmossdk.io/store/types\"\n    \"cosmossdk.io/x/circuit\"\n\tcircuitkeeper \"cosmossdk.io/x/circuit/keeper\"\n\tcircuittypes \"cosmossdk.io/x/circuit/types\"\n    \"cosmossdk.io/x/evidence\"\n\tevidencekeeper \"cosmossdk.io/x/evidence/keeper\"\n\tevidencetypes \"cosmossdk.io/x/evidence/types\"\n    \"cosmossdk.io/x/feegrant\"\n\tfeegrantkeeper \"cosmossdk.io/x/feegrant/keeper\"\n\tfeegrantmodule \"cosmossdk.io/x/feegrant/module\"\n    \"cosmossdk.io/x/nft\"\n\tnftkeeper \"cosmossdk.io/x/nft/keeper\"\n\tnftmodule \"cosmossdk.io/x/nft/module\"\n    \"cosmossdk.io/x/tx/signing\"\n    \"cosmossdk.io/x/upgrade\"\n\tupgradekeeper \"cosmossdk.io/x/upgrade/keeper\"\n\tupgradetypes \"cosmossdk.io/x/upgrade/types\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/client/flags\"\n    \"github.com/cosmos/cosmos-sdk/client/grpc/cmtservice\"\n\tnodeservice \"github.com/cosmos/cosmos-sdk/client/grpc/node\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/address\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n    \"github.com/cosmos/cosmos-sdk/runtime\"\n\truntimeservices \"github.com/cosmos/cosmos-sdk/runtime/services\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n    \"github.com/cosmos/cosmos-sdk/std\"\n\ttestdata_pulsar \"github.com/cosmos/cosmos-sdk/testutil/testdata/testpb\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n    \"github.com/cosmos/cosmos-sdk/types/module\"\n\tsigtypes \"github.com/cosmos/cosmos-sdk/types/tx/signing\"\n    \"github.com/cosmos/cosmos-sdk/version\"\n    \"github.com/cosmos/cosmos-sdk/x/auth\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/ante\"\n\tauthcodec \"github.com/cosmos/cosmos-sdk/x/auth/codec\"\n\tauthkeeper \"github.com/cosmos/cosmos-sdk/x/auth/keeper\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/posthandler\"\n\tauthsims \"github.com/cosmos/cosmos-sdk/x/auth/simulation\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\ttxmodule \"github.com/cosmos/cosmos-sdk/x/auth/tx/config\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/vesting\"\n\tvestingtypes \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n    \"github.com/cosmos/cosmos-sdk/x/authz\"\n\tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n\tauthzmodule \"github.com/cosmos/cosmos-sdk/x/authz/module\"\n    \"github.com/cosmos/cosmos-sdk/x/bank\"\n\tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n\tconsensus \"github.com/cosmos/cosmos-sdk/x/consensus\"\n\tconsensusparamkeeper \"github.com/cosmos/cosmos-sdk/x/consensus/keeper\"\n\tconsensusparamtypes \"github.com/cosmos/cosmos-sdk/x/consensus/types\"\n\tdistr \"github.com/cosmos/cosmos-sdk/x/distribution\"\n\tdistrkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n\tdistrtypes \"github.com/cosmos/cosmos-sdk/x/distribution/types\"\n    \"github.com/cosmos/cosmos-sdk/x/epochs\"\n\tepochskeeper \"github.com/cosmos/cosmos-sdk/x/epochs/keeper\"\n\tepochstypes \"github.com/cosmos/cosmos-sdk/x/epochs/types\"\n    \"github.com/cosmos/cosmos-sdk/x/genutil\"\n\tgenutiltypes \"github.com/cosmos/cosmos-sdk/x/genutil/types\"\n    \"github.com/cosmos/cosmos-sdk/x/gov\"\n\tgovclient \"github.com/cosmos/cosmos-sdk/x/gov/client\"\n\tgovkeeper \"github.com/cosmos/cosmos-sdk/x/gov/keeper\"\n\tgovtypes \"github.com/cosmos/cosmos-sdk/x/gov/types\"\n\tgovv1beta1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1\"\n    \"github.com/cosmos/cosmos-sdk/x/group\"\n\tgroupkeeper \"github.com/cosmos/cosmos-sdk/x/group/keeper\"\n\tgroupmodule \"github.com/cosmos/cosmos-sdk/x/group/module\"\n    \"github.com/cosmos/cosmos-sdk/x/mint\"\n\tmintkeeper \"github.com/cosmos/cosmos-sdk/x/mint/keeper\"\n\tminttypes \"github.com/cosmos/cosmos-sdk/x/mint/types\"\n    \"github.com/cosmos/cosmos-sdk/x/protocolpool\"\n\tprotocolpoolkeeper \"github.com/cosmos/cosmos-sdk/x/protocolpool/keeper\"\n\tprotocolpooltypes \"github.com/cosmos/cosmos-sdk/x/protocolpool/types\"\n    \"github.com/cosmos/cosmos-sdk/x/slashing\"\n\tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n\tslashingtypes \"github.com/cosmos/cosmos-sdk/x/slashing/types\"\n    \"github.com/cosmos/cosmos-sdk/x/staking\"\n\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n)\n\nconst appName = \"SimApp\"\n\nvar (\n\t// DefaultNodeHome default home directories for the application daemon\n\tDefaultNodeHome string\n\n\t// module account permissions\n\tmaccPerms = map[string][]string{\n    authtypes.FeeCollectorName:                  nil,\n\t\tdistrtypes.ModuleName:                       nil,\n\t\tminttypes.ModuleName:                        {\n    authtypes.Minter\n},\n\t\tstakingtypes.BondedPoolName:                 {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tstakingtypes.NotBondedPoolName:              {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tgovtypes.ModuleName:                         {\n    authtypes.Burner\n},\n\t\tnft.ModuleName:                              nil,\n\t\tprotocolpooltypes.ModuleName:                nil,\n\t\tprotocolpooltypes.ProtocolPoolEscrowAccount: nil\n}\n)\n\nvar (\n\t_ runtime.AppI            = (*SimApp)(nil)\n\t_ servertypes.Application = (*SimApp)(nil)\n)\n\n// SimApp extends an ABCI application, but with most of its parameters exported.\n// They are exported for convenience in creating helper functions, as object\n// capabilities aren't needed for testing.\ntype SimApp struct {\n\t*baseapp.BaseApp\n\tlegacyAmino       *codec.LegacyAmino\n\tappCodec          codec.Codec\n\ttxConfig          client.TxConfig\n\tinterfaceRegistry types.InterfaceRegistry\n\n\t// keys to access the substores\n\tkeys map[string]*storetypes.KVStoreKey\n\n\t// essential keepers\n\tAccountKeeper         authkeeper.AccountKeeper\n\tBankKeeper            bankkeeper.BaseKeeper\n\tStakingKeeper         *stakingkeeper.Keeper\n\tSlashingKeeper        slashingkeeper.Keeper\n\tMintKeeper            mintkeeper.Keeper\n\tDistrKeeper           distrkeeper.Keeper\n\tGovKeeper             govkeeper.Keeper\n\tUpgradeKeeper         *upgradekeeper.Keeper\n\tEvidenceKeeper        evidencekeeper.Keeper\n\tConsensusParamsKeeper consensusparamkeeper.Keeper\n\tCircuitKeeper         circuitkeeper.Keeper\n\n\t// supplementary keepers\n\tFeeGrantKeeper     feegrantkeeper.Keeper\n\tGroupKeeper        groupkeeper.Keeper\n\tAuthzKeeper        authzkeeper.Keeper\n\tNFTKeeper          nftkeeper.Keeper\n\tEpochsKeeper       epochskeeper.Keeper\n\tProtocolPoolKeeper protocolpoolkeeper.Keeper\n\n\t// the module manager\n\tModuleManager      *module.Manager\n\tBasicModuleManager module.BasicManager\n\n\t// simulation manager\n\tsm *module.SimulationManager\n\n\t// module configurator\n\tconfigurator module.Configurator\n}\n\nfunc init() {\n    var err error\n\tDefaultNodeHome, err = clienthelpers.GetNodeHomeDirectory(\".simapp\")\n    if err != nil {\n    panic(err)\n}\n}\n\n// NewSimApp returns a reference to an initialized SimApp.\nfunc NewSimApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tloadLatest bool,\n\tappOpts servertypes.AppOptions,\n\tbaseAppOptions ...func(*baseapp.BaseApp),\n) *SimApp {\n    interfaceRegistry, _ := types.NewInterfaceRegistryWithOptions(types.InterfaceRegistryOptions{\n    ProtoFiles: proto.HybridResolver,\n    SigningOptions: signing.Options{\n    AddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32AccountAddrPrefix(),\n},\n    ValidatorAddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32ValidatorAddrPrefix(),\n},\n},\n})\n    appCodec := codec.NewProtoCodec(interfaceRegistry)\n    legacyAmino := codec.NewLegacyAmino()\n    txConfig := tx.NewTxConfig(appCodec, tx.DefaultSignModes)\n    if err := interfaceRegistry.SigningContext().Validate(); err != nil {\n    panic(err)\n}\n\nstd.RegisterLegacyAminoCodec(legacyAmino)\n\nstd.RegisterInterfaces(interfaceRegistry)\n\n\t// Below we could construct and set an application specific mempool and\n\t// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are\n\t// already set in the SDK's BaseApp, this shows an example of how to override\n\t// them.\n\t//\n\t// Example:\n\t//\n\t// bApp := baseapp.NewBaseApp(...)\n\t// nonceMempool := mempool.NewSenderNonceMempool()\n\t// abciPropHandler := NewDefaultProposalHandler(nonceMempool, bApp)\n\t//\n\t// bApp.SetMempool(nonceMempool)\n\t// bApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t// bApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())\n\t//\n\t// Alternatively, you can construct BaseApp options, append those to\n\t// baseAppOptions and pass them to NewBaseApp.\n\t//\n\t// Example:\n\t//\n\t// prepareOpt = func(app *baseapp.BaseApp) {\n\t// \tabciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)\n\t// \tapp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t//\n}\n\t// baseAppOptions = append(baseAppOptions, prepareOpt)\n\n\t// create and set dummy vote extension handler\n    voteExtOp := func(bApp *baseapp.BaseApp) {\n    voteExtHandler := NewVoteExtensionHandler()\n\nvoteExtHandler.SetHandlers(bApp)\n}\n\nbaseAppOptions = append(baseAppOptions, voteExtOp, baseapp.SetOptimisticExecution())\n    bApp := baseapp.NewBaseApp(appName, logger, db, txConfig.TxDecoder(), baseAppOptions...)\n\nbApp.SetCommitMultiStoreTracer(traceStore)\n\nbApp.SetVersion(version.Version)\n\nbApp.SetInterfaceRegistry(interfaceRegistry)\n\nbApp.SetTxEncoder(txConfig.TxEncoder())\n    keys := storetypes.NewKVStoreKeys(\n\t\tauthtypes.StoreKey,\n\t\tbanktypes.StoreKey,\n\t\tstakingtypes.StoreKey,\n\t\tminttypes.StoreKey,\n\t\tdistrtypes.StoreKey,\n\t\tslashingtypes.StoreKey,\n\t\tgovtypes.StoreKey,\n\t\tconsensusparamtypes.StoreKey,\n\t\tupgradetypes.StoreKey,\n\t\tfeegrant.StoreKey,\n\t\tevidencetypes.StoreKey,\n\t\tcircuittypes.StoreKey,\n\t\tauthzkeeper.StoreKey,\n\t\tnftkeeper.StoreKey,\n\t\tgroup.StoreKey,\n\t\tepochstypes.StoreKey,\n\t\tprotocolpooltypes.StoreKey,\n\t)\n\n\t// register streaming services\n    if err := bApp.RegisterStreamingServices(appOpts, keys); err != nil {\n    panic(err)\n}\n    app := &SimApp{\n    BaseApp:           bApp,\n\t\tlegacyAmino:       legacyAmino,\n\t\tappCodec:          appCodec,\n\t\ttxConfig:          txConfig,\n\t\tinterfaceRegistry: interfaceRegistry,\n\t\tkeys:              keys,\n}\n\n\t// set the BaseApp's parameter store\n\tapp.ConsensusParamsKeeper = consensusparamkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[consensusparamtypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\truntime.EventService{\n},\n\t)\n\nbApp.SetParamStore(app.ConsensusParamsKeeper.ParamsStore)\n\n\t// add keepers\n\tapp.AccountKeeper = authkeeper.NewAccountKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[authtypes.StoreKey]),\n\t\tauthtypes.ProtoBaseAccount,\n\t\tmaccPerms,\n\t\tauthcodec.NewBech32Codec(sdk.Bech32MainPrefix),\n\t\tsdk.Bech32MainPrefix,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthkeeper.WithUnorderedTransactions(true),\n\t)\n\napp.BankKeeper = bankkeeper.NewBaseKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[banktypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tBlockedAddresses(),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tlogger,\n\t)\n\n\t// optional: enable sign mode textual by overwriting the default tx config (after setting the bank keeper)\n    enabledSignModes := append(tx.DefaultSignModes, sigtypes.SignMode_SIGN_MODE_TEXTUAL)\n    txConfigOpts := tx.ConfigOptions{\n    EnabledSignModes:           enabledSignModes,\n    TextualCoinMetadataQueryFn: txmodule.NewBankKeeperCoinMetadataQueryFn(app.BankKeeper),\n}\n\ntxConfig, err := tx.NewTxConfigWithOptions(\n\t\tappCodec,\n\t\ttxConfigOpts,\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.txConfig = txConfig\n\n\tapp.StakingKeeper = stakingkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[stakingtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixValAddr),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixConsAddr),\n\t)\n\napp.MintKeeper = mintkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[minttypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// mintkeeper.WithMintFn(mintkeeper.DefaultMintFn(minttypes.DefaultInflationCalculationFn)), custom mintFn can be added here\n\t)\n\napp.ProtocolPoolKeeper = protocolpoolkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[protocolpooltypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.DistrKeeper = distrkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[distrtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tdistrkeeper.WithExternalCommunityPool(app.ProtocolPoolKeeper),\n\t)\n\napp.SlashingKeeper = slashingkeeper.NewKeeper(\n\t\tappCodec,\n\t\tlegacyAmino,\n\t\truntime.NewKVStoreService(keys[slashingtypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.FeeGrantKeeper = feegrantkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[feegrant.StoreKey]),\n\t\tapp.AccountKeeper,\n\t)\n\n\t// register the staking hooks\n\t// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks\n\tapp.StakingKeeper.SetHooks(\n\t\tstakingtypes.NewMultiStakingHooks(\n\t\t\tapp.DistrKeeper.Hooks(),\n\t\t\tapp.SlashingKeeper.Hooks(),\n\t\t),\n\t)\n\napp.CircuitKeeper = circuitkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[circuittypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tapp.AccountKeeper.AddressCodec(),\n\t)\n\napp.BaseApp.SetCircuitBreaker(&app.CircuitKeeper)\n\napp.AuthzKeeper = authzkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[authzkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t)\n    groupConfig := group.DefaultConfig()\n\t/*\n\t\tExample of setting group params:\n\t\tgroupConfig.MaxMetadataLen = 1000\n\t*/\n\tapp.GroupKeeper = groupkeeper.NewKeeper(\n\t\tkeys[group.StoreKey],\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t\tgroupConfig,\n\t)\n\n\t// get skipUpgradeHeights from the app options\n    skipUpgradeHeights := map[int64]bool{\n}\n    for _, h := range cast.ToIntSlice(appOpts.Get(server.FlagUnsafeSkipUpgrades)) {\n    skipUpgradeHeights[int64(h)] = true\n}\n    homePath := cast.ToString(appOpts.Get(flags.FlagHome))\n\t// set the governance module account as the authority for conducting upgrades\n\tapp.UpgradeKeeper = upgradekeeper.NewKeeper(\n\t\tskipUpgradeHeights,\n\t\truntime.NewKVStoreService(keys[upgradetypes.StoreKey]),\n\t\tappCodec,\n\t\thomePath,\n\t\tapp.BaseApp,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\n\t// Register the proposal types\n\t// Deprecated: Avoid adding new handlers, instead use the new proposal flow\n\t// by granting the governance module the right to execute the message.\n\t// See: https://docs.cosmos.network/main/modules/gov#proposal-messages\n    govRouter := govv1beta1.NewRouter()\n\ngovRouter.AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler)\n    govConfig := govtypes.DefaultConfig()\n\t/*\n\t\tExample of setting gov params:\n\t\tgovConfig.MaxMetadataLen = 10000\n\t*/\n    govKeeper := govkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[govtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tapp.DistrKeeper,\n\t\tapp.MsgServiceRouter(),\n\t\tgovConfig,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// govkeeper.WithCustomCalculateVoteResultsAndVotingPowerFn(...), // Add if you want to use a custom vote calculation function.\n\t)\n\n\t// Set legacy router for backwards compatibility with gov v1beta1\n\tgovKeeper.SetLegacyRouter(govRouter)\n\napp.GovKeeper = *govKeeper.SetHooks(\n\t\tgovtypes.NewMultiGovHooks(\n\t\t\t// register the governance hooks\n\t\t),\n\t)\n\napp.NFTKeeper = nftkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[nftkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t)\n\n\t// create evidence keeper with router\n    evidenceKeeper := evidencekeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[evidencetypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.SlashingKeeper,\n\t\tapp.AccountKeeper.AddressCodec(),\n\t\truntime.ProvideCometInfoService(),\n\t)\n\t// If evidence needs to be handled for the app, set routes in router here and seal\n\tapp.EvidenceKeeper = *evidenceKeeper\n\n\tapp.EpochsKeeper = epochskeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[epochstypes.StoreKey]),\n\t\tappCodec,\n\t)\n\napp.EpochsKeeper.SetHooks(\n\t\tepochstypes.NewMultiEpochHooks(\n\t\t\t// insert epoch hooks receivers here\n\t\t),\n\t)\n\n\t/****  Module Options ****/\n\n\t// NOTE: Any module instantiated in the module manager that is later modified\n\t// must be passed by reference here.\n\tapp.ModuleManager = module.NewManager(\n\t\tgenutil.NewAppModule(\n\t\t\tapp.AccountKeeper, app.StakingKeeper, app,\n\t\t\ttxConfig,\n\t\t),\n\t\tauth.NewAppModule(appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n\t\tvesting.NewAppModule(app.AccountKeeper, app.BankKeeper),\n\t\tbank.NewAppModule(appCodec, app.BankKeeper, app.AccountKeeper, nil),\n\t\tfeegrantmodule.NewAppModule(appCodec, app.AccountKeeper, app.BankKeeper, app.FeeGrantKeeper, app.interfaceRegistry),\n\t\tgov.NewAppModule(appCodec, &app.GovKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tmint.NewAppModule(appCodec, app.MintKeeper, app.AccountKeeper, nil, nil),\n\t\tslashing.NewAppModule(appCodec, app.SlashingKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil, app.interfaceRegistry),\n\t\tdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil),\n\t\tstaking.NewAppModule(appCodec, app.StakingKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tupgrade.NewAppModule(app.UpgradeKeeper, app.AccountKeeper.AddressCodec()),\n\t\tevidence.NewAppModule(app.EvidenceKeeper),\n\t\tauthzmodule.NewAppModule(appCodec, app.AuthzKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tgroupmodule.NewAppModule(appCodec, app.GroupKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tnftmodule.NewAppModule(appCodec, app.NFTKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tconsensus.NewAppModule(appCodec, app.ConsensusParamsKeeper),\n\t\tcircuit.NewAppModule(appCodec, app.CircuitKeeper),\n\t\tepochs.NewAppModule(app.EpochsKeeper),\n\t\tprotocolpool.NewAppModule(app.ProtocolPoolKeeper, app.AccountKeeper, app.BankKeeper),\n\t)\n\n\t// BasicModuleManager defines the module BasicManager is in charge of setting up basic,\n\t// non-dependant module elements, such as codec registration and genesis verification.\n\t// By default it is composed of all the module from the module manager.\n\t// Additionally, app module basics can be overwritten by passing them as argument.\n\tapp.BasicModuleManager = module.NewBasicManagerFromManager(\n\t\tapp.ModuleManager,\n\t\tmap[string]module.AppModuleBasic{\n    genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),\n\t\t\tgovtypes.ModuleName: gov.NewAppModuleBasic(\n\t\t\t\t[]govclient.ProposalHandler{\n},\n\t\t\t),\n})\n\napp.BasicModuleManager.RegisterLegacyAminoCodec(legacyAmino)\n\napp.BasicModuleManager.RegisterInterfaces(interfaceRegistry)\n\n\t// NOTE: upgrade module is required to be prioritized\n\tapp.ModuleManager.SetOrderPreBlockers(\n\t\tupgradetypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t)\n\t// During begin block slashing happens after distr.BeginBlocker so that\n\t// there is nothing left over in the validator fee pool, so as to keep the\n\t// CanWithdrawInvariant invariant.\n\t// NOTE: staking module is required if HistoricalEntries param > 0\n\tapp.ModuleManager.SetOrderBeginBlockers(\n\t\tminttypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tepochstypes.ModuleName,\n\t)\n\napp.ModuleManager.SetOrderEndBlockers(\n\t\tgovtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tgroup.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t)\n\n\t// NOTE: The genutils module must occur after staking so that pools are\n\t// properly initialized with tokens from genesis accounts.\n\t// NOTE: The genutils module must also occur after auth so that it can access the params from auth.\n    genesisModuleOrder := []string{\n    authtypes.ModuleName,\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tconsensusparamtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n}\n    exportModuleOrder := []string{\n    consensusparamtypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName, // Must be exported before bank\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n}\n\napp.ModuleManager.SetOrderInitGenesis(genesisModuleOrder...)\n\napp.ModuleManager.SetOrderExportGenesis(exportModuleOrder...)\n\n\t// Uncomment if you want to set a custom migration order here.\n\t// app.ModuleManager.SetOrderMigrations(custom order)\n\napp.configurator = module.NewConfigurator(app.appCodec, app.MsgServiceRouter(), app.GRPCQueryRouter())\n\nerr = app.ModuleManager.RegisterServices(app.configurator)\n    if err != nil {\n    panic(err)\n}\n\n\t// RegisterUpgradeHandlers is used for registering any on-chain upgrades.\n\t// Make sure it's called after `app.ModuleManager` and `app.configurator` are set.\n\tapp.RegisterUpgradeHandlers()\n\nautocliv1.RegisterQueryServer(app.GRPCQueryRouter(), runtimeservices.NewAutoCLIQueryService(app.ModuleManager.Modules))\n\nreflectionSvc, err := runtimeservices.NewReflectionService()\n    if err != nil {\n    panic(err)\n}\n\nreflectionv1.RegisterReflectionServiceServer(app.GRPCQueryRouter(), reflectionSvc)\n\n\t// add test gRPC service for testing gRPC queries in isolation\n\ttestdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{\n})\n\n\t// create the simulation manager and define the order of the modules for deterministic simulations\n\t//\n\t// NOTE: this is not required apps that don't use the simulator for fuzz testing\n\t// transactions\n    overrideModules := map[string]module.AppModuleSimulation{\n    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n}\n\napp.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)\n\napp.sm.RegisterStoreDecoders()\n\n\t// initialize stores\n\tapp.MountKVStores(keys)\n\n\t// initialize BaseApp\n\tapp.SetInitChainer(app.InitChainer)\n\napp.SetPreBlocker(app.PreBlocker)\n\napp.SetBeginBlocker(app.BeginBlocker)\n\napp.SetEndBlocker(app.EndBlocker)\n\napp.setAnteHandler(txConfig)\n\n\t// In v0.46, the SDK introduces _postHandlers_. PostHandlers are like\n\t// antehandlers, but are run _after_ the `runMsgs` execution. They are also\n\t// defined as a chain, and have the same signature as antehandlers.\n\t//\n\t// In baseapp, postHandlers are run in the same store branch as `runMsgs`,\n\t// meaning that both `runMsgs` and `postHandler` state will be committed if\n\t// both are successful, and both will be reverted if any of the two fails.\n\t//\n\t// The SDK exposes a default postHandlers chain\n\t//\n\t// Please note that changing any of the anteHandler or postHandler chain is\n\t// likely to be a state-machine breaking change, which needs a coordinated\n\t// upgrade.\n\tapp.setPostHandler()\n    if loadLatest {\n    if err := app.LoadLatestVersion(); err != nil {\n    panic(fmt.Errorf(\"error loading last version: %w\", err))\n}\n\t\n}\n\nreturn app\n}\n\nfunc (app *SimApp)\n\nsetAnteHandler(txConfig client.TxConfig) {\n    anteHandler, err := NewAnteHandler(\n\t\tHandlerOptions{\n    ante.HandlerOptions{\n    AccountKeeper:   app.AccountKeeper,\n    BankKeeper:      app.BankKeeper,\n    SignModeHandler: txConfig.SignModeHandler(),\n    FeegrantKeeper:  app.FeeGrantKeeper,\n    SigGasConsumer:  ante.DefaultSigVerificationGasConsumer,\n    SigVerifyOptions: []ante.SigVerificationDecoratorOption{\n\t\t\t\t\t// change below as needed.\n\t\t\t\t\tante.WithUnorderedTxGasCost(ante.DefaultUnorderedTxGasCost),\n\t\t\t\t\tante.WithMaxUnorderedTxTimeoutDuration(ante.DefaultMaxTimeoutDuration),\n},\n},\n\t\t\t&app.CircuitKeeper,\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\n\t// Set the AnteHandler for the app\n\tapp.SetAnteHandler(anteHandler)\n}\n\nfunc (app *SimApp)\n\nsetPostHandler() {\n    postHandler, err := posthandler.NewPostHandler(\n\t\tposthandler.HandlerOptions{\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.SetPostHandler(postHandler)\n}\n\n// Name returns the name of the App\nfunc (app *SimApp)\n\nName()\n\nstring {\n    return app.BaseApp.Name()\n}\n\n// PreBlocker application updates every pre block\nfunc (app *SimApp)\n\nPreBlocker(ctx sdk.Context, _ *abci.RequestFinalizeBlock) (*sdk.ResponsePreBlock, error) {\n    return app.ModuleManager.PreBlock(ctx)\n}\n\n// BeginBlocker application updates every begin block\nfunc (app *SimApp)\n\nBeginBlocker(ctx sdk.Context) (sdk.BeginBlock, error) {\n    return app.ModuleManager.BeginBlock(ctx)\n}\n\n// EndBlocker application updates every end block\nfunc (app *SimApp)\n\nEndBlocker(ctx sdk.Context) (sdk.EndBlock, error) {\n    return app.ModuleManager.EndBlock(ctx)\n}\n\nfunc (a *SimApp)\n\nConfigurator()\n\nmodule.Configurator {\n    return a.configurator\n}\n\n// InitChainer application update at chain initialization\nfunc (app *SimApp)\n\nInitChainer(ctx sdk.Context, req *abci.RequestInitChain) (*abci.ResponseInitChain, error) {\n    var genesisState GenesisState\n    if err := json.Unmarshal(req.AppStateBytes, &genesisState); err != nil {\n    panic(err)\n}\n\napp.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())\n\nreturn app.ModuleManager.InitGenesis(ctx, app.appCodec, genesisState)\n}\n\n// LoadHeight loads a particular height\nfunc (app *SimApp)\n\nLoadHeight(height int64)\n\nerror {\n    return app.LoadVersion(height)\n}\n\n// LegacyAmino returns SimApp's amino codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nLegacyAmino() *codec.LegacyAmino {\n    return app.legacyAmino\n}\n\n// AppCodec returns SimApp's app codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nAppCodec()\n\ncodec.Codec {\n    return app.appCodec\n}\n\n// InterfaceRegistry returns SimApp's InterfaceRegistry\nfunc (app *SimApp)\n\nInterfaceRegistry()\n\ntypes.InterfaceRegistry {\n    return app.interfaceRegistry\n}\n\n// TxConfig returns SimApp's TxConfig\nfunc (app *SimApp)\n\nTxConfig()\n\nclient.TxConfig {\n    return app.txConfig\n}\n\n// AutoCliOpts returns the autocli options for the app.\nfunc (app *SimApp)\n\nAutoCliOpts()\n\nautocli.AppOptions {\n    modules := make(map[string]appmodule.AppModule, 0)\n    for _, m := range app.ModuleManager.Modules {\n    if moduleWithName, ok := m.(module.HasName); ok {\n    moduleName := moduleWithName.Name()\n    if appModule, ok := moduleWithName.(appmodule.AppModule); ok {\n    modules[moduleName] = appModule\n}\n\t\n}\n\t\n}\n\nreturn autocli.AppOptions{\n    Modules:               modules,\n    ModuleOptions:         runtimeservices.ExtractAutoCLIOptions(app.ModuleManager.Modules),\n    AddressCodec:          authcodec.NewBech32Codec(sdk.GetConfig().GetBech32AccountAddrPrefix()),\n    ValidatorAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()),\n    ConsensusAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()),\n}\n}\n\n// DefaultGenesis returns a default genesis from the registered AppModuleBasic's.\nfunc (a *SimApp)\n\nDefaultGenesis()\n\nmap[string]json.RawMessage {\n    return a.BasicModuleManager.DefaultGenesis(a.appCodec)\n}\n\n// GetKey returns the KVStoreKey for the provided store key.\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc (app *SimApp)\n\nGetKey(storeKey string) *storetypes.KVStoreKey {\n    return app.keys[storeKey]\n}\n\n// GetStoreKeys returns all the stored store keys.\nfunc (app *SimApp)\n\nGetStoreKeys() []storetypes.StoreKey {\n    keys := make([]storetypes.StoreKey, 0, len(app.keys))\n    for _, key := range app.keys {\n    keys = append(keys, key)\n}\n\nreturn keys\n}\n\n// SimulationManager implements the SimulationApp interface\nfunc (app *SimApp)\n\nSimulationManager() *module.SimulationManager {\n    return app.sm\n}\n\n// RegisterAPIRoutes registers all application module routes with the provided\n// API server.\nfunc (app *SimApp)\n\nRegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {\n    clientCtx := apiSvr.ClientCtx\n\t// Register new tx routes from grpc-gateway.\n\tauthtx.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register new CometBFT queries routes from grpc-gateway.\n\tcmtservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register node gRPC service for grpc-gateway.\n\tnodeservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register grpc-gateway routes for all modules.\n\tapp.BasicModuleManager.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// register swagger API from root so that other applications can override easily\n    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {\n    panic(err)\n}\n}\n\n// RegisterTxService implements the Application.RegisterTxService method.\nfunc (app *SimApp)\n\nRegisterTxService(clientCtx client.Context) {\n    authtx.RegisterTxService(app.BaseApp.GRPCQueryRouter(), clientCtx, app.BaseApp.Simulate, app.interfaceRegistry)\n}\n\n// RegisterTendermintService implements the Application.RegisterTendermintService method.\nfunc (app *SimApp)\n\nRegisterTendermintService(clientCtx client.Context) {\n    cmtApp := server.NewCometABCIWrapper(app)\n\ncmtservice.RegisterTendermintService(\n\t\tclientCtx,\n\t\tapp.BaseApp.GRPCQueryRouter(),\n\t\tapp.interfaceRegistry,\n\t\tcmtApp.Query,\n\t)\n}\n\nfunc (app *SimApp)\n\nRegisterNodeService(clientCtx client.Context, cfg config.Config) {\n    nodeservice.RegisterNodeService(clientCtx, app.GRPCQueryRouter(), cfg)\n}\n\n// GetMaccPerms returns a copy of the module account permissions\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc GetMaccPerms()\n\nmap[string][]string {\n    return maps.Clone(maccPerms)\n}\n\n// BlockedAddresses returns all the app's blocked account addresses.\nfunc BlockedAddresses()\n\nmap[string]bool {\n    modAccAddrs := make(map[string]bool)\n    for acc := range GetMaccPerms() {\n    modAccAddrs[authtypes.NewModuleAddress(acc).String()] = true\n}\n\n\t// allow the following addresses to receive funds\n\tdelete(modAccAddrs, authtypes.NewModuleAddress(govtypes.ModuleName).String())\n\nreturn modAccAddrs\n}\nSee all 1010 lines\n\u200b\nInitChainer\nThe InitChainer is a function that initializes the state of the application from a genesis file (i.e. token balances of genesis accounts). It is called when the application receives the InitChain message from the CometBFT engine, which happens when the node is started at appBlockHeight == 0 (i.e. on genesis). The application must set the InitChainer in its constructor via the SetInitChainer method.\nIn general, the InitChainer is mostly composed of the InitGenesis function of each of the application\u2019s modules. This is done by calling the InitGenesis function of the module manager, which in turn calls the InitGenesis function of each of the modules it contains. Note that the order in which the modules\u2019 InitGenesis functions must be called has to be set in the module manager using the module manager\u2019s SetOrderInitGenesis method. This is done in the application\u2019s constructor, and the SetOrderInitGenesis has to be called before the SetInitChainer.\nSee an example of an InitChainer from simapp:\n\nCopy\n\nAsk AI\n//go:build app_v1\n\npackage simapp\n\nimport (\n    \n\t\"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"maps\"\n\n\tabci \"github.com/cometbft/cometbft/abci/types\"\n\tdbm \"github.com/cosmos/cosmos-db\"\n    \"github.com/cosmos/gogoproto/proto\"\n    \"github.com/spf13/cast\"\n\n\tautocliv1 \"cosmossdk.io/api/cosmos/autocli/v1\"\n\treflectionv1 \"cosmossdk.io/api/cosmos/reflection/v1\"\n    \"cosmossdk.io/client/v2/autocli\"\n\tclienthelpers \"cosmossdk.io/client/v2/helpers\"\n    \"cosmossdk.io/core/appmodule\"\n    \"cosmossdk.io/log\"\n\tstoretypes \"cosmossdk.io/store/types\"\n    \"cosmossdk.io/x/circuit\"\n\tcircuitkeeper \"cosmossdk.io/x/circuit/keeper\"\n\tcircuittypes \"cosmossdk.io/x/circuit/types\"\n    \"cosmossdk.io/x/evidence\"\n\tevidencekeeper \"cosmossdk.io/x/evidence/keeper\"\n\tevidencetypes \"cosmossdk.io/x/evidence/types\"\n    \"cosmossdk.io/x/feegrant\"\n\tfeegrantkeeper \"cosmossdk.io/x/feegrant/keeper\"\n\tfeegrantmodule \"cosmossdk.io/x/feegrant/module\"\n    \"cosmossdk.io/x/nft\"\n\tnftkeeper \"cosmossdk.io/x/nft/keeper\"\n\tnftmodule \"cosmossdk.io/x/nft/module\"\n    \"cosmossdk.io/x/tx/signing\"\n    \"cosmossdk.io/x/upgrade\"\n\tupgradekeeper \"cosmossdk.io/x/upgrade/keeper\"\n\tupgradetypes \"cosmossdk.io/x/upgrade/types\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/client/flags\"\n    \"github.com/cosmos/cosmos-sdk/client/grpc/cmtservice\"\n\tnodeservice \"github.com/cosmos/cosmos-sdk/client/grpc/node\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/address\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n    \"github.com/cosmos/cosmos-sdk/runtime\"\n\truntimeservices \"github.com/cosmos/cosmos-sdk/runtime/services\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n    \"github.com/cosmos/cosmos-sdk/std\"\n\ttestdata_pulsar \"github.com/cosmos/cosmos-sdk/testutil/testdata/testpb\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n    \"github.com/cosmos/cosmos-sdk/types/module\"\n\tsigtypes \"github.com/cosmos/cosmos-sdk/types/tx/signing\"\n    \"github.com/cosmos/cosmos-sdk/version\"\n    \"github.com/cosmos/cosmos-sdk/x/auth\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/ante\"\n\tauthcodec \"github.com/cosmos/cosmos-sdk/x/auth/codec\"\n\tauthkeeper \"github.com/cosmos/cosmos-sdk/x/auth/keeper\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/posthandler\"\n\tauthsims \"github.com/cosmos/cosmos-sdk/x/auth/simulation\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\ttxmodule \"github.com/cosmos/cosmos-sdk/x/auth/tx/config\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/vesting\"\n\tvestingtypes \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n    \"github.com/cosmos/cosmos-sdk/x/authz\"\n\tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n\tauthzmodule \"github.com/cosmos/cosmos-sdk/x/authz/module\"\n    \"github.com/cosmos/cosmos-sdk/x/bank\"\n\tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n\tconsensus \"github.com/cosmos/cosmos-sdk/x/consensus\"\n\tconsensusparamkeeper \"github.com/cosmos/cosmos-sdk/x/consensus/keeper\"\n\tconsensusparamtypes \"github.com/cosmos/cosmos-sdk/x/consensus/types\"\n\tdistr \"github.com/cosmos/cosmos-sdk/x/distribution\"\n\tdistrkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n\tdistrtypes \"github.com/cosmos/cosmos-sdk/x/distribution/types\"\n    \"github.com/cosmos/cosmos-sdk/x/epochs\"\n\tepochskeeper \"github.com/cosmos/cosmos-sdk/x/epochs/keeper\"\n\tepochstypes \"github.com/cosmos/cosmos-sdk/x/epochs/types\"\n    \"github.com/cosmos/cosmos-sdk/x/genutil\"\n\tgenutiltypes \"github.com/cosmos/cosmos-sdk/x/genutil/types\"\n    \"github.com/cosmos/cosmos-sdk/x/gov\"\n\tgovclient \"github.com/cosmos/cosmos-sdk/x/gov/client\"\n\tgovkeeper \"github.com/cosmos/cosmos-sdk/x/gov/keeper\"\n\tgovtypes \"github.com/cosmos/cosmos-sdk/x/gov/types\"\n\tgovv1beta1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1\"\n    \"github.com/cosmos/cosmos-sdk/x/group\"\n\tgroupkeeper \"github.com/cosmos/cosmos-sdk/x/group/keeper\"\n\tgroupmodule \"github.com/cosmos/cosmos-sdk/x/group/module\"\n    \"github.com/cosmos/cosmos-sdk/x/mint\"\n\tmintkeeper \"github.com/cosmos/cosmos-sdk/x/mint/keeper\"\n\tminttypes \"github.com/cosmos/cosmos-sdk/x/mint/types\"\n    \"github.com/cosmos/cosmos-sdk/x/protocolpool\"\n\tprotocolpoolkeeper \"github.com/cosmos/cosmos-sdk/x/protocolpool/keeper\"\n\tprotocolpooltypes \"github.com/cosmos/cosmos-sdk/x/protocolpool/types\"\n    \"github.com/cosmos/cosmos-sdk/x/slashing\"\n\tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n\tslashingtypes \"github.com/cosmos/cosmos-sdk/x/slashing/types\"\n    \"github.com/cosmos/cosmos-sdk/x/staking\"\n\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n)\n\nconst appName = \"SimApp\"\n\nvar (\n\t// DefaultNodeHome default home directories for the application daemon\n\tDefaultNodeHome string\n\n\t// module account permissions\n\tmaccPerms = map[string][]string{\n    authtypes.FeeCollectorName:                  nil,\n\t\tdistrtypes.ModuleName:                       nil,\n\t\tminttypes.ModuleName:                        {\n    authtypes.Minter\n},\n\t\tstakingtypes.BondedPoolName:                 {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tstakingtypes.NotBondedPoolName:              {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tgovtypes.ModuleName:                         {\n    authtypes.Burner\n},\n\t\tnft.ModuleName:                              nil,\n\t\tprotocolpooltypes.ModuleName:                nil,\n\t\tprotocolpooltypes.ProtocolPoolEscrowAccount: nil\n}\n)\n\nvar (\n\t_ runtime.AppI            = (*SimApp)(nil)\n\t_ servertypes.Application = (*SimApp)(nil)\n)\n\n// SimApp extends an ABCI application, but with most of its parameters exported.\n// They are exported for convenience in creating helper functions, as object\n// capabilities aren't needed for testing.\ntype SimApp struct {\n\t*baseapp.BaseApp\n\tlegacyAmino       *codec.LegacyAmino\n\tappCodec          codec.Codec\n\ttxConfig          client.TxConfig\n\tinterfaceRegistry types.InterfaceRegistry\n\n\t// keys to access the substores\n\tkeys map[string]*storetypes.KVStoreKey\n\n\t// essential keepers\n\tAccountKeeper         authkeeper.AccountKeeper\n\tBankKeeper            bankkeeper.BaseKeeper\n\tStakingKeeper         *stakingkeeper.Keeper\n\tSlashingKeeper        slashingkeeper.Keeper\n\tMintKeeper            mintkeeper.Keeper\n\tDistrKeeper           distrkeeper.Keeper\n\tGovKeeper             govkeeper.Keeper\n\tUpgradeKeeper         *upgradekeeper.Keeper\n\tEvidenceKeeper        evidencekeeper.Keeper\n\tConsensusParamsKeeper consensusparamkeeper.Keeper\n\tCircuitKeeper         circuitkeeper.Keeper\n\n\t// supplementary keepers\n\tFeeGrantKeeper     feegrantkeeper.Keeper\n\tGroupKeeper        groupkeeper.Keeper\n\tAuthzKeeper        authzkeeper.Keeper\n\tNFTKeeper          nftkeeper.Keeper\n\tEpochsKeeper       epochskeeper.Keeper\n\tProtocolPoolKeeper protocolpoolkeeper.Keeper\n\n\t// the module manager\n\tModuleManager      *module.Manager\n\tBasicModuleManager module.BasicManager\n\n\t// simulation manager\n\tsm *module.SimulationManager\n\n\t// module configurator\n\tconfigurator module.Configurator\n}\n\nfunc init() {\n    var err error\n\tDefaultNodeHome, err = clienthelpers.GetNodeHomeDirectory(\".simapp\")\n    if err != nil {\n    panic(err)\n}\n}\n\n// NewSimApp returns a reference to an initialized SimApp.\nfunc NewSimApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tloadLatest bool,\n\tappOpts servertypes.AppOptions,\n\tbaseAppOptions ...func(*baseapp.BaseApp),\n) *SimApp {\n    interfaceRegistry, _ := types.NewInterfaceRegistryWithOptions(types.InterfaceRegistryOptions{\n    ProtoFiles: proto.HybridResolver,\n    SigningOptions: signing.Options{\n    AddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32AccountAddrPrefix(),\n},\n    ValidatorAddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32ValidatorAddrPrefix(),\n},\n},\n})\n    appCodec := codec.NewProtoCodec(interfaceRegistry)\n    legacyAmino := codec.NewLegacyAmino()\n    txConfig := tx.NewTxConfig(appCodec, tx.DefaultSignModes)\n    if err := interfaceRegistry.SigningContext().Validate(); err != nil {\n    panic(err)\n}\n\nstd.RegisterLegacyAminoCodec(legacyAmino)\n\nstd.RegisterInterfaces(interfaceRegistry)\n\n\t// Below we could construct and set an application specific mempool and\n\t// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are\n\t// already set in the SDK's BaseApp, this shows an example of how to override\n\t// them.\n\t//\n\t// Example:\n\t//\n\t// bApp := baseapp.NewBaseApp(...)\n\t// nonceMempool := mempool.NewSenderNonceMempool()\n\t// abciPropHandler := NewDefaultProposalHandler(nonceMempool, bApp)\n\t//\n\t// bApp.SetMempool(nonceMempool)\n\t// bApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t// bApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())\n\t//\n\t// Alternatively, you can construct BaseApp options, append those to\n\t// baseAppOptions and pass them to NewBaseApp.\n\t//\n\t// Example:\n\t//\n\t// prepareOpt = func(app *baseapp.BaseApp) {\n\t// \tabciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)\n\t// \tapp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t//\n}\n\t// baseAppOptions = append(baseAppOptions, prepareOpt)\n\n\t// create and set dummy vote extension handler\n    voteExtOp := func(bApp *baseapp.BaseApp) {\n    voteExtHandler := NewVoteExtensionHandler()\n\nvoteExtHandler.SetHandlers(bApp)\n}\n\nbaseAppOptions = append(baseAppOptions, voteExtOp, baseapp.SetOptimisticExecution())\n    bApp := baseapp.NewBaseApp(appName, logger, db, txConfig.TxDecoder(), baseAppOptions...)\n\nbApp.SetCommitMultiStoreTracer(traceStore)\n\nbApp.SetVersion(version.Version)\n\nbApp.SetInterfaceRegistry(interfaceRegistry)\n\nbApp.SetTxEncoder(txConfig.TxEncoder())\n    keys := storetypes.NewKVStoreKeys(\n\t\tauthtypes.StoreKey,\n\t\tbanktypes.StoreKey,\n\t\tstakingtypes.StoreKey,\n\t\tminttypes.StoreKey,\n\t\tdistrtypes.StoreKey,\n\t\tslashingtypes.StoreKey,\n\t\tgovtypes.StoreKey,\n\t\tconsensusparamtypes.StoreKey,\n\t\tupgradetypes.StoreKey,\n\t\tfeegrant.StoreKey,\n\t\tevidencetypes.StoreKey,\n\t\tcircuittypes.StoreKey,\n\t\tauthzkeeper.StoreKey,\n\t\tnftkeeper.StoreKey,\n\t\tgroup.StoreKey,\n\t\tepochstypes.StoreKey,\n\t\tprotocolpooltypes.StoreKey,\n\t)\n\n\t// register streaming services\n    if err := bApp.RegisterStreamingServices(appOpts, keys); err != nil {\n    panic(err)\n}\n    app := &SimApp{\n    BaseApp:           bApp,\n\t\tlegacyAmino:       legacyAmino,\n\t\tappCodec:          appCodec,\n\t\ttxConfig:          txConfig,\n\t\tinterfaceRegistry: interfaceRegistry,\n\t\tkeys:              keys,\n}\n\n\t// set the BaseApp's parameter store\n\tapp.ConsensusParamsKeeper = consensusparamkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[consensusparamtypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\truntime.EventService{\n},\n\t)\n\nbApp.SetParamStore(app.ConsensusParamsKeeper.ParamsStore)\n\n\t// add keepers\n\tapp.AccountKeeper = authkeeper.NewAccountKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[authtypes.StoreKey]),\n\t\tauthtypes.ProtoBaseAccount,\n\t\tmaccPerms,\n\t\tauthcodec.NewBech32Codec(sdk.Bech32MainPrefix),\n\t\tsdk.Bech32MainPrefix,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthkeeper.WithUnorderedTransactions(true),\n\t)\n\napp.BankKeeper = bankkeeper.NewBaseKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[banktypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tBlockedAddresses(),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tlogger,\n\t)\n\n\t// optional: enable sign mode textual by overwriting the default tx config (after setting the bank keeper)\n    enabledSignModes := append(tx.DefaultSignModes, sigtypes.SignMode_SIGN_MODE_TEXTUAL)\n    txConfigOpts := tx.ConfigOptions{\n    EnabledSignModes:           enabledSignModes,\n    TextualCoinMetadataQueryFn: txmodule.NewBankKeeperCoinMetadataQueryFn(app.BankKeeper),\n}\n\ntxConfig, err := tx.NewTxConfigWithOptions(\n\t\tappCodec,\n\t\ttxConfigOpts,\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.txConfig = txConfig\n\n\tapp.StakingKeeper = stakingkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[stakingtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixValAddr),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixConsAddr),\n\t)\n\napp.MintKeeper = mintkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[minttypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// mintkeeper.WithMintFn(mintkeeper.DefaultMintFn(minttypes.DefaultInflationCalculationFn)), custom mintFn can be added here\n\t)\n\napp.ProtocolPoolKeeper = protocolpoolkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[protocolpooltypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.DistrKeeper = distrkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[distrtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tdistrkeeper.WithExternalCommunityPool(app.ProtocolPoolKeeper),\n\t)\n\napp.SlashingKeeper = slashingkeeper.NewKeeper(\n\t\tappCodec,\n\t\tlegacyAmino,\n\t\truntime.NewKVStoreService(keys[slashingtypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.FeeGrantKeeper = feegrantkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[feegrant.StoreKey]),\n\t\tapp.AccountKeeper,\n\t)\n\n\t// register the staking hooks\n\t// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks\n\tapp.StakingKeeper.SetHooks(\n\t\tstakingtypes.NewMultiStakingHooks(\n\t\t\tapp.DistrKeeper.Hooks(),\n\t\t\tapp.SlashingKeeper.Hooks(),\n\t\t),\n\t)\n\napp.CircuitKeeper = circuitkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[circuittypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tapp.AccountKeeper.AddressCodec(),\n\t)\n\napp.BaseApp.SetCircuitBreaker(&app.CircuitKeeper)\n\napp.AuthzKeeper = authzkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[authzkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t)\n    groupConfig := group.DefaultConfig()\n\t/*\n\t\tExample of setting group params:\n\t\tgroupConfig.MaxMetadataLen = 1000\n\t*/\n\tapp.GroupKeeper = groupkeeper.NewKeeper(\n\t\tkeys[group.StoreKey],\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t\tgroupConfig,\n\t)\n\n\t// get skipUpgradeHeights from the app options\n    skipUpgradeHeights := map[int64]bool{\n}\n    for _, h := range cast.ToIntSlice(appOpts.Get(server.FlagUnsafeSkipUpgrades)) {\n    skipUpgradeHeights[int64(h)] = true\n}\n    homePath := cast.ToString(appOpts.Get(flags.FlagHome))\n\t// set the governance module account as the authority for conducting upgrades\n\tapp.UpgradeKeeper = upgradekeeper.NewKeeper(\n\t\tskipUpgradeHeights,\n\t\truntime.NewKVStoreService(keys[upgradetypes.StoreKey]),\n\t\tappCodec,\n\t\thomePath,\n\t\tapp.BaseApp,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\n\t// Register the proposal types\n\t// Deprecated: Avoid adding new handlers, instead use the new proposal flow\n\t// by granting the governance module the right to execute the message.\n\t// See: https://docs.cosmos.network/main/modules/gov#proposal-messages\n    govRouter := govv1beta1.NewRouter()\n\ngovRouter.AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler)\n    govConfig := govtypes.DefaultConfig()\n\t/*\n\t\tExample of setting gov params:\n\t\tgovConfig.MaxMetadataLen = 10000\n\t*/\n    govKeeper := govkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[govtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tapp.DistrKeeper,\n\t\tapp.MsgServiceRouter(),\n\t\tgovConfig,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// govkeeper.WithCustomCalculateVoteResultsAndVotingPowerFn(...), // Add if you want to use a custom vote calculation function.\n\t)\n\n\t// Set legacy router for backwards compatibility with gov v1beta1\n\tgovKeeper.SetLegacyRouter(govRouter)\n\napp.GovKeeper = *govKeeper.SetHooks(\n\t\tgovtypes.NewMultiGovHooks(\n\t\t\t// register the governance hooks\n\t\t),\n\t)\n\napp.NFTKeeper = nftkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[nftkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t)\n\n\t// create evidence keeper with router\n    evidenceKeeper := evidencekeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[evidencetypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.SlashingKeeper,\n\t\tapp.AccountKeeper.AddressCodec(),\n\t\truntime.ProvideCometInfoService(),\n\t)\n\t// If evidence needs to be handled for the app, set routes in router here and seal\n\tapp.EvidenceKeeper = *evidenceKeeper\n\n\tapp.EpochsKeeper = epochskeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[epochstypes.StoreKey]),\n\t\tappCodec,\n\t)\n\napp.EpochsKeeper.SetHooks(\n\t\tepochstypes.NewMultiEpochHooks(\n\t\t\t// insert epoch hooks receivers here\n\t\t),\n\t)\n\n\t/****  Module Options ****/\n\n\t// NOTE: Any module instantiated in the module manager that is later modified\n\t// must be passed by reference here.\n\tapp.ModuleManager = module.NewManager(\n\t\tgenutil.NewAppModule(\n\t\t\tapp.AccountKeeper, app.StakingKeeper, app,\n\t\t\ttxConfig,\n\t\t),\n\t\tauth.NewAppModule(appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n\t\tvesting.NewAppModule(app.AccountKeeper, app.BankKeeper),\n\t\tbank.NewAppModule(appCodec, app.BankKeeper, app.AccountKeeper, nil),\n\t\tfeegrantmodule.NewAppModule(appCodec, app.AccountKeeper, app.BankKeeper, app.FeeGrantKeeper, app.interfaceRegistry),\n\t\tgov.NewAppModule(appCodec, &app.GovKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tmint.NewAppModule(appCodec, app.MintKeeper, app.AccountKeeper, nil, nil),\n\t\tslashing.NewAppModule(appCodec, app.SlashingKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil, app.interfaceRegistry),\n\t\tdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil),\n\t\tstaking.NewAppModule(appCodec, app.StakingKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tupgrade.NewAppModule(app.UpgradeKeeper, app.AccountKeeper.AddressCodec()),\n\t\tevidence.NewAppModule(app.EvidenceKeeper),\n\t\tauthzmodule.NewAppModule(appCodec, app.AuthzKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tgroupmodule.NewAppModule(appCodec, app.GroupKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tnftmodule.NewAppModule(appCodec, app.NFTKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tconsensus.NewAppModule(appCodec, app.ConsensusParamsKeeper),\n\t\tcircuit.NewAppModule(appCodec, app.CircuitKeeper),\n\t\tepochs.NewAppModule(app.EpochsKeeper),\n\t\tprotocolpool.NewAppModule(app.ProtocolPoolKeeper, app.AccountKeeper, app.BankKeeper),\n\t)\n\n\t// BasicModuleManager defines the module BasicManager is in charge of setting up basic,\n\t// non-dependant module elements, such as codec registration and genesis verification.\n\t// By default it is composed of all the module from the module manager.\n\t// Additionally, app module basics can be overwritten by passing them as argument.\n\tapp.BasicModuleManager = module.NewBasicManagerFromManager(\n\t\tapp.ModuleManager,\n\t\tmap[string]module.AppModuleBasic{\n    genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),\n\t\t\tgovtypes.ModuleName: gov.NewAppModuleBasic(\n\t\t\t\t[]govclient.ProposalHandler{\n},\n\t\t\t),\n})\n\napp.BasicModuleManager.RegisterLegacyAminoCodec(legacyAmino)\n\napp.BasicModuleManager.RegisterInterfaces(interfaceRegistry)\n\n\t// NOTE: upgrade module is required to be prioritized\n\tapp.ModuleManager.SetOrderPreBlockers(\n\t\tupgradetypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t)\n\t// During begin block slashing happens after distr.BeginBlocker so that\n\t// there is nothing left over in the validator fee pool, so as to keep the\n\t// CanWithdrawInvariant invariant.\n\t// NOTE: staking module is required if HistoricalEntries param > 0\n\tapp.ModuleManager.SetOrderBeginBlockers(\n\t\tminttypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tepochstypes.ModuleName,\n\t)\n\napp.ModuleManager.SetOrderEndBlockers(\n\t\tgovtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tgroup.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t)\n\n\t// NOTE: The genutils module must occur after staking so that pools are\n\t// properly initialized with tokens from genesis accounts.\n\t// NOTE: The genutils module must also occur after auth so that it can access the params from auth.\n    genesisModuleOrder := []string{\n    authtypes.ModuleName,\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tconsensusparamtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n}\n    exportModuleOrder := []string{\n    consensusparamtypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName, // Must be exported before bank\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n}\n\napp.ModuleManager.SetOrderInitGenesis(genesisModuleOrder...)\n\napp.ModuleManager.SetOrderExportGenesis(exportModuleOrder...)\n\n\t// Uncomment if you want to set a custom migration order here.\n\t// app.ModuleManager.SetOrderMigrations(custom order)\n\napp.configurator = module.NewConfigurator(app.appCodec, app.MsgServiceRouter(), app.GRPCQueryRouter())\n\nerr = app.ModuleManager.RegisterServices(app.configurator)\n    if err != nil {\n    panic(err)\n}\n\n\t// RegisterUpgradeHandlers is used for registering any on-chain upgrades.\n\t// Make sure it's called after `app.ModuleManager` and `app.configurator` are set.\n\tapp.RegisterUpgradeHandlers()\n\nautocliv1.RegisterQueryServer(app.GRPCQueryRouter(), runtimeservices.NewAutoCLIQueryService(app.ModuleManager.Modules))\n\nreflectionSvc, err := runtimeservices.NewReflectionService()\n    if err != nil {\n    panic(err)\n}\n\nreflectionv1.RegisterReflectionServiceServer(app.GRPCQueryRouter(), reflectionSvc)\n\n\t// add test gRPC service for testing gRPC queries in isolation\n\ttestdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{\n})\n\n\t// create the simulation manager and define the order of the modules for deterministic simulations\n\t//\n\t// NOTE: this is not required apps that don't use the simulator for fuzz testing\n\t// transactions\n    overrideModules := map[string]module.AppModuleSimulation{\n    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n}\n\napp.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)\n\napp.sm.RegisterStoreDecoders()\n\n\t// initialize stores\n\tapp.MountKVStores(keys)\n\n\t// initialize BaseApp\n\tapp.SetInitChainer(app.InitChainer)\n\napp.SetPreBlocker(app.PreBlocker)\n\napp.SetBeginBlocker(app.BeginBlocker)\n\napp.SetEndBlocker(app.EndBlocker)\n\napp.setAnteHandler(txConfig)\n\n\t// In v0.46, the SDK introduces _postHandlers_. PostHandlers are like\n\t// antehandlers, but are run _after_ the `runMsgs` execution. They are also\n\t// defined as a chain, and have the same signature as antehandlers.\n\t//\n\t// In baseapp, postHandlers are run in the same store branch as `runMsgs`,\n\t// meaning that both `runMsgs` and `postHandler` state will be committed if\n\t// both are successful, and both will be reverted if any of the two fails.\n\t//\n\t// The SDK exposes a default postHandlers chain\n\t//\n\t// Please note that changing any of the anteHandler or postHandler chain is\n\t// likely to be a state-machine breaking change, which needs a coordinated\n\t// upgrade.\n\tapp.setPostHandler()\n    if loadLatest {\n    if err := app.LoadLatestVersion(); err != nil {\n    panic(fmt.Errorf(\"error loading last version: %w\", err))\n}\n\t\n}\n\nreturn app\n}\n\nfunc (app *SimApp)\n\nsetAnteHandler(txConfig client.TxConfig) {\n    anteHandler, err := NewAnteHandler(\n\t\tHandlerOptions{\n    ante.HandlerOptions{\n    AccountKeeper:   app.AccountKeeper,\n    BankKeeper:      app.BankKeeper,\n    SignModeHandler: txConfig.SignModeHandler(),\n    FeegrantKeeper:  app.FeeGrantKeeper,\n    SigGasConsumer:  ante.DefaultSigVerificationGasConsumer,\n    SigVerifyOptions: []ante.SigVerificationDecoratorOption{\n\t\t\t\t\t// change below as needed.\n\t\t\t\t\tante.WithUnorderedTxGasCost(ante.DefaultUnorderedTxGasCost),\n\t\t\t\t\tante.WithMaxUnorderedTxTimeoutDuration(ante.DefaultMaxTimeoutDuration),\n},\n},\n\t\t\t&app.CircuitKeeper,\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\n\t// Set the AnteHandler for the app\n\tapp.SetAnteHandler(anteHandler)\n}\n\nfunc (app *SimApp)\n\nsetPostHandler() {\n    postHandler, err := posthandler.NewPostHandler(\n\t\tposthandler.HandlerOptions{\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.SetPostHandler(postHandler)\n}\n\n// Name returns the name of the App\nfunc (app *SimApp)\n\nName()\n\nstring {\n    return app.BaseApp.Name()\n}\n\n// PreBlocker application updates every pre block\nfunc (app *SimApp)\n\nPreBlocker(ctx sdk.Context, _ *abci.RequestFinalizeBlock) (*sdk.ResponsePreBlock, error) {\n    return app.ModuleManager.PreBlock(ctx)\n}\n\n// BeginBlocker application updates every begin block\nfunc (app *SimApp)\n\nBeginBlocker(ctx sdk.Context) (sdk.BeginBlock, error) {\n    return app.ModuleManager.BeginBlock(ctx)\n}\n\n// EndBlocker application updates every end block\nfunc (app *SimApp)\n\nEndBlocker(ctx sdk.Context) (sdk.EndBlock, error) {\n    return app.ModuleManager.EndBlock(ctx)\n}\n\nfunc (a *SimApp)\n\nConfigurator()\n\nmodule.Configurator {\n    return a.configurator\n}\n\n// InitChainer application update at chain initialization\nfunc (app *SimApp)\n\nInitChainer(ctx sdk.Context, req *abci.RequestInitChain) (*abci.ResponseInitChain, error) {\n    var genesisState GenesisState\n    if err := json.Unmarshal(req.AppStateBytes, &genesisState); err != nil {\n    panic(err)\n}\n\napp.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())\n\nreturn app.ModuleManager.InitGenesis(ctx, app.appCodec, genesisState)\n}\n\n// LoadHeight loads a particular height\nfunc (app *SimApp)\n\nLoadHeight(height int64)\n\nerror {\n    return app.LoadVersion(height)\n}\n\n// LegacyAmino returns SimApp's amino codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nLegacyAmino() *codec.LegacyAmino {\n    return app.legacyAmino\n}\n\n// AppCodec returns SimApp's app codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nAppCodec()\n\ncodec.Codec {\n    return app.appCodec\n}\n\n// InterfaceRegistry returns SimApp's InterfaceRegistry\nfunc (app *SimApp)\n\nInterfaceRegistry()\n\ntypes.InterfaceRegistry {\n    return app.interfaceRegistry\n}\n\n// TxConfig returns SimApp's TxConfig\nfunc (app *SimApp)\n\nTxConfig()\n\nclient.TxConfig {\n    return app.txConfig\n}\n\n// AutoCliOpts returns the autocli options for the app.\nfunc (app *SimApp)\n\nAutoCliOpts()\n\nautocli.AppOptions {\n    modules := make(map[string]appmodule.AppModule, 0)\n    for _, m := range app.ModuleManager.Modules {\n    if moduleWithName, ok := m.(module.HasName); ok {\n    moduleName := moduleWithName.Name()\n    if appModule, ok := moduleWithName.(appmodule.AppModule); ok {\n    modules[moduleName] = appModule\n}\n\t\n}\n\t\n}\n\nreturn autocli.AppOptions{\n    Modules:               modules,\n    ModuleOptions:         runtimeservices.ExtractAutoCLIOptions(app.ModuleManager.Modules),\n    AddressCodec:          authcodec.NewBech32Codec(sdk.GetConfig().GetBech32AccountAddrPrefix()),\n    ValidatorAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()),\n    ConsensusAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()),\n}\n}\n\n// DefaultGenesis returns a default genesis from the registered AppModuleBasic's.\nfunc (a *SimApp)\n\nDefaultGenesis()\n\nmap[string]json.RawMessage {\n    return a.BasicModuleManager.DefaultGenesis(a.appCodec)\n}\n\n// GetKey returns the KVStoreKey for the provided store key.\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc (app *SimApp)\n\nGetKey(storeKey string) *storetypes.KVStoreKey {\n    return app.keys[storeKey]\n}\n\n// GetStoreKeys returns all the stored store keys.\nfunc (app *SimApp)\n\nGetStoreKeys() []storetypes.StoreKey {\n    keys := make([]storetypes.StoreKey, 0, len(app.keys))\n    for _, key := range app.keys {\n    keys = append(keys, key)\n}\n\nreturn keys\n}\n\n// SimulationManager implements the SimulationApp interface\nfunc (app *SimApp)\n\nSimulationManager() *module.SimulationManager {\n    return app.sm\n}\n\n// RegisterAPIRoutes registers all application module routes with the provided\n// API server.\nfunc (app *SimApp)\n\nRegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {\n    clientCtx := apiSvr.ClientCtx\n\t// Register new tx routes from grpc-gateway.\n\tauthtx.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register new CometBFT queries routes from grpc-gateway.\n\tcmtservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register node gRPC service for grpc-gateway.\n\tnodeservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register grpc-gateway routes for all modules.\n\tapp.BasicModuleManager.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// register swagger API from root so that other applications can override easily\n    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {\n    panic(err)\n}\n}\n\n// RegisterTxService implements the Application.RegisterTxService method.\nfunc (app *SimApp)\n\nRegisterTxService(clientCtx client.Context) {\n    authtx.RegisterTxService(app.BaseApp.GRPCQueryRouter(), clientCtx, app.BaseApp.Simulate, app.interfaceRegistry)\n}\n\n// RegisterTendermintService implements the Application.RegisterTendermintService method.\nfunc (app *SimApp)\n\nRegisterTendermintService(clientCtx client.Context) {\n    cmtApp := server.NewCometABCIWrapper(app)\n\ncmtservice.RegisterTendermintService(\n\t\tclientCtx,\n\t\tapp.BaseApp.GRPCQueryRouter(),\n\t\tapp.interfaceRegistry,\n\t\tcmtApp.Query,\n\t)\n}\n\nfunc (app *SimApp)\n\nRegisterNodeService(clientCtx client.Context, cfg config.Config) {\n    nodeservice.RegisterNodeService(clientCtx, app.GRPCQueryRouter(), cfg)\n}\n\n// GetMaccPerms returns a copy of the module account permissions\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc GetMaccPerms()\n\nmap[string][]string {\n    return maps.Clone(maccPerms)\n}\n\n// BlockedAddresses returns all the app's blocked account addresses.\nfunc BlockedAddresses()\n\nmap[string]bool {\n    modAccAddrs := make(map[string]bool)\n    for acc := range GetMaccPerms() {\n    modAccAddrs[authtypes.NewModuleAddress(acc).String()] = true\n}\n\n\t// allow the following addresses to receive funds\n\tdelete(modAccAddrs, authtypes.NewModuleAddress(govtypes.ModuleName).String())\n\nreturn modAccAddrs\n}\nSee all 1010 lines\n\u200b\nPreBlocker\nThere are two semantics around the new lifecycle method:\nIt runs before the BeginBlocker of all modules\nIt can modify consensus parameters in storage, and signal the caller through the return value.\nWhen it returns ConsensusParamsChanged=true, the caller must refresh the consensus parameter in the finalize context:\n\nCopy\n\nAsk AI\napp.finalizeBlockState.ctx = app.finalizeBlockState.ctx.WithConsensusParams(app.GetConsensusParams())\nThe new ctx must be passed to all the other lifecycle methods.\n\u200b\nBeginBlocker and EndBlocker\nThe Cosmos SDK offers developers the possibility to implement automatic execution of code as part of their application. This is implemented through two functions called BeginBlocker and EndBlocker. They are called when the application receives the FinalizeBlock messages from the CometBFT consensus engine, which happens respectively at the beginning and at the end of each block. The application must set the BeginBlocker and EndBlocker in its constructor via the SetBeginBlocker and SetEndBlocker methods.\nIn general, the BeginBlocker and EndBlocker functions are mostly composed of the BeginBlock and EndBlock functions of each of the application\u2019s modules. This is done by calling the BeginBlock and EndBlock functions of the module manager, which in turn calls the BeginBlock and EndBlock functions of each of the modules it contains. Note that the order in which the modules\u2019 BeginBlock and EndBlock functions must be called has to be set in the module manager using the SetOrderBeginBlockers and SetOrderEndBlockers methods, respectively. This is done via the module manager in the application\u2019s constructor, and the SetOrderBeginBlockers and SetOrderEndBlockers methods have to be called before the SetBeginBlocker and SetEndBlocker functions.\nAs a sidenote, it is important to remember that application-specific blockchains are deterministic. Developers must be careful not to introduce non-determinism in BeginBlocker or EndBlocker, and must also be careful not to make them too computationally expensive, as gas does not constrain the cost of BeginBlocker and EndBlocker execution.\nSee an example of BeginBlocker and EndBlocker functions from simapp\n\nCopy\n\nAsk AI\n//go:build app_v1\n\npackage simapp\n\nimport (\n    \n\t\"encoding/json\"\n    \"fmt\"\n    \"io\"\n    \"maps\"\n\n\tabci \"github.com/cometbft/cometbft/abci/types\"\n\tdbm \"github.com/cosmos/cosmos-db\"\n    \"github.com/cosmos/gogoproto/proto\"\n    \"github.com/spf13/cast\"\n\n\tautocliv1 \"cosmossdk.io/api/cosmos/autocli/v1\"\n\treflectionv1 \"cosmossdk.io/api/cosmos/reflection/v1\"\n    \"cosmossdk.io/client/v2/autocli\"\n\tclienthelpers \"cosmossdk.io/client/v2/helpers\"\n    \"cosmossdk.io/core/appmodule\"\n    \"cosmossdk.io/log\"\n\tstoretypes \"cosmossdk.io/store/types\"\n    \"cosmossdk.io/x/circuit\"\n\tcircuitkeeper \"cosmossdk.io/x/circuit/keeper\"\n\tcircuittypes \"cosmossdk.io/x/circuit/types\"\n    \"cosmossdk.io/x/evidence\"\n\tevidencekeeper \"cosmossdk.io/x/evidence/keeper\"\n\tevidencetypes \"cosmossdk.io/x/evidence/types\"\n    \"cosmossdk.io/x/feegrant\"\n\tfeegrantkeeper \"cosmossdk.io/x/feegrant/keeper\"\n\tfeegrantmodule \"cosmossdk.io/x/feegrant/module\"\n    \"cosmossdk.io/x/nft\"\n\tnftkeeper \"cosmossdk.io/x/nft/keeper\"\n\tnftmodule \"cosmossdk.io/x/nft/module\"\n    \"cosmossdk.io/x/tx/signing\"\n    \"cosmossdk.io/x/upgrade\"\n\tupgradekeeper \"cosmossdk.io/x/upgrade/keeper\"\n\tupgradetypes \"cosmossdk.io/x/upgrade/types\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/client/flags\"\n    \"github.com/cosmos/cosmos-sdk/client/grpc/cmtservice\"\n\tnodeservice \"github.com/cosmos/cosmos-sdk/client/grpc/node\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/address\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n    \"github.com/cosmos/cosmos-sdk/runtime\"\n\truntimeservices \"github.com/cosmos/cosmos-sdk/runtime/services\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n    \"github.com/cosmos/cosmos-sdk/server/api\"\n    \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n    \"github.com/cosmos/cosmos-sdk/std\"\n\ttestdata_pulsar \"github.com/cosmos/cosmos-sdk/testutil/testdata/testpb\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n    \"github.com/cosmos/cosmos-sdk/types/module\"\n\tsigtypes \"github.com/cosmos/cosmos-sdk/types/tx/signing\"\n    \"github.com/cosmos/cosmos-sdk/version\"\n    \"github.com/cosmos/cosmos-sdk/x/auth\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/ante\"\n\tauthcodec \"github.com/cosmos/cosmos-sdk/x/auth/codec\"\n\tauthkeeper \"github.com/cosmos/cosmos-sdk/x/auth/keeper\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/posthandler\"\n\tauthsims \"github.com/cosmos/cosmos-sdk/x/auth/simulation\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n\ttxmodule \"github.com/cosmos/cosmos-sdk/x/auth/tx/config\"\n\tauthtypes \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/vesting\"\n\tvestingtypes \"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\"\n    \"github.com/cosmos/cosmos-sdk/x/authz\"\n\tauthzkeeper \"github.com/cosmos/cosmos-sdk/x/authz/keeper\"\n\tauthzmodule \"github.com/cosmos/cosmos-sdk/x/authz/module\"\n    \"github.com/cosmos/cosmos-sdk/x/bank\"\n\tbankkeeper \"github.com/cosmos/cosmos-sdk/x/bank/keeper\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n\tconsensus \"github.com/cosmos/cosmos-sdk/x/consensus\"\n\tconsensusparamkeeper \"github.com/cosmos/cosmos-sdk/x/consensus/keeper\"\n\tconsensusparamtypes \"github.com/cosmos/cosmos-sdk/x/consensus/types\"\n\tdistr \"github.com/cosmos/cosmos-sdk/x/distribution\"\n\tdistrkeeper \"github.com/cosmos/cosmos-sdk/x/distribution/keeper\"\n\tdistrtypes \"github.com/cosmos/cosmos-sdk/x/distribution/types\"\n    \"github.com/cosmos/cosmos-sdk/x/epochs\"\n\tepochskeeper \"github.com/cosmos/cosmos-sdk/x/epochs/keeper\"\n\tepochstypes \"github.com/cosmos/cosmos-sdk/x/epochs/types\"\n    \"github.com/cosmos/cosmos-sdk/x/genutil\"\n\tgenutiltypes \"github.com/cosmos/cosmos-sdk/x/genutil/types\"\n    \"github.com/cosmos/cosmos-sdk/x/gov\"\n\tgovclient \"github.com/cosmos/cosmos-sdk/x/gov/client\"\n\tgovkeeper \"github.com/cosmos/cosmos-sdk/x/gov/keeper\"\n\tgovtypes \"github.com/cosmos/cosmos-sdk/x/gov/types\"\n\tgovv1beta1 \"github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1\"\n    \"github.com/cosmos/cosmos-sdk/x/group\"\n\tgroupkeeper \"github.com/cosmos/cosmos-sdk/x/group/keeper\"\n\tgroupmodule \"github.com/cosmos/cosmos-sdk/x/group/module\"\n    \"github.com/cosmos/cosmos-sdk/x/mint\"\n\tmintkeeper \"github.com/cosmos/cosmos-sdk/x/mint/keeper\"\n\tminttypes \"github.com/cosmos/cosmos-sdk/x/mint/types\"\n    \"github.com/cosmos/cosmos-sdk/x/protocolpool\"\n\tprotocolpoolkeeper \"github.com/cosmos/cosmos-sdk/x/protocolpool/keeper\"\n\tprotocolpooltypes \"github.com/cosmos/cosmos-sdk/x/protocolpool/types\"\n    \"github.com/cosmos/cosmos-sdk/x/slashing\"\n\tslashingkeeper \"github.com/cosmos/cosmos-sdk/x/slashing/keeper\"\n\tslashingtypes \"github.com/cosmos/cosmos-sdk/x/slashing/types\"\n    \"github.com/cosmos/cosmos-sdk/x/staking\"\n\tstakingkeeper \"github.com/cosmos/cosmos-sdk/x/staking/keeper\"\n\tstakingtypes \"github.com/cosmos/cosmos-sdk/x/staking/types\"\n)\n\nconst appName = \"SimApp\"\n\nvar (\n\t// DefaultNodeHome default home directories for the application daemon\n\tDefaultNodeHome string\n\n\t// module account permissions\n\tmaccPerms = map[string][]string{\n    authtypes.FeeCollectorName:                  nil,\n\t\tdistrtypes.ModuleName:                       nil,\n\t\tminttypes.ModuleName:                        {\n    authtypes.Minter\n},\n\t\tstakingtypes.BondedPoolName:                 {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tstakingtypes.NotBondedPoolName:              {\n    authtypes.Burner, authtypes.Staking\n},\n\t\tgovtypes.ModuleName:                         {\n    authtypes.Burner\n},\n\t\tnft.ModuleName:                              nil,\n\t\tprotocolpooltypes.ModuleName:                nil,\n\t\tprotocolpooltypes.ProtocolPoolEscrowAccount: nil\n}\n)\n\nvar (\n\t_ runtime.AppI            = (*SimApp)(nil)\n\t_ servertypes.Application = (*SimApp)(nil)\n)\n\n// SimApp extends an ABCI application, but with most of its parameters exported.\n// They are exported for convenience in creating helper functions, as object\n// capabilities aren't needed for testing.\ntype SimApp struct {\n\t*baseapp.BaseApp\n\tlegacyAmino       *codec.LegacyAmino\n\tappCodec          codec.Codec\n\ttxConfig          client.TxConfig\n\tinterfaceRegistry types.InterfaceRegistry\n\n\t// keys to access the substores\n\tkeys map[string]*storetypes.KVStoreKey\n\n\t// essential keepers\n\tAccountKeeper         authkeeper.AccountKeeper\n\tBankKeeper            bankkeeper.BaseKeeper\n\tStakingKeeper         *stakingkeeper.Keeper\n\tSlashingKeeper        slashingkeeper.Keeper\n\tMintKeeper            mintkeeper.Keeper\n\tDistrKeeper           distrkeeper.Keeper\n\tGovKeeper             govkeeper.Keeper\n\tUpgradeKeeper         *upgradekeeper.Keeper\n\tEvidenceKeeper        evidencekeeper.Keeper\n\tConsensusParamsKeeper consensusparamkeeper.Keeper\n\tCircuitKeeper         circuitkeeper.Keeper\n\n\t// supplementary keepers\n\tFeeGrantKeeper     feegrantkeeper.Keeper\n\tGroupKeeper        groupkeeper.Keeper\n\tAuthzKeeper        authzkeeper.Keeper\n\tNFTKeeper          nftkeeper.Keeper\n\tEpochsKeeper       epochskeeper.Keeper\n\tProtocolPoolKeeper protocolpoolkeeper.Keeper\n\n\t// the module manager\n\tModuleManager      *module.Manager\n\tBasicModuleManager module.BasicManager\n\n\t// simulation manager\n\tsm *module.SimulationManager\n\n\t// module configurator\n\tconfigurator module.Configurator\n}\n\nfunc init() {\n    var err error\n\tDefaultNodeHome, err = clienthelpers.GetNodeHomeDirectory(\".simapp\")\n    if err != nil {\n    panic(err)\n}\n}\n\n// NewSimApp returns a reference to an initialized SimApp.\nfunc NewSimApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tloadLatest bool,\n\tappOpts servertypes.AppOptions,\n\tbaseAppOptions ...func(*baseapp.BaseApp),\n) *SimApp {\n    interfaceRegistry, _ := types.NewInterfaceRegistryWithOptions(types.InterfaceRegistryOptions{\n    ProtoFiles: proto.HybridResolver,\n    SigningOptions: signing.Options{\n    AddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32AccountAddrPrefix(),\n},\n    ValidatorAddressCodec: address.Bech32Codec{\n    Bech32Prefix: sdk.GetConfig().GetBech32ValidatorAddrPrefix(),\n},\n},\n})\n    appCodec := codec.NewProtoCodec(interfaceRegistry)\n    legacyAmino := codec.NewLegacyAmino()\n    txConfig := tx.NewTxConfig(appCodec, tx.DefaultSignModes)\n    if err := interfaceRegistry.SigningContext().Validate(); err != nil {\n    panic(err)\n}\n\nstd.RegisterLegacyAminoCodec(legacyAmino)\n\nstd.RegisterInterfaces(interfaceRegistry)\n\n\t// Below we could construct and set an application specific mempool and\n\t// ABCI 1.0 PrepareProposal and ProcessProposal handlers. These defaults are\n\t// already set in the SDK's BaseApp, this shows an example of how to override\n\t// them.\n\t//\n\t// Example:\n\t//\n\t// bApp := baseapp.NewBaseApp(...)\n\t// nonceMempool := mempool.NewSenderNonceMempool()\n\t// abciPropHandler := NewDefaultProposalHandler(nonceMempool, bApp)\n\t//\n\t// bApp.SetMempool(nonceMempool)\n\t// bApp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t// bApp.SetProcessProposal(abciPropHandler.ProcessProposalHandler())\n\t//\n\t// Alternatively, you can construct BaseApp options, append those to\n\t// baseAppOptions and pass them to NewBaseApp.\n\t//\n\t// Example:\n\t//\n\t// prepareOpt = func(app *baseapp.BaseApp) {\n\t// \tabciPropHandler := baseapp.NewDefaultProposalHandler(nonceMempool, app)\n\t// \tapp.SetPrepareProposal(abciPropHandler.PrepareProposalHandler())\n\t//\n}\n\t// baseAppOptions = append(baseAppOptions, prepareOpt)\n\n\t// create and set dummy vote extension handler\n    voteExtOp := func(bApp *baseapp.BaseApp) {\n    voteExtHandler := NewVoteExtensionHandler()\n\nvoteExtHandler.SetHandlers(bApp)\n}\n\nbaseAppOptions = append(baseAppOptions, voteExtOp, baseapp.SetOptimisticExecution())\n    bApp := baseapp.NewBaseApp(appName, logger, db, txConfig.TxDecoder(), baseAppOptions...)\n\nbApp.SetCommitMultiStoreTracer(traceStore)\n\nbApp.SetVersion(version.Version)\n\nbApp.SetInterfaceRegistry(interfaceRegistry)\n\nbApp.SetTxEncoder(txConfig.TxEncoder())\n    keys := storetypes.NewKVStoreKeys(\n\t\tauthtypes.StoreKey,\n\t\tbanktypes.StoreKey,\n\t\tstakingtypes.StoreKey,\n\t\tminttypes.StoreKey,\n\t\tdistrtypes.StoreKey,\n\t\tslashingtypes.StoreKey,\n\t\tgovtypes.StoreKey,\n\t\tconsensusparamtypes.StoreKey,\n\t\tupgradetypes.StoreKey,\n\t\tfeegrant.StoreKey,\n\t\tevidencetypes.StoreKey,\n\t\tcircuittypes.StoreKey,\n\t\tauthzkeeper.StoreKey,\n\t\tnftkeeper.StoreKey,\n\t\tgroup.StoreKey,\n\t\tepochstypes.StoreKey,\n\t\tprotocolpooltypes.StoreKey,\n\t)\n\n\t// register streaming services\n    if err := bApp.RegisterStreamingServices(appOpts, keys); err != nil {\n    panic(err)\n}\n    app := &SimApp{\n    BaseApp:           bApp,\n\t\tlegacyAmino:       legacyAmino,\n\t\tappCodec:          appCodec,\n\t\ttxConfig:          txConfig,\n\t\tinterfaceRegistry: interfaceRegistry,\n\t\tkeys:              keys,\n}\n\n\t// set the BaseApp's parameter store\n\tapp.ConsensusParamsKeeper = consensusparamkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[consensusparamtypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\truntime.EventService{\n},\n\t)\n\nbApp.SetParamStore(app.ConsensusParamsKeeper.ParamsStore)\n\n\t// add keepers\n\tapp.AccountKeeper = authkeeper.NewAccountKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[authtypes.StoreKey]),\n\t\tauthtypes.ProtoBaseAccount,\n\t\tmaccPerms,\n\t\tauthcodec.NewBech32Codec(sdk.Bech32MainPrefix),\n\t\tsdk.Bech32MainPrefix,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthkeeper.WithUnorderedTransactions(true),\n\t)\n\napp.BankKeeper = bankkeeper.NewBaseKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[banktypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tBlockedAddresses(),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tlogger,\n\t)\n\n\t// optional: enable sign mode textual by overwriting the default tx config (after setting the bank keeper)\n    enabledSignModes := append(tx.DefaultSignModes, sigtypes.SignMode_SIGN_MODE_TEXTUAL)\n    txConfigOpts := tx.ConfigOptions{\n    EnabledSignModes:           enabledSignModes,\n    TextualCoinMetadataQueryFn: txmodule.NewBankKeeperCoinMetadataQueryFn(app.BankKeeper),\n}\n\ntxConfig, err := tx.NewTxConfigWithOptions(\n\t\tappCodec,\n\t\ttxConfigOpts,\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.txConfig = txConfig\n\n\tapp.StakingKeeper = stakingkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[stakingtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixValAddr),\n\t\tauthcodec.NewBech32Codec(sdk.Bech32PrefixConsAddr),\n\t)\n\napp.MintKeeper = mintkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[minttypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// mintkeeper.WithMintFn(mintkeeper.DefaultMintFn(minttypes.DefaultInflationCalculationFn)), custom mintFn can be added here\n\t)\n\napp.ProtocolPoolKeeper = protocolpoolkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[protocolpooltypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.DistrKeeper = distrkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[distrtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tauthtypes.FeeCollectorName,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tdistrkeeper.WithExternalCommunityPool(app.ProtocolPoolKeeper),\n\t)\n\napp.SlashingKeeper = slashingkeeper.NewKeeper(\n\t\tappCodec,\n\t\tlegacyAmino,\n\t\truntime.NewKVStoreService(keys[slashingtypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\napp.FeeGrantKeeper = feegrantkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[feegrant.StoreKey]),\n\t\tapp.AccountKeeper,\n\t)\n\n\t// register the staking hooks\n\t// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks\n\tapp.StakingKeeper.SetHooks(\n\t\tstakingtypes.NewMultiStakingHooks(\n\t\t\tapp.DistrKeeper.Hooks(),\n\t\t\tapp.SlashingKeeper.Hooks(),\n\t\t),\n\t)\n\napp.CircuitKeeper = circuitkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[circuittypes.StoreKey]),\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\tapp.AccountKeeper.AddressCodec(),\n\t)\n\napp.BaseApp.SetCircuitBreaker(&app.CircuitKeeper)\n\napp.AuthzKeeper = authzkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[authzkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t)\n    groupConfig := group.DefaultConfig()\n\t/*\n\t\tExample of setting group params:\n\t\tgroupConfig.MaxMetadataLen = 1000\n\t*/\n\tapp.GroupKeeper = groupkeeper.NewKeeper(\n\t\tkeys[group.StoreKey],\n\t\tappCodec,\n\t\tapp.MsgServiceRouter(),\n\t\tapp.AccountKeeper,\n\t\tgroupConfig,\n\t)\n\n\t// get skipUpgradeHeights from the app options\n    skipUpgradeHeights := map[int64]bool{\n}\n    for _, h := range cast.ToIntSlice(appOpts.Get(server.FlagUnsafeSkipUpgrades)) {\n    skipUpgradeHeights[int64(h)] = true\n}\n    homePath := cast.ToString(appOpts.Get(flags.FlagHome))\n\t// set the governance module account as the authority for conducting upgrades\n\tapp.UpgradeKeeper = upgradekeeper.NewKeeper(\n\t\tskipUpgradeHeights,\n\t\truntime.NewKVStoreService(keys[upgradetypes.StoreKey]),\n\t\tappCodec,\n\t\thomePath,\n\t\tapp.BaseApp,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t)\n\n\t// Register the proposal types\n\t// Deprecated: Avoid adding new handlers, instead use the new proposal flow\n\t// by granting the governance module the right to execute the message.\n\t// See: https://docs.cosmos.network/main/modules/gov#proposal-messages\n    govRouter := govv1beta1.NewRouter()\n\ngovRouter.AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler)\n    govConfig := govtypes.DefaultConfig()\n\t/*\n\t\tExample of setting gov params:\n\t\tgovConfig.MaxMetadataLen = 10000\n\t*/\n    govKeeper := govkeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[govtypes.StoreKey]),\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t\tapp.StakingKeeper,\n\t\tapp.DistrKeeper,\n\t\tapp.MsgServiceRouter(),\n\t\tgovConfig,\n\t\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\n\t\t// govkeeper.WithCustomCalculateVoteResultsAndVotingPowerFn(...), // Add if you want to use a custom vote calculation function.\n\t)\n\n\t// Set legacy router for backwards compatibility with gov v1beta1\n\tgovKeeper.SetLegacyRouter(govRouter)\n\napp.GovKeeper = *govKeeper.SetHooks(\n\t\tgovtypes.NewMultiGovHooks(\n\t\t\t// register the governance hooks\n\t\t),\n\t)\n\napp.NFTKeeper = nftkeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[nftkeeper.StoreKey]),\n\t\tappCodec,\n\t\tapp.AccountKeeper,\n\t\tapp.BankKeeper,\n\t)\n\n\t// create evidence keeper with router\n    evidenceKeeper := evidencekeeper.NewKeeper(\n\t\tappCodec,\n\t\truntime.NewKVStoreService(keys[evidencetypes.StoreKey]),\n\t\tapp.StakingKeeper,\n\t\tapp.SlashingKeeper,\n\t\tapp.AccountKeeper.AddressCodec(),\n\t\truntime.ProvideCometInfoService(),\n\t)\n\t// If evidence needs to be handled for the app, set routes in router here and seal\n\tapp.EvidenceKeeper = *evidenceKeeper\n\n\tapp.EpochsKeeper = epochskeeper.NewKeeper(\n\t\truntime.NewKVStoreService(keys[epochstypes.StoreKey]),\n\t\tappCodec,\n\t)\n\napp.EpochsKeeper.SetHooks(\n\t\tepochstypes.NewMultiEpochHooks(\n\t\t\t// insert epoch hooks receivers here\n\t\t),\n\t)\n\n\t/****  Module Options ****/\n\n\t// NOTE: Any module instantiated in the module manager that is later modified\n\t// must be passed by reference here.\n\tapp.ModuleManager = module.NewManager(\n\t\tgenutil.NewAppModule(\n\t\t\tapp.AccountKeeper, app.StakingKeeper, app,\n\t\t\ttxConfig,\n\t\t),\n\t\tauth.NewAppModule(appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n\t\tvesting.NewAppModule(app.AccountKeeper, app.BankKeeper),\n\t\tbank.NewAppModule(appCodec, app.BankKeeper, app.AccountKeeper, nil),\n\t\tfeegrantmodule.NewAppModule(appCodec, app.AccountKeeper, app.BankKeeper, app.FeeGrantKeeper, app.interfaceRegistry),\n\t\tgov.NewAppModule(appCodec, &app.GovKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tmint.NewAppModule(appCodec, app.MintKeeper, app.AccountKeeper, nil, nil),\n\t\tslashing.NewAppModule(appCodec, app.SlashingKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil, app.interfaceRegistry),\n\t\tdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, nil),\n\t\tstaking.NewAppModule(appCodec, app.StakingKeeper, app.AccountKeeper, app.BankKeeper, nil),\n\t\tupgrade.NewAppModule(app.UpgradeKeeper, app.AccountKeeper.AddressCodec()),\n\t\tevidence.NewAppModule(app.EvidenceKeeper),\n\t\tauthzmodule.NewAppModule(appCodec, app.AuthzKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tgroupmodule.NewAppModule(appCodec, app.GroupKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tnftmodule.NewAppModule(appCodec, app.NFTKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\n\t\tconsensus.NewAppModule(appCodec, app.ConsensusParamsKeeper),\n\t\tcircuit.NewAppModule(appCodec, app.CircuitKeeper),\n\t\tepochs.NewAppModule(app.EpochsKeeper),\n\t\tprotocolpool.NewAppModule(app.ProtocolPoolKeeper, app.AccountKeeper, app.BankKeeper),\n\t)\n\n\t// BasicModuleManager defines the module BasicManager is in charge of setting up basic,\n\t// non-dependant module elements, such as codec registration and genesis verification.\n\t// By default it is composed of all the module from the module manager.\n\t// Additionally, app module basics can be overwritten by passing them as argument.\n\tapp.BasicModuleManager = module.NewBasicManagerFromManager(\n\t\tapp.ModuleManager,\n\t\tmap[string]module.AppModuleBasic{\n    genutiltypes.ModuleName: genutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),\n\t\t\tgovtypes.ModuleName: gov.NewAppModuleBasic(\n\t\t\t\t[]govclient.ProposalHandler{\n},\n\t\t\t),\n})\n\napp.BasicModuleManager.RegisterLegacyAminoCodec(legacyAmino)\n\napp.BasicModuleManager.RegisterInterfaces(interfaceRegistry)\n\n\t// NOTE: upgrade module is required to be prioritized\n\tapp.ModuleManager.SetOrderPreBlockers(\n\t\tupgradetypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t)\n\t// During begin block slashing happens after distr.BeginBlocker so that\n\t// there is nothing left over in the validator fee pool, so as to keep the\n\t// CanWithdrawInvariant invariant.\n\t// NOTE: staking module is required if HistoricalEntries param > 0\n\tapp.ModuleManager.SetOrderBeginBlockers(\n\t\tminttypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tepochstypes.ModuleName,\n\t)\n\napp.ModuleManager.SetOrderEndBlockers(\n\t\tgovtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tgroup.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n\t)\n\n\t// NOTE: The genutils module must occur after staking so that pools are\n\t// properly initialized with tokens from genesis accounts.\n\t// NOTE: The genutils module must also occur after auth so that it can access the params from auth.\n    genesisModuleOrder := []string{\n    authtypes.ModuleName,\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tconsensusparamtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName,\n}\n    exportModuleOrder := []string{\n    consensusparamtypes.ModuleName,\n\t\tauthtypes.ModuleName,\n\t\tprotocolpooltypes.ModuleName, // Must be exported before bank\n\t\tbanktypes.ModuleName,\n\t\tdistrtypes.ModuleName,\n\t\tstakingtypes.ModuleName,\n\t\tslashingtypes.ModuleName,\n\t\tgovtypes.ModuleName,\n\t\tminttypes.ModuleName,\n\t\tgenutiltypes.ModuleName,\n\t\tevidencetypes.ModuleName,\n\t\tauthz.ModuleName,\n\t\tfeegrant.ModuleName,\n\t\tnft.ModuleName,\n\t\tgroup.ModuleName,\n\t\tupgradetypes.ModuleName,\n\t\tvestingtypes.ModuleName,\n\t\tcircuittypes.ModuleName,\n\t\tepochstypes.ModuleName,\n}\n\napp.ModuleManager.SetOrderInitGenesis(genesisModuleOrder...)\n\napp.ModuleManager.SetOrderExportGenesis(exportModuleOrder...)\n\n\t// Uncomment if you want to set a custom migration order here.\n\t// app.ModuleManager.SetOrderMigrations(custom order)\n\napp.configurator = module.NewConfigurator(app.appCodec, app.MsgServiceRouter(), app.GRPCQueryRouter())\n\nerr = app.ModuleManager.RegisterServices(app.configurator)\n    if err != nil {\n    panic(err)\n}\n\n\t// RegisterUpgradeHandlers is used for registering any on-chain upgrades.\n\t// Make sure it's called after `app.ModuleManager` and `app.configurator` are set.\n\tapp.RegisterUpgradeHandlers()\n\nautocliv1.RegisterQueryServer(app.GRPCQueryRouter(), runtimeservices.NewAutoCLIQueryService(app.ModuleManager.Modules))\n\nreflectionSvc, err := runtimeservices.NewReflectionService()\n    if err != nil {\n    panic(err)\n}\n\nreflectionv1.RegisterReflectionServiceServer(app.GRPCQueryRouter(), reflectionSvc)\n\n\t// add test gRPC service for testing gRPC queries in isolation\n\ttestdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{\n})\n\n\t// create the simulation manager and define the order of the modules for deterministic simulations\n\t//\n\t// NOTE: this is not required apps that don't use the simulator for fuzz testing\n\t// transactions\n    overrideModules := map[string]module.AppModuleSimulation{\n    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, nil),\n}\n\napp.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)\n\napp.sm.RegisterStoreDecoders()\n\n\t// initialize stores\n\tapp.MountKVStores(keys)\n\n\t// initialize BaseApp\n\tapp.SetInitChainer(app.InitChainer)\n\napp.SetPreBlocker(app.PreBlocker)\n\napp.SetBeginBlocker(app.BeginBlocker)\n\napp.SetEndBlocker(app.EndBlocker)\n\napp.setAnteHandler(txConfig)\n\n\t// In v0.46, the SDK introduces _postHandlers_. PostHandlers are like\n\t// antehandlers, but are run _after_ the `runMsgs` execution. They are also\n\t// defined as a chain, and have the same signature as antehandlers.\n\t//\n\t// In baseapp, postHandlers are run in the same store branch as `runMsgs`,\n\t// meaning that both `runMsgs` and `postHandler` state will be committed if\n\t// both are successful, and both will be reverted if any of the two fails.\n\t//\n\t// The SDK exposes a default postHandlers chain\n\t//\n\t// Please note that changing any of the anteHandler or postHandler chain is\n\t// likely to be a state-machine breaking change, which needs a coordinated\n\t// upgrade.\n\tapp.setPostHandler()\n    if loadLatest {\n    if err := app.LoadLatestVersion(); err != nil {\n    panic(fmt.Errorf(\"error loading last version: %w\", err))\n}\n\t\n}\n\nreturn app\n}\n\nfunc (app *SimApp)\n\nsetAnteHandler(txConfig client.TxConfig) {\n    anteHandler, err := NewAnteHandler(\n\t\tHandlerOptions{\n    ante.HandlerOptions{\n    AccountKeeper:   app.AccountKeeper,\n    BankKeeper:      app.BankKeeper,\n    SignModeHandler: txConfig.SignModeHandler(),\n    FeegrantKeeper:  app.FeeGrantKeeper,\n    SigGasConsumer:  ante.DefaultSigVerificationGasConsumer,\n    SigVerifyOptions: []ante.SigVerificationDecoratorOption{\n\t\t\t\t\t// change below as needed.\n\t\t\t\t\tante.WithUnorderedTxGasCost(ante.DefaultUnorderedTxGasCost),\n\t\t\t\t\tante.WithMaxUnorderedTxTimeoutDuration(ante.DefaultMaxTimeoutDuration),\n},\n},\n\t\t\t&app.CircuitKeeper,\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\n\t// Set the AnteHandler for the app\n\tapp.SetAnteHandler(anteHandler)\n}\n\nfunc (app *SimApp)\n\nsetPostHandler() {\n    postHandler, err := posthandler.NewPostHandler(\n\t\tposthandler.HandlerOptions{\n},\n\t)\n    if err != nil {\n    panic(err)\n}\n\napp.SetPostHandler(postHandler)\n}\n\n// Name returns the name of the App\nfunc (app *SimApp)\n\nName()\n\nstring {\n    return app.BaseApp.Name()\n}\n\n// PreBlocker application updates every pre block\nfunc (app *SimApp)\n\nPreBlocker(ctx sdk.Context, _ *abci.RequestFinalizeBlock) (*sdk.ResponsePreBlock, error) {\n    return app.ModuleManager.PreBlock(ctx)\n}\n\n// BeginBlocker application updates every begin block\nfunc (app *SimApp)\n\nBeginBlocker(ctx sdk.Context) (sdk.BeginBlock, error) {\n    return app.ModuleManager.BeginBlock(ctx)\n}\n\n// EndBlocker application updates every end block\nfunc (app *SimApp)\n\nEndBlocker(ctx sdk.Context) (sdk.EndBlock, error) {\n    return app.ModuleManager.EndBlock(ctx)\n}\n\nfunc (a *SimApp)\n\nConfigurator()\n\nmodule.Configurator {\n    return a.configurator\n}\n\n// InitChainer application update at chain initialization\nfunc (app *SimApp)\n\nInitChainer(ctx sdk.Context, req *abci.RequestInitChain) (*abci.ResponseInitChain, error) {\n    var genesisState GenesisState\n    if err := json.Unmarshal(req.AppStateBytes, &genesisState); err != nil {\n    panic(err)\n}\n\napp.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())\n\nreturn app.ModuleManager.InitGenesis(ctx, app.appCodec, genesisState)\n}\n\n// LoadHeight loads a particular height\nfunc (app *SimApp)\n\nLoadHeight(height int64)\n\nerror {\n    return app.LoadVersion(height)\n}\n\n// LegacyAmino returns SimApp's amino codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nLegacyAmino() *codec.LegacyAmino {\n    return app.legacyAmino\n}\n\n// AppCodec returns SimApp's app codec.\n//\n// NOTE: This is solely to be used for testing purposes as it may be desirable\n// for modules to register their own custom testing types.\nfunc (app *SimApp)\n\nAppCodec()\n\ncodec.Codec {\n    return app.appCodec\n}\n\n// InterfaceRegistry returns SimApp's InterfaceRegistry\nfunc (app *SimApp)\n\nInterfaceRegistry()\n\ntypes.InterfaceRegistry {\n    return app.interfaceRegistry\n}\n\n// TxConfig returns SimApp's TxConfig\nfunc (app *SimApp)\n\nTxConfig()\n\nclient.TxConfig {\n    return app.txConfig\n}\n\n// AutoCliOpts returns the autocli options for the app.\nfunc (app *SimApp)\n\nAutoCliOpts()\n\nautocli.AppOptions {\n    modules := make(map[string]appmodule.AppModule, 0)\n    for _, m := range app.ModuleManager.Modules {\n    if moduleWithName, ok := m.(module.HasName); ok {\n    moduleName := moduleWithName.Name()\n    if appModule, ok := moduleWithName.(appmodule.AppModule); ok {\n    modules[moduleName] = appModule\n}\n\t\n}\n\t\n}\n\nreturn autocli.AppOptions{\n    Modules:               modules,\n    ModuleOptions:         runtimeservices.ExtractAutoCLIOptions(app.ModuleManager.Modules),\n    AddressCodec:          authcodec.NewBech32Codec(sdk.GetConfig().GetBech32AccountAddrPrefix()),\n    ValidatorAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ValidatorAddrPrefix()),\n    ConsensusAddressCodec: authcodec.NewBech32Codec(sdk.GetConfig().GetBech32ConsensusAddrPrefix()),\n}\n}\n\n// DefaultGenesis returns a default genesis from the registered AppModuleBasic's.\nfunc (a *SimApp)\n\nDefaultGenesis()\n\nmap[string]json.RawMessage {\n    return a.BasicModuleManager.DefaultGenesis(a.appCodec)\n}\n\n// GetKey returns the KVStoreKey for the provided store key.\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc (app *SimApp)\n\nGetKey(storeKey string) *storetypes.KVStoreKey {\n    return app.keys[storeKey]\n}\n\n// GetStoreKeys returns all the stored store keys.\nfunc (app *SimApp)\n\nGetStoreKeys() []storetypes.StoreKey {\n    keys := make([]storetypes.StoreKey, 0, len(app.keys))\n    for _, key := range app.keys {\n    keys = append(keys, key)\n}\n\nreturn keys\n}\n\n// SimulationManager implements the SimulationApp interface\nfunc (app *SimApp)\n\nSimulationManager() *module.SimulationManager {\n    return app.sm\n}\n\n// RegisterAPIRoutes registers all application module routes with the provided\n// API server.\nfunc (app *SimApp)\n\nRegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {\n    clientCtx := apiSvr.ClientCtx\n\t// Register new tx routes from grpc-gateway.\n\tauthtx.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register new CometBFT queries routes from grpc-gateway.\n\tcmtservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register node gRPC service for grpc-gateway.\n\tnodeservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// Register grpc-gateway routes for all modules.\n\tapp.BasicModuleManager.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\n\n\t// register swagger API from root so that other applications can override easily\n    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {\n    panic(err)\n}\n}\n\n// RegisterTxService implements the Application.RegisterTxService method.\nfunc (app *SimApp)\n\nRegisterTxService(clientCtx client.Context) {\n    authtx.RegisterTxService(app.BaseApp.GRPCQueryRouter(), clientCtx, app.BaseApp.Simulate, app.interfaceRegistry)\n}\n\n// RegisterTendermintService implements the Application.RegisterTendermintService method.\nfunc (app *SimApp)\n\nRegisterTendermintService(clientCtx client.Context) {\n    cmtApp := server.NewCometABCIWrapper(app)\n\ncmtservice.RegisterTendermintService(\n\t\tclientCtx,\n\t\tapp.BaseApp.GRPCQueryRouter(),\n\t\tapp.interfaceRegistry,\n\t\tcmtApp.Query,\n\t)\n}\n\nfunc (app *SimApp)\n\nRegisterNodeService(clientCtx client.Context, cfg config.Config) {\n    nodeservice.RegisterNodeService(clientCtx, app.GRPCQueryRouter(), cfg)\n}\n\n// GetMaccPerms returns a copy of the module account permissions\n//\n// NOTE: This is solely to be used for testing purposes.\nfunc GetMaccPerms()\n\nmap[string][]string {\n    return maps.Clone(maccPerms)\n}\n\n// BlockedAddresses returns all the app's blocked account addresses.\nfunc BlockedAddresses()\n\nmap[string]bool {\n    modAccAddrs := make(map[string]bool)\n    for acc := range GetMaccPerms() {\n    modAccAddrs[authtypes.NewModuleAddress(acc).String()] = true\n}\n\n\t// allow the following addresses to receive funds\n\tdelete(modAccAddrs, authtypes.NewModuleAddress(govtypes.ModuleName).String())\n\nreturn modAccAddrs\n}\nSee all 1010 lines\n\u200b\nRegister Codec\nThe EncodingConfig structure is the last important part of the app.go file. The goal of this structure is to define the codecs that will be used throughout the app.\n\nCopy\n\nAsk AI\npackage params\n\nimport (\n    \n\t\"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n)\n\n// EncodingConfig specifies the concrete encoding types to use for a given app.\n// This is provided for compatibility between protobuf and amino implementations.\ntype EncodingConfig struct {\n    InterfaceRegistry types.InterfaceRegistry\n\tCodec             codec.Codec\n\tTxConfig          client.TxConfig\n\tAmino             *codec.LegacyAmino\n}\nSee all 17 lines\nHere are descriptions of what each of the four fields means:\nInterfaceRegistry: The InterfaceRegistry is used by the Protobuf codec to handle interfaces that are encoded and decoded (we also say \u201cunpacked\u201d) using google.protobuf.Any. Any could be thought as a struct that contains a type_url (name of a concrete type implementing the interface) and a value (its encoded bytes). InterfaceRegistry provides a mechanism for registering interfaces and implementations that can be safely unpacked from Any. Each application module implements the RegisterInterfaces method that can be used to register the module\u2019s own interfaces and implementations.\nYou can read more about Any in ADR-019.\nTo go more into details, the Cosmos SDK uses an implementation of the Protobuf specification called gogoprotobuf. By default, the gogo protobuf implementation of Any uses global type registration to decode values packed in Any into concrete Go types. This introduces a vulnerability where any malicious module in the dependency tree could register a type with the global protobuf registry and cause it to be loaded and unmarshaled by a transaction that referenced it in the type_url field. For more information, please refer to ADR-019.\nCodec: The default codec used throughout the Cosmos SDK. It is composed of a BinaryCodec used to encode and decode state, and a JSONCodec used to output data to the users (for example, in the CLI). By default, the SDK uses Protobuf as Codec.\nTxConfig: TxConfig defines an interface a client can utilize to generate an application-defined concrete transaction type. Currently, the SDK handles two transaction types: SIGN_MODE_DIRECT (which uses Protobuf binary as over-the-wire encoding) and SIGN_MODE_LEGACY_AMINO_JSON (which depends on Amino). Read more about transactions here.\nAmino: Some legacy parts of the Cosmos SDK still use Amino for backwards-compatibility. Each module exposes a RegisterLegacyAmino method to register the module\u2019s specific types within Amino. This Amino codec should not be used by app developers anymore, and will be removed in future releases.\nAn application should create its own encoding config. See an example of a simappparams.EncodingConfig from simapp:\n\nCopy\n\nAsk AI\npackage params\n\nimport (\n    \n\t\"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    \"github.com/cosmos/cosmos-sdk/codec/types\"\n)\n\n// EncodingConfig specifies the concrete encoding types to use for a given app.\n// This is provided for compatibility between protobuf and amino implementations.\ntype EncodingConfig struct {\n    InterfaceRegistry types.InterfaceRegistry\n\tCodec             codec.Codec\n\tTxConfig          client.TxConfig\n\tAmino             *codec.LegacyAmino\n}\nSee all 17 lines\n\u200b\nModules\nModules are the heart and soul of Cosmos SDK applications. They can be considered as state-machines nested within the state-machine. When a transaction is relayed from the underlying CometBFT engine via the ABCI to the application, it is routed by baseapp to the appropriate module in order to be processed. This paradigm enables developers to easily build complex state-machines, as most of the modules they need often already exist. For developers, most of the work involved in building a Cosmos SDK application revolves around building custom modules required by their application that do not exist yet, and integrating them with modules that do already exist into one coherent application. In the application directory, the standard practice is to store modules in the x/ folder (not to be confused with the Cosmos SDK\u2019s x/ folder, which contains already-built modules).\n\u200b\nApplication Module Interface\nModules must implement interfaces defined in the Cosmos SDK, AppModuleBasic and AppModule. The former implements basic non-dependent elements of the module, such as the codec, while the latter handles the bulk of the module methods (including methods that require references to other modules\u2019 keepers). Both the AppModule and AppModuleBasic types are, by convention, defined in a file called module.go.\nAppModule exposes a collection of useful methods on the module that facilitates the composition of modules into a coherent application. These methods are called from the module manager, which manages the application\u2019s collection of modules.\n\u200b\nMsg Services\nEach application module defines two Protobuf services: one Msg service to handle messages, and one gRPC Query service to handle queries. If we consider the module as a state-machine, then a Msg service is a set of state transition RPC methods. Each Protobuf Msg service method is 1:1 related to a Protobuf request type, which must implement sdk.Msg interface. Note that sdk.Msgs are bundled in transactions, and each transaction contains one or multiple messages.\nWhen a valid block of transactions is received by the full-node, CometBFT relays each one to the application via DeliverTx. Then, the application handles the transaction:\nUpon receiving the transaction, the application first unmarshalls it from []byte.\nThen, it verifies a few things about the transaction like fee payment and signatures before extracting the Msg(s) contained in the transaction.\nsdk.Msgs are encoded using Protobuf Anys. By analyzing each Any\u2019s type_url, baseapp\u2019s msgServiceRouter routes the sdk.Msg to the corresponding module\u2019s Msg service.\nIf the message is successfully processed, the state is updated.\nFor more details, see transaction lifecycle.\nModule developers create custom Msg services when they build their own module. The general practice is to define the Msg Protobuf service in a tx.proto file. For example, the x/bank module defines a service with two methods to transfer tokens:\n\nCopy\n\nAsk AI\n// Reference: https://github.com/cosmos/cosmos-sdk/blob/v0.53.0/proto/cosmos/bank/v1beta1/tx.proto#L13-L36\nService methods use keeper in order to update the module state.\nEach module should also implement the RegisterServices method as part of the AppModule interface. This method should call the RegisterMsgServer function provided by the generated Protobuf code.\n\u200b\ngRPC Query Services\ngRPC Query services allow users to query the state using gRPC. They are enabled by default, and can be configured under the grpc.enable and grpc.address fields inside app.toml.\ngRPC Query services are defined in the module\u2019s Protobuf definition files, specifically inside query.proto. The query.proto definition file exposes a single Query Protobuf service. Each gRPC query endpoint corresponds to a service method, starting with the rpc keyword, inside the Query service.\nProtobuf generates a QueryServer interface for each module, containing all the service methods. A module\u2019s keeper then needs to implement this QueryServer interface, by providing the concrete implementation of each service method. This concrete implementation is the handler of the corresponding gRPC query endpoint.\nFinally, each module should also implement the RegisterServices method as part of the AppModule interface. This method should call the RegisterQueryServer function provided by the generated Protobuf code.\n\u200b\nKeeper\nKeepers are the gatekeepers of their module\u2019s store(s). To read or write in a module\u2019s store, it is mandatory to go through one of its keeper\u2019s methods. This is ensured by the object-capabilities model of the Cosmos SDK. Only objects that hold the key to a store can access it, and only the module\u2019s keeper should hold the key(s) to the module\u2019s store(s).\nKeepers are generally defined in a file called keeper.go. It contains the keeper\u2019s type definition and methods.\nThe keeper type definition generally consists of the following:\nKey(s) to the module\u2019s store(s) in the multistore.\nReference to other module\u2019s keepers. Only needed if the keeper needs to access other module\u2019s store(s) (either to read or write from them).\nA reference to the application\u2019s codec. The keeper needs it to marshal structs before storing them, or to unmarshal them when it retrieves them, because stores only accept []bytes as value.\nAlong with the type definition, the next important component of the keeper.go file is the keeper\u2019s constructor function, NewKeeper. This function instantiates a new keeper of the type defined above with a codec, stores keys and potentially references other modules\u2019 keepers as parameters. The NewKeeper function is called from the application\u2019s constructor. The rest of the file defines the keeper\u2019s methods, which are primarily getters and setters.\n\u200b\nCommand-Line, gRPC Services and REST Interfaces\nEach module defines command-line commands, gRPC services, and REST routes to be exposed to the end-user via the application\u2019s interfaces. This enables end-users to create messages of the types defined in the module, or to query the subset of the state managed by the module.\n\u200b\nCLI\nGenerally, the commands related to a module are defined in a folder called client/cli in the module\u2019s folder. The CLI divides commands into two categories, transactions and queries, defined in client/cli/tx.go and client/cli/query.go, respectively. Both commands are built on top of the Cobra Library:\nTransactions commands let users generate new transactions so that they can be included in a block and eventually update the state. One command should be created for each message type defined in the module. The command calls the constructor of the message with the parameters provided by the end-user, and wraps it into a transaction. The Cosmos SDK handles signing and the addition of other transaction metadata.\nQueries let users query the subset of the state defined by the module. Query commands forward queries to the application\u2019s query router, which routes them to the appropriate querier the queryRoute parameter supplied.\n\u200b\ngRPC\ngRPC is a modern open-source high performance RPC framework that has support in multiple languages. It is the recommended way for external clients (such as wallets, browsers and other backend services) to interact with a node.\nEach module can expose gRPC endpoints called service methods, which are defined in the module\u2019s Protobuf query.proto file. A service method is defined by its name, input arguments, and output response. The module then needs to perform the following actions:\nDefine a RegisterGRPCGatewayRoutes method on AppModuleBasic to wire the client gRPC requests to the correct handler inside the module.\nFor each service method, define a corresponding handler. The handler implements the core logic necessary to serve the gRPC request, and is located in the keeper/grpc_query.go file.\n\u200b\ngRPC-gateway REST Endpoints\nSome external clients may not wish to use gRPC. In this case, the Cosmos SDK provides a gRPC gateway service, which exposes each gRPC service as a corresponding REST endpoint. Please refer to the grpc-gateway documentation to learn more.\nThe REST endpoints are defined in the Protobuf files, along with the gRPC services, using Protobuf annotations. Modules that want to expose REST queries should add google.api.http annotations to their rpc methods. By default, all REST endpoints defined in the SDK have a URL starting with the /cosmos/ prefix.\nThe Cosmos SDK also provides a development endpoint to generate Swagger definition files for these REST endpoints. This endpoint can be enabled inside the app.toml config file, under the api.swagger key.\n\u200b\nApplication Interface\nInterfaces let end-users interact with full-node clients. This means querying data from the full-node or creating and sending new transactions to be relayed by the full-node and eventually included in a block.\nThe main interface is the Command-Line Interface. The CLI of a Cosmos SDK application is built by aggregating CLI commands defined in each of the modules used by the application. The CLI of an application is the same as the daemon (e.g. appd), and is defined in a file called appd/main.go. The file contains the following:\nA main() function, which is executed to build the appd interface client. This function prepares each command and adds them to the rootCmd before building them. At the root of appd, the function adds generic commands like status, keys, and config, query commands, tx commands, and rest-server.\nQuery commands, which are added by calling the queryCmd function. This function returns a Cobra command that contains the query commands defined in each of the application\u2019s modules (passed as an array of sdk.ModuleClients from the main() function), as well as some other lower level query commands such as block or validator queries. Query command are called by using the command appd query [query] of the CLI.\nTransaction commands, which are added by calling the txCmd function. Similar to queryCmd, the function returns a Cobra command that contains the tx commands defined in each of the application\u2019s modules, as well as lower level tx commands like transaction signing or broadcasting. Tx commands are called by using the command appd tx [tx] of the CLI.\nSee an example of an application\u2019s main command-line file from the Cosmos Hub.\n\nCopy\n\nAsk AI\npackage cmd\n\nimport (\n    \n\t\"errors\"\n    \"io\"\n    \"os\"\n    \"path/filepath\"\n    \"github.com/cosmos/cosmos-sdk/baseapp\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/client/config\"\n    \"github.com/cosmos/cosmos-sdk/client/debug\"\n    \"github.com/cosmos/cosmos-sdk/client/flags\"\n    \"github.com/cosmos/cosmos-sdk/client/keys\"\n    \"github.com/cosmos/cosmos-sdk/client/rpc\"\n    \"github.com/cosmos/cosmos-sdk/server\"\n\tserverconfig \"github.com/cosmos/cosmos-sdk/server/config\"\n\tservertypes \"github.com/cosmos/cosmos-sdk/server/types\"\n    \"github.com/cosmos/cosmos-sdk/snapshots\"\n\tsnapshottypes \"github.com/cosmos/cosmos-sdk/snapshots/types\"\n    \"github.com/cosmos/cosmos-sdk/store\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tauthcmd \"github.com/cosmos/cosmos-sdk/x/auth/client/cli\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/types\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n    \"github.com/cosmos/cosmos-sdk/x/crisis\"\n\tgenutilcli \"github.com/cosmos/cosmos-sdk/x/genutil/client/cli\"\n    \"github.com/spf13/cast\"\n    \"github.com/spf13/cobra\"\n\ttmcfg \"github.com/tendermint/tendermint/config\"\n\ttmcli \"github.com/tendermint/tendermint/libs/cli\"\n    \"github.com/tendermint/tendermint/libs/log\"\n\tdbm \"github.com/tendermint/tm-db\"\n\n\tgaia \"github.com/cosmos/gaia/v8/app\"\n    \"github.com/cosmos/gaia/v8/app/params\"\n)\n\n// NewRootCmd creates a new root command for simd. It is called once in the\n// main function.\nfunc NewRootCmd() (*cobra.Command, params.EncodingConfig) {\n    encodingConfig := gaia.MakeTestEncodingConfig()\n    initClientCtx := client.Context{\n}.\n\t\tWithCodec(encodingConfig.Codec).\n\t\tWithInterfaceRegistry(encodingConfig.InterfaceRegistry).\n\t\tWithTxConfig(encodingConfig.TxConfig).\n\t\tWithLegacyAmino(encodingConfig.Amino).\n\t\tWithInput(os.Stdin).\n\t\tWithAccountRetriever(types.AccountRetriever{\n}).\n\t\tWithHomeDir(gaia.DefaultNodeHome).\n\t\tWithViper(\"\")\n    rootCmd := &cobra.Command{\n    Use:   \"gaiad\",\n    Short: \"Stargate Cosmos Hub App\",\n    PersistentPreRunE: func(cmd *cobra.Command, _ []string)\n\nerror {\n    initClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())\n    if err != nil {\n    return err\n}\n\ninitClientCtx, err = config.ReadFromClientConfig(initClientCtx)\n    if err != nil {\n    return err\n}\n    if err = client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {\n    return err\n}\n\ncustomTemplate, customGaiaConfig := initAppConfig()\n    customTMConfig := initTendermintConfig()\n\nreturn server.InterceptConfigsPreRunHandler(cmd, customTemplate, customGaiaConfig, customTMConfig)\n},\n}\n\ninitRootCmd(rootCmd, encodingConfig)\n\nreturn rootCmd, encodingConfig\n}\n\n// initTendermintConfig helps to override default Tendermint Config values.\n// return tmcfg.DefaultConfig if no custom configuration is required for the application.\nfunc initTendermintConfig() *tmcfg.Config {\n    cfg := tmcfg.DefaultConfig()\n\n\t// these values put a higher strain on node memory\n\t// cfg.P2P.MaxNumInboundPeers = 100\n\t// cfg.P2P.MaxNumOutboundPeers = 40\n\n\treturn cfg\n}\n\nfunc initAppConfig() (string, interface{\n}) {\n    srvCfg := serverconfig.DefaultConfig()\n\nsrvCfg.StateSync.SnapshotInterval = 1000\n\tsrvCfg.StateSync.SnapshotKeepRecent = 10\n\n\treturn params.CustomConfigTemplate(), params.CustomAppConfig{\n    Config:               *srvCfg,\n    BypassMinFeeMsgTypes: gaia.GetDefaultBypassFeeMessages(),\n}\n}\n\nfunc initRootCmd(rootCmd *cobra.Command, encodingConfig params.EncodingConfig) {\n    cfg := sdk.GetConfig()\n\ncfg.Seal()\n\nrootCmd.AddCommand(\n\t\tgenutilcli.InitCmd(gaia.ModuleBasics, gaia.DefaultNodeHome),\n\t\tgenutilcli.CollectGenTxsCmd(banktypes.GenesisBalancesIterator{\n}, gaia.DefaultNodeHome),\n\t\tgenutilcli.GenTxCmd(gaia.ModuleBasics, encodingConfig.TxConfig, banktypes.GenesisBalancesIterator{\n}, gaia.DefaultNodeHome),\n\t\tgenutilcli.ValidateGenesisCmd(gaia.ModuleBasics),\n\t\tAddGenesisAccountCmd(gaia.DefaultNodeHome),\n\t\ttmcli.NewCompletionCmd(rootCmd, true),\n\t\ttestnetCmd(gaia.ModuleBasics, banktypes.GenesisBalancesIterator{\n}),\n\t\tdebug.Cmd(),\n\t\tconfig.Cmd(),\n\t)\n    ac := appCreator{\n    encCfg: encodingConfig,\n}\n\nserver.AddCommands(rootCmd, gaia.DefaultNodeHome, ac.newApp, ac.appExport, addModuleInitFlags)\n\n\t// add keybase, auxiliary RPC, query, and tx child commands\n\trootCmd.AddCommand(\n\t\trpc.StatusCommand(),\n\t\tqueryCommand(),\n\t\ttxCommand(),\n\t\tkeys.Commands(gaia.DefaultNodeHome),\n\t)\n\nrootCmd.AddCommand(server.RosettaCommand(encodingConfig.InterfaceRegistry, encodingConfig.Codec))\n}\n\nfunc addModuleInitFlags(startCmd *cobra.Command) {\n    crisis.AddModuleInitFlags(startCmd)\n}\n\nfunc queryCommand() *cobra.Command {\n    cmd := &cobra.Command{\n    Use:                        \"query\",\n    Aliases:                    []string{\"q\"\n},\n    Short:                      \"Querying subcommands\",\n    DisableFlagParsing:         true,\n    SuggestionsMinimumDistance: 2,\n    RunE:                       client.ValidateCmd,\n}\n\ncmd.AddCommand(\n\t\tauthcmd.GetAccountCmd(),\n\t\trpc.ValidatorCommand(),\n\t\trpc.BlockCommand(),\n\t\tauthcmd.QueryTxsByEventsCmd(),\n\t\tauthcmd.QueryTxCmd(),\n\t)\n\ngaia.ModuleBasics.AddQueryCommands(cmd)\n\ncmd.PersistentFlags().String(flags.FlagChainID, \"\", \"The network chain ID\")\n\nreturn cmd\n}\n\nfunc txCommand() *cobra.Command {\n    cmd := &cobra.Command{\n    Use:                        \"tx\",\n    Short:                      \"Transactions subcommands\",\n    DisableFlagParsing:         true,\n    SuggestionsMinimumDistance: 2,\n    RunE:                       client.ValidateCmd,\n}\n\ncmd.AddCommand(\n\t\tauthcmd.GetSignCommand(),\n\t\tauthcmd.GetSignBatchCommand(),\n\t\tauthcmd.GetMultiSignCommand(),\n\t\tauthcmd.GetMultiSignBatchCmd(),\n\t\tauthcmd.GetValidateSignaturesCommand(),\n\t\tflags.LineBreak,\n\t\tauthcmd.GetBroadcastCommand(),\n\t\tauthcmd.GetEncodeCommand(),\n\t\tauthcmd.GetDecodeCommand(),\n\t\tauthcmd.GetAuxToFeeCommand(),\n\t)\n\ngaia.ModuleBasics.AddTxCommands(cmd)\n\ncmd.PersistentFlags().String(flags.FlagChainID, \"\", \"The network chain ID\")\n\nreturn cmd\n}\n\ntype appCreator struct {\n    encCfg params.EncodingConfig\n}\n\nfunc (ac appCreator)\n\nnewApp(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\tappOpts servertypes.AppOptions,\n)\n\nservertypes.Application {\n    var cache sdk.MultiStorePersistentCache\n    if cast.ToBool(appOpts.Get(server.FlagInterBlockCache)) {\n    cache = store.NewCommitKVStoreCacheManager()\n}\n    skipUpgradeHeights := make(map[int64]bool)\n    for _, h := range cast.ToIntSlice(appOpts.Get(server.FlagUnsafeSkipUpgrades)) {\n    skipUpgradeHeights[int64(h)] = true\n}\n\npruningOpts, err := server.GetPruningOptionsFromFlags(appOpts)\n    if err != nil {\n    panic(err)\n}\n    snapshotDir := filepath.Join(cast.ToString(appOpts.Get(flags.FlagHome)), \"data\", \"snapshots\")\n\nsnapshotDB, err := dbm.NewDB(\"metadata\", server.GetAppDBBackend(appOpts), snapshotDir)\n    if err != nil {\n    panic(err)\n}\n\nsnapshotStore, err := snapshots.NewStore(snapshotDB, snapshotDir)\n    if err != nil {\n    panic(err)\n}\n    snapshotOptions := snapshottypes.NewSnapshotOptions(\n\t\tcast.ToUint64(appOpts.Get(server.FlagStateSyncSnapshotInterval)),\n\t\tcast.ToUint32(appOpts.Get(server.FlagStateSyncSnapshotKeepRecent)),\n\t)\n\nreturn gaia.NewGaiaApp(\n\t\tlogger, db, traceStore, true, skipUpgradeHeights,\n\t\tcast.ToString(appOpts.Get(flags.FlagHome)),\n\t\tcast.ToUint(appOpts.Get(server.FlagInvCheckPeriod)),\n\t\tac.encCfg,\n\t\tappOpts,\n\t\tbaseapp.SetPruning(pruningOpts),\n\t\tbaseapp.SetMinGasPrices(cast.ToString(appOpts.Get(server.FlagMinGasPrices))),\n\t\tbaseapp.SetHaltHeight(cast.ToUint64(appOpts.Get(server.FlagHaltHeight))),\n\t\tbaseapp.SetHaltTime(cast.ToUint64(appOpts.Get(server.FlagHaltTime))),\n\t\tbaseapp.SetMinRetainBlocks(cast.ToUint64(appOpts.Get(server.FlagMinRetainBlocks))),\n\t\tbaseapp.SetInterBlockCache(cache),\n\t\tbaseapp.SetTrace(cast.ToBool(appOpts.Get(server.FlagTrace))),\n\t\tbaseapp.SetIndexEvents(cast.ToStringSlice(appOpts.Get(server.FlagIndexEvents))),\n\t\tbaseapp.SetSnapshot(snapshotStore, snapshotOptions),\n\t)\n}\n\nfunc (ac appCreator)\n\nappExport(\n\tlogger log.Logger,\n\tdb dbm.DB,\n\ttraceStore io.Writer,\n\theight int64,\n    forZeroHeight bool,\n\tjailAllowedAddrs []string,\n\tappOpts servertypes.AppOptions,\n) (servertypes.ExportedApp, error) {\n    homePath, ok := appOpts.Get(flags.FlagHome).(string)\n    if !ok || homePath == \"\" {\n    return servertypes.ExportedApp{\n}, errors.New(\"application home is not set\")\n}\n\nvar loadLatest bool\n    if height == -1 {\n    loadLatest = true\n}\n    gaiaApp := gaia.NewGaiaApp(\n\t\tlogger,\n\t\tdb,\n\t\ttraceStore,\n\t\tloadLatest,\n\t\tmap[int64]bool{\n},\n\t\thomePath,\n\t\tcast.ToUint(appOpts.Get(server.FlagInvCheckPeriod)),\n\t\tac.encCfg,\n\t\tappOpts,\n\t)\n    if height != -1 {\n    if err := gaiaApp.LoadHeight(height); err != nil {\n    return servertypes.ExportedApp{\n}, err\n}\n\t\n}\n\nreturn gaiaApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs)\n}\nSee all 308 lines\n\u200b\nDependencies and Makefile\nThis section is optional, as developers are free to choose their dependency manager and project building method. That said, the current most used framework for versioning control is go.mod. It ensures each of the libraries used throughout the application are imported with the correct version.\nThe following is the go.mod of the Cosmos Hub, provided as an example.\n\nCopy\n\nAsk AI\nmodule github.com/cosmos/gaia/v8\n\ngo 1.18\n\nrequire (\n\tcosmossdk.io/math v1.0.0-beta.3\n\tgithub.com/cosmos/cosmos-sdk v0.46.2\n\tgithub.com/cosmos/go-bip39 v1.0.0 // indirect\n\tgithub.com/cosmos/ibc-go/v5 v5.0.0\n\tgithub.com/gogo/protobuf v1.3.3\n\tgithub.com/golang/protobuf v1.5.2\n\tgithub.com/golangci/golangci-lint v1.50.0\n\tgithub.com/gorilla/mux v1.8.0\n\tgithub.com/gravity-devs/liquidity/v2 v2.0.0\n\tgithub.com/grpc-ecosystem/grpc-gateway v1.16.0\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/rakyll/statik v0.1.7\n\tgithub.com/spf13/cast v1.5.0\n\tgithub.com/spf13/cobra v1.6.0\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/spf13/viper v1.13.0\n\tgithub.com/strangelove-ventures/packet-forward-middleware/v2 v2.1.4-0.20220802012200-5a62a55a7f1d\n\tgithub.com/stretchr/testify v1.8.0\n\tgithub.com/tendermint/tendermint v0.34.21\n\tgithub.com/tendermint/tm-db v0.6.7\n\tgoogle.golang.org/genproto v0.0.0-20220815135757-37a418bb8959\n\tgoogle.golang.org/grpc v1.50.0\n)\n\nrequire (\n\t4d63.com/gochecknoglobals v0.1.0 // indirect\n\tcloud.google.com/go v0.102.1 // indirect\n\tcloud.google.com/go/compute v1.7.0 // indirect\n\tcloud.google.com/go/iam v0.4.0 // indirect\n\tcloud.google.com/go/storage v1.22.1 // indirect\n\tcosmossdk.io/errors v1.0.0-beta.7 // indirect\n\tfilippo.io/edwards25519 v1.0.0-rc.1 // indirect\n\tgithub.com/99designs/go-keychain v0.0.0-20191008050251-8e49817e8af4 // indirect\n\tgithub.com/99designs/keyring v1.2.1 // indirect\n\tgithub.com/Abirdcfly/dupword v0.0.7 // indirect\n\tgithub.com/Antonboom/errname v0.1.7 // indirect\n\tgithub.com/Antonboom/nilnil v0.1.1 // indirect\n\tgithub.com/BurntSushi/toml v1.2.0 // indirect\n\tgithub.com/ChainSafe/go-schnorrkel v0.0.0-20200405005733-88cbf1b4c40d // indirect\n\tgithub.com/Djarvur/go-err113 v0.0.0-20210108212216-aea10b59be24 // indirect\n\tgithub.com/GaijinEntertainment/go-exhaustruct/v2 v2.3.0 // indirect\n\tgithub.com/Masterminds/semver v1.5.0 // indirect\n\tgithub.com/OpenPeeDeeP/depguard v1.1.1 // indirect\n\tgithub.com/Workiva/go-datastructures v1.0.53 // indirect\n\tgithub.com/alexkohler/prealloc v1.0.0 // indirect\n\tgithub.com/alingse/asasalint v0.0.11 // indirect\n\tgithub.com/armon/go-metrics v0.4.0 // indirect\n\tgithub.com/ashanbrown/forbidigo v1.3.0 // indirect\n\tgithub.com/ashanbrown/makezero v1.1.1 // indirect\n\tgithub.com/aws/aws-sdk-go v1.40.45 // indirect\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/bgentry/go-netrc v0.0.0-20140422174119-9fd32a8b3d3d // indirect\n\tgithub.com/bgentry/speakeasy v0.1.0 // indirect\n\tgithub.com/bkielbasa/cyclop v1.2.0 // indirect\n\tgithub.com/blizzy78/varnamelen v0.8.0 // indirect\n\tgithub.com/bombsimon/wsl/v3 v3.3.0 // indirect\n\tgithub.com/breml/bidichk v0.2.3 // indirect\n\tgithub.com/breml/errchkjson v0.3.0 // indirect\n\tgithub.com/btcsuite/btcd v0.22.1 // indirect\n\tgithub.com/butuzov/ireturn v0.1.1 // indirect\n\tgithub.com/cenkalti/backoff/v4 v4.1.3 // indirect\n\tgithub.com/cespare/xxhash v1.1.0 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.1.2 // indirect\n\tgithub.com/charithe/durationcheck v0.0.9 // indirect\n\tgithub.com/chavacava/garif v0.0.0-20220630083739-93517212f375 // indirect\n\tgithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e // indirect\n\tgithub.com/cockroachdb/apd/v2 v2.0.2 // indirect\n\tgithub.com/coinbase/rosetta-sdk-go v0.7.9 // indirect\n\tgithub.com/confio/ics23/go v0.7.0 // indirect\n\tgithub.com/cosmos/btcutil v1.0.4 // indirect\n\tgithub.com/cosmos/cosmos-proto v1.0.0-alpha7 // indirect\n\tgithub.com/cosmos/gorocksdb v1.2.0 // indirect\n\tgithub.com/cosmos/iavl v0.19.2-0.20220916140702-9b6be3095313 // indirect\n\tgithub.com/cosmos/ledger-cosmos-go v0.11.1 // indirect\n\tgithub.com/cosmos/ledger-go v0.9.3 // indirect\n\tgithub.com/creachadair/taskgroup v0.3.2 // indirect\n\tgithub.com/curioswitch/go-reassign v0.2.0 // indirect\n\tgithub.com/daixiang0/gci v0.8.0 // indirect\n\tgithub.com/danieljoos/wincred v1.1.2 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/denis-tingaikin/go-header v0.4.3 // indirect\n\tgithub.com/desertbit/timer v0.0.0-20180107155436-c41aec40b27f // indirect\n\tgithub.com/dgraph-io/badger/v2 v2.2007.4 // indirect\n\tgithub.com/dgraph-io/ristretto v0.1.0 // indirect\n\tgithub.com/dgryski/go-farm v0.0.0-20200201041132-a6ae2369ad13 // indirect\n\tgithub.com/dustin/go-humanize v1.0.0 // indirect\n\tgithub.com/dvsekhvalnov/jose2go v1.5.0 // indirect\n\tgithub.com/esimonov/ifshort v1.0.4 // indirect\n\tgithub.com/ettle/strcase v0.1.1 // indirect\n\tgithub.com/fatih/color v1.13.0 // indirect\n\tgithub.com/fatih/structtag v1.2.0 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.1 // indirect\n\tgithub.com/firefart/nonamedreturns v1.0.4 // indirect\n\tgithub.com/fsnotify/fsnotify v1.5.4 // indirect\n\tgithub.com/fzipp/gocyclo v0.6.0 // indirect\n\tgithub.com/go-critic/go-critic v0.6.5 // indirect\n\tgithub.com/go-kit/kit v0.12.0 // indirect\n\tgithub.com/go-kit/log v0.2.1 // indirect\n\tgithub.com/go-logfmt/logfmt v0.5.1 // indirect\n\tgithub.com/go-playground/validator/v10 v10.4.1 // indirect\n\tgithub.com/go-toolsmith/astcast v1.0.0 // indirect\n\tgithub.com/go-toolsmith/astcopy v1.0.2 // indirect\n\tgithub.com/go-toolsmith/astequal v1.0.3 // indirect\n\tgithub.com/go-toolsmith/astfmt v1.0.0 // indirect\n\tgithub.com/go-toolsmith/astp v1.0.0 // indirect\n\tgithub.com/go-toolsmith/strparse v1.0.0 // indirect\n\tgithub.com/go-toolsmith/typep v1.0.2 // indirect\n\tgithub.com/go-xmlfmt/xmlfmt v0.0.0-20191208150333-d5b6f63a941b // indirect\n\tgithub.com/gobwas/glob v0.2.3 // indirect\n\tgithub.com/godbus/dbus v0.0.0-20190726142602-4481cbc300e2 // indirect\n\tgithub.com/gofrs/flock v0.8.1 // indirect\n\tgithub.com/gogo/gateway v1.1.0 // indirect\n\tgithub.com/golang/glog v1.0.0 // indirect\n\tgithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da // indirect\n\tgithub.com/golang/snappy v0.0.4 // indirect\n\tgithub.com/golangci/check v0.0.0-20180506172741-cfe4005ccda2 // indirect\n\tgithub.com/golangci/dupl v0.0.0-20180902072040-3e9179ac440a // indirect\n\tgithub.com/golangci/go-misc v0.0.0-20220329215616-d24fe342adfe // indirect\n\tgithub.com/golangci/gofmt v0.0.0-20220901101216-f2edd75033f2 // indirect\n\tgithub.com/golangci/lint-1 v0.0.0-20191013205115-297bf364a8e0 // indirect\n\tgithub.com/golangci/maligned v0.0.0-20180506175553-b1d89398deca // indirect\n\tgithub.com/golangci/misspell v0.3.5 // indirect\n\tgithub.com/golangci/revgrep v0.0.0-20220804021717-745bb2f7c2e6 // indirect\n\tgithub.com/golangci/unconvert v0.0.0-20180507085042-28b1c447d1f4 // indirect\n\tgithub.com/google/btree v1.0.1 // indirect\n\tgithub.com/google/go-cmp v0.5.9 // indirect\n\tgithub.com/google/orderedcode v0.0.1 // indirect\n\tgithub.com/google/uuid v1.3.0 // indirect\n\tgithub.com/googleapis/enterprise-certificate-proxy v0.1.0 // indirect\n\tgithub.com/googleapis/gax-go/v2 v2.4.0 // indirect\n\tgithub.com/googleapis/go-type-adapters v1.0.0 // indirect\n\tgithub.com/gordonklaus/ineffassign v0.0.0-20210914165742-4cc7213b9bc8 // indirect\n\tgithub.com/gorilla/handlers v1.5.1 // indirect\n\tgithub.com/gorilla/websocket v1.5.0 // indirect\n\tgithub.com/gostaticanalysis/analysisutil v0.7.1 // indirect\n\tgithub.com/gostaticanalysis/comment v1.4.2 // indirect\n\tgithub.com/gostaticanalysis/forcetypeassert v0.1.0 // indirect\n\tgithub.com/gostaticanalysis/nilerr v0.1.1 // indirect\n\tgithub.com/grpc-ecosystem/go-grpc-middleware v1.3.0 // indirect\n\tgithub.com/grpc-ecosystem/grpc-gateway/v2 v2.0.1 // indirect\n\tgithub.com/gsterjov/go-libsecret v0.0.0-20161001094733-a6f4afe4910c // indirect\n\tgithub.com/gtank/merlin v0.1.1 // indirect\n\tgithub.com/gtank/ristretto255 v0.1.2 // indirect\n\tgithub.com/hashicorp/errwrap v1.1.0 // indirect\n\tgithub.com/hashicorp/go-cleanhttp v0.5.2 // indirect\n\tgithub.com/hashicorp/go-getter v1.6.1 // indirect\n\tgithub.com/hashicorp/go-immutable-radix v1.3.1 // indirect\n\tgithub.com/hashicorp/go-multierror v1.1.1 // indirect\n\tgithub.com/hashicorp/go-safetemp v1.0.0 // indirect\n\tgithub.com/hashicorp/go-version v1.6.0 // indirect\n\tgithub.com/hashicorp/golang-lru v0.5.5-0.20210104140557-80c98217689d // indirect\n\tgithub.com/hashicorp/hcl v1.0.0 // indirect\n\tgithub.com/hdevalence/ed25519consensus v0.0.0-20220222234857-c00d1f31bab3 // indirect\n\tgithub.com/hexops/gotextdiff v1.0.3 // indirect\n\tgithub.com/improbable-eng/grpc-web v0.15.0 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.0.1 // indirect\n\tgithub.com/jgautheron/goconst v1.5.1 // indirect\n\tgithub.com/jingyugao/rowserrcheck v1.1.1 // indirect\n\tgithub.com/jirfag/go-printf-func-name v0.0.0-20200119135958-7558a9eaa5af // indirect\n\tgithub.com/jmespath/go-jmespath v0.4.0 // indirect\n\tgithub.com/jmhodges/levigo v1.0.0 // indirect\n\tgithub.com/julz/importas v0.1.0 // indirect\n\tgithub.com/kisielk/errcheck v1.6.2 // indirect\n\tgithub.com/kisielk/gotool v1.0.0 // indirect\n\tgithub.com/kkHAIKE/contextcheck v1.1.2 // indirect\n\tgithub.com/klauspost/compress v1.15.9 // indirect\n\tgithub.com/kulti/thelper v0.6.3 // indirect\n\tgithub.com/kunwardeep/paralleltest v1.0.6 // indirect\n\tgithub.com/kyoh86/exportloopref v0.1.8 // indirect\n\tgithub.com/ldez/gomoddirectives v0.2.3 // indirect\n\tgithub.com/ldez/tagliatelle v0.3.1 // indirect\n\tgithub.com/leonklingele/grouper v1.1.0 // indirect\n\tgithub.com/lib/pq v1.10.6 // indirect\n\tgithub.com/libp2p/go-buffer-pool v0.1.0 // indirect\n\tgithub.com/lufeee/execinquery v1.2.1 // indirect\n\tgithub.com/magiconair/properties v1.8.6 // indirect\n\tgithub.com/manifoldco/promptui v0.9.0 // indirect\n\tgithub.com/maratori/testableexamples v1.0.0 // indirect\n\tgithub.com/maratori/testpackage v1.1.0 // indirect\n\tgithub.com/matoous/godox v0.0.0-20210227103229-6504466cf951 // indirect\n\tgithub.com/mattn/go-colorable v0.1.13 // indirect\n\tgithub.com/mattn/go-isatty v0.0.16 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.9 // indirect\n\tgithub.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369 // indirect\n\tgithub.com/mbilski/exhaustivestruct v1.2.0 // indirect\n\tgithub.com/mgechev/revive v1.2.4 // indirect\n\tgithub.com/mimoo/StrobeGo v0.0.0-20181016162300-f8f6d4d2b643 // indirect\n\tgithub.com/minio/highwayhash v1.0.2 // indirect\n\tgithub.com/mitchellh/go-homedir v1.1.0 // indirect\n\tgithub.com/mitchellh/go-testing-interface v1.0.0 // indirect\n\tgithub.com/mitchellh/mapstructure v1.5.0 // indirect\n\tgithub.com/moricho/tparallel v0.2.1 // indirect\n\tgithub.com/mtibben/percent v0.2.1 // indirect\n\tgithub.com/nakabonne/nestif v0.3.1 // indirect\n\tgithub.com/nbutton23/zxcvbn-go v0.0.0-20210217022336-fa2cb2858354 // indirect\n\tgithub.com/nishanths/exhaustive v0.8.3 // indirect\n\tgithub.com/nishanths/predeclared v0.2.2 // indirect\n\tgithub.com/olekukonko/tablewriter v0.0.5 // indirect\n\tgithub.com/pelletier/go-toml v1.9.5 // indirect\n\tgithub.com/pelletier/go-toml/v2 v2.0.5 // indirect\n\tgithub.com/petermattis/goid v0.0.0-20180202154549-b0b1615b78e5 // indirect\n\tgithub.com/phayes/checkstyle v0.0.0-20170904204023-bfd46e6a821d // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/polyfloyd/go-errorlint v1.0.5 // indirect\n\tgithub.com/prometheus/client_golang v1.12.2 // indirect\n\tgithub.com/prometheus/client_model v0.2.0 // indirect\n\tgithub.com/prometheus/common v0.34.0 // indirect\n\tgithub.com/prometheus/procfs v0.7.3 // indirect\n\tgithub.com/quasilyte/go-ruleguard v0.3.18 // indirect\n\tgithub.com/quasilyte/gogrep v0.0.0-20220828223005-86e4605de09f // indirect\n\tgithub.com/quasilyte/regex/syntax v0.0.0-20200407221936-30656e2c4a95 // indirect\n\tgithub.com/quasilyte/stdinfo v0.0.0-20220114132959-f7386bf02567 // indirect\n\tgithub.com/rcrowley/go-metrics v0.0.0-20200313005456-10cdbea86bc0 // indirect\n\tgithub.com/regen-network/cosmos-proto v0.3.1 // indirect\n\tgithub.com/rs/cors v1.8.2 // indirect\n\tgithub.com/rs/zerolog v1.27.0 // indirect\n\tgithub.com/ryancurrah/gomodguard v1.2.4 // indirect\n\tgithub.com/ryanrolds/sqlclosecheck v0.3.0 // indirect\n\tgithub.com/sanposhiho/wastedassign/v2 v2.0.6 // indirect\n\tgithub.com/sasha-s/go-deadlock v0.2.1-0.20190427202633-1595213edefa // indirect\n\tgithub.com/sashamelentyev/interfacebloat v1.1.0 // indirect\n\tgithub.com/sashamelentyev/usestdlibvars v1.20.0 // indirect\n\tgithub.com/securego/gosec/v2 v2.13.1 // indirect\n\tgithub.com/shazow/go-diff v0.0.0-20160112020656-b6b7b6733b8c // indirect\n\tgithub.com/sirupsen/logrus v1.9.0 // indirect\n\tgithub.com/sivchari/containedctx v1.0.2 // indirect\n\tgithub.com/sivchari/nosnakecase v1.7.0 // indirect\n\tgithub.com/sivchari/tenv v1.7.0 // indirect\n\tgithub.com/sonatard/noctx v0.0.1 // indirect\n\tgithub.com/sourcegraph/go-diff v0.6.1 // indirect\n\tgithub.com/spf13/afero v1.8.2 // indirect\n\tgithub.com/spf13/jwalterweatherman v1.1.0 // indirect\n\tgithub.com/ssgreg/nlreturn/v2 v2.2.1 // indirect\n\tgithub.com/stbenjam/no-sprintf-host-port v0.1.1 // indirect\n\tgithub.com/stretchr/objx v0.4.0 // indirect\n\tgithub.com/subosito/gotenv v1.4.1 // indirect\n\tgithub.com/syndtr/goleveldb v1.0.1-0.20210819022825-2ae1ddf74ef7 // indirect\n\tgithub.com/tdakkota/asciicheck v0.1.1 // indirect\n\tgithub.com/tendermint/btcd v0.1.1 // indirect\n\tgithub.com/tendermint/crypto v0.0.0-20191022145703-50d29ede1e15 // indirect\n\tgithub.com/tendermint/go-amino v0.16.0 // indirect\n\tgithub.com/tetafro/godot v1.4.11 // indirect\n\tgithub.com/timakin/bodyclose v0.0.0-20210704033933-f49887972144 // indirect\n\tgithub.com/timonwong/loggercheck v0.9.3 // indirect\n\tgithub.com/tomarrell/wrapcheck/v2 v2.6.2 // indirect\n\tgithub.com/tommy-muehle/go-mnd/v2 v2.5.0 // indirect\n\tgithub.com/ulikunitz/xz v0.5.8 // indirect\n\tgithub.com/ultraware/funlen v0.0.3 // indirect\n\tgithub.com/ultraware/whitespace v0.0.5 // indirect\n\tgithub.com/uudashr/gocognit v1.0.6 // indirect\n\tgithub.com/yagipy/maintidx v1.0.0 // indirect\n\tgithub.com/yeya24/promlinter v0.2.0 // indirect\n\tgithub.com/zondax/hid v0.9.1-0.20220302062450-5552068d2266 // indirect\n\tgitlab.com/bosi/decorder v0.2.3 // indirect\n\tgo.etcd.io/bbolt v1.3.6 // indirect\n\tgo.opencensus.io v0.23.0 // indirect\n\tgo.uber.org/atomic v1.9.0 // indirect\n\tgo.uber.org/multierr v1.8.0 // indirect\n\tgo.uber.org/zap v1.21.0 // indirect\n\tgolang.org/x/crypto v0.0.0-20220722155217-630584e8d5aa // indirect\n\tgolang.org/x/exp v0.0.0-20220722155223-a9213eeb770e // indirect\n\tgolang.org/x/exp/typeparams v0.0.0-20220827204233-334a2380cb91 // indirect\n\tgolang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4 // indirect\n\tgolang.org/x/net v0.0.0-20220726230323-06994584191e // indirect\n\tgolang.org/x/oauth2 v0.0.0-20220622183110-fd043fe589d2 // indirect\n\tgolang.org/x/sync v0.0.0-20220819030929-7fc1605a5dde // indirect\n\tgolang.org/x/sys v0.0.0-20220915200043-7b5979e65e41 // indirect\n\tgolang.org/x/term v0.0.0-20220722155259-a9ba230a4035 // indirect\n\tgolang.org/x/text v0.3.7 // indirect\n\tgolang.org/x/tools v0.1.12 // indirect\n\tgolang.org/x/xerrors v0.0.0-20220609144429-65e65417b02f // indirect\n\tgoogle.golang.org/api v0.93.0 // indirect\n\tgoogle.golang.org/appengine v1.6.7 // indirect\n\tgoogle.golang.org/protobuf v1.28.1 // indirect\n\tgopkg.in/ini.v1 v1.67.0 // indirect\n\tgopkg.in/yaml.v2 v2.4.0 // indirect\n\tgopkg.in/yaml.v3 v3.0.1 // indirect\n\thonnef.co/go/tools v0.3.3 // indirect\n\tmvdan.cc/gofumpt v0.4.0 // indirect\n\tmvdan.cc/interfacer v0.0.0-20180901003855-c20040233aed // indirect\n\tmvdan.cc/lint v0.0.0-20170908181259-adc824a0674b // indirect\n\tmvdan.cc/unparam v0.0.0-20220706161116-678bad134442 // indirect\n\tnhooyr.io/websocket v1.8.6 // indirect\n\tsigs.k8s.io/yaml v1.3.0 // indirect\n)\n\nreplace (\n\tgithub.com/gogo/protobuf => github.com/regen-network/protobuf v1.3.3-alpha.regen.1\n\tgithub.com/zondax/hid => github.com/zondax/hid v0.9.0\n)\nSee all 295 lines\nFor building the application, a Makefile is generally used. The Makefile primarily ensures that the go.mod is run before building the two entrypoints to the application, Node Client and Application Interface.\nHere is an example of the Cosmos Hub Makefile.",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "human",
            "name": null,
            "id": "c2064eb9-b62f-4e06-8a1b-9a8dd81f8411",
            "example": false
        },
        {
            "content": "{\n  \"Start the full node client\": 95,\n  \"Initialize a new Cosmos SDK blockchain\": 92,\n  \"Query the balance of an address\": 90,\n  \"Send 100token from address A to address B\": 88,\n  \"Generate genesis file with default modules\": 86,\n  \"Create and add a custom module to the app wiring config\": 84,\n  \"Set the order of BeginBlockers for modules\": 82,\n  \"Run the InitChainer to initialize state from genesis\": 80,\n  \"Mount KV stores for new module\": 78,\n  \"Register gRPC gateway routes for my module\": 76,\n  \"Register Msg service for bank module\": 74,\n  \"Register Query service for staking module\": 73,\n  \"Configure the application encoding config\": 72,\n  \"Build the appd binary\": 70,\n  \"Create staking delegate transaction\": 68,\n  \"Submit a governance text proposal\": 67,\n  \"Vote yes on proposal 5\": 66,\n  \"Set custom ante handler for my app\": 65,\n  \"Enable state sync snapshots with interval 1000\": 64,\n  \"Set custom inflation minting function\": 63,\n  \"Add a circuit breaker to the application baseapp\": 62,\n  \"Register upgrade handlers\": 61,\n  \"Export app state and validators\": 60,\n  \"Load application at block height 1000\": 59,\n  \"Trigger PrepareProposal handler override\": 58,\n  \"Add bank send CLI command\": 57,\n  \"Add transaction sign mode TEXTUAL\": 56,\n  \"Enable grpc and swagger in app.toml\": 55,\n  \"Set PreBlocker to update consensus params\": 54,\n  \"Generate default simulation manager\": 53,\n  \"Create module keeper with store keys\": 52,\n  \"Register interfaces in InterfaceRegistry\": 51,\n  \"Set order of InitGenesis for modules\": 50,\n  \"Add REST endpoints using grpc-gateway annotations\": 49,\n  \"Create a group with groupkeeper\": 48,\n  \"Grant fee allowance to address\": 47,\n  \"Enable inter-block cache\": 46,\n  \"Start chain with unsafe skip upgrade heights 100,200\": 45,\n  \"Register NFT module\": 44,\n  \"Configure gov max metadata length to 10000\": 43,\n  \"Create snapshot store in data/snapshots\": 42,\n  \"Set min gas prices to 0.01token\": 41,\n  \"Create protoc-generated tx and query services\": 40,\n  \"Execute simulation fuzz testing\": 39,\n  \"Add message to Bank module via tx command\": 38,\n  \"Register Swagger API routes\": 37,\n  \"Setup module account permissions\": 36,\n  \"Enable object-capabilities security model\": 35,\n  \"Create new bech32 address codec\": 34,\n  \"Set custom validator address codec\": 33,\n  \"Add wallet keys to keyring\": 32,\n  \"Query node status\": 31,\n  \"Query block at height 0 should return error\": 30,\n  \"Add streaming services to kv stores\": 29,\n  \"Create and sign multi-sign transaction\": 28,\n  \"Build docker image for the chain\": 27,\n  \"Generate Swagger docs for REST endpoints\": 26,\n  \"Configure gRPC address to 0.0.0.0:9090\": 25,\n  \"Create Tendermint service registration\": 24,\n  \"Run test gRPC query using testdata pulsar\": 23\n}",
            "additional_kwargs": {
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 2122,
                    "prompt_tokens": 95807,
                    "total_tokens": 97929,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 1344,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CQE7MMZJ3PF1wvXUeCpgfCZNchQ2t",
                "service_tier": "default",
                "finish_reason": "stop",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--d0916290-c2ad-4a76-9b75-2795c4e991b1-0",
            "example": false,
            "tool_calls": [],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 95807,
                "output_tokens": 2122,
                "total_tokens": 97929,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 1344
                }
            }
        }
    ]
}