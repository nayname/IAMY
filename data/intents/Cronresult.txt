{
    "messages": [
        {
            "content": "Cron Module\nSchedule automated smart contract executions with block-based timing\n\nThis document explains the cron module for the Neutron network.\nThe Cron module allows scheduling automatic smart contract executions at predefined block intervals, similar to Unix cron jobs. This feature enables time-based automation in blockchain applications through governance-controlled schedule management.\n\u200b\nTable of contents\nOverview \u2014 a high-level description of the module.\nExplanation \u2014 an explanation of the module\u2019s concepts and the reasoning behind its design choices.\nHow To \u2014 short guides on performing basic operations with the module.\nReference \u2014 comprehensive technical details including messages, events, state, client, and API documentation.\n\u200b\nConcepts\nThe Cron module serves as an on-chain block-based scheduling system that enables:\nScheduled Block Executions: Register messages to be executed at specific block intervals\nPeriodic Tasks: Set up recurring executions every N blocks\nGovernance-Controlled Scheduling: All schedule creation requires governance approval\n\u200b\nGovernance-Gated Access\nSchedule creation is controlled through governance (Main DAO or Cron SubDAO)\nContracts cannot directly create schedules\nSchedule management requires governance proposals\nThe Cron module operates within Neutron\u2019s modular governance system, which uses specialized subDAOs to handle different aspects of network management. The Cron SubDAO specifically manages scheduling-related proposals.\n\u200b\nBlock-Based Execution\nExecution timing is based on block heights, not precise timestamps\nThe module has a limit on how many schedules can be executed per block\nSchedules are identified by unique names for easy management\n\u200b\nOperation Flow\nA typical workflow using the Cron module consists of:\nGovernance Proposal: Submit a governance proposal to create a schedule specifying:\nA unique name\nThe execution period (in blocks)\nMessages to execute\nSchedule Tracking: The module maintains a registry of all schedules and tracks their execution status.\nAutomatic Execution: When a block is produced, the module:\nIdentifies schedules due for execution\nExecutes up to the per-block limit of schedules\nUpdates their last execution height\nSchedule Management: Through governance, schedules can be:\nRemoved when they\u2019re no longer needed\n\u200b\nIntegration with Smart Contracts\nThe Cron module integrates with smart contracts through:\nExecution Callbacks: The scheduled messages are sent to target contracts\nGovernance Proposals: Contract owners work with governance to create schedules\nThis allows developers to implement various block-based functionalities such as:\nRegular protocol maintenance operations\nPeriodic distribution schedules\nBlock-based DeFi operations\nAutomated governance actions\nReference\nExplanation\ntwitter\ndiscord\ntelegram\ngithub\n\n\nExplanation\nDetailed explanation of how the Cron module works and why it\u2019s designed this way\n\nThis document provides a technical explanation of the Cron module architecture, concepts, and design choices.\n\u200b\nWhat is the Cron Module?\nThe Cron module enables on-chain time-based automation by maintaining a registry of schedules and executing them at the appropriate block heights. Traditional blockchain applications require external triggers for time-sensitive operations, which creates several challenges:\nReliability concerns: External automation services might fail\nCentralization risks: Reliance on third-party services\nCoordination problems: Multiple actors might attempt the same operation\nTiming precision: Exact execution timing is difficult to ensure\nThe Cron module solves these problems by moving time-based automation directly onto the blockchain, ensuring deterministic, reliable, and decentralized execution of scheduled operations.\nGovernance-Only Access: The Cron module is governance-gated. Only the Main DAO or Cron SubDAO can create, modify, or remove schedules. Individual users and contracts cannot directly interact with this module.\n\u200b\nHow does the Cron module work?\nThe Cron module enables on-chain time-based automation through several components working together:\n\u200b\nSchedule Registration\nWhen a governance proposal creates a schedule, it specifies:\nA unique name for identification\nThe execution period (in blocks)\nOne or more CosmWasm contract messages to execute\nThe execution stage (BEGIN_BLOCKER or END_BLOCKER)\nThe module stores this schedule in its state and begins executing it according to the specified period.\n\u200b\nExecution Mechanism\nThe module hooks into Neutron\u2019s block production process to check for schedules due for execution:\nDuring each block\u2019s BeginBlock or EndBlock phase (depending on the schedule\u2019s execution_stage), the module queries for all schedules where:\n\nCopy\n\nAsk AI\ncurrent_block_height \u2265 (last_execution_height + period)\nThe module processes up to the configured limit of schedules per block to prevent resource exhaustion.\nFor each schedule that meets the execution condition:\nThe module constructs wasmtypes.MsgExecuteContract messages from the stored schedule data\nSets the sender as the Cron module account\nSets funds to empty (no tokens are sent)\nExecutes the messages using the WASM message server\nUpdates the schedule\u2019s last_execute_height to the current block height\nAtomicity: All messages within a single schedule must succeed, or the entire schedule execution is rolled back.\n\u200b\nSchedule Structure\nA schedule is the core data structure in the Cron module:\n\nCopy\n\nAsk AI\nmessage Schedule {\n  string name = 1;                           // Unique identifier\n  uint64 period = 2;                         // Blocks between executions  \n  repeated MsgExecuteContract msgs = 3;      // Messages to execute\n  uint64 last_execute_height = 4;           // Last execution block height\n}\n\nmessage MsgExecuteContract {\n  string contract = 1;                       // Contract address\n  string msg = 2;                           // JSON-encoded message\n}\n\u200b\nExecution Stages\nThe Cron module supports two execution stages:\nBEGIN_BLOCKER: Schedules are executed at the beginning of the block, before any transactions. This is useful for operations that need to happen before other transactions in the block.\nEND_BLOCKER: Schedules are executed at the end of the block, after all transactions. This is useful for operations that should occur after all other transactions in the block have been processed.\nThe choice of execution stage is important for dependencies between operations. For example, if a scheduled operation depends on the state resulting from regular transactions, it should use the END_BLOCKER stage.\n\u200b\nGovernance-Based Management\nSchedule creation is controlled through governance (Main DAO or Cron SubDAO)\nContracts cannot directly create schedules\nSchedule management requires governance proposals\nThis governance-gated approach ensures that critical automated processes cannot be tampered with by unauthorized parties and maintains the security and integrity of the network.\n\u200b\nSecurity Model\nThe Cron module implements several mechanisms to ensure security and prevent abuse:\n\u200b\nExecution Limits\nTo prevent DoS attacks and excessive resource consumption:\nThere\u2019s a network-wide limit parameter (default: configurable) that restricts the number of schedules processed in a single block\nIf more schedules are due than the limit allows, some are delayed until subsequent blocks\nSchedules are processed in deterministic order (by last execution height, then alphabetically by name)\n\u200b\nMessage Validation\nThe module validates messages before execution:\nMessages must be properly formatted JSON for CosmWasm contracts\nInvalid messages are rejected during schedule creation\nExecution failures are logged but don\u2019t stop other schedules from executing\n\u200b\nProtected State Access\nThe module\u2019s state can only be modified through governance:\nDirect state manipulation is not possible\nAll state changes follow proper authorization checks\nOnly governance proposals can manage schedules\n\u200b\nDesign Decisions\n\u200b\nWhy use block heights instead of timestamps?\nBlock heights provide several advantages over timestamps for scheduling:\nDeterminism: Block heights advance in a predictable manner, while block times can vary\nSimplicity: Working with integer increments is simpler than datetime calculations\nConsensus: All validators agree on the current block height without ambiguity\nHowever, this approach means that schedules are sensitive to changes in average block time. If block times slow down or speed up significantly, the real-world timing of scheduled executions will be affected.\n\u200b\nWhy allow multiple messages per schedule?\nSupporting multiple messages in a single schedule enables more complex workflows:\nAtomicity: Related operations can be grouped together and either all succeed or all fail\nEfficiency: Reduces the number of separate schedules needed\nSequence: Actions can be executed in a specific order within the same block\nThis approach simplifies common patterns like \u201cupdate state, then transfer funds\u201d or \u201ccheck condition, then execute action.\u201d\n\u200b\nWhy have different execution stages?\nHaving both BEGIN_BLOCKER and END_BLOCKER execution stages provides flexibility for different types of automated tasks:\nState Preparation: BEGIN_BLOCKER allows setting up state before any transactions in the block\nPost-Processing: END_BLOCKER enables operations that should occur after all transactions\nDependency Management: Different stages help manage dependencies between automated operations\nThis design allows for more complex automation workflows that respect the natural ordering of blockchain operations.\n\u200b\nWhy governance-gate the module?\nThe governance-only access pattern serves several important purposes:\nSecurity: Prevents malicious actors from creating disruptive schedules\nResource Management: Ensures only necessary automation is added to the network\nQuality Control: Community review process for all automated tasks\nAccountability: Clear ownership and responsibility for scheduled operations\n\u200b\nImplementation Considerations\n\u200b\nSchedule Execution Order\nWhen multiple schedules are due for execution in the same block, they are processed in a deterministic order:\nFirst by last_execution_height (schedules that haven\u2019t run in longer get priority)\nThen by name (alphabetical order for ties)\nThis ordering ensures fairness and prevents starvation of schedules.\n\u200b\nFailure Handling\nIf a scheduled message fails during execution:\nThe entire schedule\u2019s execution is rolled back (atomicity)\nThe failure is logged with details\nThe schedule\u2019s last_execution_height is still updated to prevent retry loops\nThe schedule continues to be processed in future blocks if it\u2019s periodic\nThis approach ensures that temporary failures don\u2019t permanently break scheduling logic while maintaining transaction atomicity.\n\u200b\nMessage Construction\nWhen executing schedules, the module constructs wasmtypes.MsgExecuteContract messages:\n\nCopy\n\nAsk AI\nmsg := wasmtypes.MsgExecuteContract{\n    Sender:   cronModuleAccount,  // Cron module account\n    Contract: scheduleMsg.Contract, // From schedule definition\n    Msg:      scheduleMsg.Msg,     // From schedule definition  \n    Funds:    sdk.Coins{},        // Always empty\n}\n\u200b\nModule Parameters\nNetwork-wide parameters that can be adjusted through governance:\nParameter\tDescription\tPurpose\nsecurity_address\tAddress authorized to remove schedules\tEmergency schedule removal\nlimit\tMaximum schedules executed per block\tResource management and DoS prevention\n\u200b\nMetrics and Monitoring\nThe Cron module collects several metrics for monitoring and observability:\nexecute_ready_schedules (histogram): Time taken to execute all ready schedules in EndBlocker\nschedule_count (gauge): Current number of active schedules\nschedule_executions_count (counter): Total schedule executions, labeled by success/failure and schedule name\nThese metrics help operators monitor the health and performance of the Cron module.\n\u200b\nBest Practices for Integration\n\u200b\nError Handling\nSince schedules might fail for various reasons, contracts should:\nMake scheduled operations idempotent (safe to execute multiple times)\nInclude validation within scheduled messages\nImplement fallback mechanisms for critical operations\nDesign messages to be robust against temporary failures\n\u200b\nSchedule Organization\nFor complex applications:\nUse descriptive, consistent naming schemes for schedules\nCreate separate schedules for independent operations\nConsider execution stages carefully to manage dependencies\nGroup related operations into single schedules for atomicity\n\u200b\nTypical Use Cases\nThe Cron module supports a wide range of time-based tasks:\n\u200b\nFinancial Operations\nInterest accrual: Regular updates to lending/borrowing rates\nVesting schedules: Gradual token unlocking over time\nReward distribution: Periodic rewards to stakers or liquidity providers\nFee collection: Regular harvesting of accumulated fees\n\u200b\nProtocol Maintenance\nState cleanup: Removing expired or obsolete data\nParameter updates: Scheduled changes to protocol parameters\nRebalancing: Periodic adjustments to maintain target ratios\nHealth checks: Regular validation of system state\n\u200b\nTime-Sensitive Events\nAuction endings: Automatic settlement at deadline\nGovernance execution: Implementing approved proposals after timelock\nEmergency procedures: Scheduled failsafes or circuit breakers\nMarket operations: Regular price updates or arbitrage opportunities\nAll of these use cases require governance approval to implement, ensuring that only legitimate and beneficial automation is added to the network.\nCron Module\nHow-to\ntwitter\ndiscord\ntelegram\ngithub\n\n\nHow-to\nStep-by-step instructions for using the Cron module through governance\n\nThis guide provides practical instructions for working with the Cron module, including creating governance proposals for schedules and handling scheduled executions in smart contracts.\n\u200b\nPrerequisites\nUnderstanding of Neutron governance processes\nFamiliarity with CosmWasm contract development\nAccess to governance proposal submission (for schedule creation)\n\u200b\nUnderstanding Cron Module Access\nThe Cron module is governance-gated, meaning:\nOnly governance can create or remove schedules\nIndividual users and contracts cannot directly interact with this module\nSchedule management requires proposals to either:\nMain DAO: Can create and remove any schedule\nSecurity SubDAO: Can remove schedules (emergency situations)\nNo Individual Access: Unlike other modules, the Cron module does not accept direct user transactions. All schedule management must go through governance proposals.\nNeutron uses a modular governance system with specialized subDAOs that handle different aspects of network management. The Security SubDAO can remove schedules in emergency situations, providing a safety mechanism for the network.\n\u200b\nCreating Schedules Through Governance\n\u200b\nStep 1: Prepare Your Governance Proposal\nTo create a schedule, you need to submit a governance proposal using the DAO contract format. Here\u2019s the structure for adding a schedule:\n\nCopy\n\nAsk AI\n{\n  \"title\": \"Add Daily Reward Distribution Schedule\",\n  \"description\": \"Creates a schedule to distribute rewards every 7200 blocks (approximately daily)\",\n  \"messages\": [\n    {\n      \"@type\": \"/neutron.cron.MsgAddSchedule\",\n      \"authority\": \"neutron1...\",\n      \"name\": \"daily_rewards\",\n      \"period\": 7200,\n      \"msgs\": [\n        {\n          \"contract\": \"neutron1contract...\",\n          \"msg\": \"{\\\"distribute_rewards\\\": {\\\"amount\\\": \\\"1000\\\"}}\"\n        }\n      ],\n      \"execution_stage\": \"EXECUTION_STAGE_END_BLOCKER\"\n    }\n  ]\n}\n\u200b\nStep 2: Understanding the Message Structure\nThe MsgAddSchedule message contains:\nauthority: Address of the governance authority\nname: Unique identifier for the schedule\nperiod: Number of blocks between executions\nmsgs: Array of contract messages to execute\ncontract: Address of the contract to call\nmsg: JSON string of the message to send\nexecution_stage: When to execute (EXECUTION_STAGE_BEGIN_BLOCKER or EXECUTION_STAGE_END_BLOCKER)\n\u200b\nStep 3: Submit the Governance Proposal\n\u200b\nStandard Governance Proposal\nSubmit the proposal using the standard governance module:\n\nCopy\n\nAsk AI\n# Submit governance proposal\nneutrond tx gov submit-proposal [proposal-file.json] \\\n  --from=<your-key> \\\n  --chain-id=neutron-1 \\\n  --gas=auto \\\n  --gas-adjustment=1.5\n\u200b\nStep 4: Governance Voting Process\nOnce submitted, the proposal goes through the standard governance process:\nProposal Period: Community can review the proposal\nVoting Period: NTRN token holders vote on the proposal\nExecution: If passed, the schedule is automatically created\n\u200b\nPreparing Your Contract for Scheduled Execution\n\u200b\nHandle Scheduled Messages\nYour contract must be prepared to receive messages from the Cron module account:\n\nCopy\n\nAsk AI\nuse cosmwasm_std::{\n    entry_point, DepsMut, Env, MessageInfo, Response, StdResult,\n};\n\n#[entry_point]\npub fn execute(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    msg: ExecuteMsg,\n) -> StdResult<Response> {\n    match msg {\n        ExecuteMsg::DistributeRewards { amount } => {\n            handle_scheduled_execution(deps, env, info, amount)\n        },\n        // Other handlers...\n    }\n}\n\nfn handle_scheduled_execution(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    amount: String,\n) -> StdResult<Response> {\n    // Note: The sender will be the Cron module account\n    // You can optionally validate this if needed\n    \n    // Perform your scheduled task\n    // This could be:\n    // - Updating state\n    // - Distributing rewards\n    // - Triggering other contract calls\n    // - Protocol maintenance tasks\n    \n    Ok(Response::new()\n        .add_attribute(\"action\", \"scheduled_task_executed\")\n        .add_attribute(\"sender\", info.sender.to_string())\n        .add_attribute(\"block_height\", env.block.height.to_string())\n        .add_attribute(\"amount\", amount))\n}\n\u200b\nDesign Considerations\nWhen designing your contract for scheduled execution:\n\nCopy\n\nAsk AI\n// Example: Periodic reward distribution with safety checks\nfn handle_scheduled_execution(\n    deps: DepsMut,\n    env: Env,\n    info: MessageInfo,\n    amount: String,\n) -> StdResult<Response> {\n    // Optional: Verify sender is Cron module (for extra security)\n    let cron_module_addr = \"neutron1...\"; // Known Cron module address\n    if info.sender != cron_module_addr {\n        return Err(StdError::generic_err(\"Unauthorized: not from Cron module\"));\n    }\n    \n    // Check if execution is appropriate (additional safety check)\n    let last_execution = LAST_EXECUTION.may_load(deps.storage)?.unwrap_or(0);\n    let blocks_since_last = env.block.height - last_execution;\n    \n    if blocks_since_last < MIN_BLOCKS_BETWEEN_EXECUTIONS {\n        return Ok(Response::new()\n            .add_attribute(\"action\", \"execution_skipped\")\n            .add_attribute(\"reason\", \"too_early\"));\n    }\n    \n    // Perform the actual task\n    distribute_rewards(deps, env, amount)?;\n    \n    // Update last execution height\n    LAST_EXECUTION.save(deps.storage, &env.block.height)?;\n    \n    Ok(Response::new()\n        .add_attribute(\"action\", \"rewards_distributed\")\n        .add_attribute(\"height\", env.block.height.to_string())\n        .add_attribute(\"amount\", amount))\n}\n\u200b\nCommon Use Cases and Examples\n\u200b\nProtocol Maintenance\nFor regular protocol maintenance tasks:\n\nCopy\n\nAsk AI\n{\n  \"title\": \"Add Daily Protocol Maintenance Schedule\",\n  \"description\": \"Performs daily maintenance tasks every 7200 blocks\",\n  \"messages\": [\n    {\n      \"@type\": \"/neutron.cron.MsgAddSchedule\",\n      \"authority\": \"neutron1...\",\n      \"name\": \"daily_maintenance\",\n      \"period\": 7200,\n      \"msgs\": [\n        {\n          \"contract\": \"neutron1protocol_contract...\",\n          \"msg\": \"{\\\"perform_maintenance\\\": {}}\"\n        }\n      ],\n      \"execution_stage\": \"EXECUTION_STAGE_END_BLOCKER\"\n    }\n  ]\n}\n\u200b\nReward Distribution\nFor periodic reward distribution:\n\nCopy\n\nAsk AI\n{\n  \"title\": \"Add Weekly Reward Distribution Schedule\",\n  \"description\": \"Distributes rewards every 50400 blocks (approximately weekly)\",\n  \"messages\": [\n    {\n      \"@type\": \"/neutron.cron.MsgAddSchedule\",\n      \"authority\": \"neutron1...\",\n      \"name\": \"weekly_rewards\",\n      \"period\": 50400,\n      \"msgs\": [\n        {\n          \"contract\": \"neutron1rewards_contract...\",\n          \"msg\": \"{\\\"distribute_rewards\\\": {\\\"validator\\\": \\\"channel-52\\\", \\\"recipient\\\": \\\"neutron123...\\\"}}\"\n        }\n      ],\n      \"execution_stage\": \"EXECUTION_STAGE_END_BLOCKER\"\n    }\n  ]\n}\n\u200b\nMulti-Message Schedule\nFor complex operations requiring multiple contract calls:\n\nCopy\n\nAsk AI\n{\n  \"title\": \"Add Multi-Step Protocol Update Schedule\",\n  \"description\": \"Performs multi-step protocol update every 100800 blocks\",\n  \"messages\": [\n    {\n      \"@type\": \"/neutron.cron.MsgAddSchedule\",\n      \"authority\": \"neutron1...\",\n      \"name\": \"protocol_update\",\n      \"period\": 100800,\n      \"msgs\": [\n        {\n          \"contract\": \"neutron1contract1...\",\n          \"msg\": \"{\\\"prepare_update\\\": {}}\"\n        },\n        {\n          \"contract\": \"neutron1contract2...\",\n          \"msg\": \"{\\\"apply_update\\\": {\\\"version\\\": \\\"2.0\\\"}}\"\n        },\n        {\n          \"contract\": \"neutron1contract3...\",\n          \"msg\": \"{\\\"notify_update_complete\\\": {}}\"\n        }\n      ],\n      \"execution_stage\": \"EXECUTION_STAGE_END_BLOCKER\"\n    }\n  ]\n}\n\u200b\nRemoving Schedules\n\u200b\nStandard Removal (Main DAO)\nTo remove a schedule through Main DAO governance:\n\nCopy\n\nAsk AI\n{\n  \"title\": \"Remove Daily Reward Distribution Schedule\",\n  \"description\": \"Removes the daily rewards distribution schedule as it's no longer needed\",\n  \"messages\": [\n    {\n      \"@type\": \"/neutron.cron.MsgRemoveSchedule\",\n      \"authority\": \"neutron1...\",\n      \"name\": \"daily_rewards\"\n    }\n  ]\n}\n\u200b\nEmergency Removal (Security SubDAO)\nThe Security SubDAO can also submit remove_schedule proposals for emergency situations:\n\nCopy\n\nAsk AI\n{\n  \"title\": \"Emergency Removal of Malfunctioning Schedule\",\n  \"description\": \"Emergency removal of schedule causing network issues\",\n  \"messages\": [\n    {\n      \"@type\": \"/neutron.cron.MsgRemoveSchedule\",\n      \"authority\": \"neutron1...\",\n      \"name\": \"problematic_schedule\"\n    }\n  ]\n}\n\u200b\nBest Practices\n\u200b\nGovernance Proposal Strategy\nClear Documentation: Include detailed rationale for the schedule\nCommunity Engagement: Discuss the proposal with the community first\nTesting: Test your contract\u2019s scheduled execution on testnet\nMonitoring: Plan for monitoring and maintenance of the schedule\n\u200b\nContract Design\nIdempotent Operations: Design scheduled tasks to be safely re-runnable\nError Handling: Implement robust error handling for scheduled executions\nState Validation: Add checks to prevent unexpected state changes\nLogging: Include comprehensive logging with meaningful attributes\nSender Verification: Optionally verify the sender is the Cron module account\n\u200b\nSchedule Parameters\nAppropriate Periods: Choose block intervals that match your use case\nDaily: ~7200 blocks (assuming 12-second blocks)\nWeekly: ~50400 blocks\nMonthly: ~216000 blocks\nExecution Stage: Choose BEGIN_BLOCKER or END_BLOCKER based on dependencies\nMessage Format: Ensure messages are valid JSON strings for contract execution\nAtomicity: Group related operations in a single schedule for atomic execution\nDescriptive Names: Use clear, descriptive names that indicate the schedule\u2019s purpose\n\u200b\nMonitoring and Troubleshooting\n\u200b\nQuerying Schedules\nTo check existing schedules:\n\nCopy\n\nAsk AI\n# List all schedules\nneutrond query cron list-schedule\n\n# Get specific schedule\nneutrond query cron show-schedule <schedule-name>\n\n# Check module parameters\nneutrond query cron params\n\u200b\nCommon Issues and Solutions\nIssue\tPossible Cause\tSolution\nProposal rejected\tInsufficient community support\tEngage with community, revise proposal\nSchedule not executing\tExecution failures or limit reached\tCheck contract logic, monitor events\nExecution failures\tInvalid message format or contract errors\tTest messages manually, check contract state\nSchedule not found\tGovernance proposal failed\tVerify proposal passed and was executed\n\u200b\nDebugging Steps\nVerify Governance: Check if the governance proposal passed and was executed\nQuery Schedule: Confirm the schedule exists with correct parameters\nMonitor Logs: Check validator logs for schedule execution information\nTest Manually: Execute the scheduled message manually to verify contract logic\nCheck Limits: Ensure the schedule isn\u2019t being skipped due to block limits\n\u200b\nEvent Monitoring\nThe Cron module does not emit blockchain events. Schedule execution and management operations are logged internally but do not generate events that can be monitored externally. Use the query commands to check schedule status and execution history.\n\u200b\nSecurity Considerations\n\u200b\nGovernance Security\nProposal Review: Thoroughly review all governance proposals\nCommunity Oversight: Ensure adequate community review period\nEmergency Procedures: Understand Security SubDAO removal capabilities\nTesting: Always test on testnet before mainnet proposals\n\u200b\nContract Security\nAccess Control: Consider implementing additional access controls in your contracts\nInput Validation: Validate all inputs in scheduled message handlers\nState Protection: Protect critical state from unauthorized modifications\nFailure Handling: Handle execution failures gracefully without breaking contract state\nThis governance-gated approach ensures that only approved schedules run on the network, maintaining security and preventing spam while enabling powerful automation capabilities for the Neutron ecosystem.\nExplanation\nReference\ntwitter\ndiscord\ntelegram\ngithub\n\n\nReference\nComprehensive technical reference for the Cron module\n\n\u200b\nMessages\nThe Cron module accepts messages through governance proposals only.\n\u200b\nMsgAddSchedule\nCreates a new schedule through governance proposal.\n\nCopy\n\nAsk AI\nmessage MsgAddSchedule {\n  string authority = 1;                      // The address of the governance account\n  string name = 2;                           // Unique identifier for the schedule\n  uint64 period = 3;                         // Number of blocks between executions\n  repeated MsgExecuteContract msgs = 4;      // Messages to execute\n  ExecutionStage execution_stage = 5;        // Execution stage (BEGIN_BLOCKER or END_BLOCKER)\n}\n\u200b\nMsgRemoveSchedule\nRemoves an existing schedule through governance proposal.\n\nCopy\n\nAsk AI\nmessage MsgRemoveSchedule {\n  string authority = 1;                      // The address of the governance account\n  string name = 2;                           // Name of the schedule to remove\n}\n\u200b\nMsgUpdateParams\nUpdates the module parameters through governance proposal.\n\nCopy\n\nAsk AI\nmessage MsgUpdateParams {\n  string authority = 1;                      // The address of the governance account\n  Params params = 2;                         // New module parameters\n}\n\u200b\nState\n\u200b\nSchedule\nThe primary state object in the Cron module:\n\nCopy\n\nAsk AI\nmessage Schedule {\n  string name = 1;                           // Unique identifier for the schedule\n  uint64 period = 2;                         // Number of blocks between executions\n  repeated MsgExecuteContract msgs = 3;      // Messages to execute when triggered\n  uint64 last_execute_height = 4;           // Last block height when executed\n  ExecutionStage execution_stage = 5;        // Execution stage\n}\n\u200b\nMsgExecuteContract\nDefines the contract and the message to execute:\n\nCopy\n\nAsk AI\nmessage MsgExecuteContract {\n  string contract = 1;                       // The address of the smart contract\n  string msg = 2;                            // JSON encoded message to be passed to the contract\n}\n\u200b\nExecutionStage\nDefines when messages will be executed in the block:\n\nCopy\n\nAsk AI\nenum ExecutionStage {\n  EXECUTION_STAGE_END_BLOCKER = 0;          // Execution at the end of the block\n  EXECUTION_STAGE_BEGIN_BLOCKER = 1;        // Execution at the beginning of the block\n}\n\u200b\nParams\nModule-wide parameters:\n\nCopy\n\nAsk AI\nmessage Params {\n  string security_address = 1;              // Security address that can remove schedules\n  uint64 limit = 2;                        // Limit of schedules executed in one block\n}\n\u200b\nScheduleCount\nTracks the number of current schedules:\n\nCopy\n\nAsk AI\nmessage ScheduleCount {\n  int32 count = 1;                          // The number of current schedules\n}\n\u200b\nQuery Methods\n\u200b\nParams\nReturns the module parameters.\nCLI Usage:\n\nCopy\n\nAsk AI\nneutrond query cron params\ngRPC Endpoint:\n\nCopy\n\nAsk AI\n/neutron/cron/params\n\u200b\nSchedule\nReturns a specific schedule by name.\nCLI Usage:\n\nCopy\n\nAsk AI\nneutrond query cron show-schedule [schedule-name]\ngRPC Endpoint:\n\nCopy\n\nAsk AI\n/neutron/cron/schedule/{name}\n\u200b\nSchedules\nReturns all schedules with pagination support.\nCLI Usage:\n\nCopy\n\nAsk AI\nneutrond query cron list-schedule\ngRPC Endpoint:\n\nCopy\n\nAsk AI\n/neutron/cron/schedule\n\u200b\nEvents\nThe Cron module does not emit any custom events. Schedule execution and management operations are logged but do not generate blockchain events.\n\u200b\nMetrics\nThe Cron module collects several metrics for monitoring:\nexecute_ready_schedules (histogram): Time taken to execute all ready schedules\nschedule_count (gauge): Current number of active schedules\nschedule_executions_count (counter): Total schedule executions, labeled by success/failure and schedule name\n\u200b\nClient\n\u200b\nQuery Commands\nThe neutrond CLI provides commands to query the Cron module:\n\nCopy\n\nAsk AI\n# Get all schedules\nneutrond query cron list-schedule\n\n# Get a specific schedule\nneutrond query cron show-schedule [schedule-name]\n\n# Get module parameters\nneutrond query cron params\n\u200b\nGovernance Proposals\nSince the Cron module is governance-gated, schedules can only be managed through governance proposals:\n\nCopy\n\nAsk AI\n# Submit a governance proposal to add a schedule\nneutrond tx gov submit-proposal [proposal-file]\n\n# Submit a governance proposal to remove a schedule\nneutrond tx gov submit-proposal [proposal-file]\nExample proposal file to add a schedule:\n\nCopy\n\nAsk AI\n{\n  \"title\": \"Add Cron Schedule\",\n  \"description\": \"Add a new cron schedule for periodic operations\",\n  \"messages\": [\n    {\n      \"@type\": \"/neutron.cron.MsgAddSchedule\",\n      \"authority\": \"neutron1...\",\n      \"name\": \"my-schedule\",\n      \"period\": \"100\",\n      \"msgs\": [\n        {\n          \"contract\": \"neutron1...\",\n          \"msg\": \"{\\\"execute_action\\\": {}}\"\n        }\n      ],\n      \"execution_stage\": \"EXECUTION_STAGE_END_BLOCKER\"\n    }\n  ]\n}\n\u200b\nAPI Endpoints\n\u200b\ngRPC Service\n\nCopy\n\nAsk AI\nservice Query {\n  // Parameters queries the parameters of the module\n  rpc Params(QueryParamsRequest) returns (QueryParamsResponse) {\n    option (google.api.http).get = \"/neutron/cron/params\";\n  }\n\n  // Queries a Schedule by name\n  rpc Schedule(QueryGetScheduleRequest) returns (QueryGetScheduleResponse) {\n    option (google.api.http).get = \"/neutron/cron/schedule/{name}\";\n  }\n\n  // Queries a list of Schedule items\n  rpc Schedules(QuerySchedulesRequest) returns (QuerySchedulesResponse) {\n    option (google.api.http).get = \"/neutron/cron/schedule\";\n  }\n}\n\u200b\nHTTP REST Endpoints\nGET /neutron/cron/params - Get module parameters\nGET /neutron/cron/schedule/{name} - Get specific schedule\nGET /neutron/cron/schedule - Get all schedules\nHow-to\nHarpoon Module\ntwitter\ndiscord\ntelegram\ngithub\n",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "human",
            "name": null,
            "id": "1f2a6ff5-c9ad-412a-812c-90153be60149",
            "example": false
        },
        {
            "content": "{\n  \"Create a cron schedule named daily_rewards that distributes rewards every 7200 blocks at END_BLOCKER\": 100,\n  \"Remove the cron schedule named daily_rewards\": 98,\n  \"List all existing cron schedules\": 96,\n  \"Show details for the cron schedule protocol_update\": 94,\n  \"Update cron limit parameter to 30 schedules per block\": 92,\n  \"Submit governance proposal to add daily reward distribution schedule\": 90,\n  \"Submit governance proposal to remove schedule weekly_rewards\": 88,\n  \"Create a weekly_rewards schedule that runs every 50400 blocks at END_BLOCKER\": 86,\n  \"Add a BEGIN_BLOCKER schedule for daily state cleanup every 7200 blocks\": 84,\n  \"Emergency remove schedule problematic_schedule via Security SubDAO\": 82,\n  \"Query cron module parameters\": 80,\n  \"Query specific schedule daily_maintenance\": 78,\n  \"Create a multi-message protocol_update schedule with three contract calls every 100800 blocks\": 76,\n  \"Set cron security address to neutron1guard...\": 74,\n  \"Create a vesting schedule for token unlock every 216000 blocks\": 72,\n  \"Create a fee_collection schedule to harvest fees every 1200 blocks\": 70,\n  \"Remove schedule protocol_update\": 68,\n  \"Create a schedule to rebalance portfolio every 3600 blocks\": 66,\n  \"Submit proposal to update cron parameters\": 64,\n  \"Create a schedule to perform health checks every 300 blocks\": 62,\n  \"Create a schedule to distribute staking rewards weekly\": 60,\n  \"Set cron execution stage to BEGIN_BLOCKER for schedule health_check\": 58,\n  \"Show the number of active cron schedules\": 56,\n  \"Show last execution height for schedule daily_rewards\": 54,\n  \"Create a governance proposal file for daily maintenance schedule\": 52,\n  \"Submit governance vote in favor of proposal 42 to add new schedule\": 50,\n  \"Create a schedule to trigger emergency fail-safe at BEGIN_BLOCKER every 50 blocks\": 48,\n  \"Query cron schedule count\": 46,\n  \"Update schedule daily_rewards period to 3600 blocks\": 44,\n  \"Create a schedule for automatic governance execution after timelock every 100 blocks\": 42,\n  \"Create a schedule to end auctions at END_BLOCKER every 50 blocks\": 40,\n  \"Create a schedule to collect interest accrual every block\": 38,\n  \"Remove all cron schedules through governance proposal\": 36,\n  \"Query cron params via gRPC\": 34,\n  \"Add a new schedule named fee_harvest with no tokens sent\": 32,\n  \"Cancel schedule named fee_harvest\": 30,\n  \"Set cron limit to 10 and security address to neutron1safe...\": 28,\n  \"Show cron metrics execute_ready_schedules latency\": 26,\n  \"List schedules ordered by last execute height\": 24,\n  \"Pause schedule daily_rewards by removing it\": 22,\n  \"Create a schedule to distribute monthly rewards every 216000 blocks\": 20,\n  \"Emergency remove schedule named broken_schedule due to failure\": 18,\n  \"Create a schedule named block_alert to send notification every block\": 16,\n  \"Add a BEGIN_BLOCKER schedule to prepare state before transactions\": 14,\n  \"Add an END_BLOCKER schedule to run post-processing tasks\": 12,\n  \"Update cron module security address\": 10,\n  \"Query cron module schedule list via REST endpoint\": 8,\n  \"List all schedules with pagination\": 6\n}",
            "additional_kwargs": {
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 3335,
                    "prompt_tokens": 7613,
                    "total_tokens": 10948,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 2560,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CBR23KlyiTioPiscBGqyGED2AXpCR",
                "service_tier": "default",
                "finish_reason": "stop",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--b87ce3b7-0396-4056-a275-9e80c4483192-0",
            "example": false,
            "tool_calls": [],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 7613,
                "output_tokens": 3335,
                "total_tokens": 10948,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 2560
                }
            }
        }
    ]
}