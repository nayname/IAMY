{
    "messages": [
        {
            "content": "User Guides\n\nCopy page\n\nVersion: v0.53\n\nThis section is designed for developers who are using the Cosmos SDK to build applications. It provides essential guides and references to effectively use the SDK\u2019s features.\nSetting up keys - Learn how to set up secure key management using the Cosmos SDK\u2019s keyring feature. This guide provides a streamlined approach to cryptographic key handling, which is crucial for securing your application.\nRunning a node - This guide provides step-by-step instructions to deploy and manage a node in the Cosmos network. It ensures a smooth and reliable operation of your blockchain application by covering all the necessary setup and maintenance steps.\nCLI - Discover how to navigate and interact with the Cosmos SDK using the Command Line Interface (CLI). This section covers efficient and powerful command-based operations that can help you manage your application effectively.\n\nRunning a Node, API and CLI\nSetting up the keyring\n\nCopy page\n\nSynopsis This document describes how to configure and use the keyring and its various backends for an application.\nThe keyring holds the private/public key pairs used to interact with a node. For instance, a validator key needs to be set up before running the blockchain node, so that blocks can be correctly signed. The private key can be stored in different locations, called \u201cbackends,\u201d such as a file or the operating system\u2019s own key storage.\n\u200b\nAvailable backends for the keyring\nStarting with the v0.38.0 release, Cosmos SDK comes with a new keyring implementation that provides a set of commands to manage cryptographic keys in a secure fashion. The new keyring supports multiple storage backends, some of which may not be available on all operating systems.\n\u200b\nThe os backend\nThe os backend relies on operating system-specific defaults to handle key storage securely. Typically, an operating system\u2019s credential subsystem handles password prompts, private keys storage, and user sessions according to the user\u2019s password policies. Here is a list of the most popular operating systems and their respective passwords manager:\nmacOS: Keychain\nWindows: Credentials Management API\nGNU/Linux:\nlibsecret\nkwallet\nkeyctl\nGNU/Linux distributions that use GNOME as the default desktop environment typically come with Seahorse. Users of KDE based distributions are commonly provided with KDE Wallet Manager. Whilst the former is in fact a libsecret convenient frontend, the latter is a kwallet client. keyctl is a secure backend that leverages the Linux\u2019s kernel security key management system to store cryptographic keys securely in memory.\nos is the default option since operating system\u2019s default credentials managers are designed to meet users\u2019 most common needs and provide them with a comfortable experience without compromising on security.\nThe recommended backends for headless environments are file and pass.\n\u200b\nThe file backend\nThe file backend more closely resembles the keybase implementation used prior to v0.38.1. It stores the keyring encrypted within the app\u2019s configuration directory. This keyring will request a password each time it is accessed, which may occur multiple times in a single command resulting in repeated password prompts. If using bash scripts to execute commands using the file option you may want to utilize the following format for multiple prompts:\n\nCopy\n\nAsk AI\n# assuming that KEYPASSWD is set in the environment\n$ gaiacli config keyring-backend file                             # use file backend\n$ (echo $KEYPASSWD; echo $KEYPASSWD) | gaiacli keys add me        # multiple prompts\n$ echo $KEYPASSWD | gaiacli keys show me                          # single prompt\nThe first time you add a key to an empty keyring, you will be prompted to type the password twice.\n\u200b\nThe pass backend\nThe pass backend uses the pass utility to manage on-disk encryption of keys\u2019 sensitive data and metadata. Keys are stored inside gpg encrypted files within app-specific directories. pass is available for the most popular UNIX operating systems as well as GNU/Linux distributions. Please refer to its manual page for information on how to download and install it.\npass uses GnuPG for encryption. gpg automatically invokes the gpg-agent daemon upon execution, which handles the caching of GnuPG credentials. Please refer to gpg-agent man page for more information on how to configure cache parameters such as credentials TTL and passphrase expiration.\nThe password store must be set up prior to first use:\n\nCopy\n\nAsk AI\npass init <GPG_KEY_ID>\nReplace <GPG_KEY_ID> with your GPG key ID. You can use your personal GPG key or an alternative one you may want to use specifically to encrypt the password store.\n\u200b\nThe kwallet backend\nThe kwallet backend uses KDE Wallet Manager, which comes installed by default on the GNU/Linux distributions that ships KDE as default desktop environment. Please refer to KWallet Handbook for more information.\n\u200b\nThe keyctl backend\nThe Kernel Key Retention Service is a security facility that has been added to the Linux kernel relatively recently. It allows sensitive cryptographic data such as passwords, private key, authentication tokens, etc to be stored securely in memory.\nThe keyctl backend is available on Linux platforms only.\n\u200b\nThe test backend\nThe test backend is a password-less variation of the file backend. Keys are stored unencrypted on disk.\nProvided for testing purposes only. The test backend is not recommended for use in production environments.\n\u200b\nThe memory backend\nThe memory backend stores keys in memory. The keys are immediately deleted after the program has exited.\nProvided for testing purposes only. The memory backend is not recommended for use in production environments.\n\u200b\nSetting backend using the env variable\nYou can set the keyring-backend using env variable: BINNAME_KEYRING_BACKEND. For example, if your binary name is gaia-v5 then set: export GAIA_V5_KEYRING_BACKEND=pass\n\u200b\nAdding keys to the keyring\nMake sure you can build your own binary, and replace simd with the name of your binary in the snippets.\nApplications developed using the Cosmos SDK come with the keys subcommand. For the purpose of this tutorial, we\u2019re running the simd CLI, which is an application built using the Cosmos SDK for testing and educational purposes. For more information, see simapp.\nYou can use simd keys for help about the keys command and simd keys [command] --help for more information about a particular subcommand.\nTo create a new key in the keyring, run the add subcommand with a <key_name> argument. For the purpose of this tutorial, we will solely use the test backend, and call our new key my_validator. This key will be used in the next section.\n\nCopy\n\nAsk AI\n$ simd keys add my_validator --keyring-backend test\n\n# Put the generated address in a variable for later use.\nMY_VALIDATOR_ADDRESS=$(simd keys show my_validator -a --keyring-backend test)\nThis command generates a new 24-word mnemonic phrase, persists it to the relevant backend, and outputs information about the keypair. If this keypair will be used to hold value-bearing tokens, be sure to write down the mnemonic phrase somewhere safe!\nBy default, the keyring generates a secp256k1 keypair. The keyring also supports ed25519 keys, which may be created by passing the --algo ed25519 flag. A keyring can of course hold both types of keys simultaneously, and the Cosmos SDK\u2019s x/auth module supports natively these two public key algorithms.\n\nRunning a Node\n\nCopy page\n\nSynopsis Now that the application is ready and the keyring populated, it\u2019s time to see how to run the blockchain node. In this section, the application we are running is called simapp, and its corresponding CLI binary simd.\nPre-requisite Readings\nAnatomy of a Cosmos SDK Application\nSetting up the keyring\n\u200b\nInitialize the Chain\nMake sure you can build your own binary, and replace simd with the name of your binary in the snippets.\nBefore actually running the node, we need to initialize the chain, and most importantly, its genesis file. This is done with the init subcommand:\n\nCopy\n\nAsk AI\n# The argument <moniker> is the custom username of your node, it should be human-readable.\nsimd init <moniker> --chain-id my-test-chain\nThe command above creates all the configuration files needed for your node to run, as well as a default genesis file, which defines the initial state of the network.\nAll these configuration files are in ~/.simapp by default, but you can overwrite the location of this folder by passing the --home flag to each command, or set an $APPD_HOME environment variable (where APPD is the name of the binary).\nThe ~/.simapp folder has the following structure:\n\nCopy\n\nAsk AI\n.                                   # ~/.simapp\n  |- data                           # Contains the databases used by the node.\n  |- config/\n      |- app.toml                   # Application-related configuration file.\n      |- config.toml                # CometBFT-related configuration file.\n      |- genesis.json               # The genesis file.\n      |- node_key.json              # Private key to use for node authentication in the p2p protocol.\n      |- priv_validator_key.json    # Private key to use as a validator in the consensus protocol.\n\u200b\nUpdating Some Default Settings\nIf you want to change any field values in configuration files (for ex: genesis.json) you can use jq (installation & docs) & sed commands to do that. Few examples are listed here.\n\nCopy\n\nAsk AI\n# to change the chain-id\njq '.chain_id = \"testing\"' genesis.json > temp.json && mv temp.json genesis.json\n\n# to enable the api server\nsed -i '/\\[api\\]/,+3 s/enable = false/enable = true/' app.toml\n\n# to change the voting_period\njq '.app_state.gov.voting_params.voting_period = \"600s\"' genesis.json > temp.json && mv temp.json genesis.json\n\n# to change the inflation\njq '.app_state.mint.minter.inflation = \"0.300000000000000000\"' genesis.json > temp.json && mv temp.json genesis.json\nSee all 11 lines\n\u200b\nClient Interaction\nWhen instantiating a node, GRPC and REST are defaulted to localhost to avoid unknown exposure of your node to the public. It is recommended to not expose these endpoints without a proxy that can handle load balancing or authentication is set up between your node and the public.\nA commonly used tool for this is nginx.\n\u200b\nAdding Genesis Accounts\nBefore starting the chain, you need to populate the state with at least one account. To do so, first create a new account in the keyring named my_validator under the test keyring backend (feel free to choose another name and another backend).\nNow that you have created a local account, go ahead and grant it some stake tokens in your chain\u2019s genesis file. Doing so will also make sure your chain is aware of this account\u2019s existence:\n\nCopy\n\nAsk AI\nsimd genesis add-genesis-account $MY_VALIDATOR_ADDRESS 100000000000stake\nRecall that $MY_VALIDATOR_ADDRESS is a variable that holds the address of the my_validator key in the keyring. Also note that the tokens in the Cosmos SDK have the {amount}{denom} format: amount is an 18-digit-precision decimal number, and denom is the unique token identifier with its denomination key (e.g. atom or uatom). Here, we are granting stake tokens, as stake is the token identifier used for staking in simapp. For your own chain with its own staking denom, that token identifier should be used instead.\nNow that your account has some tokens, you need to add a validator to your chain. Validators are special full-nodes that participate in the consensus process (implemented in the underlying consensus engine) in order to add new blocks to the chain. Any account can declare its intention to become a validator operator, but only those with sufficient delegation get to enter the active set (for example, only the top 125 validator candidates with the most delegation get to be validators in the Cosmos Hub). For this guide, you will add your local node (created via the init command above) as a validator of your chain. Validators can be declared before a chain is first started via a special transaction included in the genesis file called a gentx:\n\nCopy\n\nAsk AI\n# Create a gentx.\nsimd genesis gentx my_validator 100000000stake --chain-id my-test-chain --keyring-backend test\n\n# Add the gentx to the genesis file.\nsimd genesis collect-gentxs\nA gentx does three things:\nRegisters the validator account you created as a validator operator account (i.e., the account that controls the validator).\nSelf-delegates the provided amount of staking tokens.\nLink the operator account with a CometBFT node pubkey that will be used for signing blocks. If no --pubkey flag is provided, it defaults to the local node pubkey created via the simd init command above.\nFor more information on gentx, use the following command:\n\nCopy\n\nAsk AI\nsimd genesis gentx --help\n\u200b\nConfiguring the Node Using app.toml and config.toml\nThe Cosmos SDK automatically generates two configuration files inside ~/.simapp/config:\nconfig.toml: used to configure the CometBFT, learn more on CometBFT\u2019s documentation,\napp.toml: generated by the Cosmos SDK, and used to configure your app, such as state pruning strategies, telemetry, gRPC and REST servers configuration, state sync\u2026\nBoth files are heavily commented, please refer to them directly to tweak your node.\nOne example config to tweak is the minimum-gas-prices field inside app.toml, which defines the minimum gas prices the validator node is willing to accept for processing a transaction. Depending on the chain, it might be an empty string or not. If it\u2019s empty, make sure to edit the field with some value, for example 10token, or else the node will halt on startup. For the purpose of this tutorial, let\u2019s set the minimum gas price to 0:\n\nCopy\n\nAsk AI\n # The minimum gas prices a validator is willing to accept for processing a\n # transaction. A transaction's fees must meet the minimum of any denomination\n # specified in this config (e.g. 0.25token1;0.0001token2).\n minimum-gas-prices = \"0stake\"\nWhen running a node (not a validator!) and not wanting to run the application mempool, set the max-txs field to -1.\n\nCopy\n\nAsk AI\n[mempool]\n# Setting max-txs to 0 will allow for an unbounded amount of transactions in the mempool.\n# Setting max_txs to negative 1 (-1) will disable transactions from being inserted into the mempool.\n# Setting max_txs to a positive number (> 0) will limit the number of transactions in the mempool, by the specified amount.\n#\n# Note, this configuration only applies to SDK built-in app-side mempool\n# implementations.\nmax-txs = \"-1\"\n\u200b\nRun a Localnet\nNow that everything is set up, you can finally start your node:\n\nCopy\n\nAsk AI\nsimd start\nYou should see blocks come in.\nThe previous command allows you to run a single node. This is enough for the next section on interacting with this node, but you may wish to run multiple nodes at the same time, and see how consensus happens between them.\nThe naive way would be to run the same commands again in separate terminal windows. This is possible, however, in the Cosmos SDK, we leverage the power of Docker Compose to run a localnet. If you need inspiration on how to set up your own localnet with Docker Compose, you can have a look at the Cosmos SDK\u2019s docker-compose.yml.\n\u200b\nStandalone App/CometBFT\nBy default, the Cosmos SDK runs CometBFT in-process with the application If you want to run the application and CometBFT in separate processes, start the application with the --with-comet=false flag and set rpc.laddr in config.toml to the CometBFT node\u2019s RPC address.\n\u200b\nLogging\nLogging provides a way to see what is going on with a node. The default logging level is info. This is a global level and all info logs will be outputted to the terminal. If you would like to filter specific logs to the terminal instead of all, then setting module:log_level is how this can work.\nExample:\nIn config.toml:\n\nCopy\n\nAsk AI\nlog_level: \"state:info,p2p:info,consensus:info,x/staking:info,x/ibc:info,*error\"\n\u200b\nState Sync\nState sync is the act in which a node syncs the latest or close to the latest state of a blockchain. This is useful for users who don\u2019t want to sync all the blocks in history. Read more in CometBFT documentation.\nState sync works thanks to snapshots. Read how the SDK handles snapshots here.\n\u200b\nLocal State Sync\nLocal state sync works similar to normal state sync except that it works off a local snapshot of state instead of one provided via the p2p network. The steps to start local state sync are similar to normal state sync with a few different designs.\nAs mentioned in Link, one must set a height and hash in the config.toml along with a few rpc servers (the aforementioned link has instructions on how to do this).\nRun <appd snapshot restore <height> <format> to restore a local snapshot (note: first load it from a file with the load command).\nBootstrapping Comet state to start the node after the snapshot has been ingested. This can be done with the bootstrap command <app> comet bootstrap-state\n\u200b\nSnapshots Commands\nThe Cosmos SDK provides commands for managing snapshots. These commands can be added in an app with the following snippet in cmd/<app>/root.go:\n\nCopy\n\nAsk AI\nimport (\n    \n  \"github.com/cosmos/cosmos-sdk/client/snapshot\"\n)\n\nfunc initRootCmd(/* ... */) {\n  // ...\n  rootCmd.AddCommand(\n    snapshot.Cmd(appCreator),\n  )\n}\nThen the following commands are available at <appd> snapshots [command]:\nlist: list local snapshots\nload: Load a snapshot archive file into snapshot store\nrestore: Restore app state from local snapshot\nexport: Export app state to snapshot store\ndump: Dump the snapshot as portable archive format\ndelete: Delete a local snapshot\n\nInteracting with the Node\n\nCopy page\n\nSynopsis There are multiple ways to interact with a node: using the CLI, using gRPC or using the REST endpoints.\nPre-requisite Readings\ngRPC, REST and CometBFT Endpoints\nRunning a Node\n\u200b\nUsing the CLI\nNow that your chain is running, it is time to try sending tokens from the first account you created to a second account. In a new terminal window, start by running the following query command:\n\nCopy\n\nAsk AI\nsimd query bank balances $MY_VALIDATOR_ADDRESS\nYou should see the current balance of the account you created, equal to the original balance of stake you granted it minus the amount you delegated via the gentx. Now, create a second account:\n\nCopy\n\nAsk AI\nsimd keys add recipient --keyring-backend test\n\n# Put the generated address in a variable for later use.\nRECIPIENT=$(simd keys show recipient -a --keyring-backend test)\nThe command above creates a local key-pair that is not yet registered on the chain. An account is created the first time it receives tokens from another account. Now, run the following command to send tokens to the recipient account:\n\nCopy\n\nAsk AI\nsimd tx bank send $MY_VALIDATOR_ADDRESS $RECIPIENT 1000000stake --chain-id my-test-chain --keyring-backend test\n\n# Check that the recipient account did receive the tokens.\nsimd query bank balances $RECIPIENT\nFinally, delegate some of the stake tokens sent to the recipient account to the validator:\n\nCopy\n\nAsk AI\nsimd tx staking delegate $(simd keys show my_validator --bech val -a --keyring-backend test) 500stake --from recipient --chain-id my-test-chain --keyring-backend test\n\n# Query the total delegations to `validator`.\nsimd query staking delegations-to $(simd keys show my_validator --bech val -a --keyring-backend test)\nYou should see two delegations, the first one made from the gentx, and the second one you just performed from the recipient account.\n\u200b\nUsing gRPC\nThe Protobuf ecosystem developed tools for different use cases, including code-generation from *.proto files into various languages. These tools allow the building of clients easily. Often, the client connection (i.e. the transport) can be plugged and replaced very easily. Let\u2019s explore one of the most popular transport: gRPC.\nSince the code generation library largely depends on your own tech stack, we will only present three alternatives:\ngrpcurl for generic debugging and testing,\nprogrammatically via Go,\nCosmJS for JavaScript/TypeScript developers.\n\u200b\ngrpcurl\ngrpcurl is like curl but for gRPC. It is also available as a Go library, but we will use it only as a CLI command for debugging and testing purposes. Follow the instructions in the previous link to install it.\nAssuming you have a local node running (either a localnet, or connected a live network), you should be able to run the following command to list the Protobuf services available (you can replace localhost:9000 by the gRPC server endpoint of another node, which is configured under the grpc.address field inside app.toml):\n\nCopy\n\nAsk AI\ngrpcurl -plaintext localhost:9090 list\nYou should see a list of gRPC services, like cosmos.bank.v1beta1.Query. This is called reflection, which is a Protobuf endpoint returning a description of all available endpoints. Each of these represents a different Protobuf service, and each service exposes multiple RPC methods you can query against.\nIn order to get a description of the service you can run the following command:\n\nCopy\n\nAsk AI\ngrpcurl -plaintext \\\n    localhost:9090 \\\n    describe cosmos.bank.v1beta1.Query                  # Service we want to inspect\nIt\u2019s also possible to execute an RPC call to query the node for information:\n\nCopy\n\nAsk AI\ngrpcurl \\\n    -plaintext \\\n    -d \"{\\\"address\\\":\\\"$MY_VALIDATOR_ADDRESS\\\"}\" \\\n    localhost:9090 \\\n    cosmos.bank.v1beta1.Query/AllBalances\nThe list of all available gRPC query endpoints is coming soon.\n\u200b\nQuery for historical state using grpcurl\nYou may also query for historical data by passing some gRPC metadata to the query: the x-cosmos-block-height metadata should contain the block to query. Using grpcurl as above, the command looks like:\n\nCopy\n\nAsk AI\ngrpcurl \\\n    -plaintext \\\n    -H \"x-cosmos-block-height: 123\" \\\n    -d \"{\\\"address\\\":\\\"$MY_VALIDATOR_ADDRESS\\\"}\" \\\n    localhost:9090 \\\n    cosmos.bank.v1beta1.Query/AllBalances\nAssuming the state at that block has not yet been pruned by the node, this query should return a non-empty response.\n\u200b\nProgrammatically via Go\nThe following snippet shows how to query the state using gRPC inside a Go program. The idea is to create a gRPC connection, and use the Protobuf-generated client code to query the gRPC server.\n\u200b\nInstall Cosmos SDK\n\nCopy\n\nAsk AI\ngo get github.com/cosmos/cosmos-sdk@main\n\nCopy\n\nAsk AI\npackage main\n\nimport (\n    \n    \"context\"\n    \"fmt\"\n    \"google.golang.org/grpc\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n    sdk \"github.com/cosmos/cosmos-sdk/types\"\n    banktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n)\n\nfunc queryState()\n\nerror {\n    myAddress, err := sdk.AccAddressFromBech32(\"cosmos1...\") // the my_validator or recipient address.\n    if err != nil {\n    return err\n}\n\n    // Create a connection to the gRPC server.\n    grpcConn, err := grpc.Dial(\n        \"127.0.0.1:9090\", // your gRPC server address.\n        grpc.WithInsecure(), // The Cosmos SDK doesn't support any transport security mechanism. \n        // This instantiates a general gRPC codec which handles proto bytes. We pass in a nil interface registry\n        // if the request/response types contain interface instead of 'nil' you should pass the application specific codec.\n\t\tgrpc.WithDefaultCallOptions(grpc.ForceCodec(codec.NewProtoCodec(nil).GRPCCodec())),\n\t)\n    if err != nil {\n    return err\n}\n\ndefer grpcConn.Close()\n\n    // This creates a gRPC client to query the x/bank service.\n    bankClient := banktypes.NewQueryClient(grpcConn)\n\nbankRes, err := bankClient.Balance(\n        context.Background(),\n        &banktypes.QueryBalanceRequest{\n    Address: myAddress.String(),\n    Denom: \"stake\"\n},\n    )\n    if err != nil {\n    return err\n}\n\nfmt.Println(bankRes.GetBalance()) // Prints the account balance\n\n    return nil\n}\n\nfunc main() {\n    if err := queryState(); err != nil {\n    panic(err)\n}\n}\nSee all 58 lines\nYou can replace the query client (here we are using x/bank\u2019s) with one generated from any other Protobuf service. The list of all available gRPC query endpoints is coming soon.\n\u200b\nQuery for historical state using Go\nQuerying for historical blocks is done by adding the block height metadata in the gRPC request.\n\nCopy\n\nAsk AI\npackage main\n\nimport (\n    \n\t\"context\"\n    \"fmt\"\n    \"google.golang.org/grpc\"\n    \"google.golang.org/grpc/metadata\"\n    \"github.com/cosmos/cosmos-sdk/codec\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n\tgrpctypes \"github.com/cosmos/cosmos-sdk/types/grpc\"\n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n)\n\nfunc queryState()\n\nerror {\n    myAddress, err := sdk.AccAddressFromBech32(\"cosmos1yerherx4d43gj5wa3zl5vflj9d4pln42n7kuzu\") // the my_validator or recipient address.\n    if err != nil {\n    return err\n}\n\n\t// Create a connection to the gRPC server.\n\tgrpcConn, err := grpc.Dial(\n\t\t\"127.0.0.1:9090\",    // your gRPC server address.\n\t\tgrpc.WithInsecure(), // The Cosmos SDK doesn't support any transport security mechanism.\n\t\t// This instantiates a general gRPC codec which handles proto bytes. We pass in a nil interface registry\n\t\t// if the request/response types contain interface instead of 'nil' you should pass the application specific codec.\n\t\tgrpc.WithDefaultCallOptions(grpc.ForceCodec(codec.NewProtoCodec(nil).GRPCCodec())),\n\t)\n    if err != nil {\n    return err\n}\n\ndefer grpcConn.Close()\n\n\t// This creates a gRPC client to query the x/bank service.\n    bankClient := banktypes.NewQueryClient(grpcConn)\n\nvar header metadata.MD\n\t_, err = bankClient.Balance(\n\t\tmetadata.AppendToOutgoingContext(context.Background(), grpctypes.GRPCBlockHeightHeader, \"12\"), // Add metadata to request\n\t\t&banktypes.QueryBalanceRequest{\n    Address: myAddress.String(),\n    Denom: \"stake\"\n},\n\t\tgrpc.Header(&header), // Retrieve header from response\n\t)\n    if err != nil {\n    return err\n}\n    blockHeight := header.Get(grpctypes.GRPCBlockHeightHeader)\n\nfmt.Println(blockHeight) // Prints the block height (12)\n\nreturn nil\n}\n\nfunc main() {\n    if err := queryState(); err != nil {\n    panic(err)\n}\n}\nSee all 63 lines\n\u200b\nCosmJS\nCosmJS documentation can be found at Link. As of January 2021, CosmJS documentation is still work in progress.\n\u200b\nUsing the REST Endpoints\nAs described in the gRPC guide, all gRPC services on the Cosmos SDK are made available for more convenient REST-based queries through gRPC-gateway. The format of the URL path is based on the Protobuf service method\u2019s full-qualified name, but may contain small customizations so that final URLs look more idiomatic. For example, the REST endpoint for the cosmos.bank.v1beta1.Query/AllBalances method is GET /cosmos/bank/v1beta1/balances/{address}. Request arguments are passed as query parameters.\nNote that the REST endpoints are not enabled by default. To enable them, edit the api section of your ~/.simapp/config/app.toml file:\n\nCopy\n\nAsk AI\n# Enable defines if the API server should be enabled.\nenable = true\nAs a concrete example, the curl command to make balances request is:\n\nCopy\n\nAsk AI\ncurl \\\n    -X GET \\\n    -H \"Content-Type: application/json\" \\\n    http://localhost:1317/cosmos/bank/v1beta1/balances/$MY_VALIDATOR_ADDRESS\nMake sure to replace localhost:1317 with the REST endpoint of your node, configured under the api.address field.\nThe list of all available REST endpoints is available as a Swagger specification file, it can be viewed at localhost:1317/swagger. Make sure that the api.swagger field is set to true in your app.toml file.\n\u200b\nQuery for historical state using REST\nQuerying for historical state is done using the HTTP header x-cosmos-block-height. For example, a curl command would look like:\n\nCopy\n\nAsk AI\ncurl \\\n    -X GET \\\n    -H \"Content-Type: application/json\" \\\n    -H \"x-cosmos-block-height: 123\" \\\n    http://localhost:1317/cosmos/bank/v1beta1/balances/$MY_VALIDATOR_ADDRESS\nAssuming the state at that block has not yet been pruned by the node, this query should return a non-empty response.\n\u200b\nCross-Origin Resource Sharing (CORS)\nCORS policies are not enabled by default to help with security. If you would like to use the rest-server in a public environment we recommend you provide a reverse proxy, this can be done with nginx. For testing and development purposes there is an enabled-unsafe-cors field inside app.toml.\n\n\nGenerating, Signing and Broadcasting Transactions\n\nCopy page\n\nSynopsis This document describes how to generate an (unsigned) transaction, signing it (with one or multiple keys), and broadcasting it to the network.\n\u200b\nUsing the CLI\nThe easiest way to send transactions is using the CLI, as we have seen in the previous page when interacting with a node. For example, running the following command\n\nCopy\n\nAsk AI\nsimd tx bank send $MY_VALIDATOR_ADDRESS $RECIPIENT 1000stake --chain-id my-test-chain --keyring-backend test\nwill run the following steps:\ngenerate a transaction with one Msg (x/bank\u2019s MsgSend), and print the generated transaction to the console.\nask the user for confirmation to send the transaction from the $MY_VALIDATOR_ADDRESS account.\nfetch $MY_VALIDATOR_ADDRESS from the keyring. This is possible because we have set up the CLI\u2019s keyring in a previous step.\nsign the generated transaction with the keyring\u2019s account.\nbroadcast the signed transaction to the network. This is possible because the CLI connects to the node\u2019s CometBFT RPC endpoint.\nThe CLI bundles all the necessary steps into a simple-to-use user experience. However, it\u2019s possible to run all the steps individually too.\n\u200b\nGenerating a Transaction\nGenerating a transaction can simply be done by appending the --generate-only flag on any tx command, e.g.:\n\nCopy\n\nAsk AI\nsimd tx bank send $MY_VALIDATOR_ADDRESS $RECIPIENT 1000stake --chain-id my-test-chain --generate-only\nThis will output the unsigned transaction as JSON in the console. We can also save the unsigned transaction to a file (to be passed around between signers more easily) by appending > unsigned_tx.json to the above command.\n\u200b\nSigning a Transaction\nSigning a transaction using the CLI requires the unsigned transaction to be saved in a file. Let\u2019s assume the unsigned transaction is in a file called unsigned_tx.json in the current directory (see previous paragraph on how to do that). Then, simply run the following command:\n\nCopy\n\nAsk AI\nsimd tx sign unsigned_tx.json --chain-id my-test-chain --keyring-backend test --from $MY_VALIDATOR_ADDRESS\nThis command will decode the unsigned transaction and sign it with SIGN_MODE_DIRECT with $MY_VALIDATOR_ADDRESS\u2019s key, which we already set up in the keyring. The signed transaction will be output as JSON to the console, and, as above, we can save it to a file by appending --output-document signed_tx.json.\nSome useful flags to consider in the tx sign command:\n--sign-mode: you may use amino-json to sign the transaction using SIGN_MODE_LEGACY_AMINO_JSON,\n--offline: sign in offline mode. This means that the tx sign command doesn\u2019t connect to the node to retrieve the signer\u2019s account number and sequence, both needed for signing. In this case, you must manually supply the --account-number and --sequence flags. This is useful for offline signing, i.e. signing in a secure environment which doesn\u2019t have access to the internet.\n\u200b\nSigning with Multiple Signers\nPlease note that signing a transaction with multiple signers or with a multisig account, where at least one signer uses SIGN_MODE_DIRECT, is not yet possible. You may follow this Github issue for more info.\nSigning with multiple signers is done with the tx multisign command. This command assumes that all signers use SIGN_MODE_LEGACY_AMINO_JSON. The flow is similar to the tx sign command flow, but instead of signing an unsigned transaction file, each signer signs the file signed by previous signer(s). The tx multisign command will append signatures to the existing transactions. It is important that signers sign the transaction in the same order as given by the transaction, which is retrievable using the GetSigners() method.\nFor example, starting with the unsigned_tx.json, and assuming the transaction has 4 signers, we would run:\n\nCopy\n\nAsk AI\n# Let signer1 sign the unsigned tx.\nsimd tx multisign unsigned_tx.json signer_key_1 --chain-id my-test-chain --keyring-backend test > partial_tx_1.json\n# Now signer1 will send the partial_tx_1.json to the signer2.\n# Signer2 appends their signature:\nsimd tx multisign partial_tx_1.json signer_key_2 --chain-id my-test-chain --keyring-backend test > partial_tx_2.json\n# Signer2 sends the partial_tx_2.json file to signer3, and signer3 can append his signature:\nsimd tx multisign partial_tx_2.json signer_key_3 --chain-id my-test-chain --keyring-backend test > partial_tx_3.json\n\u200b\nBroadcasting a Transaction\nBroadcasting a transaction is done using the following command:\n\nCopy\n\nAsk AI\nsimd tx broadcast tx_signed.json\nYou may optionally pass the --broadcast-mode flag to specify which response to receive from the node:\nsync: the CLI waits for a CheckTx execution response only.\nasync: the CLI returns immediately (transaction might fail).\n\u200b\nEncoding a Transaction\nIn order to broadcast a transaction using the gRPC or REST endpoints, the transaction will need to be encoded first. This can be done using the CLI.\nEncoding a transaction is done using the following command:\n\nCopy\n\nAsk AI\nsimd tx encode tx_signed.json\nThis will read the transaction from the file, serialize it using Protobuf, and output the transaction bytes as base64 in the console.\n\u200b\nDecoding a Transaction\nThe CLI can also be used to decode transaction bytes.\nDecoding a transaction is done using the following command:\n\nCopy\n\nAsk AI\nsimd tx decode [protobuf-byte-string]\nThis will decode the transaction bytes and output the transaction as JSON in the console. You can also save the transaction to a file by appending > tx.json to the above command.\n\u200b\nProgrammatically with Go\nIt is possible to manipulate transactions programmatically via Go using the Cosmos SDK\u2019s TxBuilder interface.\n\u200b\nGenerating a Transaction\nBefore generating a transaction, a new instance of a TxBuilder needs to be created. Since the Cosmos SDK supports both Amino and Protobuf transactions, the first step would be to decide which encoding scheme to use. All the subsequent steps remain unchanged, whether you\u2019re using Amino or Protobuf, as TxBuilder abstracts the encoding mechanisms. In the following snippet, we will use Protobuf.\n\nCopy\n\nAsk AI\nimport (\n    \n\t\"github.com/cosmos/cosmos-sdk/simapp\"\n)\n\nfunc sendTx()\n\nerror {\n    // Choose your codec: Amino or Protobuf. Here, we use Protobuf, given by the following function.\n    app := simapp.NewSimApp(...)\n\n    // Create a new TxBuilder.\n    txBuilder := app.TxConfig().NewTxBuilder()\n\n    // --snip--\n}\nSee all 16 lines\nWe can also set up some keys and addresses that will send and receive the transactions. Here, for the purpose of the tutorial, we will be using some dummy data to create keys.\n\nCopy\n\nAsk AI\nimport (\n    \n\t\"github.com/cosmos/cosmos-sdk/testutil/testdata\"\n)\n\npriv1, _, addr1 := testdata.KeyTestPubAddr()\n\npriv2, _, addr2 := testdata.KeyTestPubAddr()\n\npriv3, _, addr3 := testdata.KeyTestPubAddr()\nPopulating the TxBuilder can be done via its methods:\n\nCopy\n\nAsk AI\npackage client\n\nimport (\n    \n\t\"time\"\n\n\ttxsigning \"cosmossdk.io/x/tx/signing\"\n\n\tcodectypes \"github.com/cosmos/cosmos-sdk/codec/types\"\n\tsdk \"github.com/cosmos/cosmos-sdk/types\"\n    \"github.com/cosmos/cosmos-sdk/types/tx\"\n\tsigningtypes \"github.com/cosmos/cosmos-sdk/types/tx/signing\"\n    \"github.com/cosmos/cosmos-sdk/x/auth/signing\"\n)\n\ntype (\n\t// TxEncodingConfig defines an interface that contains transaction\n\t// encoders and decoders\n\tTxEncodingConfig interface {\n    TxEncoder()\n\nsdk.TxEncoder\n\t\tTxDecoder()\n\nsdk.TxDecoder\n\t\tTxJSONEncoder()\n\nsdk.TxEncoder\n\t\tTxJSONDecoder()\n\nsdk.TxDecoder\n\t\tMarshalSignatureJSON([]signingtypes.SignatureV2) ([]byte, error)\n\nUnmarshalSignatureJSON([]byte) ([]signingtypes.SignatureV2, error)\n}\n\n\t// TxConfig defines an interface a client can utilize to generate an\n\t// application-defined concrete transaction type. The type returned must\n\t// implement TxBuilder.\n\tTxConfig interface {\n    TxEncodingConfig\n\n\t\tNewTxBuilder()\n\nTxBuilder\n\t\tWrapTxBuilder(sdk.Tx) (TxBuilder, error)\n\nSignModeHandler() *txsigning.HandlerMap\n\t\tSigningContext() *txsigning.Context\n}\n\n\t// TxBuilder defines an interface which an application-defined concrete transaction\n\t// type must implement. Namely, it must be able to set messages, generate\n\t// signatures, and provide canonical bytes to sign over. The transaction must\n\t// also know how to encode itself.\n\tTxBuilder interface {\n    GetTx()\n\nsigning.Tx\n\n\t\tSetMsgs(msgs ...sdk.Msg)\n\nerror\n\t\tSetSignatures(signatures ...signingtypes.SignatureV2)\n\nerror\n\t\tSetMemo(memo string)\n\nSetFeeAmount(amount sdk.Coins)\n\nSetFeePayer(feePayer sdk.AccAddress)\n\nSetGasLimit(limit uint64)\n\nSetTimeoutHeight(height uint64)\n\nSetTimeoutTimestamp(timestamp time.Time)\n\nSetUnordered(v bool)\n\nSetFeeGranter(feeGranter sdk.AccAddress)\n\nAddAuxSignerData(tx.AuxSignerData)\n\nerror\n}\n\n\t// ExtendedTxBuilder extends the TxBuilder interface,\n\t// which is used to set extension options to be included in a transaction.\n\tExtendedTxBuilder interface {\n    SetExtensionOptions(extOpts ...*codectypes.Any)\n}\n)\nSee all 93 lines\n\nCopy\n\nAsk AI\nimport (\n    \n\tbanktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n)\n\nfunc sendTx()\n\nerror {\n    // --snip--\n\n    // Define two x/bank MsgSend messages:\n    // - from addr1 to addr3,\n    // - from addr2 to addr3.\n    // This means that the transactions needs two signers: addr1 and addr2.\n    msg1 := banktypes.NewMsgSend(addr1, addr3, types.NewCoins(types.NewInt64Coin(\"atom\", 12)))\n\nmsg2 := banktypes.NewMsgSend(addr2, addr3, types.NewCoins(types.NewInt64Coin(\"atom\", 34)))\n    err := txBuilder.SetMsgs(msg1, msg2)\n    if err != nil {\n    return err\n}\n\ntxBuilder.SetGasLimit(...)\n\ntxBuilder.SetFeeAmount(...)\n\ntxBuilder.SetMemo(...)\n\ntxBuilder.SetTimeoutHeight(...)\n}\nSee all 30 lines\nAt this point, TxBuilder\u2019s underlying transaction is ready to be signed.\n\u200b\nGenerating an Unordered Transaction\nStarting with Cosmos SDK v0.53.0, users may send unordered transactions to chains that have the feature enabled.\nUnordered transactions MUST leave sequence values unset. When a transaction is both unordered and contains a non-zero sequence value, the transaction will be rejected. External services that operate on prior assumptions about transaction sequence values should be updated to handle unordered transactions. Services should be aware that when the transaction is unordered, the transaction sequence will always be zero.\nUsing the example above, we can set the required fields to mark a transaction as unordered. By default, unordered transactions charge an extra 2240 units of gas to offset the additional storage overhead that supports their functionality. The extra units of gas are customizable and therefore vary by chain, so be sure to check the chain\u2019s ante handler for the gas value set, if any.\n\nCopy\n\nAsk AI\nfunc sendTx()\n\nerror {\n    // --snip--\n    expiration := 5 * time.Minute\n    txBuilder.SetUnordered(true)\n\ntxBuilder.SetTimeoutTimestamp(time.Now().Add(expiration + (1 * time.Nanosecond)))\n}\nUnordered transactions from the same account must use a unique timeout timestamp value. The difference between each timeout timestamp value may be as small as a nanosecond, however.\n\nCopy\n\nAsk AI\nimport (\n    \n\t\"github.com/cosmos/cosmos-sdk/client\"\n)\n\nfunc sendMessages(txBuilders []client.TxBuilder)\n\nerror {\n    // --snip--\n    expiration := 5 * time.Minute\n    for _, txb := range txBuilders {\n    txb.SetUnordered(true)\n\ntxb.SetTimeoutTimestamp(time.Now().Add(expiration + (1 * time.Nanosecond)))\n}\n}\nSee all 16 lines\n\u200b\nSigning a Transaction\nWe set encoding config to use Protobuf, which will use SIGN_MODE_DIRECT by default. As per ADR-020, each signer needs to sign the SignerInfos of all other signers. This means that we need to perform two steps sequentially:\nfor each signer, populate the signer\u2019s SignerInfo inside TxBuilder,\nonce all SignerInfos are populated, for each signer, sign the SignDoc (the payload to be signed).\nIn the current TxBuilder\u2019s API, both steps are done using the same method: SetSignatures(). The current API requires us to first perform a round of SetSignatures() with empty signatures, only to populate SignerInfos, and a second round of SetSignatures() to actually sign the correct payload.\n\nCopy\n\nAsk AI\nimport (\n    \n    cryptotypes \"github.com/cosmos/cosmos-sdk/crypto/types\"\n    \"github.com/cosmos/cosmos-sdk/types/tx/signing\"\n\txauthsigning \"github.com/cosmos/cosmos-sdk/x/auth/signing\"\n)\n\nfunc sendTx()\n\nerror {\n    // --snip--\n    privs := []cryptotypes.PrivKey{\n    priv1, priv2\n}\n    accNums:= []uint64{..., ...\n} // The accounts' account numbers\n    accSeqs:= []uint64{..., ...\n} // The accounts' sequence numbers\n\n    // First round: we gather all the signer infos. We use the \"set empty\n    // signature\" hack to do that.\n    var sigsV2 []signing.SignatureV2\n    for i, priv := range privs {\n    sigV2 := signing.SignatureV2{\n    PubKey: priv.PubKey(),\n    Data: &signing.SingleSignatureData{\n    SignMode:  encCfg.TxConfig.SignModeHandler().DefaultMode(),\n    Signature: nil,\n},\n    Sequence: accSeqs[i],\n}\n\nsigsV2 = append(sigsV2, sigV2)\n}\n    err := txBuilder.SetSignatures(sigsV2...)\n    if err != nil {\n    return err\n}\n\n    // Second round: all signer infos are set, so each signer can sign.\n    sigsV2 = []signing.SignatureV2{\n}\n    for i, priv := range privs {\n    signerData := xauthsigning.SignerData{\n    ChainID:       chainID,\n    AccountNumber: accNums[i],\n    Sequence:      accSeqs[i],\n}\n\nsigV2, err := tx.SignWithPrivKey(\n            encCfg.TxConfig.SignModeHandler().DefaultMode(), signerData,\n            txBuilder, priv, encCfg.TxConfig, accSeqs[i])\n    if err != nil {\n    return nil, err\n}\n\nsigsV2 = append(sigsV2, sigV2)\n}\n\nerr = txBuilder.SetSignatures(sigsV2...)\n    if err != nil {\n    return err\n}\n}\nSee all 64 lines\nThe TxBuilder is now correctly populated. To print it, you can use the TxConfig interface from the initial encoding config encCfg:\n\nCopy\n\nAsk AI\nfunc sendTx()\n\nerror {\n    // --snip--\n\n    // Generated Protobuf-encoded bytes.\n    txBytes, err := encCfg.TxConfig.TxEncoder()(txBuilder.GetTx())\n    if err != nil {\n    return err\n}\n\n    // Generate a JSON string.\n    txJSONBytes, err := encCfg.TxConfig.TxJSONEncoder()(txBuilder.GetTx())\n    if err != nil {\n    return err\n}\n    txJSON := string(txJSONBytes)\n}\nSee all 18 lines\n\u200b\nBroadcasting a Transaction\nThe preferred way to broadcast a transaction is to use gRPC, though using REST (via gRPC-gateway) or the CometBFT RPC is also possible. An overview of the differences between these methods is exposed here. For this tutorial, we will only describe the gRPC method.\n\nCopy\n\nAsk AI\nimport (\n    \n    \"context\"\n    \"fmt\"\n    \"google.golang.org/grpc\"\n    \"github.com/cosmos/cosmos-sdk/types/tx\"\n)\n\nfunc sendTx(ctx context.Context)\n\nerror {\n    // --snip--\n\n    // Create a connection to the gRPC server.\n    grpcConn := grpc.Dial(\n        \"127.0.0.1:9090\", // Or your gRPC server address.\n        grpc.WithInsecure(), // The Cosmos SDK doesn't support any transport security mechanism.\n    )\n\ndefer grpcConn.Close()\n\n    // Broadcast the tx via gRPC. We create a new client for the Protobuf Tx\n    // service.\n    txClient := tx.NewServiceClient(grpcConn)\n    // We then call the BroadcastTx method on this client.\n    grpcRes, err := txClient.BroadcastTx(\n        ctx,\n        &tx.BroadcastTxRequest{\n    Mode:    tx.BroadcastMode_BROADCAST_MODE_SYNC,\n    TxBytes: txBytes, // Proto-binary of the signed transaction, see previous step.\n},\n    )\n    if err != nil {\n    return err\n}\n\nfmt.Println(grpcRes.TxResponse.Code) // Should be `0` if the tx is successful\n\n    return nil\n}\nSee all 40 lines\n\u200b\nSimulating a Transaction\nBefore broadcasting a transaction, we sometimes may want to dry-run the transaction, to estimate some information about the transaction without actually committing it. This is called simulating a transaction, and can be done as follows:\n\nCopy\n\nAsk AI\nimport (\n    \n\t\"context\"\n    \"fmt\"\n    \"testing\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    \"github.com/cosmos/cosmos-sdk/types/tx\"\n\tauthtx \"github.com/cosmos/cosmos-sdk/x/auth/tx\"\n)\n\nfunc simulateTx()\n\nerror {\n    // --snip--\n\n    // Simulate the tx via gRPC. We create a new client for the Protobuf Tx\n    // service.\n    txClient := tx.NewServiceClient(grpcConn)\n    txBytes := /* Fill in with your signed transaction bytes. */\n\n    // We then call the Simulate method on this client.\n    grpcRes, err := txClient.Simulate(\n        context.Background(),\n        &tx.SimulateRequest{\n    TxBytes: txBytes,\n},\n    )\n    if err != nil {\n    return err\n}\n\nfmt.Println(grpcRes.GasInfo) // Prints estimated gas used.\n\n    return nil\n}\nSee all 35 lines\n\u200b\nUsing gRPC\nIt is not possible to generate or sign a transaction using gRPC, only to broadcast one. In order to broadcast a transaction using gRPC, you will need to generate, sign, and encode the transaction using either the CLI or programmatically with Go.\n\u200b\nBroadcasting a Transaction\nBroadcasting a transaction using the gRPC endpoint can be done by sending a BroadcastTx request as follows, where the txBytes are the protobuf-encoded bytes of a signed transaction:\n\nCopy\n\nAsk AI\ngrpcurl -plaintext \\\n    -d '{\"tx_bytes\":\"{{txBytes}}\",\"mode\":\"BROADCAST_MODE_SYNC\"}' \\\n    localhost:9090 \\\n    cosmos.tx.v1beta1.Service/BroadcastTx\n\u200b\nUsing REST\nIt is not possible to generate or sign a transaction using REST, only to broadcast one. In order to broadcast a transaction using REST, you will need to generate, sign, and encode the transaction using either the CLI or programmatically with Go.\n\u200b\nBroadcasting a Transaction\nBroadcasting a transaction using the REST endpoint (served by gRPC-gateway) can be done by sending a POST request as follows, where the txBytes are the protobuf-encoded bytes of a signed transaction:\n\nCopy\n\nAsk AI\ncurl -X POST \\\n    -H \"Content-Type: application/json\" \\\n    -d'{\"tx_bytes\":\"{{txBytes}}\",\"mode\":\"BROADCAST_MODE_SYNC\"}' \\\n    localhost:1317/cosmos/tx/v1beta1/txs\n\u200b\nUsing CosmJS (JavaScript & TypeScript)\nCosmJS aims to build client libraries in JavaScript that can be embedded in web applications. Please see Link for more information. As of January 2021, CosmJS documentation is still work in progress.\n\n\nRunning a Testnet\n\nCopy page\n\nSynopsis The simd testnet subcommand makes it easy to initialize and start a simulated test network for testing purposes.\nIn addition to the commands for running a node, the simd binary also includes a testnet command that allows you to start a simulated test network in-process or to initialize files for a simulated test network that runs in a separate process.\n\u200b\nInitialize Files\nFirst, let\u2019s take a look at the init-files subcommand.\nThis is similar to the init command when initializing a single node, but in this case we are initializing multiple nodes, generating the genesis transactions for each node, and then collecting those transactions.\nThe init-files subcommand initializes the necessary files to run a test network in a separate process (i.e. using a Docker container). Running this command is not a prerequisite for the start subcommand (see below).\nIn order to initialize the files for a test network, run the following command:\n\nCopy\n\nAsk AI\nsimd testnet init-files\nYou should see the following output in your terminal:\n\nCopy\n\nAsk AI\nSuccessfully initialized 4 node directories\nThe default output directory is a relative .testnets directory. Let\u2019s take a look at the files created within the .testnets directory.\n\u200b\ngentxs\nThe gentxs directory includes a genesis transaction for each validator node. Each file includes a JSON encoded genesis transaction used to register a validator node at the time of genesis. The genesis transactions are added to the genesis.json file within each node directory during the initialization process.\n\u200b\nnodes\nA node directory is created for each validator node. Within each node directory is a simd directory. The simd directory is the home directory for each node, which includes the configuration and data files for that node (i.e. the same files included in the default ~/.simapp directory when running a single node).\n\u200b\nStart Testnet\nNow, let\u2019s take a look at the start subcommand.\nThe start subcommand both initializes and starts an in-process test network. This is the fastest way to spin up a local test network for testing purposes.\nYou can start the local test network by running the following command:\n\nCopy\n\nAsk AI\nsimd testnet start\nYou should see something similar to the following:\n\nCopy\n\nAsk AI\nacquiring test network lock\npreparing test network with chain-id \"chain-mtoD9v\"\n\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n++       THIS MNEMONIC IS FOR TESTING PURPOSES ONLY        ++\n++                DO NOT USE IN PRODUCTION                 ++\n++                                                         ++\n++  sustain know debris minute gate hybrid stereo custom   ++\n++  divorce cross spoon machine latin vibrant term oblige  ++\n++   moment beauty laundry repeat grab game bronze truly   ++\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\nstarting test network...\nstarted test network\npress the Enter Key to terminate\nSee all 15 lines\nThe first validator node is now running in-process, which means the test network will terminate once you either close the terminal window or you press the Enter key. In the output, the mnemonic phrase for the first validator node is provided for testing purposes. The validator node is using the same default addresses being used when initializing and starting a single node (no need to provide a --node flag).\nCheck the status of the first validator node:\n\nCopy\n\nAsk AI\nsimd status\nImport the key from the provided mnemonic:\n\nCopy\n\nAsk AI\nsimd keys add test --recover --keyring-backend test\nCheck the balance of the account address:\n\nCopy\n\nAsk AI\nsimd q bank balances [address]\nUse this test account to manually test against the test network.\n\u200b\nTestnet Options\nYou can customize the configuration of the test network with flags. In order to see all flag options, append the --help flag to each command.\n\n\nRunning in Production\n\nCopy page\n\nSynopsis This section describes how to securely run a node in a public setting and/or on a mainnet on one of the many Cosmos SDK public blockchains.\nWhen operating a node, full node or validator, in production it is important to set your server up securely.\nThere are many different ways to secure a server and your node, the described steps here is one way. To see another way of setting up a server see the run in production tutorial.\nThis walkthrough assumes the underlying operating system is Ubuntu.\n\u200b\nSever Setup\n\u200b\nUser\nWhen creating a server most times it is created as user root. This user has heightened privileges on the server. When operating a node, it is recommended to not run your node as the root user.\nCreate a new user\n\nCopy\n\nAsk AI\nsudo adduser change_me\nWe want to allow this user to perform sudo tasks\n\nCopy\n\nAsk AI\nsudo usermod -aG sudo change_me\nNow when logging into the server, the non root user can be used.\n\u200b\nGo\nInstall the Go version preconized by the application.\nIn the past, validators have had issues when using different versions of Go. It is recommended that the whole validator set uses the version of Go that is preconized by the application.\n\u200b\nFirewall\nNodes should not have all ports open to the public, this is a simple way to get DDOS\u2019d. Secondly it is recommended by CometBFT to never expose ports that are not required to operate a node.\nWhen setting up a firewall there are a few ports that can be open when operating a Cosmos SDK node. There is the CometBFT json-RPC, prometheus, p2p, remote signer and Cosmos SDK GRPC and REST. If the node is being operated as a node that does not offer endpoints to be used for submission or querying then a max of three endpoints are needed.\nMost, if not all servers come equipped with ufw. Ufw will be used in this tutorial.\nReset UFW to disallow all incoming connections and allow outgoing\n\nCopy\n\nAsk AI\nsudo ufw default deny incoming\nsudo ufw default allow outgoing\nLets make sure that port 22 (ssh) stays open.\n\nCopy\n\nAsk AI\nsudo ufw allow ssh\nor\n\nCopy\n\nAsk AI\nsudo ufw allow 22\nBoth of the above commands are the same.\nAllow Port 26656 (cometbft p2p port). If the node has a modified p2p port then that port must be used here.\n\nCopy\n\nAsk AI\nsudo ufw allow 26656/tcp\nAllow port 26660 (cometbft prometheus). This acts as the applications monitoring port as well.\n\nCopy\n\nAsk AI\nsudo ufw allow 26660/tcp\nIF the node which is being setup would like to expose CometBFTs jsonRPC and Cosmos SDK GRPC and REST then follow this step. (Optional)\nCometBFT JsonRPC\n\nCopy\n\nAsk AI\nsudo ufw allow 26657/tcp\nCosmos SDK GRPC\n\nCopy\n\nAsk AI\nsudo ufw allow 9090/tcp\nCosmos SDK REST\n\nCopy\n\nAsk AI\nsudo ufw allow 1317/tcp\nLastly, enable ufw\n\nCopy\n\nAsk AI\nsudo ufw enable\n\u200b\nSigning\nIf the node that is being started is a validator there are multiple ways a validator could sign blocks.\n\u200b\nFile\nFile based signing is the simplest and default approach. This approach works by storing the consensus key, generated on initialization, to sign blocks. This approach is only as safe as your server setup as if the server is compromised so is your key. This key is located in the config/priv_val_key.json directory generated on initialization.\nA second file exists that user must be aware of, the file is located in the data directory data/priv_val_state.json. This file protects your node from double signing. It keeps track of the consensus keys last sign height, round and latest signature. If the node crashes and needs to be recovered this file must be kept in order to ensure that the consensus key will not be used for signing a block that was previously signed.\n\u200b\nRemote Signer\nA remote signer is a secondary server that is separate from the running node that signs blocks with the consensus key. This means that the consensus key does not live on the node itself. This increases security because your full node which is connected to the remote signer can be swapped without missing blocks.\nThe two most used remote signers are tmkms from Iqlusion and horcrux from Strangelove.\nTMKMS\nDependencies\nUpdate server dependencies and install extras needed.\n\nCopy\n\nAsk AI\nsudo apt update -y && sudo apt install build-essential curl jq -y\nInstall Rust:\n\nCopy\n\nAsk AI\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nInstall Libusb:\n\nCopy\n\nAsk AI\nsudo apt install libusb-1.0-0-dev\nSetup\nThere are two ways to install tmkms, from source or cargo install. In the examples we will cover downloading or building from source and using softsign. Softsign stands for software signing, but you could use a yubihsm as your signing key if you wish.\nBuild:\nFrom source:\n\nCopy\n\nAsk AI\ncd $HOME\ngit clone https://github.com/iqlusioninc/tmkms.git\ncd $HOME/tmkms\ncargo install tmkms --features=softsign\ntmkms init config\ntmkms softsign keygen ./config/secrets/secret_connection_key\nor\nCargo install:\n\nCopy\n\nAsk AI\ncargo install tmkms --features=softsign\ntmkms init config\ntmkms softsign keygen ./config/secrets/secret_connection_key\nTo use tmkms with a yubikey install the binary with --features=yubihsm.\nMigrate the validator key from the full node to the new tmkms instance.\n\nCopy\n\nAsk AI\nscp user@123.456.32.123:~/.simd/config/priv_validator_key.json ~/tmkms/config/secrets\nImport the validator key into tmkms.\n\nCopy\n\nAsk AI\ntmkms softsign import $HOME/tmkms/config/secrets/priv_validator_key.json $HOME/tmkms/config/secrets/priv_validator_key\nAt this point, it is necessary to delete the priv_validator_key.json from the validator node and the tmkms node. Since the key has been imported into tmkms (above) it is no longer necessary on the nodes. The key can be safely stored offline.\nModifiy the tmkms.toml.\n\nCopy\n\nAsk AI\nvim $HOME/tmkms/config/tmkms.toml\nThis example shows a configuration that could be used for soft signing. The example has an IP of 123.456.12.345 with a port of 26659 a chain_id of test-chain-waSDSe. These are items that most be modified for the usecase of tmkms and the network.\n\nCopy\n\nAsk AI\n# CometBFT KMS configuration file\n\n## Chain Configuration\n\n[[chain]]\nid = \"osmosis-1\"\nkey_format = { type = \"bech32\", account_key_prefix = \"cosmospub\", consensus_key_prefix = \"cosmosvalconspub\" }\nstate_file = \"/root/tmkms/config/state/priv_validator_state.json\"\n\n## Signing Provider Configuration\n\n### Software-based Signer Configuration\n\n[[providers.softsign]]\nchain_ids = [\"test-chain-waSDSe\"]\nkey_type = \"consensus\"\npath = \"/root/tmkms/config/secrets/priv_validator_key\"\n\n## Validator Configuration\n\n[[validator]]\nchain_id = \"test-chain-waSDSe\"\naddr = \"tcp://123.456.12.345:26659\"\nsecret_key = \"/root/tmkms/config/secrets/secret_connection_key\"\nprotocol_version = \"v0.34\"\nreconnect = true\nSee all 26 lines\nSet the address of the tmkms instance.\n\nCopy\n\nAsk AI\nvim $HOME/.simd/config/config.toml\n\npriv_validator_laddr = \"tcp://0.0.0.0:26659\"\nThe above address it set to 0.0.0.0 but it is recommended to set the tmkms server to secure the startup\nIt is recommended to comment or delete the lines that specify the path of the validator key and validator:\n\nCopy\n\nAsk AI\n# Path to the JSON file containing the private key to use as a validator in the consensus protocol\n# priv_validator_key_file = \"config/priv_validator_key.json\"\n\n# Path to the JSON file containing the last sign state of a validator\n# priv_validator_state_file = \"data/priv_validator_state.json\"\nStart the two processes.\n\nCopy\n\nAsk AI\ntmkms start -c $HOME/tmkms/config/tmkms.toml\n\nCopy\n\nAsk AI\nsimd start\n\n",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "human",
            "name": null,
            "id": "81005895-01e2-423d-94d8-e1792b8bb7a8",
            "example": false
        },
        {
            "content": "{\n  \"Send 1000stake from my_validator to recipient\": 98,\n  \"Query the bank balance of my_validator address\": 95,\n  \"Add a new key called my_validator to the test keyring\": 92,\n  \"Initialize a new chain with chain-id my-test-chain\": 90,\n  \"Start the local simd node\": 88,\n  \"Add my_validator address as a genesis account with 100000000000stake\": 85,\n  \"Generate a gentx for my_validator staking 100000000stake\": 83,\n  \"Collect all gentxs into the genesis file\": 80,\n  \"Delegate 500stake from recipient to my_validator validator\": 79,\n  \"Query total delegations to my_validator validator\": 78,\n  \"Enable the REST API server in app.toml\": 76,\n  \"Generate an unsigned transaction sending 1000stake from A to B\": 75,\n  \"Sign unsigned_tx.json with my_validator key in the test backend\": 74,\n  \"Broadcast the signed transaction tx_signed.json in sync mode\": 72,\n  \"Encode the signed transaction to protobuf bytes\": 70,\n  \"Decode protobuf transaction bytes to JSON\": 69,\n  \"Simulate the signed transaction to estimate gas\": 68,\n  \"Query AllBalances for an address at block height 123 via gRPC\": 67,\n  \"Start an in-process test network with simd testnet start\": 66,\n  \"Initialize testnet files with simd testnet init-files\": 65,\n  \"Set the keyring backend to pass\": 64,\n  \"Export GAIA_V5_KEYRING_BACKEND=pass environment variable\": 63,\n  \"Initialize pass password store with pass init <GPG_KEY_ID>\": 62,\n  \"Set minimum-gas-prices to 0stake in app.toml\": 61,\n  \"Enable unsafe CORS on the REST server\": 60,\n  \"Turn on REST Swagger documentation\": 59,\n  \"Change the chain-id in genesis.json to testing\": 58,\n  \"Update voting_period in genesis to 600s\": 57,\n  \"Set inflation in genesis to 0.300000000000000000\": 56,\n  \"Run simd start with application and CometBFT split (--with-comet=false)\": 55,\n  \"Launch simd start with max-txs set to -1\": 54,\n  \"List local snapshots\": 53,\n  \"Export current app state to a snapshot\": 52,\n  \"Load a snapshot archive into the store\": 51,\n  \"Restore app state from a local snapshot\": 50,\n  \"Delete a local snapshot\": 49,\n  \"List available gRPC services on localhost:9090 via grpcurl\": 48,\n  \"Query bank balances via REST endpoint\": 47,\n  \"Broadcast a transaction over REST\": 46,\n  \"Broadcast a transaction over gRPC\": 45,\n  \"Create an unordered transaction with a unique timeout timestamp\": 44,\n  \"Set mempool max-txs to -1 in app.toml\": 43,\n  \"Configure log_level to state:info,p2p:info,consensus:info,*error\": 42,\n  \"Allow p2p port 26656 through ufw\": 41,\n  \"Allow prometheus port 26660 through ufw\": 40,\n  \"Enable ufw firewall\": 39,\n  \"Add ufw rule to allow SSH on port 22\": 38,\n  \"Back up priv_val_state.json to prevent double signing\": 37\n}",
            "additional_kwargs": {
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 2379,
                    "prompt_tokens": 15026,
                    "total_tokens": 17405,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 1600,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 14976
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CPorTFsUOfzDuD0BaGxos0993op10",
                "service_tier": "default",
                "finish_reason": "stop",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--14ec5d3e-37c0-4795-9257-327ce51d7e74-0",
            "example": false,
            "tool_calls": [],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 15026,
                "output_tokens": 2379,
                "total_tokens": 17405,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 14976
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 1600
                }
            }
        }
    ]
}