{
    "messages": [
        {
            "content": "Overview\n\nCopy page\n\nTooling and resources to 10x your development workflows.\n\n\u200b\nClient Integrations\nClient libraries play a crucial role indevelopment by making it easier for developers interact with the underlying protocols. Well-made libraries abstract away complexities and provide optimized methods to allow developers to focus on their project rather than the network itself.\u201d\nEthersJS and Web3JS are two most commonly used libraries in dApp development. Developer uses these libraries to interact with blockchain and query JSON-RPC data, for example. Additionally, both of these libraries contain utilities to aid in task like converting large numbers (BigNumber).\nEthers.js is the latest JS library that aims to be a complete and compact library for interacting with the Ethereum Blockchain and its ecosystem.\n\n\nBlock Explorers\n\nCopy page\n\nBlockchain explorers allow users to query the blockchain for data. Explorers are often compared to search engines for the blockchain. By using an explorer, users can search and track balances, transactions, contracts, and other broadcast data to the blockchain.\n\nCosmos EVM chains can use two types block explorers: an EVM explorer and a Cosmos explorer. Each explorer queries data respective to their environment with the EVM explorers querying Ethereum-formatted data (blocks, transactions, accounts, smart contracts, etc) and the Cosmos explorers querying Cosmos-formatted data (Cosmos and IBC transactions, blocks, accounts, module data, etc).\n\u200b\nList of Block Explorers\u200b\nBelow is a list of open source explorers that you can use:\nService\tSupport\tURL\nPing.Pub\tcosmos\tGithub Repo\nBigDipper\tcosmos\tGithub Repo\nBlockscout\tethereum\tGithub Repo\n\u200b\nCosmos & EVM Compatible explorers\u200b\nAs of yet, there is no open source explorer that supports both EVM and Cosmos transactions. Mintscan does support this but requires an integration.\n\n\nFoundry Guide - Setup & Walkthrough\n\nCopy page\n\nAn introduction to Foundry and using the cast function, replacing complex scripts that may otherwise require multiple rpc calls and other functions in between with a single command.\n\nFoundry is a fast and modular toolkit for Ethereum application development written in Rust. It provides four main command-line tools\u2014forge, cast, anvil, and chisel\u2014to streamline everything from project setup to live-chain interactions.\nAmong these, cast serves as your \u201cSwiss-army knife\u201d for JSON-RPC calls, letting you execute tedious day-to-day tasks (like sending raw transactions, querying balances, fetching blocks, and looking up chain metadata) with simple, consistent commands instead of verbose curl scripts.\nThis guide walks you through installing Foundry, configuring your environment, and using the most common cast commands to accelerate your development workflow.\n\u200b\nInstallation & Setup\n\u200b\nInstall Foundry\nRun the following command to install foundryup, the Foundry toolchain installer. This will give you the four main binaries.\n\nCopy\n\nAsk AI\ncurl -L https://foundry.paradigm.xyz | bash\nfoundryup\nAfter installation, you can switch to the nightly builds for the latest features, though this is optional.\n\nCopy\n\nAsk AI\nfoundryup -i nightly\n\u200b\nVerify Installation\nCheck that each binary was installed correctly by running:\n\nCopy\n\nAsk AI\nfoundryup --version\ncast --version\nforge --version\nanvil --version\nSee all 4 lines\nYou should see version outputs for each tool (e.g., cast 0.2.0).\n\u200b\nConfiguration\nTo avoid passing the --rpc-url flag with every command, you can set defaults in a foundry.toml file. This file can be placed in your project\u2019s root directory for project-specific settings, or you can create a global configuration at ~/.foundry/foundry.toml for settings you use across all projects.\nHere is an example of a global configuration for connecting to a local Cosmos EVM node:\n~/.foundry/foundry.toml\n\nCopy\n\nAsk AI\n# ~/.foundry/foundry.toml\n\n# Declare your named endpoints (optional; for forge test / forking)\n[rpc_endpoints]\ncosmos = \"<evm_rpc_url>\"\n\n# Configure the default profile for cast/forge/anvil\n[profile.default]\n# Tell Foundry which chain you're targeting:\nchain_id     = 4321\n# Directly tell cast to use your endpoint:\neth_rpc_url  = \"<evm_rpc_url>\"\n# Set EVM version for Solidity compilation\nevm_version  = \"istanbul\"\nSee all 14 lines\nWith this global configuration, Foundry tools will automatically connect to your local node without needing additional flags.\n\u200b\nBasic Usage of cast\ncast replaces the need for custom shell scripts and verbose curl commands by offering first-class RPC commands.\n\u200b\nChain Metadata\nGet Chain ID\n\nCopy\n\nAsk AI\ncast chain-id --rpc-url local\nReturns the chain ID in decimal format.\nGet Client Version\n\nCopy\n\nAsk AI\ncast client --rpc-url local\nDisplays the client implementation and version (e.g., reth/v1.0.0).\n\u200b\ncast Command Reference\n\u200b\nChain Commands\nCommand\tPurpose\ncast chain\tShow the symbolic name of the current chain.\ncast chain-id\tFetch the numeric chain ID.\ncast client\tGet the JSON-RPC client version.\nExample:\n\nCopy\n\nAsk AI\n# Assuming FOUNDRY_RPC_URL is set or using a configured alias\ncast chain\ncast chain-id\ncast client\n\u200b\nTransaction Commands\nCommand\tPurpose\ncast send\tSign and publish a transaction.\ncast publish\tPublish a raw, signed transaction.\ncast receipt\tFetch the receipt for a transaction hash.\ncast tx\tQuery transaction details (status, logs, etc.).\ncast rpc\tInvoke any raw JSON-RPC method.\nSign and Send (using a private key or local keystore):\n\nCopy\n\nAsk AI\ncast send 0xRecipientAddress \"transfer(address,uint256)\" \"0xSomeOtherAddress,100\" --private-key $YOUR_PK\nPublish Raw Transaction (hex-encoded):\n\nCopy\n\nAsk AI\ncast publish 0xf86b808504a817c80082520894...\nGeneric RPC Call:\n\nCopy\n\nAsk AI\ncast rpc eth_sendRawTransaction 0xf86b8085...\n\u200b\nAccount & Block Commands\nCommand\tPurpose\ncast balance\tGet an account\u2019s balance (supports ENS and units).\ncast block\tFetch block information by number or hash.\ncast block-number\tGet the latest block number.\ncast logs\tQuery event logs.\nGet Balance (with unit flag):\n\nCopy\n\nAsk AI\n# Using an ENS name on Ethereum mainnet\ncast balance vitalik.eth --ether --rpc-url https://eth.merkle.io\nGet Block Details:\n\nCopy\n\nAsk AI\ncast block latest\n\u200b\nUtility & Conversion Commands\nCommand\tPurpose\ncast estimate\tEstimate gas for a call or deployment.\ncast find-block\tFind a block by its timestamp.\ncast compute-address\tCalculate a CREATE2 address.\ncast from-bin\tDecode binary data to hex.\ncast from-wei\tConvert wei to a more readable unit (e.g., ether).\ncast to-wei\tConvert a unit (e.g., ether) to wei.\ncast abi-encode\tEncode function arguments.\ncast keccak\tHash data with Keccak-256.\nThese commands allow you to drop one-off scripts for common conversions and estimations.\n\u200b\nStreamlining Repetative / Tedious tasks\nWhen performing testing or development roles you may find yourself doing one or more small but very tedious tasks frequently. In your shell\u2019s configuration file (~/.bashrc, ~/.zshrc), you can alias cast with your default RPC URL (or multiple on various chains) to save time.\n\nCopy\n\nAsk AI\n# Set your default RPC endpoint\nexport CDEV_RPC=\"<evm_rpc_url>\"\n# Create an alias\nalias ccast='cast --rpc-url $CDEV_RPC'\n\n# Now you can run commands like:\nccast balance 0x...\nSee all 7 lines\nThis is an extremely basic example of how you can improve your workflows by building upon the heavy lifting Foundry already does out of the box.\n\n\nHardhat Guide: Setup & Workflows\n\nCopy page\n\nA guide to setting up and using the Hardhat development environment for building, testing, and deploying on Cosmos EVM.\n\nHardhat is a flexible and extensible Ethereum development environment that is fully compatible with Cosmos EVM. It\u2019s an excellent choice for teams with JavaScript/TypeScript expertise or those who need complex deployment and testing workflows.\n\u200b\nProject Setup and Configuration\nInitialize and configure a new Hardhat project for Cosmos EVM development.\n\u200b\n1. Installation\n\nCopy\n\nAsk AI\nmkdir cosmos-evm-hardhat\ncd cosmos-evm-hardhat\nnpm init -y\nnpm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @openzeppelin/contracts\nnpx hardhat init # Select \"Create a TypeScript project\"\nSee all 5 lines\n\u200b\n2. Configuration\nModify hardhat.config.ts to include networks and settings for Cosmos EVM.\nhardhat.config.ts\n\nCopy\n\nAsk AI\nimport { HardhatUserConfig } from \"hardhat/config\";\nimport \"@nomicfoundation/hardhat-toolbox\";\nimport \"dotenv/config\";\n\nconst config: HardhatUserConfig = {\n  solidity: {\n    version: \"0.8.24\",\n    settings: {\n      optimizer: {\n        enabled: true,\n        runs: 200,\n      },\n      evmVersion: \"istanbul\"\n    },\n  },\n  networks: {\n    local: {\n      url: \"http://127.0.0.1:8545\",\n      chainId: 4321, // Your EVM chain ID\n      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],\n      gasPrice: 20000000000,\n    },\n    testnet: {\n      url: \"<evm_rpc_url>\",\n      chainId: 4321, // Your EVM chain ID\n      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],\n    }\n  },\n  gasReporter: {\n    enabled: process.env.REPORT_GAS !== undefined,\n    currency: \"USD\",\n  },\n  etherscan: {\n    apiKey: {\n      cosmosEvmTestnet: process.env.ETHERSCAN_API_KEY || \"dummy_key\"\n    },\n    customChains: [\n      {\n        network: \"cosmosEvmTestnet\",\n        chainId: 4321, // Your EVM chain ID\n        urls: {\n          apiURL: \"\",\n          browserURL: \"\"\n        }\n      }\n    ]\n  }\n};\n\nexport default config;\nSee all 50 lines\n\u200b\nTypeScript Integration\nHardhat\u2019s first-class TypeScript support enables type-safe contract interactions and tests.\n\u200b\n1. Writing a Contract\nCreate a contract in the contracts/ directory. For this example, we\u2019ll use a simple LiquidStakingVault.\ncontracts/LiquidStakingVault.sol\n\nCopy\n\nAsk AI\n// contracts/LiquidStakingVault.sol\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n// Interface for the staking precompile\ninterface IStaking {\n    function delegate(address validator, uint256 amount) external returns (bool);\n    function undelegate(address validator, uint256 amount) external returns (bool, uint64);\n}\n\ncontract LiquidStakingVault is Ownable {\n    IStaking constant STAKING = IStaking(0x0000000000000000000000000000000000000800);\n\n    mapping(address => uint256) public stakedBalance;\n    address public primaryValidator;\n    uint256 public totalStaked;\n\n    event Staked(address indexed user, uint256 amount);\n\n    constructor(address _primaryValidator) Ownable(msg.sender) {\n        primaryValidator = _primaryValidator;\n    }\n\n    function stake() external payable {\n        require(msg.value > 0, \"Must stake positive amount\");\n        bool success = STAKING.delegate(primaryValidator, msg.value);\n        require(success, \"Delegation failed\");\n        stakedBalance[msg.sender] += msg.value;\n        totalStaked += msg.value;\n        emit Staked(msg.sender, msg.value);\n    }\n}\nSee all 34 lines\n\u200b\n2. Writing Tests\nCreate type-safe tests in the test/ directory.\ntest/LiquidStakingVault.test.ts\n\nCopy\n\nAsk AI\n// test/LiquidStakingVault.test.ts\nimport { expect } from \"chai\";\nimport { ethers } from \"hardhat\";\nimport { LiquidStakingVault } from \"../typechain-types\";\nimport { SignerWithAddress } from \"@nomicfoundation/hardhat-ethers/signers\";\n\ndescribe(\"LiquidStakingVault\", function () {\n  let vault: LiquidStakingVault;\n  let owner: SignerWithAddress;\n  let user1: SignerWithAddress;\n\n  const STAKING_PRECOMPILE = \"0x0000000000000000000000000000000000000800\";\n  const VALIDATOR_ADDRESS = \"0x1234567890123456789012345678901234567890\";\n\n  beforeEach(async function () {\n    [owner, user1] = await ethers.getSigners();\n\n    const VaultFactory = await ethers.getContractFactory(\"LiquidStakingVault\");\n    vault = await VaultFactory.deploy(VALIDATOR_ADDRESS);\n    await vault.waitForDeployment();\n\n    // Mock the staking precompile's delegate function to always return true\n    // This bytecode is a minimal contract that returns true for any call\n    const successBytecode = \"0x6080604052348015600f57600080fd5b50600160005560016000f3\";\n    await ethers.provider.send(\"hardhat_setCode\", [\n      STAKING_PRECOMPILE,\n      successBytecode,\n    ]);\n  });\n\n  it(\"Should allow a user to stake tokens\", async function () {\n    const stakeAmount = ethers.parseEther(\"1.0\");\n\n    await expect(vault.connect(user1).stake({ value: stakeAmount }))\n      .to.emit(vault, \"Staked\")\n      .withArgs(user1.address, stakeAmount);\n\n    expect(await vault.stakedBalance(user1.address)).to.equal(stakeAmount);\n    expect(await vault.totalStaked()).to.equal(stakeAmount);\n  });\n});\nSee all 41 lines\nRun your tests:\n\nCopy\n\nAsk AI\nnpx hardhat test\n\u200b\nDeployment Scripts\nCreate a deployment script in the scripts/ directory to deploy your contract to a live network.\nscripts/deploy.ts\n\nCopy\n\nAsk AI\n// scripts/deploy.ts\nimport { ethers, network } from \"hardhat\";\nimport { writeFileSync } from \"fs\";\n\nasync function main() {\n  const [deployer] = await ethers.getSigners();\n\n  console.log(\"Deploying contracts with the account:\", deployer.address);\n\n  const validatorAddress = process.env.VALIDATOR_ADDRESS || \"0x0000000000000000000000000000000000000000\";\n\n  const VaultFactory = await ethers.getContractFactory(\"LiquidStakingVault\");\n  const vault = await VaultFactory.deploy(validatorAddress);\n  await vault.waitForDeployment();\n\n  const vaultAddress = await vault.getAddress();\n  console.log(\"LiquidStakingVault deployed to:\", vaultAddress);\n\n  // Save deployment information\n  const deploymentInfo = {\n    contractAddress: vaultAddress,\n    deployer: deployer.address,\n    network: network.name,\n    chainId: network.config.chainId,\n  };\n\n  writeFileSync(\n    `deployments/${network.name}-deployment.json`,\n    JSON.stringify(deploymentInfo, null, 2)\n  );\n\n  // Optional: Verify contract on Etherscan-compatible explorer\n  if (network.name !== \"local\" && process.env.ETHERSCAN_API_KEY) {\n    console.log(\"Waiting for block confirmations before verification...\");\n    // await vault.deploymentTransaction()?.wait(5); // Wait for 5 blocks\n    await new Promise(resolve => setTimeout(resolve, 30000)); // Or wait 30 seconds\n\n    await hre.run(\"verify:verify\", {\n        address: vaultAddress,\n        constructorArguments: [validatorAddress],\n    });\n  }\n}\n\nmain()\n  .then(() => process.exit(0))\n  .catch((error) => {\n    console.error(error);\n    process.exit(1);\n  });\nSee all 50 lines\nRun the deployment script:\n\nCopy\n\nAsk AI\nnpx hardhat run scripts/deploy.ts --network testnet\n\n\n\nRemix IDE\n\nCopy page\n\nDeploy and test smart contracts on Cosmos EVM chains using the Remix browser-based IDE\n\n\u200b\nRemix IDE\nRemix is a powerful browser-based IDE that allows you to write, compile, deploy, and test smart contracts directly from your web browser. It\u2019s an excellent tool for rapid prototyping and testing smart contracts on Cosmos EVM chains without needing to set up a local development environment.\n\u200b\nConnecting to Cosmos EVM Chains\nTo deploy contracts to a Cosmos EVM chain through Remix, you\u2019ll need to use the Injected Provider option with MetaMask.\nRemix cannot connect directly to custom RPC endpoints. You must use MetaMask as an intermediary to connect to Cosmos EVM chains.\n\u200b\nStep-by-Step Guide\nConfigure MetaMask: First, add your Cosmos EVM chain to MetaMask with the correct RPC endpoint, Chain ID, and currency symbol.\nSelect Network in MetaMask: Make sure the Cosmos EVM network you want to use is currently selected in MetaMask.\nOpen Remix: Navigate to https://remix.ethereum.org\nDeploy Your Contract:\nGo to the \u201cDeploy & Run Transactions\u201d tab (the Ethereum icon in the sidebar)\nIn the \u201cEnvironment\u201d dropdown, select \u201cInjected Provider - MetaMask\u201d\nRemix will automatically connect to the network currently selected in MetaMask\nRemix Injected Provider Selection\nConfirm Connection: MetaMask will prompt you to connect to Remix. Approve the connection to proceed.\nDeploy and Interact: You can now compile, deploy, and interact with your contracts on the Cosmos EVM chain through Remix.\n\u200b\nImportant Considerations\nNetwork Selection: Always verify that MetaMask is connected to the correct network before deploying contracts\nGas Fees: Ensure you have sufficient native tokens in your MetaMask wallet to pay for transaction fees\nChain Compatibility: Your smart contracts should be compatible with the EVM version supported by the Cosmos chain\n\u200b\nAdditional Resources\nFor more detailed information about using Remix IDE, including advanced features and troubleshooting, refer to the official Remix documentation.\nQuick Tip: You can save your Remix workspace to GitHub or IPFS to preserve your contracts and deployment configurations across sessions.\n\n\n\n\nPopular Libraries for Development, Testing & Fuzzing\n\nCopy page\n\nKey frameworks, libraries, and practices for frontend development, wallet integration, smart contracts, testing and more.\n\n\u200b\nCommon Libraries & Tooling\nThese libraries are used across the stack to write tests, simulate transactions, connect wallets, and interface with the blockchain in both scripting and frontend contexts.\nLibrary\tPurpose\tKey Features\nEthers.js\tContract interaction, transaction signing, provider management in JS/TS environments\tProvides Contract, Provider, Wallet, and Interface abstractions. Deep Hardhat integration. ABI coder, calldata utilities, and ENS support.\nViem\tModular TypeScript-first library for RPC, contract access, encoding, and data formatting\tTree-shakeable. Supports batching, client-side caching, EIP-1559 fees, multicalls, typed reads/writes. Used by Wagmi.\nWagmi\tReact hooks for wallet connection, chain state, and contract calls in frontend apps\tBuilt on Viem. Includes useAccount, useConnect, useContractRead, and event subscriptions. Enables seamless integration with wallet modals.\nWeb3.js\tLegacy Ethereum contract and RPC library\tOne of the earliest libraries. Now largely unmaintained. Lacks EIP-1559 support and modern modularity.\nRainbowKit\tReact component library for wallet connection UI and chain management\tPre-built wallet connect buttons, chain switch UI, and custom themes. Integrates with Wagmi for wallet state management and tx handling.\nEthers and Viem serve similar purposes, but Viem is optimized for frontend apps. Wagmi builds on Viem. Web3.js is no longer recommended for new projects.\n\u200b\nTesting Frameworks\nNote Smart contract quality and security depend on a comprehensive testing strategy including but not limited to:\nUnit Tests: Verify individual functions and components\nProperty-Based Fuzzing: Test invariants with random inputs\nCode Coverage: Ensure all code paths are tested\nStatic Analysis: Detect common vulnerabilities and anti-patterns\nThe tools and frameworks below provide a foundation for each of these testing layers.\n\u200b\nFoundry \u2014 Solidity-Native\nTests written directly in Solidity.\nVery fast runner (forge test) and rich cheatcodes for state manipulation.\nBuilt-in, configurable fuzzing (forge test --fuzz-runs=N).\nIncludes tools like forge script, forge coverage, and forge snapshot.\n\u200b\nHardhat \u2014 JavaScript / TypeScript\nMocha + Chai test runner for JS/TS-based tests.\nFlexible task system (hardhat.config.js), plugin support, and network forking.\nIntegrates with Ethers.js and Solidity tooling for deployments, gas tracking, and test orchestration.\n\u200b\nFuzz (Property-Based) Testing\nFuzz testing generates random inputs to find edge cases that violate expected properties.\ntest/MyContract.t.sol (Foundry)\n\nCopy\n\nAsk AI\n// test/MyContract.t.sol  (Foundry)\nfunction test_myFunction_fuzz(uint256 amount) public {\n    vm.assume(amount > 0 && amount < 1e18);   // constrain input\n    myContract.myFunction(amount);\n    assertEq(myContract.someState(), expectedValue);\n}\nSee all 6 lines\nTool\tNotes\nFoundry\tBuilt-in fuzzing; enabled by default when running forge test.\nEchidna\tExternal, property-based fuzzer. Supports invariants and campaigns.\nUse fuzzing to test against invariants such as:\nbalance never exceeds total supply\nno overflow or underflow under bounded inputs\naccess control is consistently enforced\n\u200b\nSupplementary Tools\nTools that enhance test coverage, assert correctness, or catch common vulnerabilities.\nTool\tPurpose\tTypical Command\nOpenZeppelin Test Helpers\tTime travel, event assertions, reverts\tJS/TS only. Works with Hardhat + Mocha.\nsolidity-coverage\tReports untested branches in Solidity\tnpx hardhat coverage \u00b7 forge coverage\nSlither\tStatic analysis for known vuln patterns\tslither .\n\u200b\nExample \u2014 OpenZeppelin Test Helpers\n\nCopy\n\nAsk AI\nconst { time, expectRevert } = require('@openzeppelin/test-helpers');\n\n// advance clock by one day\nawait time.increase(time.duration.days(1));\n\n// expect revert with specific reason\nawait expectRevert(contract.someFunction(), \"Ownable: caller is not the owner\");\nCollapse\n\n\nWallet Integration\n\nCopy page\n\nWallet integration is an essential aspect of dApp development that allows users to securely interact with blockchain-based applications.\n\n\u200b\nEVM Wallet Compatibility\u200b\nAny standard EVM wallet works out of the box with Cosmos EVM chains. This includes popular wallets like MetaMask, Rabby, WalletConnect, and any other wallet that supports Ethereum and EVM-compatible chains. No special configuration or custom integration is required - simply add your chain\u2019s RPC endpoint and chain ID to any EVM wallet.\n\u200b\nKey Integration Points\u200b\nStandard EVM RPC: Cosmos EVM exposes the standard Ethereum JSON-RPC API, ensuring compatibility with all EVM wallets\nEIP-1559 Support: Full support for EIP-1559 dynamic fee transactions, enabling automatic gas estimation\nAddress Format: Uses standard Ethereum addresses (0x format) for EVM transactions\nTransaction Types: Supports all standard Ethereum transaction types including legacy and EIP-1559 transactions\n\u200b\nWallet Support\u200b\nWallet\tType\tNotes\nMetaMask\tEVM\tWorks out of the box - just add network RPC\nRabby\tEVM\tWorks out of the box - just add network RPC\nWalletConnect\tEVM\tStandard WalletConnect integration works\nKeplr\tCosmos + EVM\tSupports both Cosmos and Ethereum transaction formats\nLeap\tCosmos + EVM\tSupports both Cosmos and Ethereum transaction formats\nLedger\tHardware\tCompatible via MetaMask or other wallet interfaces\n\u200b\nClient Libraries\u200b\nFor programmatic wallet integration, use standard Ethereum client libraries like ethers.js, web3.js, or viem which are fully compatible with Cosmos EVM chains.\n\u200b\nQuick Start\u200b\nTo add a Cosmos EVM chain to MetaMask or any EVM wallet:\nOpen your wallet and navigate to \u201cAdd Network\u201d\nEnter the following details:\nNetwork Name: Your chain name\nRPC URL: Your chain\u2019s JSON-RPC endpoint (port 8545)\nChain ID: Your EVM chain ID (integer)\nCurrency Symbol: Your native token symbol\nBlock Explorer URL: (optional) Your chain\u2019s block explorer\nThat\u2019s it! Your wallet is now ready to interact with the Cosmos EVM chain.",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "human",
            "name": null,
            "id": "bcf597b8-5360-4483-a9a2-42471ff6df0a",
            "example": false
        },
        {
            "content": "{\n  \"Add a Cosmos EVM network to MetaMask\": 97,\n  \"Query an account\u2019s balance with cast\": 96,\n  \"Send a signed transaction with cast\": 94,\n  \"Fetch the current chain ID using cast\": 93,\n  \"Initialize a new Hardhat TypeScript project for Cosmos EVM\": 91,\n  \"Deploy a smart contract to a Cosmos EVM testnet with Hardhat\": 90,\n  \"Install the Foundry toolchain using foundryup\": 89,\n  \"Use ethers.js to send a transaction on Cosmos EVM\": 88,\n  \"Estimate gas for a contract call with cast estimate\": 87,\n  \"Connect Remix IDE to Cosmos EVM via Injected Provider\": 86,\n  \"Configure Hardhat networks for Cosmos EVM in hardhat.config.ts\": 85,\n  \"Get the latest block number with cast block-number\": 84,\n  \"Get details of the latest block with cast block latest\": 83,\n  \"Publish a raw signed transaction with cast publish\": 82,\n  \"Run Hardhat tests with npx hardhat test\": 81,\n  \"Update Foundry to the nightly build\": 80,\n  \"Set the default RPC URL in ~/.foundry/foundry.toml\": 79,\n  \"Verify a contract on an Etherscan-compatible explorer from Hardhat\": 78,\n  \"Run fuzz tests with forge test --fuzz-runs\": 77,\n  \"Start an Anvil local JSON-RPC node\": 76,\n  \"Create a shell alias for cast with a default RPC endpoint\": 75,\n  \"Query transaction details with cast tx\": 74,\n  \"Fetch a transaction receipt with cast receipt\": 73,\n  \"Make a raw JSON-RPC call with cast rpc\": 72,\n  \"Estimate gas fees for EIP-1559 transactions\": 71,\n  \"Convert ether to wei with cast to-wei\": 70,\n  \"Convert wei to ether with cast from-wei\": 69,\n  \"Hash arbitrary data with cast keccak\": 68,\n  \"Compute a CREATE2 address with cast compute-address\": 67,\n  \"Find a block by timestamp with cast find-block\": 66,\n  \"Query event logs with cast logs\": 65,\n  \"Initialize a global foundry.toml configuration file\": 64,\n  \"Install Hardhat and @nomicfoundation/hardhat-toolbox\": 63,\n  \"Import OpenZeppelin contracts into a project\": 62,\n  \"Write unit tests for a Solidity contract in Hardhat\": 61,\n  \"Stake tokens using the LiquidStakingVault stake function\": 60,\n  \"Generate a Solidity coverage report with hardhat coverage\": 59,\n  \"Run Slither static analysis on a Solidity project\": 58,\n  \"Decode binary data to hex with cast from-bin\": 57,\n  \"Convert large numbers with ethers.js BigNumber\": 56,\n  \"Use viem to read contract state\": 55,\n  \"Configure EIP-1559 gas parameters in ethers.js\": 54,\n  \"Add a Blockscout explorer URL to the network settings\": 53,\n  \"Query the client version of the node with cast client\": 52,\n  \"Verify the Foundry installation versions\": 51,\n  \"Switch MetaMask to the correct Cosmos EVM network before deployment\": 50,\n  \"Save a Remix workspace to GitHub\": 49,\n  \"Add ENS support when querying balances via cast\": 48,\n  \"Use Wagmi React hooks to connect a wallet\": 47,\n  \"Batch multiple RPC calls with viem\": 46\n}",
            "additional_kwargs": {
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 3028,
                    "prompt_tokens": 6244,
                    "total_tokens": 9272,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 2240,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CPtWvRb3EKz3m81gNaztwXAQCPbTV",
                "service_tier": "default",
                "finish_reason": "stop",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--6ccc5314-96d0-456f-8da6-e72932ec1f84-0",
            "example": false,
            "tool_calls": [],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 6244,
                "output_tokens": 3028,
                "total_tokens": 9272,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 2240
                }
            }
        }
    ]
}