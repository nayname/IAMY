{
    "messages": [
        {
            "content": " Compile a Contract\nHow to Compile CosmWasm Smart Contracts\n\nThis guide is from the official CosmWasm/rust-optimizer repository. This method of compiling the contract will optimize the final build so that it reduces gas consumption.\n\nExample contracts for this can be found at https://github.com/CosmWasm/cw-examples. This repository requires this section to compile since multiple contracts are involved in a single repository.\n\nIf you have ZERO experience with smart contracts, you need to check out book.cosmwasm.com for setting up your environment, testnet, and the basics of CosmWasm.\n\nFor all great CosmWasm tools, https://github.com/CosmWasm/awesome-cosmwasm\n\nSingle Contract Repository\nThe easiest way is to simply use the published docker image. You must run this in the root of the smart contract repository you wish to compile. It will produce an artifacts directory with <crate_name>.wasm and contracts.txt containing the hashes. This is just one file.\n\n\nCopy\ndocker run --rm -v \"$(pwd)\":/code \\\n  --mount type=volume,source=\"$(basename \"$(pwd)\")_cache\",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/rust-optimizer:0.12.11\n\n# If you you use an ARM machine (Ex: Mac M1), you need to use the following\n# This is experimental and should not be used for production use\n\ndocker run --rm -v \"$(pwd)\":/code \\\n  --mount type=volume,source=\"$(basename \"$(pwd)\")_cache\",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/rust-optimizer-arm64:0.12.11\nBy running this in the root of your project, it will compile your contract into an artifacts/ folder. From here you can upload it to chain, collect the store code, and interact with it as you design\n\nMultiple Contract Repository (Mono Repo)\nSometime you want many contracts to be related and import common functionality. This is exactly the case of cosmwasm-plus. In such a case, we can often not just compile from root, as the compile order is not deterministic and there are feature flags shared among the repos. This has lead to issues in the past.\n\nFor this use-case there is second docker image, which will compile all the contracts/* folders inside the workspace and do so one-by-one in alphabetical order. It will then add all the generated wasm files to an artifacts directory with a checksum, just like the basic docker image (same output format).\n\nTo compile all contracts in the workspace deterministically, you can run:\n\n\nCopy\ndocker run --rm -v \"$(pwd)\":/code \\\n  --mount type=volume,source=\"$(basename \"$(pwd)\")_cache\",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/workspace-optimizer:0.12.11\n\n# If you you use an ARM machine (Ex: Mac M1), you need to use the following\n# This is experimental and should not be used for production use\n\ndocker run --rm -v \"$(pwd)\":/code \\\n  --mount type=volume,source=\"$(basename \"$(pwd)\")_cache\",target=/code/target \\\n  --mount type=volume,source=registry_cache,target=/usr/local/cargo/registry \\\n  cosmwasm/workspace-optimizer-arm64:0.12.11\nNOTE: See the difference with workspace-optimizer vs rust-optimizer in the previous single contract example.\\\n\n\nDeploy a Contract\nSubmit the code of a smart contract to chain and get its code id\n\nPreRequisite\nMake sure you follow the compile a contract guide first for your project. Once you have a contract compiled in the artifacts/*.wasm directory, you are ready for this guide.\n\nThis guide will show you how to deploy and interact with a contract using CLI. For scripting using Rust, you can use cw-orchestrator.\n\nUpload\nYou need to upload the contract via the CLI to chain. To do this, perform the following\n\n\nCopy\nTXFLAGS=\"--chain-id=uni-6 --gas-prices=0.025ujunox --gas=auto --gas-adjustment 1.3\"\n\njunod tx wasm store artifacts/CONRTACT_NAME.wasm \\\n    --from <KEY> $TXFLAGS -y --broadcast-mode=block\nThis will then return a transaction hash. With this data, you need to query it to get the code id of the contract on chain\n\n\nCopy\njunod q tx 38330E909CD219B80927009DA37FD69D334D19B2AD4EC47456A24E85034F0085 --output=json\nThis will return the data about the transaction, and give us the code id of our contract\n\n\nCopy\n{\n  \"height\": \"294601\",\n  \"txhash\": \"38330E909CD219B80927009DA37FD69D334D19B2AD4EC47456A24E85034F0085\",\n  \"codespace\": \"\",\n  \"code\": 0,\n  \"data\": \"0A460A1E2F636F736D7761736D2E7761736D2E76312E4D736753746F7265436F64651224080D12203318E74E8C68DBCC6E0317C42B8DB0AB642B61AEFAD487DEDB6ECB54FFED4D72\",\n  \"raw_log\": \"[{\\\"events\\\":[{\\\"type\\\":\\\"message\\\",\\\"attributes\\\":[{\\\"key\\\":\\\"action\\\",\\\"value\\\":\\\"/cosmwasm.wasm.v1.MsgStoreCode\\\"},{\\\"key\\\":\\\"module\\\",\\\"value\\\":\\\"wasm\\\"},{\\\"key\\\":\\\"sender\\\",\\\"value\\\":\\\"juno1hj5fveer5cjtn4wd6wstzugjfdxzl0xps73ftl\\\"}]},{\\\"type\\\":\\\"store_code\\\",\\\"attributes\\\":[{\\\"key\\\":\\\"code_checksum\\\",\\\"value\\\":\\\"3318e74e8c68dbcc6e0317c42b8db0ab642b61aefad487dedb6ecb54ffed4d72\\\"},{\\\"key\\\":\\\"code_id\\\",\\\"value\\\":\\\"13\\\"}]}]}]\",\n  \"logs\": [\n    {\n      \"msg_index\": 0,\n      \"log\": \"\",\n      \"events\": [\n        {\n          \"type\": \"message\",\n          \"attributes\": [\n            {\n              \"key\": \"action\",\n              \"value\": \"/cosmwasm.wasm.v1.MsgStoreCode\"\n            },\n            {\n              \"key\": \"module\",\n              \"value\": \"wasm\"\n            },\n            {\n              \"key\": \"sender\",\n              \"value\": \"juno1hj5fveer5cjtn4wd6wstzugjfdxzl0xps73ftl\"\n            }\n          ]\n        },\n        {\n          \"type\": \"store_code\",\n          \"attributes\": [\n            {\n              \"key\": \"code_checksum\",\n              \"value\": \"3318e74e8c68dbcc6e0317c42b8db0ab642b61aefad487dedb6ecb54ffed4d72\"\n            },\n            {\n              \"key\": \"code_id\",\n              \"value\": \"13\"\n            }\n          ]\n        }\n      ]\n    }\n  }]\n}\nWe can see both raw_log and also logs[0].events[1].store_code shows the code_id being 13. If you wish the automate this return code in bash to a variable, you can\n\n\nCopy\n# ensure jq is installed\nUPLOAD_TX_HASH=38330E909CD219B80927009DA37FD69D334D19B2AD4EC47456A24E85034F0085\nCODE_ID=$(junod q tx $UPLOAD_TX_HASH --output json | jq -r '.logs[0].events[] | select(.type == \"store_code\").attributes[] | select(.key == \"code_id\").value') && echo \"Code Id: $CODE_ID\"\nInstantiate\nWith the code now being up on chain, we can now run logic to setup our own copy of the contract which we control. This will then give us a unique contract address for others to interact with in accordance with the contract logic. This example is from the cosmwasm/cw-template.\n\nEnsure you change CODE_ID to match your code id from the store code\n\n\nCopy\n# Manual\nCODE_ID=1\njunod tx wasm instantiate \"$CODE_ID\" '{\"count\":0}' --label \"some-contract\" $FLAGS -y --admin <your-address-here>\n# then query the tranasaction hash as we do above.\n\n# Automated return of the contract address\nCODE_ID=1\nTX_INIT=$(junod tx wasm instantiate \"$CODE_ID\" '{\"count\":0}' --label \"contract\" $FLAGS -y --admin <your-address-here> | jq -r '.txhash') && echo $TX_INIT\nCONTRACT_ADDR=$($BINARY query tx $TX_INIT --output json | jq -r '.logs[0].events[0].attributes[0\n\n\nGuide: How to Upload a Smart Contract on the Juno Chain\nWelcome to this tutorial on deploying a smart contract to the Juno testnet. This guide will show you how to deploy and interact with a contract using CLI. For scripting using Rust, you can use [cw-orc\n\n\nPreparation:\nRequired Materials: A computer with an internet connection, familiarity with GitHub, and basic knowledge of smart contracts.\n\nSteps:\nFind an Example Smart Contract:\n\n(Note: The steps here mainly involve browsing, no specific bash commands.)\n\nIn this tutorial we will be using https://github.com/Reecepbcups/cw-clock-exampl\n\nConnect to the Juno Testnet:\n\nCheck out our new video that shows you how to deploy a local env\n\nhttps://github.com/Reecepbcups/cw-clock-example\n\nCreate a Juno Wallet:\n\n\nCopy\nbash junod keys add MyWalletName\n5. Claim junox Test Tokens:\n\nHead to Juno Discord https://discord.com/invite/caEBtA4QDb and find FAUCET section. In there you can get some using the API provided and inputting the wallet address you created in the previous step. https://faucet.reece.sh/uni-6/JUNO_ADDRESS_HERE\n\n6. Verify Token Receipt:\n\n\nCopy\njunod query bank balances [YOUR_WALLET_ADDRESS]\n7. Configure the Juno Command Line:\n\n\nCopy\nbash junod config node [NODE_URL]\njunod config chain-id [CHAIN_ID]\njunod config gas auto\njunod config gas-prices 0.025ujuno\n8. Deploy the Smart Contract:\n\nAssuming you've downloaded clock_example.wasm to your current directory\n\n\nCopy\njunod tx wasm store clock_example.wasm --from MyWalletName --gas 1500000 --chain-id [CHAIN_ID]\n9. Instantiate the Smart Contract:\n\nReplace [CODE_ID] with the code ID obtained from the previous step e.g 3785\n\n\nCopy\n junod tx wasm instantiate [CODE_ID] '{\"count\": 0}' --label \"my-clock-instance\" --from MyWalletName --amount 100ujuno\n10. Interact with the Smart Contract:\n\nQuery the smart contract (replace [CONTRACT_ADDRESS] with the address from instantiation) junod query wasm contract [CONTRACT_ADDRESS]\n\n\nCopy\n\njunod tx wasm execute [CONTRACT_ADDRESS] '{\"increment\": {}}' --from MyWalletName --amount 10ujuno\nConclusion:\nYou've now successfully uploaded, instantiated, and interacted with a smart contract on the Juno testnet.\n\nIf you have further questions or ideas, join the Juno community on Discord, particularly the \"developer lounge\".\n\nNote: Adjust the bash commands to fit your specific situation, and always double-check them, especially when working with real tokens or live environments.\\\n\n\nUse Cw-orchestrator to speed-up your development\nIntegrate you smart-contract with cw-orch and facilitate testing/development and maintenance of your project.\n\nIntroduction\ncw-orchestrator is the most advanced scripting, testing, and deployment framework for CosmWasm smart-contracts. It makes it easy to write cross-environment compatible code for cw-multi-test, Test Tube, Starship (alpha), and live networks, significantly reducing code duplication and test-writing time.\n\nGet ready to change the way you interact with contracts and simplify you smart-contracts journey. The following steps will allow you to integrate cw-orch and write clean code such as:\n\n\nCopy\ncounter.upload()?;\ncounter.instantiate(&InstantiateMsg { count: 0 }, None, None)?;\ncounter.increment()?;\n\nlet count = counter.get_count()?;\nassert_eq!(count.count, 1);\nIn this quick-start guide, we will review the necessary steps in order to integrate cw-orch into a simple contract crate. We review integration of rust-workspaces (multiple contracts) at the end of this page.\n\nNOTE: Quicker than the quick start\n\nIf you're moving quicker than everybody else, we suggest looking at a before-after review of this example integration. This will help you catch the additions you need to make to your contract to be able to interact with it using cw-orchestrator.\n\nNOTE: If you want to go more in depth, browse the full cw-orch documentation.\n\nSummary\nIntroduction\n\nSummary\n\nSingle Contract Integration\n\nAdding cw-orch to your Cargo.toml file\n\nCreating an Interface\n\nInteraction helpers\n\nUsing the integration\n\nIntegration in a workspace\n\nHandling dependencies and features\n\nCreating an interface crate\n\nIntegrating single contracts\n\nMore examples and scripts\n\nSingle Contract Integration\nThroughout this example, we will be using cw-orch to interact with a simple counter contract. All the steps below apply to any smart contract, no matter the complexity.\n\nAdding cw-orch to your Cargo.toml file\nTo use cw-orchestrator, you need to add cw-orch to your contract's TOML file. Run the command below in your contract's directory:\n\n\nCopy\ncargo add --optional cw-orch\nAlternatively, you can add it manually in your Cargo.toml file as shown below:\n\n\nCopy\n[dependencies]\ncw-orch = {version = \"0.19.1\", optional = true } # Latest version at time of writing\nNow that we have added cw-orch as an optional dependency we will want to enable it through a feature-flag. This ensures that the code added by cw-orch is not included in the wasm artifact of the contract.\n\nTo do this add an interface feature to the Cargo.toml and enable cw-orch when it is enabled like so:\n\n\nCopy\n[features]\ninterface = [\"dep:cw-orch\"] # Enables cw-orch when the feature is enabled\nNOTE: If you are using rust-analyzer, you can add the following two lines in your settings.json to make sure the features get taken into account when checking the project:\n\n\nCopy\n \"rust-analyzer.cargo.features\": \"all\",\n \"rust-analyzer.check.features\": \"all\",\nCreating an Interface\nWhen using a single contract, we advise creating an interface.rs file inside your contract's directory. You then need to add this module to your lib.rs file. Don't forget to feature-flag the module in order to be able to use cw-orch inside it.\n\n\nCopy\n#[cfg(feature = \"interface\")]\nmod interface;\nThen, inside that interface.rs file, you can define the interface for your contract:\n\n\nCopy\nuse cw_orch::{interface, prelude::*};\n\nuse crate::msg::{ExecuteMsg, InstantiateMsg, MigrateMsg, QueryMsg};\n\npub const CONTRACT_ID: &str = \"counter_contract\";\n\n#[interface(InstantiateMsg, ExecuteMsg, QueryMsg, MigrateMsg, id = CONTRACT_ID)]\npub struct CounterContract;\n\nimpl<Chain: CwEnv> Uploadable for CounterContract<Chain> {\n    /// Return the path to the wasm file corresponding to the contract\n    fn wasm(&self) -> WasmPath {\n        artifacts_dir_from_workspace!()\n            .find_wasm_path(\"counter_contract\")\n            .unwrap()\n    }\n    /// Returns a CosmWasm contract wrapper\n    fn wrapper(&self) -> Box<dyn MockContract<Empty>> {\n        Box::new(\n            ContractWrapper::new_with_empty(\n                crate::contract::execute,\n                crate::contract::instantiate,\n                crate::contract::query,\n            )\n            .with_migrate(crate::contract::migrate),\n        )\n    }\n}\nLearn more about the content of the interface creation specifics in the cw-orch documentation\n\nNOTE: It can be useful to re-export this struct to simplify usage (in lib.rs):\n\n\nCopy\n#[cfg(feature = \"interface\")]\npub use crate::interface::CounterContract;\nInteraction helpers\ncw-orchestrator provides a additional macros that simplify contract calls and queries. The macro implements functions on the interface for each variant of the contract's ExecuteMsg and QueryMsg.\n\nEnabling this functionality is very straightforward. Find your ExecuteMsg and QueryMsg definitions (in msg.rs in our example) and add the ExecuteFns and QueryFns derive macros to them like below:\n\n\nCopy\n#[cw_serde]\n#[cfg_attr(feature = \"interface\", derive(cw_orch::ExecuteFns))] // Function generation\n/// Execute methods for counter\npub enum ExecuteMsg {\n    /// Increment count by one\n    Increment {},\n    /// Reset count\n    Reset {\n        /// Count value after reset\n        count: i32,\n    },\n}\n\n#[cw_serde]\n#[cfg_attr(feature = \"interface\", derive(cw_orch::QueryFns))] // Function generation\n#[derive(QueryResponses)]\n/// Query methods for counter\npub enum QueryMsg {\n    /// GetCount returns the current count as a json-encoded number\n    #[returns(GetCountResponse)]\n    GetCount {},\n}\n\n// Custom response for the query\n#[cw_serde]\n/// Response from get_count query\npub struct GetCountResponse {\n    /// Current count in the state\n    pub count: i32,\n}\nFind out more about the interaction helpers in the cw-orch documentation\n\nNOTE: Again, it can be useful to re-export these generated traits to simplify usage (in lib.rs):\n\n\nCopy\n#[cfg(feature = \"interface\")]\npub use crate::msg::{ExecuteMsgFns as CounterExecuteMsgFns, QueryMsgFns as CounterQueryMsgFns};\nUsing the integration\nNow that all the setup is done, you can use your contract in tests, integration-tests or scripts.\n\nStart by importing your crate, with the interface feature enabled. Depending on your use-case this will be in [dependencies] or [dev-dependencies]:\n\n\nCopy\ncounter-contract = { path = \"../counter-contract\", features = [\"interface\"] }\nYou can now use:\n\n\nCopy\nuse counter_contract::{\n    msg::InstantiateMsg, CounterContract, CounterExecuteMsgFns, CounterQueryMsgFns,\n};\nuse cw_orch::{anyhow, prelude::*, tokio};\nuse tokio::runtime::Runtime;\n\nconst LOCAL_MNEMONIC: &str = \"clip hire initial neck maid actor venue client foam budget lock catalog sweet steak waste crater broccoli pipe steak sister coyote moment obvious choose\";\npub fn main() -> anyhow::Result<()> {\n    std::env::set_var(\"LOCAL_MNEMONIC\", LOCAL_MNEMONIC);\n    dotenv::dotenv().ok(); // Used to load the `.env` file if any\n    pretty_env_logger::init(); // Used to log contract and chain interactions\n\n    let rt = Runtime::new()?;\n    let network = networks::LOCAL_JUNO;\n    let chain = DaemonBuilder::default()\n        .handle(rt.handle())\n        .chain(network)\n        .build()?;\n\n\n    let counter = CounterContract::new(chain);\n\n    counter.upload()?;\n    counter.instantiate(&InstantiateMsg { count: 0 }, None, None)?;\n\n    counter.increment()?;\n\n    let count = counter.get_count()?;\n    assert_eq!(count.count, 1);\n\n    Ok(())\n}\nIntegration in a workspace\nIn this paragraph, we will use the cw-plus repository as an example. You can review:\n\nThe full integration code with cw-orch added\n\nThe complete diff that shows you all integration spots (if you want to go fast)\n\nHandling dependencies and features\nWhen using workspaces, you need to do the 2 following actions on all crates that include ExecuteMsg and QueryMsg used in your contracts:\n\nAdd cw-orch as an optional dependency\n\nAdd an interface feature (ensures cw-orch is not compiled into your wasm contract)\n\nRefer above to Adding cw-orch to your Cargo.toml file for more details on how to do that.\n\nFor instance, for the cw20_base contract, you need to execute those 2 steps on the cw20-base contract (where the QueryMsg are defined) as well as on the cw20 package (where the ExecuteMsg are defined).\n\nCreating an interface crate\nWhen using a workspace, we advise you to create a new crate inside your workspace for defining your contract's interfaces. In order to do that, use:\n\n\nCopy\ncargo new interface --lib\ncargo add cw-orch --package interface\nAdd the interface package to your workspace Cargo.toml file\n\n\nCopy\n[workspace]\nmembers = [\"packages/*\", \"contracts/*\", \"interface\"]\nInside this interface crate, we advise to integrate all your contracts 1 by 1 in separate files. Here is the structure of the cw-plus integration for reference:\n\n\nCopy\ninterface (interface collection)\n\u251c\u2500\u2500 Cargo.toml\n\u2514\u2500\u2500 src\n    \u251c\u2500\u2500 cw1_subkeys.rs\n    \u251c\u2500\u2500 cw1_whitelist.rs\n    \u251c\u2500\u2500 cw20_base.rs\n    \u251c\u2500\u2500 cw20_ics20.rs\n    \u2514\u2500\u2500 ..\nWhen importing your crates to get the messages types, you can use the following command in the interface folder. Don't forget to activate the interface feature to be able to use the cw_orch functionalities.\n\n\nCopy\ncargo add cw20-base --path ../contracts/cw20-base/ --features=interface\ncargo add cw20 --path ../packages/cw20 --features=interface\nIntegrating single contracts\nNow that you workspace is setup, you can integrate with single contracts using the above section\n\nMore examples and scripts\nYou can find more example interactions on the counter-contract example directly in the cw-orchestrator repo:\n\nSome examples showcase interacting with live chains.\n\nSome other examples show how to use the library for testing your contracts.\n\nFINAL ADVICE: Learn more and explorer our full cw-orch documentation !\n\n\nQuery A Contract\nDescribes how to query a cosmwasm smart contract with the CLI & REST API.\n\nCommand Line Interface\nThe most common way to query a cosmwasm smart contract is within the junod wasm smart query command. This follows the following format where query is a JSON string with no spaces. By default, the least amount of data this can be is an empty JSON payload '{}'.\n\n\nCopy\njunod query wasm contract-state smart [contract_bech32] [query] [flags]\nFor this example, we are going to use a random NFT contract on the juno chain. This will show you how to brute force query a contract if you have no idea what the query schema of the contract is. At this time, there is no way to query the format of a contract's requests, but this is something many are actively working on.\n\nNow we attempt to query this contract address and extract some data from it and get which queries are allowed. As you can see, we pass through a random payload for abcde so that the contract will return actual valid query requests\n\nNOTE: A Query can never be empty such as '{}' given you need to specify the path of data you want to reach.\n\n\nCopy\nCONTRACT=juno1anh4pf98fe8uh64uuhaasqdmg89qe6kk5xsklxuvtjmu6rhpg53sj9uejj\njunod q wasm contract-state smart $CONTRACT '{\"abcde\":{}}'\n\n# Error parsing into type\n#    cw721_base::msg::QueryMsg<cosmwasm_std::results::empty::Empty>\n#    unknown variant `abcde`,\n#    expected one of `owner_of`, `approval`, `approvals`, `all_operators`,\n#    `num_tokens`, `contract_info`, `nft_info`, `all_nft_info`, `tokens`,\n#    `all_tokens`, `minter`, `extension`\nThe query shows CW721 Base is this contracts name. As this is a standard contract, all messages can be found in the CosmWasm/cw-nfts repository on github\n\nhttps://github.com/CosmWasm/cw-nfts/blob/main/contracts/cw721-base/src/msg.rs\n\nFrom this, we now know all of the query endpoints and can requests something more specific from the contract for our usage. Let's get\n\n\nCopy\nCONTRACT=juno1anh4pf98fe8uh64uuhaasqdmg89qe6kk5xsklxuvtjmu6rhpg53sj9uejj\njunod q wasm contract-state smart $CONTRACT '{\"all_tokens\":{}}'\n\ndata:\n  tokens:\n  - \"0\"\n  - \"1\"\n  - \"2\"\n  - \"3\"\n  - \"4\"\n  - \"5\"\n  - \"6\"\n  - \"7\"\n  - \"8\"\n\n# You can use --output=json to read it via JSON form\n# junod q wasm contract-state smart $CONTRACT '{\"all_tokens\":{}}' --output=json | jq .data\nHere we can see there are 8 tokens in this set. Lets query one of the NFTs information\n\n\nCopy\nCONTRACT=juno1anh4pf98fe8uh64uuhaasqdmg89qe6kk5xsklxuvtjmu6rhpg53sj9uejj\njunod q wasm contract-state smart $CONTRACT '{\"nft_info\":{}}'\n\n# missing field `token_id`: query wasm contract failed\nJust like the first query, we can see that the payload needs more information. It returned an error that we need to specify the token_id we want the nft_info for. Note, Uint128 sized numbers are read as a string\n\n\nCopy\nCONTRACT=juno1anh4pf98fe8uh64uuhaasqdmg89qe6kk5xsklxuvtjmu6rhpg53sj9uejj\njunod q wasm contract-state smart $CONTRACT '{\"nft_info\":{\"token_id\":\"8\"}}'\n\n# data:\n#   extension: null\n#   token_uri: ipfs://bafyreib42csdu7426ki7mxk6firvbz4uk3fo4dxpjy2kkskzdhtgj3rriq/metadata.json\nRest API Query\nIf you wish to query the data more programmatically with an application such as Python, you may be better suited to use the rest API. You can find these endpoints on https://cosmos.directory/juno/nodes in the REST section.\n\nThis query endpoint can be found via Juno's SwaggerUI. However, some modules you will not be able to easily find the endpoint. To do this, you will need to search through the proto files. Here we know we want to query the cosmwasm module, which is called wasmd on chain. This repo is found at https://github.com/cosmwasm/wasmd.\n\nIn this module, you can see the proto folder in the root of the repo. This will house the endpoints the module exposes so we can find the above path which. This is a query so we find the query proto file\nhttps://github.com/CosmWasm/wasmd/blob/main/proto/cosmwasm/wasm/v1/query.proto\\\n\n\nCopy\noption go_package = \"github.com/CosmWasm/wasmd/x/wasm/types\";\noption (gogoproto.goproto_getters_all) = false;\noption (gogoproto.equal_all) = false;\n\n// Query provides defines the gRPC querier service\nservice Query {\n   ...\n  // SmartContractState get smart query result from the contract\n  rpc SmartContractState(QuerySmartContractStateRequest)\n      returns (QuerySmartContractStateResponse) {\n    option (google.api.http).get =\n        \"/cosmwasm/wasm/v1/contract/{address}/smart/{query_data}\";\n  }\n  ...\nYou must base64 encode the JSON payload for REST API Request. Just take your JSON payload and\n\n- put it into https://www.base64encode.org/\n- or use Mac / Linux built in command\n\necho '{\"all_tokens\":{}}' | base64\n# eyJhbGxfdG9rZW5zIjp7fX0K\n\nWith this, we can now query the contract and gather the data. You can use your web browser, or a library like httpx / requests in Python for automated bots. Be aware that many API providers will late limit the number of requests you can make.\n\nhttps://api.juno.strange.love/cosmwasm/wasm/v1/contract/juno1anh4pf98fe8uh64uuhaasqdmg89qe6kk5xsklxuvtjmu6rhpg53sj9uejj/smart/eyJhbGxfdG9rZW5zIjp7fX0K\n\n\nCopy\n{\n    \"data\": {\n        \"tokens\": [\n            \"0\",\n            \"1\",\n            \"2\",\n            \"3\",\n            \"4\",\n            \"5\",\n            \"6\",\n            \"7\",\n            \"8\"\n        ]\n    }\n}\nCosmology Smart Contract Query\nUsing CosmWasm/ts-codegen, you can create an NPM module to make interactions and queries into dev-friendly Typescript classes to allow you to focus on shipping code.\n\nHere are a few tutorials from cosmology:\n\nts-codegen overview for CosmWasm\n\nCosmWasm Contract to Typescript npm module\n\nConfigure CosmWasm ts-codegen in your Contracts repo\n\nQuery a CosmWasm smart contract from ts-codegen\n\nEnable React Query\n\nEnable Recoil\n\nIntegrate Telescope with ts-codegen\n\nCosmJS Query\nTODO: Add how to query a smart contract data with Typescript + Example through the RPC endpoint (proto encoded) & httpbatch tendermint client\n\nInternal\nTODO: internal rust impl of how to WasmQuery a contract and get some data back.\n\n\nSend Tokens to a Contract\nCommand Line Interface\nWhen you execute a message, a user can also pass through a flag which sends funds from their account to the contract to do logic. You can check if a user sends any funds in your contract's execute endpoint with the info.funds array of Coins sent by the user. These funds then get added to the contracts balance just like any other account. So it is up to you as the developer to ensure to save how many funds each user has sent via a BTreeMap or other object storage in state (if they can redeem funds back at a later time).\n\nTo send funds to a contract with some arbitrary endpoint, you use the --amount flag.\n\n\nCopy\njunod tx wasm execute CONTRACT '{\"some_endpoint\":{}}' --amount 1000000ujuno\nIf the \"some_endpoint\" execute errors on the contract, the funds will remain in the users account.\n\nTypescript\n\nCopy\nimport type {Coin} from \"@cosmjs/stargate\"\nimport { SigningStargateClient, StargateClient, type StdFee } from '@cosmjs/stargate';\n\nimport type { OfflineAminoSigner } from '@cosmjs/amino';\nimport type { OfflineDirectSigner } from '@cosmjs/proto-signing';\n\nimport { SigningCosmWasmClient } from '@cosmjs/cosmwasm-stargate';\n\nlet RPC = \"https://rpc.juno.strange.love\"\n\nconst get_wallet_for_chain = async (\n    chain_id: string\n): Promise<OfflineAminoSigner | OfflineDirectSigner> => {\n\t// open keplr\n\tconst keplr = window as KeplrWindow;\n\tif (keplr === undefined) {\n\t\tthrow new Error('Keplr not found');\n\t}\n\tlet signer = keplr.getOfflineSignerAuto;\n\tif (signer === undefined) {\n\t\tthrow new Error('Keplr not found');\n\t}\n\treturn signer(chain_id);\n};\n\nlet wallet = await get_wallet_for_chain(\"juno-1\");\nlet address = (await wallet.getAccounts())[0].address;\n\nlet from_client = await SigningCosmWasmClient.connectWithSigner(RPC, wallet, {\n\tprefix: \"juno\"\n});\n\nconst msg = {\"some_endpoint\": {}}\n\nlet fee: StdFee = {\n    amount: [{amount: \"5000\",denom: \"ujuno\"}],\n    gas: \"500000\"\n}\n\nlet send_amount: Coin = {\n    amount: \"100000\",\n    denom: \"ujuno\"\n}\n\nawait from_client.execute(\n\taddress,\n\tREVIEWS_CONTRACT_ADDRESS,\n\tmsg,\n\tfee,\n\t\"memo\",\n\tsend_amount,\n).then((res) => {\n    console.log(`Success @ height ${res.height}\\n\\nTxHash: ${res.transactionHash}`)\n});\nts-codegen\nThe cosmology toolkit has some useful typescript tools for interacting with your smart contracts. The repo can be found at https://github.com/CosmWasm/ts-codegen, with setup and query tutorials in Query A Contract section of this documentation.\n\nHere are some video tutorials:\n\nHow to Execute a cosmwasm smart contract\n\nAdvanced execution with a cosmwasm message composer",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "human",
            "name": null,
            "id": "f8ec57d3-1106-4d60-b718-d09974a6f0c6"
        },
        {
            "content": "{\n  \"Upload the compiled wasm file artifacts/CONTRACT_NAME.wasm to the Juno chain\": 100,\n  \"Compile the current CosmWasm smart contract using rust-optimizer\": 98,\n  \"Instantiate the contract with code id 13 and init message {\\\"count\\\":0}\": 96,\n  \"Execute increment on contract address CONTRACT_ADDRESS with 10ujuno\": 94,\n  \"Compile all workspace contracts with workspace-optimizer\": 92,\n  \"Query the transaction hash 38330E909CD219B80927009DA37FD69D334D19B2AD4EC47456A24E85034F0085 to get the code id\": 90,\n  \"Send 1000000ujuno to contract address CONTRACT_ADDRESS using some_endpoint\": 88,\n  \"Query all_tokens list from NFT contract CONTRACT_ADDRESS\": 86,\n  \"Query nft_info for token 8 on contract CONTRACT_ADDRESS\": 84,\n  \"Create a new Juno wallet named MyWalletName\": 83,\n  \"Check the balance of wallet ADDRESS on Juno\": 82,\n  \"Configure junod with node NODE_URL and chain-id uni-6\": 81,\n  \"Compile the contract for ARM64 using rust-optimizer-arm64\": 79,\n  \"Claim JUNOX test tokens from the faucet for ADDRESS\": 78,\n  \"Add cw-orch as an optional dependency in Cargo.toml\": 77,\n  \"Generate interface.rs for the contract with cw-orch interface macro\": 76,\n  \"Upload, instantiate and increment the counter using cw-orchestrator\": 75,\n  \"Base64 encode the JSON payload {'all_tokens':{}}\": 74,\n  \"Set TXFLAGS environment variable with gas settings\": 73,\n  \"Automatically extract the contract address from instantiate txhash\": 72,\n  \"Query contract smart state with payload {'abcde':{}} to discover schema\": 71,\n  \"Execute reset on contract CONTRACT_ADDRESS setting count to 0\": 70,\n  \"Get current count from contract CONTRACT_ADDRESS\": 69,\n  \"Store the returned code id in shell variable CODE_ID\": 68,\n  \"Connect SigningCosmWasmClient to RPC https://rpc.juno.strange.love and execute increment\": 67,\n  \"Add 'interface' feature flag to enable cw-orch in Cargo.toml\": 66,\n  \"Query the smart contract via REST endpoint with base64 encoded query\": 65,\n  \"Compile and upload clock_example.wasm to the Juno testnet\": 64,\n  \"Use --amount flag to attach tokens when executing a contract\": 63,\n  \"Generate a TypeScript client with ts-codegen for the contract\": 62,\n  \"Query contract-state smart with junod CLI\": 61\n}",
            "additional_kwargs": {
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 2716,
                    "prompt_tokens": 8315,
                    "total_tokens": 11031,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 2112,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 8192
                    }
                },
                "model_provider": "openai",
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-Cb6JQWcWIAEzZUTeaWjjs4Ke21HKA",
                "service_tier": "default",
                "finish_reason": "stop",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "lc_run--83fa1752-6e46-4ec8-b87c-8359c932a86a-0",
            "tool_calls": [],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 8315,
                "output_tokens": 2716,
                "total_tokens": 11031,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 8192
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 2112
                }
            }
        }
    ]
}