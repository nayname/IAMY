Overview

Copy page

Tooling and resources to 10x your development workflows.

​
Client Integrations
Client libraries play a crucial role indevelopment by making it easier for developers interact with the underlying protocols. Well-made libraries abstract away complexities and provide optimized methods to allow developers to focus on their project rather than the network itself.”
EthersJS and Web3JS are two most commonly used libraries in dApp development. Developer uses these libraries to interact with blockchain and query JSON-RPC data, for example. Additionally, both of these libraries contain utilities to aid in task like converting large numbers (BigNumber).
Ethers.js is the latest JS library that aims to be a complete and compact library for interacting with the Ethereum Blockchain and its ecosystem.


Block Explorers

Copy page

Blockchain explorers allow users to query the blockchain for data. Explorers are often compared to search engines for the blockchain. By using an explorer, users can search and track balances, transactions, contracts, and other broadcast data to the blockchain.

Cosmos EVM chains can use two types block explorers: an EVM explorer and a Cosmos explorer. Each explorer queries data respective to their environment with the EVM explorers querying Ethereum-formatted data (blocks, transactions, accounts, smart contracts, etc) and the Cosmos explorers querying Cosmos-formatted data (Cosmos and IBC transactions, blocks, accounts, module data, etc).
​
List of Block Explorers​
Below is a list of open source explorers that you can use:
Service	Support	URL
Ping.Pub	cosmos	Github Repo
BigDipper	cosmos	Github Repo
Blockscout	ethereum	Github Repo
​
Cosmos & EVM Compatible explorers​
As of yet, there is no open source explorer that supports both EVM and Cosmos transactions. Mintscan does support this but requires an integration.


Foundry Guide - Setup & Walkthrough

Copy page

An introduction to Foundry and using the cast function, replacing complex scripts that may otherwise require multiple rpc calls and other functions in between with a single command.

Foundry is a fast and modular toolkit for Ethereum application development written in Rust. It provides four main command-line tools—forge, cast, anvil, and chisel—to streamline everything from project setup to live-chain interactions.
Among these, cast serves as your “Swiss-army knife” for JSON-RPC calls, letting you execute tedious day-to-day tasks (like sending raw transactions, querying balances, fetching blocks, and looking up chain metadata) with simple, consistent commands instead of verbose curl scripts.
This guide walks you through installing Foundry, configuring your environment, and using the most common cast commands to accelerate your development workflow.
​
Installation & Setup
​
Install Foundry
Run the following command to install foundryup, the Foundry toolchain installer. This will give you the four main binaries.

Copy

Ask AI
curl -L https://foundry.paradigm.xyz | bash
foundryup
After installation, you can switch to the nightly builds for the latest features, though this is optional.

Copy

Ask AI
foundryup -i nightly
​
Verify Installation
Check that each binary was installed correctly by running:

Copy

Ask AI
foundryup --version
cast --version
forge --version
anvil --version
See all 4 lines
You should see version outputs for each tool (e.g., cast 0.2.0).
​
Configuration
To avoid passing the --rpc-url flag with every command, you can set defaults in a foundry.toml file. This file can be placed in your project’s root directory for project-specific settings, or you can create a global configuration at ~/.foundry/foundry.toml for settings you use across all projects.
Here is an example of a global configuration for connecting to a local Cosmos EVM node:
~/.foundry/foundry.toml

Copy

Ask AI
# ~/.foundry/foundry.toml

# Declare your named endpoints (optional; for forge test / forking)
[rpc_endpoints]
cosmos = "<evm_rpc_url>"

# Configure the default profile for cast/forge/anvil
[profile.default]
# Tell Foundry which chain you're targeting:
chain_id     = 4321
# Directly tell cast to use your endpoint:
eth_rpc_url  = "<evm_rpc_url>"
# Set EVM version for Solidity compilation
evm_version  = "istanbul"
See all 14 lines
With this global configuration, Foundry tools will automatically connect to your local node without needing additional flags.
​
Basic Usage of cast
cast replaces the need for custom shell scripts and verbose curl commands by offering first-class RPC commands.
​
Chain Metadata
Get Chain ID

Copy

Ask AI
cast chain-id --rpc-url local
Returns the chain ID in decimal format.
Get Client Version

Copy

Ask AI
cast client --rpc-url local
Displays the client implementation and version (e.g., reth/v1.0.0).
​
cast Command Reference
​
Chain Commands
Command	Purpose
cast chain	Show the symbolic name of the current chain.
cast chain-id	Fetch the numeric chain ID.
cast client	Get the JSON-RPC client version.
Example:

Copy

Ask AI
# Assuming FOUNDRY_RPC_URL is set or using a configured alias
cast chain
cast chain-id
cast client
​
Transaction Commands
Command	Purpose
cast send	Sign and publish a transaction.
cast publish	Publish a raw, signed transaction.
cast receipt	Fetch the receipt for a transaction hash.
cast tx	Query transaction details (status, logs, etc.).
cast rpc	Invoke any raw JSON-RPC method.
Sign and Send (using a private key or local keystore):

Copy

Ask AI
cast send 0xRecipientAddress "transfer(address,uint256)" "0xSomeOtherAddress,100" --private-key $YOUR_PK
Publish Raw Transaction (hex-encoded):

Copy

Ask AI
cast publish 0xf86b808504a817c80082520894...
Generic RPC Call:

Copy

Ask AI
cast rpc eth_sendRawTransaction 0xf86b8085...
​
Account & Block Commands
Command	Purpose
cast balance	Get an account’s balance (supports ENS and units).
cast block	Fetch block information by number or hash.
cast block-number	Get the latest block number.
cast logs	Query event logs.
Get Balance (with unit flag):

Copy

Ask AI
# Using an ENS name on Ethereum mainnet
cast balance vitalik.eth --ether --rpc-url https://eth.merkle.io
Get Block Details:

Copy

Ask AI
cast block latest
​
Utility & Conversion Commands
Command	Purpose
cast estimate	Estimate gas for a call or deployment.
cast find-block	Find a block by its timestamp.
cast compute-address	Calculate a CREATE2 address.
cast from-bin	Decode binary data to hex.
cast from-wei	Convert wei to a more readable unit (e.g., ether).
cast to-wei	Convert a unit (e.g., ether) to wei.
cast abi-encode	Encode function arguments.
cast keccak	Hash data with Keccak-256.
These commands allow you to drop one-off scripts for common conversions and estimations.
​
Streamlining Repetative / Tedious tasks
When performing testing or development roles you may find yourself doing one or more small but very tedious tasks frequently. In your shell’s configuration file (~/.bashrc, ~/.zshrc), you can alias cast with your default RPC URL (or multiple on various chains) to save time.

Copy

Ask AI
# Set your default RPC endpoint
export CDEV_RPC="<evm_rpc_url>"
# Create an alias
alias ccast='cast --rpc-url $CDEV_RPC'

# Now you can run commands like:
ccast balance 0x...
See all 7 lines
This is an extremely basic example of how you can improve your workflows by building upon the heavy lifting Foundry already does out of the box.


Hardhat Guide: Setup & Workflows

Copy page

A guide to setting up and using the Hardhat development environment for building, testing, and deploying on Cosmos EVM.

Hardhat is a flexible and extensible Ethereum development environment that is fully compatible with Cosmos EVM. It’s an excellent choice for teams with JavaScript/TypeScript expertise or those who need complex deployment and testing workflows.
​
Project Setup and Configuration
Initialize and configure a new Hardhat project for Cosmos EVM development.
​
1. Installation

Copy

Ask AI
mkdir cosmos-evm-hardhat
cd cosmos-evm-hardhat
npm init -y
npm install --save-dev hardhat @nomicfoundation/hardhat-toolbox @openzeppelin/contracts
npx hardhat init # Select "Create a TypeScript project"
See all 5 lines
​
2. Configuration
Modify hardhat.config.ts to include networks and settings for Cosmos EVM.
hardhat.config.ts

Copy

Ask AI
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import "dotenv/config";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.24",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
      evmVersion: "istanbul"
    },
  },
  networks: {
    local: {
      url: "http://127.0.0.1:8545",
      chainId: 4321, // Your EVM chain ID
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      gasPrice: 20000000000,
    },
    testnet: {
      url: "<evm_rpc_url>",
      chainId: 4321, // Your EVM chain ID
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
    }
  },
  gasReporter: {
    enabled: process.env.REPORT_GAS !== undefined,
    currency: "USD",
  },
  etherscan: {
    apiKey: {
      cosmosEvmTestnet: process.env.ETHERSCAN_API_KEY || "dummy_key"
    },
    customChains: [
      {
        network: "cosmosEvmTestnet",
        chainId: 4321, // Your EVM chain ID
        urls: {
          apiURL: "",
          browserURL: ""
        }
      }
    ]
  }
};

export default config;
See all 50 lines
​
TypeScript Integration
Hardhat’s first-class TypeScript support enables type-safe contract interactions and tests.
​
1. Writing a Contract
Create a contract in the contracts/ directory. For this example, we’ll use a simple LiquidStakingVault.
contracts/LiquidStakingVault.sol

Copy

Ask AI
// contracts/LiquidStakingVault.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/access/Ownable.sol";

// Interface for the staking precompile
interface IStaking {
    function delegate(address validator, uint256 amount) external returns (bool);
    function undelegate(address validator, uint256 amount) external returns (bool, uint64);
}

contract LiquidStakingVault is Ownable {
    IStaking constant STAKING = IStaking(0x0000000000000000000000000000000000000800);

    mapping(address => uint256) public stakedBalance;
    address public primaryValidator;
    uint256 public totalStaked;

    event Staked(address indexed user, uint256 amount);

    constructor(address _primaryValidator) Ownable(msg.sender) {
        primaryValidator = _primaryValidator;
    }

    function stake() external payable {
        require(msg.value > 0, "Must stake positive amount");
        bool success = STAKING.delegate(primaryValidator, msg.value);
        require(success, "Delegation failed");
        stakedBalance[msg.sender] += msg.value;
        totalStaked += msg.value;
        emit Staked(msg.sender, msg.value);
    }
}
See all 34 lines
​
2. Writing Tests
Create type-safe tests in the test/ directory.
test/LiquidStakingVault.test.ts

Copy

Ask AI
// test/LiquidStakingVault.test.ts
import { expect } from "chai";
import { ethers } from "hardhat";
import { LiquidStakingVault } from "../typechain-types";
import { SignerWithAddress } from "@nomicfoundation/hardhat-ethers/signers";

describe("LiquidStakingVault", function () {
  let vault: LiquidStakingVault;
  let owner: SignerWithAddress;
  let user1: SignerWithAddress;

  const STAKING_PRECOMPILE = "0x0000000000000000000000000000000000000800";
  const VALIDATOR_ADDRESS = "0x1234567890123456789012345678901234567890";

  beforeEach(async function () {
    [owner, user1] = await ethers.getSigners();

    const VaultFactory = await ethers.getContractFactory("LiquidStakingVault");
    vault = await VaultFactory.deploy(VALIDATOR_ADDRESS);
    await vault.waitForDeployment();

    // Mock the staking precompile's delegate function to always return true
    // This bytecode is a minimal contract that returns true for any call
    const successBytecode = "0x6080604052348015600f57600080fd5b50600160005560016000f3";
    await ethers.provider.send("hardhat_setCode", [
      STAKING_PRECOMPILE,
      successBytecode,
    ]);
  });

  it("Should allow a user to stake tokens", async function () {
    const stakeAmount = ethers.parseEther("1.0");

    await expect(vault.connect(user1).stake({ value: stakeAmount }))
      .to.emit(vault, "Staked")
      .withArgs(user1.address, stakeAmount);

    expect(await vault.stakedBalance(user1.address)).to.equal(stakeAmount);
    expect(await vault.totalStaked()).to.equal(stakeAmount);
  });
});
See all 41 lines
Run your tests:

Copy

Ask AI
npx hardhat test
​
Deployment Scripts
Create a deployment script in the scripts/ directory to deploy your contract to a live network.
scripts/deploy.ts

Copy

Ask AI
// scripts/deploy.ts
import { ethers, network } from "hardhat";
import { writeFileSync } from "fs";

async function main() {
  const [deployer] = await ethers.getSigners();

  console.log("Deploying contracts with the account:", deployer.address);

  const validatorAddress = process.env.VALIDATOR_ADDRESS || "0x0000000000000000000000000000000000000000";

  const VaultFactory = await ethers.getContractFactory("LiquidStakingVault");
  const vault = await VaultFactory.deploy(validatorAddress);
  await vault.waitForDeployment();

  const vaultAddress = await vault.getAddress();
  console.log("LiquidStakingVault deployed to:", vaultAddress);

  // Save deployment information
  const deploymentInfo = {
    contractAddress: vaultAddress,
    deployer: deployer.address,
    network: network.name,
    chainId: network.config.chainId,
  };

  writeFileSync(
    `deployments/${network.name}-deployment.json`,
    JSON.stringify(deploymentInfo, null, 2)
  );

  // Optional: Verify contract on Etherscan-compatible explorer
  if (network.name !== "local" && process.env.ETHERSCAN_API_KEY) {
    console.log("Waiting for block confirmations before verification...");
    // await vault.deploymentTransaction()?.wait(5); // Wait for 5 blocks
    await new Promise(resolve => setTimeout(resolve, 30000)); // Or wait 30 seconds

    await hre.run("verify:verify", {
        address: vaultAddress,
        constructorArguments: [validatorAddress],
    });
  }
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
See all 50 lines
Run the deployment script:

Copy

Ask AI
npx hardhat run scripts/deploy.ts --network testnet



Remix IDE

Copy page

Deploy and test smart contracts on Cosmos EVM chains using the Remix browser-based IDE

​
Remix IDE
Remix is a powerful browser-based IDE that allows you to write, compile, deploy, and test smart contracts directly from your web browser. It’s an excellent tool for rapid prototyping and testing smart contracts on Cosmos EVM chains without needing to set up a local development environment.
​
Connecting to Cosmos EVM Chains
To deploy contracts to a Cosmos EVM chain through Remix, you’ll need to use the Injected Provider option with MetaMask.
Remix cannot connect directly to custom RPC endpoints. You must use MetaMask as an intermediary to connect to Cosmos EVM chains.
​
Step-by-Step Guide
Configure MetaMask: First, add your Cosmos EVM chain to MetaMask with the correct RPC endpoint, Chain ID, and currency symbol.
Select Network in MetaMask: Make sure the Cosmos EVM network you want to use is currently selected in MetaMask.
Open Remix: Navigate to https://remix.ethereum.org
Deploy Your Contract:
Go to the “Deploy & Run Transactions” tab (the Ethereum icon in the sidebar)
In the “Environment” dropdown, select “Injected Provider - MetaMask”
Remix will automatically connect to the network currently selected in MetaMask
Remix Injected Provider Selection
Confirm Connection: MetaMask will prompt you to connect to Remix. Approve the connection to proceed.
Deploy and Interact: You can now compile, deploy, and interact with your contracts on the Cosmos EVM chain through Remix.
​
Important Considerations
Network Selection: Always verify that MetaMask is connected to the correct network before deploying contracts
Gas Fees: Ensure you have sufficient native tokens in your MetaMask wallet to pay for transaction fees
Chain Compatibility: Your smart contracts should be compatible with the EVM version supported by the Cosmos chain
​
Additional Resources
For more detailed information about using Remix IDE, including advanced features and troubleshooting, refer to the official Remix documentation.
Quick Tip: You can save your Remix workspace to GitHub or IPFS to preserve your contracts and deployment configurations across sessions.




Popular Libraries for Development, Testing & Fuzzing

Copy page

Key frameworks, libraries, and practices for frontend development, wallet integration, smart contracts, testing and more.

​
Common Libraries & Tooling
These libraries are used across the stack to write tests, simulate transactions, connect wallets, and interface with the blockchain in both scripting and frontend contexts.
Library	Purpose	Key Features
Ethers.js	Contract interaction, transaction signing, provider management in JS/TS environments	Provides Contract, Provider, Wallet, and Interface abstractions. Deep Hardhat integration. ABI coder, calldata utilities, and ENS support.
Viem	Modular TypeScript-first library for RPC, contract access, encoding, and data formatting	Tree-shakeable. Supports batching, client-side caching, EIP-1559 fees, multicalls, typed reads/writes. Used by Wagmi.
Wagmi	React hooks for wallet connection, chain state, and contract calls in frontend apps	Built on Viem. Includes useAccount, useConnect, useContractRead, and event subscriptions. Enables seamless integration with wallet modals.
Web3.js	Legacy Ethereum contract and RPC library	One of the earliest libraries. Now largely unmaintained. Lacks EIP-1559 support and modern modularity.
RainbowKit	React component library for wallet connection UI and chain management	Pre-built wallet connect buttons, chain switch UI, and custom themes. Integrates with Wagmi for wallet state management and tx handling.
Ethers and Viem serve similar purposes, but Viem is optimized for frontend apps. Wagmi builds on Viem. Web3.js is no longer recommended for new projects.
​
Testing Frameworks
Note Smart contract quality and security depend on a comprehensive testing strategy including but not limited to:
Unit Tests: Verify individual functions and components
Property-Based Fuzzing: Test invariants with random inputs
Code Coverage: Ensure all code paths are tested
Static Analysis: Detect common vulnerabilities and anti-patterns
The tools and frameworks below provide a foundation for each of these testing layers.
​
Foundry — Solidity-Native
Tests written directly in Solidity.
Very fast runner (forge test) and rich cheatcodes for state manipulation.
Built-in, configurable fuzzing (forge test --fuzz-runs=N).
Includes tools like forge script, forge coverage, and forge snapshot.
​
Hardhat — JavaScript / TypeScript
Mocha + Chai test runner for JS/TS-based tests.
Flexible task system (hardhat.config.js), plugin support, and network forking.
Integrates with Ethers.js and Solidity tooling for deployments, gas tracking, and test orchestration.
​
Fuzz (Property-Based) Testing
Fuzz testing generates random inputs to find edge cases that violate expected properties.
test/MyContract.t.sol (Foundry)

Copy

Ask AI
// test/MyContract.t.sol  (Foundry)
function test_myFunction_fuzz(uint256 amount) public {
    vm.assume(amount > 0 && amount < 1e18);   // constrain input
    myContract.myFunction(amount);
    assertEq(myContract.someState(), expectedValue);
}
See all 6 lines
Tool	Notes
Foundry	Built-in fuzzing; enabled by default when running forge test.
Echidna	External, property-based fuzzer. Supports invariants and campaigns.
Use fuzzing to test against invariants such as:
balance never exceeds total supply
no overflow or underflow under bounded inputs
access control is consistently enforced
​
Supplementary Tools
Tools that enhance test coverage, assert correctness, or catch common vulnerabilities.
Tool	Purpose	Typical Command
OpenZeppelin Test Helpers	Time travel, event assertions, reverts	JS/TS only. Works with Hardhat + Mocha.
solidity-coverage	Reports untested branches in Solidity	npx hardhat coverage · forge coverage
Slither	Static analysis for known vuln patterns	slither .
​
Example — OpenZeppelin Test Helpers

Copy

Ask AI
const { time, expectRevert } = require('@openzeppelin/test-helpers');

// advance clock by one day
await time.increase(time.duration.days(1));

// expect revert with specific reason
await expectRevert(contract.someFunction(), "Ownable: caller is not the owner");
Collapse


Wallet Integration

Copy page

Wallet integration is an essential aspect of dApp development that allows users to securely interact with blockchain-based applications.

​
EVM Wallet Compatibility​
Any standard EVM wallet works out of the box with Cosmos EVM chains. This includes popular wallets like MetaMask, Rabby, WalletConnect, and any other wallet that supports Ethereum and EVM-compatible chains. No special configuration or custom integration is required - simply add your chain’s RPC endpoint and chain ID to any EVM wallet.
​
Key Integration Points​
Standard EVM RPC: Cosmos EVM exposes the standard Ethereum JSON-RPC API, ensuring compatibility with all EVM wallets
EIP-1559 Support: Full support for EIP-1559 dynamic fee transactions, enabling automatic gas estimation
Address Format: Uses standard Ethereum addresses (0x format) for EVM transactions
Transaction Types: Supports all standard Ethereum transaction types including legacy and EIP-1559 transactions
​
Wallet Support​
Wallet	Type	Notes
MetaMask	EVM	Works out of the box - just add network RPC
Rabby	EVM	Works out of the box - just add network RPC
WalletConnect	EVM	Standard WalletConnect integration works
Keplr	Cosmos + EVM	Supports both Cosmos and Ethereum transaction formats
Leap	Cosmos + EVM	Supports both Cosmos and Ethereum transaction formats
Ledger	Hardware	Compatible via MetaMask or other wallet interfaces
​
Client Libraries​
For programmatic wallet integration, use standard Ethereum client libraries like ethers.js, web3.js, or viem which are fully compatible with Cosmos EVM chains.
​
Quick Start​
To add a Cosmos EVM chain to MetaMask or any EVM wallet:
Open your wallet and navigate to “Add Network”
Enter the following details:
Network Name: Your chain name
RPC URL: Your chain’s JSON-RPC endpoint (port 8545)
Chain ID: Your EVM chain ID (integer)
Currency Symbol: Your native token symbol
Block Explorer URL: (optional) Your chain’s block explorer
That’s it! Your wallet is now ready to interact with the Cosmos EVM chain.