Cron Module
Schedule automated smart contract executions with block-based timing

This document explains the cron module for the Neutron network.
The Cron module allows scheduling automatic smart contract executions at predefined block intervals, similar to Unix cron jobs. This feature enables time-based automation in blockchain applications through governance-controlled schedule management.
​
Table of contents
Overview — a high-level description of the module.
Explanation — an explanation of the module’s concepts and the reasoning behind its design choices.
How To — short guides on performing basic operations with the module.
Reference — comprehensive technical details including messages, events, state, client, and API documentation.
​
Concepts
The Cron module serves as an on-chain block-based scheduling system that enables:
Scheduled Block Executions: Register messages to be executed at specific block intervals
Periodic Tasks: Set up recurring executions every N blocks
Governance-Controlled Scheduling: All schedule creation requires governance approval
​
Governance-Gated Access
Schedule creation is controlled through governance (Main DAO or Cron SubDAO)
Contracts cannot directly create schedules
Schedule management requires governance proposals
The Cron module operates within Neutron’s modular governance system, which uses specialized subDAOs to handle different aspects of network management. The Cron SubDAO specifically manages scheduling-related proposals.
​
Block-Based Execution
Execution timing is based on block heights, not precise timestamps
The module has a limit on how many schedules can be executed per block
Schedules are identified by unique names for easy management
​
Operation Flow
A typical workflow using the Cron module consists of:
Governance Proposal: Submit a governance proposal to create a schedule specifying:
A unique name
The execution period (in blocks)
Messages to execute
Schedule Tracking: The module maintains a registry of all schedules and tracks their execution status.
Automatic Execution: When a block is produced, the module:
Identifies schedules due for execution
Executes up to the per-block limit of schedules
Updates their last execution height
Schedule Management: Through governance, schedules can be:
Removed when they’re no longer needed
​
Integration with Smart Contracts
The Cron module integrates with smart contracts through:
Execution Callbacks: The scheduled messages are sent to target contracts
Governance Proposals: Contract owners work with governance to create schedules
This allows developers to implement various block-based functionalities such as:
Regular protocol maintenance operations
Periodic distribution schedules
Block-based DeFi operations
Automated governance actions
Reference
Explanation
twitter
discord
telegram
github


Explanation
Detailed explanation of how the Cron module works and why it’s designed this way

This document provides a technical explanation of the Cron module architecture, concepts, and design choices.
​
What is the Cron Module?
The Cron module enables on-chain time-based automation by maintaining a registry of schedules and executing them at the appropriate block heights. Traditional blockchain applications require external triggers for time-sensitive operations, which creates several challenges:
Reliability concerns: External automation services might fail
Centralization risks: Reliance on third-party services
Coordination problems: Multiple actors might attempt the same operation
Timing precision: Exact execution timing is difficult to ensure
The Cron module solves these problems by moving time-based automation directly onto the blockchain, ensuring deterministic, reliable, and decentralized execution of scheduled operations.
Governance-Only Access: The Cron module is governance-gated. Only the Main DAO or Cron SubDAO can create, modify, or remove schedules. Individual users and contracts cannot directly interact with this module.
​
How does the Cron module work?
The Cron module enables on-chain time-based automation through several components working together:
​
Schedule Registration
When a governance proposal creates a schedule, it specifies:
A unique name for identification
The execution period (in blocks)
One or more CosmWasm contract messages to execute
The execution stage (BEGIN_BLOCKER or END_BLOCKER)
The module stores this schedule in its state and begins executing it according to the specified period.
​
Execution Mechanism
The module hooks into Neutron’s block production process to check for schedules due for execution:
During each block’s BeginBlock or EndBlock phase (depending on the schedule’s execution_stage), the module queries for all schedules where:

Copy

Ask AI
current_block_height ≥ (last_execution_height + period)
The module processes up to the configured limit of schedules per block to prevent resource exhaustion.
For each schedule that meets the execution condition:
The module constructs wasmtypes.MsgExecuteContract messages from the stored schedule data
Sets the sender as the Cron module account
Sets funds to empty (no tokens are sent)
Executes the messages using the WASM message server
Updates the schedule’s last_execute_height to the current block height
Atomicity: All messages within a single schedule must succeed, or the entire schedule execution is rolled back.
​
Schedule Structure
A schedule is the core data structure in the Cron module:

Copy

Ask AI
message Schedule {
  string name = 1;                           // Unique identifier
  uint64 period = 2;                         // Blocks between executions  
  repeated MsgExecuteContract msgs = 3;      // Messages to execute
  uint64 last_execute_height = 4;           // Last execution block height
}

message MsgExecuteContract {
  string contract = 1;                       // Contract address
  string msg = 2;                           // JSON-encoded message
}
​
Execution Stages
The Cron module supports two execution stages:
BEGIN_BLOCKER: Schedules are executed at the beginning of the block, before any transactions. This is useful for operations that need to happen before other transactions in the block.
END_BLOCKER: Schedules are executed at the end of the block, after all transactions. This is useful for operations that should occur after all other transactions in the block have been processed.
The choice of execution stage is important for dependencies between operations. For example, if a scheduled operation depends on the state resulting from regular transactions, it should use the END_BLOCKER stage.
​
Governance-Based Management
Schedule creation is controlled through governance (Main DAO or Cron SubDAO)
Contracts cannot directly create schedules
Schedule management requires governance proposals
This governance-gated approach ensures that critical automated processes cannot be tampered with by unauthorized parties and maintains the security and integrity of the network.
​
Security Model
The Cron module implements several mechanisms to ensure security and prevent abuse:
​
Execution Limits
To prevent DoS attacks and excessive resource consumption:
There’s a network-wide limit parameter (default: configurable) that restricts the number of schedules processed in a single block
If more schedules are due than the limit allows, some are delayed until subsequent blocks
Schedules are processed in deterministic order (by last execution height, then alphabetically by name)
​
Message Validation
The module validates messages before execution:
Messages must be properly formatted JSON for CosmWasm contracts
Invalid messages are rejected during schedule creation
Execution failures are logged but don’t stop other schedules from executing
​
Protected State Access
The module’s state can only be modified through governance:
Direct state manipulation is not possible
All state changes follow proper authorization checks
Only governance proposals can manage schedules
​
Design Decisions
​
Why use block heights instead of timestamps?
Block heights provide several advantages over timestamps for scheduling:
Determinism: Block heights advance in a predictable manner, while block times can vary
Simplicity: Working with integer increments is simpler than datetime calculations
Consensus: All validators agree on the current block height without ambiguity
However, this approach means that schedules are sensitive to changes in average block time. If block times slow down or speed up significantly, the real-world timing of scheduled executions will be affected.
​
Why allow multiple messages per schedule?
Supporting multiple messages in a single schedule enables more complex workflows:
Atomicity: Related operations can be grouped together and either all succeed or all fail
Efficiency: Reduces the number of separate schedules needed
Sequence: Actions can be executed in a specific order within the same block
This approach simplifies common patterns like “update state, then transfer funds” or “check condition, then execute action.”
​
Why have different execution stages?
Having both BEGIN_BLOCKER and END_BLOCKER execution stages provides flexibility for different types of automated tasks:
State Preparation: BEGIN_BLOCKER allows setting up state before any transactions in the block
Post-Processing: END_BLOCKER enables operations that should occur after all transactions
Dependency Management: Different stages help manage dependencies between automated operations
This design allows for more complex automation workflows that respect the natural ordering of blockchain operations.
​
Why governance-gate the module?
The governance-only access pattern serves several important purposes:
Security: Prevents malicious actors from creating disruptive schedules
Resource Management: Ensures only necessary automation is added to the network
Quality Control: Community review process for all automated tasks
Accountability: Clear ownership and responsibility for scheduled operations
​
Implementation Considerations
​
Schedule Execution Order
When multiple schedules are due for execution in the same block, they are processed in a deterministic order:
First by last_execution_height (schedules that haven’t run in longer get priority)
Then by name (alphabetical order for ties)
This ordering ensures fairness and prevents starvation of schedules.
​
Failure Handling
If a scheduled message fails during execution:
The entire schedule’s execution is rolled back (atomicity)
The failure is logged with details
The schedule’s last_execution_height is still updated to prevent retry loops
The schedule continues to be processed in future blocks if it’s periodic
This approach ensures that temporary failures don’t permanently break scheduling logic while maintaining transaction atomicity.
​
Message Construction
When executing schedules, the module constructs wasmtypes.MsgExecuteContract messages:

Copy

Ask AI
msg := wasmtypes.MsgExecuteContract{
    Sender:   cronModuleAccount,  // Cron module account
    Contract: scheduleMsg.Contract, // From schedule definition
    Msg:      scheduleMsg.Msg,     // From schedule definition  
    Funds:    sdk.Coins{},        // Always empty
}
​
Module Parameters
Network-wide parameters that can be adjusted through governance:
Parameter	Description	Purpose
security_address	Address authorized to remove schedules	Emergency schedule removal
limit	Maximum schedules executed per block	Resource management and DoS prevention
​
Metrics and Monitoring
The Cron module collects several metrics for monitoring and observability:
execute_ready_schedules (histogram): Time taken to execute all ready schedules in EndBlocker
schedule_count (gauge): Current number of active schedules
schedule_executions_count (counter): Total schedule executions, labeled by success/failure and schedule name
These metrics help operators monitor the health and performance of the Cron module.
​
Best Practices for Integration
​
Error Handling
Since schedules might fail for various reasons, contracts should:
Make scheduled operations idempotent (safe to execute multiple times)
Include validation within scheduled messages
Implement fallback mechanisms for critical operations
Design messages to be robust against temporary failures
​
Schedule Organization
For complex applications:
Use descriptive, consistent naming schemes for schedules
Create separate schedules for independent operations
Consider execution stages carefully to manage dependencies
Group related operations into single schedules for atomicity
​
Typical Use Cases
The Cron module supports a wide range of time-based tasks:
​
Financial Operations
Interest accrual: Regular updates to lending/borrowing rates
Vesting schedules: Gradual token unlocking over time
Reward distribution: Periodic rewards to stakers or liquidity providers
Fee collection: Regular harvesting of accumulated fees
​
Protocol Maintenance
State cleanup: Removing expired or obsolete data
Parameter updates: Scheduled changes to protocol parameters
Rebalancing: Periodic adjustments to maintain target ratios
Health checks: Regular validation of system state
​
Time-Sensitive Events
Auction endings: Automatic settlement at deadline
Governance execution: Implementing approved proposals after timelock
Emergency procedures: Scheduled failsafes or circuit breakers
Market operations: Regular price updates or arbitrage opportunities
All of these use cases require governance approval to implement, ensuring that only legitimate and beneficial automation is added to the network.
Cron Module
How-to
twitter
discord
telegram
github


How-to
Step-by-step instructions for using the Cron module through governance

This guide provides practical instructions for working with the Cron module, including creating governance proposals for schedules and handling scheduled executions in smart contracts.
​
Prerequisites
Understanding of Neutron governance processes
Familiarity with CosmWasm contract development
Access to governance proposal submission (for schedule creation)
​
Understanding Cron Module Access
The Cron module is governance-gated, meaning:
Only governance can create or remove schedules
Individual users and contracts cannot directly interact with this module
Schedule management requires proposals to either:
Main DAO: Can create and remove any schedule
Security SubDAO: Can remove schedules (emergency situations)
No Individual Access: Unlike other modules, the Cron module does not accept direct user transactions. All schedule management must go through governance proposals.
Neutron uses a modular governance system with specialized subDAOs that handle different aspects of network management. The Security SubDAO can remove schedules in emergency situations, providing a safety mechanism for the network.
​
Creating Schedules Through Governance
​
Step 1: Prepare Your Governance Proposal
To create a schedule, you need to submit a governance proposal using the DAO contract format. Here’s the structure for adding a schedule:

Copy

Ask AI
{
  "title": "Add Daily Reward Distribution Schedule",
  "description": "Creates a schedule to distribute rewards every 7200 blocks (approximately daily)",
  "messages": [
    {
      "@type": "/neutron.cron.MsgAddSchedule",
      "authority": "neutron1...",
      "name": "daily_rewards",
      "period": 7200,
      "msgs": [
        {
          "contract": "neutron1contract...",
          "msg": "{\"distribute_rewards\": {\"amount\": \"1000\"}}"
        }
      ],
      "execution_stage": "EXECUTION_STAGE_END_BLOCKER"
    }
  ]
}
​
Step 2: Understanding the Message Structure
The MsgAddSchedule message contains:
authority: Address of the governance authority
name: Unique identifier for the schedule
period: Number of blocks between executions
msgs: Array of contract messages to execute
contract: Address of the contract to call
msg: JSON string of the message to send
execution_stage: When to execute (EXECUTION_STAGE_BEGIN_BLOCKER or EXECUTION_STAGE_END_BLOCKER)
​
Step 3: Submit the Governance Proposal
​
Standard Governance Proposal
Submit the proposal using the standard governance module:

Copy

Ask AI
# Submit governance proposal
neutrond tx gov submit-proposal [proposal-file.json] \
  --from=<your-key> \
  --chain-id=neutron-1 \
  --gas=auto \
  --gas-adjustment=1.5
​
Step 4: Governance Voting Process
Once submitted, the proposal goes through the standard governance process:
Proposal Period: Community can review the proposal
Voting Period: NTRN token holders vote on the proposal
Execution: If passed, the schedule is automatically created
​
Preparing Your Contract for Scheduled Execution
​
Handle Scheduled Messages
Your contract must be prepared to receive messages from the Cron module account:

Copy

Ask AI
use cosmwasm_std::{
    entry_point, DepsMut, Env, MessageInfo, Response, StdResult,
};

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> StdResult<Response> {
    match msg {
        ExecuteMsg::DistributeRewards { amount } => {
            handle_scheduled_execution(deps, env, info, amount)
        },
        // Other handlers...
    }
}

fn handle_scheduled_execution(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    amount: String,
) -> StdResult<Response> {
    // Note: The sender will be the Cron module account
    // You can optionally validate this if needed
    
    // Perform your scheduled task
    // This could be:
    // - Updating state
    // - Distributing rewards
    // - Triggering other contract calls
    // - Protocol maintenance tasks
    
    Ok(Response::new()
        .add_attribute("action", "scheduled_task_executed")
        .add_attribute("sender", info.sender.to_string())
        .add_attribute("block_height", env.block.height.to_string())
        .add_attribute("amount", amount))
}
​
Design Considerations
When designing your contract for scheduled execution:

Copy

Ask AI
// Example: Periodic reward distribution with safety checks
fn handle_scheduled_execution(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    amount: String,
) -> StdResult<Response> {
    // Optional: Verify sender is Cron module (for extra security)
    let cron_module_addr = "neutron1..."; // Known Cron module address
    if info.sender != cron_module_addr {
        return Err(StdError::generic_err("Unauthorized: not from Cron module"));
    }
    
    // Check if execution is appropriate (additional safety check)
    let last_execution = LAST_EXECUTION.may_load(deps.storage)?.unwrap_or(0);
    let blocks_since_last = env.block.height - last_execution;
    
    if blocks_since_last < MIN_BLOCKS_BETWEEN_EXECUTIONS {
        return Ok(Response::new()
            .add_attribute("action", "execution_skipped")
            .add_attribute("reason", "too_early"));
    }
    
    // Perform the actual task
    distribute_rewards(deps, env, amount)?;
    
    // Update last execution height
    LAST_EXECUTION.save(deps.storage, &env.block.height)?;
    
    Ok(Response::new()
        .add_attribute("action", "rewards_distributed")
        .add_attribute("height", env.block.height.to_string())
        .add_attribute("amount", amount))
}
​
Common Use Cases and Examples
​
Protocol Maintenance
For regular protocol maintenance tasks:

Copy

Ask AI
{
  "title": "Add Daily Protocol Maintenance Schedule",
  "description": "Performs daily maintenance tasks every 7200 blocks",
  "messages": [
    {
      "@type": "/neutron.cron.MsgAddSchedule",
      "authority": "neutron1...",
      "name": "daily_maintenance",
      "period": 7200,
      "msgs": [
        {
          "contract": "neutron1protocol_contract...",
          "msg": "{\"perform_maintenance\": {}}"
        }
      ],
      "execution_stage": "EXECUTION_STAGE_END_BLOCKER"
    }
  ]
}
​
Reward Distribution
For periodic reward distribution:

Copy

Ask AI
{
  "title": "Add Weekly Reward Distribution Schedule",
  "description": "Distributes rewards every 50400 blocks (approximately weekly)",
  "messages": [
    {
      "@type": "/neutron.cron.MsgAddSchedule",
      "authority": "neutron1...",
      "name": "weekly_rewards",
      "period": 50400,
      "msgs": [
        {
          "contract": "neutron1rewards_contract...",
          "msg": "{\"distribute_rewards\": {\"validator\": \"channel-52\", \"recipient\": \"neutron123...\"}}"
        }
      ],
      "execution_stage": "EXECUTION_STAGE_END_BLOCKER"
    }
  ]
}
​
Multi-Message Schedule
For complex operations requiring multiple contract calls:

Copy

Ask AI
{
  "title": "Add Multi-Step Protocol Update Schedule",
  "description": "Performs multi-step protocol update every 100800 blocks",
  "messages": [
    {
      "@type": "/neutron.cron.MsgAddSchedule",
      "authority": "neutron1...",
      "name": "protocol_update",
      "period": 100800,
      "msgs": [
        {
          "contract": "neutron1contract1...",
          "msg": "{\"prepare_update\": {}}"
        },
        {
          "contract": "neutron1contract2...",
          "msg": "{\"apply_update\": {\"version\": \"2.0\"}}"
        },
        {
          "contract": "neutron1contract3...",
          "msg": "{\"notify_update_complete\": {}}"
        }
      ],
      "execution_stage": "EXECUTION_STAGE_END_BLOCKER"
    }
  ]
}
​
Removing Schedules
​
Standard Removal (Main DAO)
To remove a schedule through Main DAO governance:

Copy

Ask AI
{
  "title": "Remove Daily Reward Distribution Schedule",
  "description": "Removes the daily rewards distribution schedule as it's no longer needed",
  "messages": [
    {
      "@type": "/neutron.cron.MsgRemoveSchedule",
      "authority": "neutron1...",
      "name": "daily_rewards"
    }
  ]
}
​
Emergency Removal (Security SubDAO)
The Security SubDAO can also submit remove_schedule proposals for emergency situations:

Copy

Ask AI
{
  "title": "Emergency Removal of Malfunctioning Schedule",
  "description": "Emergency removal of schedule causing network issues",
  "messages": [
    {
      "@type": "/neutron.cron.MsgRemoveSchedule",
      "authority": "neutron1...",
      "name": "problematic_schedule"
    }
  ]
}
​
Best Practices
​
Governance Proposal Strategy
Clear Documentation: Include detailed rationale for the schedule
Community Engagement: Discuss the proposal with the community first
Testing: Test your contract’s scheduled execution on testnet
Monitoring: Plan for monitoring and maintenance of the schedule
​
Contract Design
Idempotent Operations: Design scheduled tasks to be safely re-runnable
Error Handling: Implement robust error handling for scheduled executions
State Validation: Add checks to prevent unexpected state changes
Logging: Include comprehensive logging with meaningful attributes
Sender Verification: Optionally verify the sender is the Cron module account
​
Schedule Parameters
Appropriate Periods: Choose block intervals that match your use case
Daily: ~7200 blocks (assuming 12-second blocks)
Weekly: ~50400 blocks
Monthly: ~216000 blocks
Execution Stage: Choose BEGIN_BLOCKER or END_BLOCKER based on dependencies
Message Format: Ensure messages are valid JSON strings for contract execution
Atomicity: Group related operations in a single schedule for atomic execution
Descriptive Names: Use clear, descriptive names that indicate the schedule’s purpose
​
Monitoring and Troubleshooting
​
Querying Schedules
To check existing schedules:

Copy

Ask AI
# List all schedules
neutrond query cron list-schedule

# Get specific schedule
neutrond query cron show-schedule <schedule-name>

# Check module parameters
neutrond query cron params
​
Common Issues and Solutions
Issue	Possible Cause	Solution
Proposal rejected	Insufficient community support	Engage with community, revise proposal
Schedule not executing	Execution failures or limit reached	Check contract logic, monitor events
Execution failures	Invalid message format or contract errors	Test messages manually, check contract state
Schedule not found	Governance proposal failed	Verify proposal passed and was executed
​
Debugging Steps
Verify Governance: Check if the governance proposal passed and was executed
Query Schedule: Confirm the schedule exists with correct parameters
Monitor Logs: Check validator logs for schedule execution information
Test Manually: Execute the scheduled message manually to verify contract logic
Check Limits: Ensure the schedule isn’t being skipped due to block limits
​
Event Monitoring
The Cron module does not emit blockchain events. Schedule execution and management operations are logged internally but do not generate events that can be monitored externally. Use the query commands to check schedule status and execution history.
​
Security Considerations
​
Governance Security
Proposal Review: Thoroughly review all governance proposals
Community Oversight: Ensure adequate community review period
Emergency Procedures: Understand Security SubDAO removal capabilities
Testing: Always test on testnet before mainnet proposals
​
Contract Security
Access Control: Consider implementing additional access controls in your contracts
Input Validation: Validate all inputs in scheduled message handlers
State Protection: Protect critical state from unauthorized modifications
Failure Handling: Handle execution failures gracefully without breaking contract state
This governance-gated approach ensures that only approved schedules run on the network, maintaining security and preventing spam while enabling powerful automation capabilities for the Neutron ecosystem.
Explanation
Reference
twitter
discord
telegram
github


Reference
Comprehensive technical reference for the Cron module

​
Messages
The Cron module accepts messages through governance proposals only.
​
MsgAddSchedule
Creates a new schedule through governance proposal.

Copy

Ask AI
message MsgAddSchedule {
  string authority = 1;                      // The address of the governance account
  string name = 2;                           // Unique identifier for the schedule
  uint64 period = 3;                         // Number of blocks between executions
  repeated MsgExecuteContract msgs = 4;      // Messages to execute
  ExecutionStage execution_stage = 5;        // Execution stage (BEGIN_BLOCKER or END_BLOCKER)
}
​
MsgRemoveSchedule
Removes an existing schedule through governance proposal.

Copy

Ask AI
message MsgRemoveSchedule {
  string authority = 1;                      // The address of the governance account
  string name = 2;                           // Name of the schedule to remove
}
​
MsgUpdateParams
Updates the module parameters through governance proposal.

Copy

Ask AI
message MsgUpdateParams {
  string authority = 1;                      // The address of the governance account
  Params params = 2;                         // New module parameters
}
​
State
​
Schedule
The primary state object in the Cron module:

Copy

Ask AI
message Schedule {
  string name = 1;                           // Unique identifier for the schedule
  uint64 period = 2;                         // Number of blocks between executions
  repeated MsgExecuteContract msgs = 3;      // Messages to execute when triggered
  uint64 last_execute_height = 4;           // Last block height when executed
  ExecutionStage execution_stage = 5;        // Execution stage
}
​
MsgExecuteContract
Defines the contract and the message to execute:

Copy

Ask AI
message MsgExecuteContract {
  string contract = 1;                       // The address of the smart contract
  string msg = 2;                            // JSON encoded message to be passed to the contract
}
​
ExecutionStage
Defines when messages will be executed in the block:

Copy

Ask AI
enum ExecutionStage {
  EXECUTION_STAGE_END_BLOCKER = 0;          // Execution at the end of the block
  EXECUTION_STAGE_BEGIN_BLOCKER = 1;        // Execution at the beginning of the block
}
​
Params
Module-wide parameters:

Copy

Ask AI
message Params {
  string security_address = 1;              // Security address that can remove schedules
  uint64 limit = 2;                        // Limit of schedules executed in one block
}
​
ScheduleCount
Tracks the number of current schedules:

Copy

Ask AI
message ScheduleCount {
  int32 count = 1;                          // The number of current schedules
}
​
Query Methods
​
Params
Returns the module parameters.
CLI Usage:

Copy

Ask AI
neutrond query cron params
gRPC Endpoint:

Copy

Ask AI
/neutron/cron/params
​
Schedule
Returns a specific schedule by name.
CLI Usage:

Copy

Ask AI
neutrond query cron show-schedule [schedule-name]
gRPC Endpoint:

Copy

Ask AI
/neutron/cron/schedule/{name}
​
Schedules
Returns all schedules with pagination support.
CLI Usage:

Copy

Ask AI
neutrond query cron list-schedule
gRPC Endpoint:

Copy

Ask AI
/neutron/cron/schedule
​
Events
The Cron module does not emit any custom events. Schedule execution and management operations are logged but do not generate blockchain events.
​
Metrics
The Cron module collects several metrics for monitoring:
execute_ready_schedules (histogram): Time taken to execute all ready schedules
schedule_count (gauge): Current number of active schedules
schedule_executions_count (counter): Total schedule executions, labeled by success/failure and schedule name
​
Client
​
Query Commands
The neutrond CLI provides commands to query the Cron module:

Copy

Ask AI
# Get all schedules
neutrond query cron list-schedule

# Get a specific schedule
neutrond query cron show-schedule [schedule-name]

# Get module parameters
neutrond query cron params
​
Governance Proposals
Since the Cron module is governance-gated, schedules can only be managed through governance proposals:

Copy

Ask AI
# Submit a governance proposal to add a schedule
neutrond tx gov submit-proposal [proposal-file]

# Submit a governance proposal to remove a schedule
neutrond tx gov submit-proposal [proposal-file]
Example proposal file to add a schedule:

Copy

Ask AI
{
  "title": "Add Cron Schedule",
  "description": "Add a new cron schedule for periodic operations",
  "messages": [
    {
      "@type": "/neutron.cron.MsgAddSchedule",
      "authority": "neutron1...",
      "name": "my-schedule",
      "period": "100",
      "msgs": [
        {
          "contract": "neutron1...",
          "msg": "{\"execute_action\": {}}"
        }
      ],
      "execution_stage": "EXECUTION_STAGE_END_BLOCKER"
    }
  ]
}
​
API Endpoints
​
gRPC Service

Copy

Ask AI
service Query {
  // Parameters queries the parameters of the module
  rpc Params(QueryParamsRequest) returns (QueryParamsResponse) {
    option (google.api.http).get = "/neutron/cron/params";
  }

  // Queries a Schedule by name
  rpc Schedule(QueryGetScheduleRequest) returns (QueryGetScheduleResponse) {
    option (google.api.http).get = "/neutron/cron/schedule/{name}";
  }

  // Queries a list of Schedule items
  rpc Schedules(QuerySchedulesRequest) returns (QuerySchedulesResponse) {
    option (google.api.http).get = "/neutron/cron/schedule";
  }
}
​
HTTP REST Endpoints
GET /neutron/cron/params - Get module parameters
GET /neutron/cron/schedule/{name} - Get specific schedule
GET /neutron/cron/schedule - Get all schedules
How-to
Harpoon Module
twitter
discord
telegram
github
