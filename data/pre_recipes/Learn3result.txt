{
    "messages": [
        {
            "content": "[{\"label\": \"Learn\", \"query\": \"Register Msg service for bank module\"}, {\"label\": \"Learn\", \"query\": \"Register Query service for staking module\"}, {\"label\": \"Learn\", \"query\": \"Configure the application encoding config\"}, {\"label\": \"Learn\", \"query\": \"Build the appd binary\"}, {\"label\": \"Learn\", \"query\": \"Create staking delegate transaction\"}]",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "human",
            "name": null,
            "id": "56b3cf50-b822-4f03-a99f-96c0609374a4",
            "example": false
        },
        {
            "content": "",
            "additional_kwargs": {
                "tool_calls": [
                    {
                        "id": "call_VjxOwixvYLpkyeToFsVC8f83",
                        "function": {
                            "arguments": "{\"query\":\"Register Msg service for bank module app.go RegisterMsgServer cosmos\"}",
                            "name": "SearchCosmosDocumentation"
                        },
                        "type": "function"
                    }
                ],
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 356,
                    "prompt_tokens": 682,
                    "total_tokens": 1038,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 320,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CQEWUgkvMVq0fzwZjhD0H5ib1CGAI",
                "service_tier": "default",
                "finish_reason": "tool_calls",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--0a19e14a-f56b-40f7-9d8a-4d58293595ba-0",
            "example": false,
            "tool_calls": [
                {
                    "name": "SearchCosmosDocumentation",
                    "args": {
                        "query": "Register Msg service for bank module app.go RegisterMsgServer cosmos"
                    },
                    "id": "call_VjxOwixvYLpkyeToFsVC8f83",
                    "type": "tool_call"
                }
            ],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 682,
                "output_tokens": 356,
                "total_tokens": 1038,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 320
                }
            }
        },
        {
            "content": "[\"Title: Main Components of Cosmos SDK Modules\\nLink: https://evm.cosmos.network/docs/sdk/v0.50/build/building-modules/intro\\nContent: Modules are by convention defined in the ./x/ subfolder (e.g. the bank module will be defined in the ./x/bank folder). They generally share the same core components: A keeper , used to access the module's store(s) and update the state. A Msg service , used to process messages when they are routed to the module by BaseApp and trigger state-transitions. A query service , used to process user queries when they are routed to the module by BaseApp. Interfaces, for end users to query the subset of the state defined by the module and create message s of the custom types defined in the module. In addition to these components, modules implement the AppModule interface in order to be managed by the module manager. Please refer to the structure document to learn about the recommended structure of a module's directory.\\n\\nIntroduction to Cosmos SDK Modules\\nSynopsis Modules define most of the logic of Cosmos SDK applications. Developers compose modules together using the Cosmos SDK to build their custom application-specific blockchains. This document outlines the basic concepts behind SDK modules and how to approach module management. Pre requisite Readings Anatomy of a Cosmos SDK application Lifecycle of a Cosmos SDK transaction\\n\\nIntroduction to Cosmos SDK Modules\\nIntroduction to Cosmos SDK Modules\\nSynopsis Modules define most of the logic of Cosmos SDK applications. Developers compose modules together using the Cosmos SDK to build their custom application-specific blockchains. This document outlines the basic concepts behind SDK modules and how to approach module management. Pre requisite Readings Anatomy of a Cosmos SDK application Lifecycle of a Cosmos SDK transaction\\n\\n\", \"Title: Main Components of Cosmos SDK Modules\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/build/building-modules/intro\\nContent: Modules are by convention defined in the ./x/ subfolder (e.g. the bank module will be defined in the ./x/bank folder). They generally share the same core components: A  keeper , used to access the module's store(s) and update the state. A Msg service , used to process messages when they are routed to the module by BaseApp and trigger state-transitions. A query service , used to process user queries when they are routed to the module by BaseApp. Interfaces, for end users to query the subset of the state defined by the module and create message s of the custom types defined in the module. In addition to these components, modules implement the AppModule interface in order to be managed by the module manager. Please refer to the structure document to learn about the recommended structure of a module's directory.\\n\\nIntroduction to Cosmos SDK Modules\\nSynopsis Modules define most of the logic of Cosmos SDK applications. Developers compose modules together using the Cosmos SDK to build their custom application-specific blockchains. This document outlines the basic concepts behind SDK modules and how to approach module management.\\n\\nIntroduction to Cosmos SDK Modules\\nIntroduction to Cosmos SDK Modules\\nSynopsis Modules define most of the logic of Cosmos SDK applications. Developers compose modules together using the Cosmos SDK to build their custom application-specific blockchains. This document outlines the basic concepts behind SDK modules and how to approach module management.\\n\\n\", \"Title: Main Components of Cosmos SDK Modules\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/build/building-modules/intro\\nContent: Modules are by convention defined in the ./x/ subfolder (e.g. the bank module will be defined in the ./x/bank folder). They generally share the same core components: A keeper , used to access the module's store(s) and update the state. A Msg service , used to process messages when they are routed to the module by BaseApp and trigger state-transitions. A query service , used to process user queries when they are routed to the module by BaseApp. Interfaces, for end users to query the subset of the state defined by the module and create message s of the custom types defined in the module. In addition to these components, modules implement the AppModule interface in order to be managed by the module manager. Please refer to the structure document to learn about the recommended structure of a module's directory.\\n\\nIntroduction to Cosmos SDK Modules\\nSynopsis Modules define most of the logic of Cosmos SDK applications. Developers compose modules together using the Cosmos SDK to build their custom application-specific blockchains. This document outlines the basic concepts behind SDK modules and how to approach module management. Pre-requisite Readings Anatomy of a Cosmos SDK application Lifecycle of a Cosmos SDK transaction\\n\\nIntroduction to Cosmos SDK Modules\\nIntroduction to Cosmos SDK Modules\\nSynopsis Modules define most of the logic of Cosmos SDK applications. Developers compose modules together using the Cosmos SDK to build their custom application-specific blockchains. This document outlines the basic concepts behind SDK modules and how to approach module management. Pre-requisite Readings Anatomy of a Cosmos SDK application Lifecycle of a Cosmos SDK transaction\\n\\n\", \"Title: Implementation of a module Msg service\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/build/building-modules/msg-services\\nContent: Each module should define a Protobuf Msg service, which will be responsible for processing requests (implementing sdk.Msg ) and returning responses. As further described in ADR 031 , this approach has the advantage of clearly specifying return types and generating server and client code. Protobuf generates a MsgServer interface based on a definition of Msg service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each sdk.Msg . As an example, here is the generated MsgServer interface for x/bank , which exposes two sdk.Msg s: When possible, the existing module's Keeper should implement MsgServer , otherwise a msgServer struct that embeds the Keeper can be created, typically in ./keeper/msg_server.go: package keeper\\n\\nimport (\\n    \\n\\t\\\"context\\\"\\n    \\\"github.com/armon/go-metrics\\\"\\n\\n\\terrorsmod \\\"cosmossdk.io/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\tsdkerrors \\\"github.com/cosmos/cosmos-sdk/types/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/bank/types\\\"\\n\\tgovtypes \\\"github.com/cosmos/cosmos-sdk/x/gov/types\\\"\\n)\\n\\ntype msgServer struct {\\n    Keeper\\n}\\n\\nvar _ types.MsgServer = msgServer{\\n}\\n\\n// NewMsgServerImpl returns an implementation of the bank MsgServer interface\\n// for the provided Keeper.\\nfunc NewMsgServerImpl(keeper Keeper)\\n\\ntypes.MsgServer {\\n    return &msgServer{\\n    Keeper: keeper\\n}\\n}\\n\\nfunc (k msgServer)\\n\\nSend(goCtx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {\\n    var (\\n\\t\\tfrom, to []byte\\n\\t\\terr      error\\n\\t)\\n    if base, ok := k.Keeper.(BaseKeeper); ok {\\n    from, err = base.ak.AddressCodec().StringToBytes(msg.FromAddress)\\n    if err != nil {\\n    return nil, sdkerrors.ErrInvalidAddress.Wrapf(\\\"invalid from address: %s\\\", err)\\n}\\n\\nto, err = base.ak.AddressCodec().StringToBytes(msg.ToAddress)\\n    if err != nil {\\n    return nil, sdkerrors.ErrInvalidAddress.Wrapf(\\\"invalid to address: %s\\\", err)\\n}\\n\\t\\n}\\n\\nelse {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid keeper type: %T\\\", k.Keeper)\\n}\\n    if !msg.Amount.IsValid() {\\n    return nil, errorsmod.Wrap(sdkerrors.ErrInvalidCoins, msg.Amount.String())\\n}\\n    if !msg.Amount.IsAllPositive() {\\n    return nil, errorsmod.Wrap(sdkerrors.ErrInvalidCoins, msg.Amount.String())\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(to) {\\n    return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", msg.ToAddress)\\n}\\n\\nerr = k.SendCoins(ctx, from, to, msg.Amount)\\n    if err != nil {\\n    return nil, err\\n}\\n\\ndefer func() {\\n    for _, a := range msg.Amount {\\n    if a.Amount.IsInt64() {\\n    telemetry.SetGaugeWithLabels(\\n\\t\\t\\t\\t\\t[]string{\\\"tx\\\", \\\"msg\\\", \\\"send\\\"\\n},\\n\\t\\t\\t\\t\\tfloat32(a.Amount.Int64()),\\n\\t\\t\\t\\t\\t[]metrics.Label{\\n    telemetry.NewLabel(\\\"denom\\\", a.Denom)\\n},\\n\\t\\t\\t\\t)\\n}\\n\\t\\n}\\n\\t\\n}()\\n\\nreturn &types.MsgSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nMultiSend(goCtx context.Context, msg *types.MsgMultiSend) (*types.MsgMultiSendResponse, error) {\\n    if len(msg.Inputs) == 0 {\\n    return nil, types.ErrNoInputs\\n}\\n    if len(msg.Inputs) != 1 {\\n    return nil, types.ErrMultipleSenders\\n}\\n    if len(msg.Outputs) == 0 {\\n    return nil, types.ErrNoOutputs\\n}\\n    if err := types.ValidateInputOutputs(msg.Inputs[0], msg.Outputs); err != nil {\\n    return nil, err\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n\\n\\t// NOTE: totalIn == totalOut should already have been checked\\n    for _, in := range msg.Inputs {\\n    if err := k.IsSendEnabledCoins(ctx, in.Coins...); err != nil {\\n    return nil, err\\n}\\n\\t\\n}\\n    for _, out := range msg.Outputs {\\n    if base, ok := k.Keeper.(BaseKeeper); ok {\\n    accAddr, err := base.ak.AddressCodec().StringToBytes(out.Address)\\n    if err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(accAddr) {\\n    return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", out.Address)\\n}\\n\\t\\n}\\n\\nelse {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid keeper type: %T\\\", k.Keeper)\\n}\\n\\t\\n}\\n    err := k.InputOutputCoins(ctx, msg.Inputs[0], msg.Outputs)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgMultiSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nUpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) {\\n    if k.GetAuthority() != req.Authority {\\n    return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), req.Authority)\\n}\\n    if err := req.Params.Validate(); err != nil {\\n    return nil, err\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.SetParams(ctx, req.Params); err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgUpdateParamsResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nSetSendEnabled(goCtx context.Context, msg *types.MsgSetSendEnabled) (*types.MsgSetSendEnabledResponse, error) {\\n    if k.GetAuthority() != msg.Authority {\\n    return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), msg.Authority)\\n}\\n    seen := map[string]bool{\\n}\\n    for _, se := range msg.SendEnabled {\\n    if _, alreadySeen := seen[se.Denom]; alreadySeen {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"duplicate denom entries found for %q\\\", se.Denom)\\n}\\n\\nseen[se.Denom] = true\\n    if err := se.Validate(); err != nil {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid SendEnabled denom %q: %s\\\", se.Denom, err)\\n}\\n\\t\\n}\\n    for _, denom := range msg.UseDefaultFor {\\n    if err := sdk.ValidateDenom(denom); err != nil {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid UseDefaultFor denom %q: %s\\\", denom, err)\\n}\\n\\t\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if len(msg.SendEnabled) > 0 {\\n    k.SetAllSendEnabled(ctx, msg.SendEnabled)\\n}\\n    if len(msg.UseDefaultFor) > 0 {\\n    k.DeleteSendEnabled(ctx, msg.UseDefaultFor...)\\n}\\n\\nreturn &types.MsgSetSendEnabledResponse{\\n}, nil\\n}\\n\\nEach module should define a Protobuf Msg service, which will be responsible for processing requests (implementing sdk.Msg ) and returning responses. As further described in ADR 031 , this approach has the advantage of clearly specifying return types and generating server and client code. Protobuf generates a MsgServer interface based on a definition of Msg service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each sdk.Msg . As an example, here is the generated MsgServer interface for x/bank , which exposes two sdk.Msg s: When possible, the existing module's Keeper should implement MsgServer , otherwise a msgServer struct that embeds the Keeper can be created, typically in ./keeper/msg_server.go: msgServer methods can retrieve the context.Context from the context.Context parameter method using the sdk.UnwrapSDKContext: package keeper\\n\\nimport (\\n    \\n\\t\\\"context\\\"\\n    \\\"github.com/armon/go-metrics\\\"\\n\\n\\terrorsmod \\\"cosmossdk.io/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\tsdkerrors \\\"github.com/cosmos/cosmos-sdk/types/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/bank/types\\\"\\n\\tgovtypes \\\"github.com/cosmos/cosmos-sdk/x/gov/types\\\"\\n)\\n\\ntype msgServer struct {\\n    Keeper\\n}\\n\\nvar _ types.MsgServer = msgServer{\\n}\\n\\n// NewMsgServerImpl returns an implementation of the bank MsgServer interface\\n// for the provided Keeper.\\nfunc NewMsgServerImpl(keeper Keeper)\\n\\ntypes.MsgServer {\\n    return &msgServer{\\n    Keeper: keeper\\n}\\n}\\n\\nfunc (k msgServer)\\n\\nSend(goCtx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {\\n    var (\\n\\t\\tfrom, to []byte\\n\\t\\terr      error\\n\\t)\\n    if base, ok := k.Keeper.(BaseKeeper); ok {\\n    from, err = base.ak.AddressCodec().StringToBytes(msg.FromAddress)\\n    if err != nil {\\n    return nil, sdkerrors.ErrInvalidAddress.Wrapf(\\\"invalid from address: %s\\\", err)\\n}\\n\\nto, err = base.ak.AddressCodec().StringToBytes(msg.ToAddress)\\n    if err != nil {\\n    return nil, sdkerrors.ErrInvalidAddress.Wrapf(\\\"invalid to address: %s\\\", err)\\n}\\n\\t\\n}\\n\\nelse {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid keeper type: %T\\\", k.Keeper)\\n}\\n    if !msg.Amount.IsValid() {\\n    return nil, errorsmod.Wrap(sdkerrors.ErrInvalidCoins, msg.Amount.String())\\n}\\n    if !msg.Amount.IsAllPositive() {\\n    return nil, errorsmod.Wrap(sdkerrors.ErrInvalidCoins, msg.Amount.String())\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(to) {\\n    return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", msg.ToAddress)\\n}\\n\\nerr = k.SendCoins(ctx, from, to, msg.Amount)\\n    if err != nil {\\n    return nil, err\\n}\\n\\ndefer func() {\\n    for _, a := range msg.Amount {\\n    if a.Amount.IsInt64() {\\n    telemetry.SetGaugeWithLabels(\\n\\t\\t\\t\\t\\t[]string{\\\"tx\\\", \\\"msg\\\", \\\"send\\\"\\n},\\n\\t\\t\\t\\t\\tfloat32(a.Amount.Int64()),\\n\\t\\t\\t\\t\\t[]metrics.Label{\\n    telemetry.NewLabel(\\\"denom\\\", a.Denom)\\n},\\n\\t\\t\\t\\t)\\n}\\n\\t\\n}\\n\\t\\n}()\\n\\nreturn &types.MsgSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nMultiSend(goCtx context.Context, msg *types.MsgMultiSend) (*types.MsgMultiSendResponse, error) {\\n    if len(msg.Inputs) == 0 {\\n    return nil, types.ErrNoInputs\\n}\\n    if len(msg.Inputs) != 1 {\\n    return nil, types.ErrMultipleSenders\\n}\\n    if len(msg.Outputs) == 0 {\\n    return nil, types.ErrNoOutputs\\n}\\n    if err := types.ValidateInputOutputs(msg.Inputs[0], msg.Outputs); err != nil {\\n    return nil, err\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n\\n\\t// NOTE: totalIn == totalOut should already have been checked\\n    for _, in := range msg.Inputs {\\n    if err := k.IsSendEnabledCoins(ctx, in.Coins...); err != nil {\\n    return nil, err\\n}\\n\\t\\n}\\n    for _, out := range msg.Outputs {\\n    if base, ok := k.Keeper.(BaseKeeper); ok {\\n    accAddr, err := base.ak.AddressCodec().StringToBytes(out.Address)\\n    if err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(accAddr) {\\n    return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", out.Address)\\n}\\n\\t\\n}\\n\\nelse {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid keeper type: %T\\\", k.Keeper)\\n}\\n\\t\\n}\\n    err := k.InputOutputCoins(ctx, msg.Inputs[0], msg.Outputs)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgMultiSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nUpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) {\\n    if k.GetAuthority() != req.Authority {\\n    return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), req.Authority)\\n}\\n    if err := req.Params.Validate(); err != nil {\\n    return nil, err\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.SetParams(ctx, req.Params); err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgUpdateParamsResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nSetSendEnabled(goCtx context.Context, msg *types.MsgSetSendEnabled) (*types.MsgSetSendEnabledResponse, error) {\\n    if k.GetAuthority() != msg.Authority {\\n    return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), msg.Authority)\\n}\\n    seen := map[string]bool{\\n}\\n    for _, se := range msg.SendEnabled {\\n    if _, alreadySeen := seen[se.Denom]; alreadySeen {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"duplicate denom entries found for %q\\\", se.Denom)\\n}\\n\\nseen[se.Denom] = true\\n    if err := se.Validate(); err != nil {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid SendEnabled denom %q: %s\\\", se.Denom, err)\\n}\\n\\t\\n}\\n    for _, denom := range msg.UseDefaultFor {\\n    if err := sdk.ValidateDenom(denom); err != nil {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid UseDefaultFor denom %q: %s\\\", denom, err)\\n}\\n\\t\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if len(msg.SendEnabled) > 0 {\\n    k.SetAllSendEnabled(ctx, msg.SendEnabled)\\n}\\n    if len(msg.UseDefaultFor) > 0 {\\n    k.DeleteSendEnabled(ctx, msg.UseDefaultFor...)\\n}\\n\\nreturn &types.MsgSetSendEnabledResponse{\\n}, nil\\n}\\n\\nEach module should define a Protobuf Msg service, which will be responsible for processing requests (implementing sdk.Msg ) and returning responses. As further described in ADR 031 , this approach has the advantage of clearly specifying return types and generating server and client code. Protobuf generates a MsgServer interface based on a definition of Msg service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each sdk.Msg . As an example, here is the generated MsgServer interface for x/bank , which exposes two sdk.Msg s: // Code generated by protoc-gen-gogo. DO NOT EDIT.\\n// source: cosmos/bank/v1beta1/tx.proto\\n\\npackage types\\n\\nimport (\\n    \\n\\tcontext \\\"context\\\"\\n\\tfmt \\\"fmt\\\"\\n\\t_ \\\"github.com/cosmos/cosmos-proto\\\"\\n\\tgithub_com_cosmos_cosmos_sdk_types \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\ttypes \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\t_ \\\"github.com/cosmos/cosmos-sdk/types/msgservice\\\"\\n\\t_ \\\"github.com/cosmos/cosmos-sdk/types/tx/amino\\\"\\n\\t_ \\\"github.com/cosmos/gogoproto/gogoproto\\\"\\n\\tgrpc1 \\\"github.com/cosmos/gogoproto/grpc\\\"\\n\\tproto \\\"github.com/cosmos/gogoproto/proto\\\"\\n\\tgrpc \\\"google.golang.org/grpc\\\"\\n\\tcodes \\\"google.golang.org/grpc/codes\\\"\\n\\tstatus \\\"google.golang.org/grpc/status\\\"\\n\\tio \\\"io\\\"\\n\\tmath \\\"math\\\"\\n\\tmath_bits \\\"math/bits\\\"\\n)\\n\\n// Reference imports to suppress errors if they are not otherwise used.\\nvar _ = proto.Marshal\\nvar _ = fmt.Errorf\\nvar _ = math.Inf\\n\\n// This is a compile-time assertion to ensure that this generated file\\n// is compatible with the proto package it is being compiled against.\\n// A compilation error at this line likely means your copy of the\\n// proto package needs to be updated.\\nconst _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package\\n\\n// MsgSend represents a message to send coins from one account to another.\\ntype MsgSend struct {\\n    FromAddress string                                   `protobuf:\\\"bytes,1,opt,name=from_address,json=fromAddress,proto3\\\" json:\\\"from_address,omitempty\\\"`\\n\\tToAddress   string                                   `protobuf:\\\"bytes,2,opt,name=to_address,json=toAddress,proto3\\\" json:\\\"to_address,omitempty\\\"`\\n\\tAmount      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:\\\"bytes,3,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins\\\" json:\\\"amount\\\"`\\n}\\n\\nfunc (m *MsgSend)\\n\\nReset() { *m = MsgSend{\\n} \\n}\\n\\nfunc (m *MsgSend)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSend)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSend)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{0\\n}\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSend.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSend.Merge(m, src)\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSend.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSend proto.InternalMessageInfo\\n\\n// MsgSendResponse defines the Msg/Send response type.\\ntype MsgSendResponse struct {\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nReset() { *m = MsgSendResponse{\\n} \\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSendResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSendResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{1\\n}\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSendResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSendResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSendResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSendResponse proto.InternalMessageInfo\\n\\n// MsgMultiSend represents an arbitrary multi-in, multi-out send message.\\ntype MsgMultiSend struct {\\n\\t// Inputs, despite being `repeated`, only allows one sender input. This is\\n\\t// checked in MsgMultiSend's ValidateBasic.\\n\\tInputs  []Input  `protobuf:\\\"bytes,1,rep,name=inputs,proto3\\\" json:\\\"inputs\\\"`\\n\\tOutputs []Output `protobuf:\\\"bytes,2,rep,name=outputs,proto3\\\" json:\\\"outputs\\\"`\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nReset() { *m = MsgMultiSend{\\n} \\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgMultiSend)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgMultiSend)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{2\\n}\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgMultiSend.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgMultiSend.Merge(m, src)\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgMultiSend.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgMultiSend proto.InternalMessageInfo\\n\\nfunc (m *MsgMultiSend)\\n\\nGetInputs() []Input {\\n    if m != nil {\\n    return m.Inputs\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nGetOutputs() []Output {\\n    if m != nil {\\n    return m.Outputs\\n}\\n\\nreturn nil\\n}\\n\\n// MsgMultiSendResponse defines the Msg/MultiSend response type.\\ntype MsgMultiSendResponse struct {\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nReset() { *m = MsgMultiSendResponse{\\n} \\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgMultiSendResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgMultiSendResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{3\\n}\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgMultiSendResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgMultiSendResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgMultiSendResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgMultiSendResponse proto.InternalMessageInfo\\n\\n// MsgUpdateParams is the Msg/UpdateParams request type.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgUpdateParams struct {\\n\\t// authority is the address that controls the module (defaults to x/gov unless overwritten).\\n\\tAuthority string `protobuf:\\\"bytes,1,opt,name=authority,proto3\\\" json:\\\"authority,omitempty\\\"`\\n\\t// params defines the x/bank parameters to update.\\n\\t//\\n\\t// NOTE: All parameters must be supplied.\\n\\tParams Params `protobuf:\\\"bytes,2,opt,name=params,proto3\\\" json:\\\"params\\\"`\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nReset() { *m = MsgUpdateParams{\\n} \\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgUpdateParams)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgUpdateParams)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{4\\n}\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgUpdateParams.Merge(m, src)\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo\\n\\nfunc (m *MsgUpdateParams)\\n\\nGetAuthority()\\n\\nstring {\\n    if m != nil {\\n    return m.Authority\\n}\\n\\nreturn \\\"\\\"\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nGetParams()\\n\\nParams {\\n    if m != nil {\\n    return m.Params\\n}\\n\\nreturn Params{\\n}\\n}\\n\\n// MsgUpdateParamsResponse defines the response structure for executing a\\n// MsgUpdateParams message.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgUpdateParamsResponse struct {\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nReset() { *m = MsgUpdateParamsResponse{\\n} \\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgUpdateParamsResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgUpdateParamsResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{5\\n}\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo\\n\\n// MsgSetSendEnabled is the Msg/SetSendEnabled request type.\\n//\\n// Only entries to add/update/delete need to be included.\\n// Existing SendEnabled entries that are not included in this\\n// message are left unchanged.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgSetSendEnabled struct {\\n    Authority string `protobuf:\\\"bytes,1,opt,name=authority,proto3\\\" json:\\\"authority,omitempty\\\"`\\n\\t// send_enabled is the list of entries to add or update.\\n\\tSendEnabled []*SendEnabled `protobuf:\\\"bytes,2,rep,name=send_enabled,json=sendEnabled,proto3\\\" json:\\\"send_enabled,omitempty\\\"`\\n\\t// use_default_for is a list of denoms that should use the params.default_send_enabled value.\\n\\t// Denoms listed here will have their SendEnabled entries deleted.\\n\\t// If a denom is included that doesn't have a SendEnabled entry,\\n\\t// it will be ignored.\\n\\tUseDefaultFor []string `protobuf:\\\"bytes,3,rep,name=use_default_for,json=useDefaultFor,proto3\\\" json:\\\"use_default_for,omitempty\\\"`\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nReset() { *m = MsgSetSendEnabled{\\n} \\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSetSendEnabled)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSetSendEnabled)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{6\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSetSendEnabled.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSetSendEnabled.Merge(m, src)\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSetSendEnabled.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSetSendEnabled proto.InternalMessageInfo\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nGetAuthority()\\n\\nstring {\\n    if m != nil {\\n    return m.Authority\\n}\\n\\nreturn \\\"\\\"\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nGetSendEnabled() []*SendEnabled {\\n    if m != nil {\\n    return m.SendEnabled\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nGetUseDefaultFor() []string {\\n    if m != nil {\\n    return m.UseDefaultFor\\n}\\n\\nreturn nil\\n}\\n\\n// MsgSetSendEnabledResponse defines the Msg/SetSendEnabled response type.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgSetSendEnabledResponse struct {\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nReset() { *m = MsgSetSendEnabledResponse{\\n} \\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSetSendEnabledResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSetSendEnabledResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{7\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSetSendEnabledResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSetSendEnabledResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSetSendEnabledResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSetSendEnabledResponse proto.InternalMessageInfo\\n\\nfunc init() {\\n    proto.RegisterType((*MsgSend)(nil), \\\"cosmos.bank.v1beta1.MsgSend\\\")\\n\\nproto.RegisterType((*MsgSendResponse)(nil), \\\"cosmos.bank.v1beta1.MsgSendResponse\\\")\\n\\nproto.RegisterType((*MsgMultiSend)(nil), \\\"cosmos.bank.v1beta1.MsgMultiSend\\\")\\n\\nproto.RegisterType((*MsgMultiSendResponse)(nil), \\\"cosmos.bank.v1beta1.MsgMultiSendResponse\\\")\\n\\nproto.RegisterType((*MsgUpdateParams)(nil), \\\"cosmos.bank.v1beta1.MsgUpdateParams\\\")\\n\\nproto.RegisterType((*MsgUpdateParamsResponse)(nil), \\\"cosmos.bank.v1beta1.MsgUpdateParamsResponse\\\")\\n\\nproto.RegisterType((*MsgSetSendEnabled)(nil), \\\"cosmos.bank.v1beta1.MsgSetSendEnabled\\\")\\n\\nproto.RegisterType((*MsgSetSendEnabledResponse)(nil), \\\"cosmos.bank.v1beta1.MsgSetSendEnabledResponse\\\")\\n}\\n\\nfunc init() {\\n    proto.RegisterFile(\\\"cosmos/bank/v1beta1/tx.proto\\\", fileDescriptor_1d8cb1613481f5b7)\\n}\\n\\nvar fileDescriptor_1d8cb1613481f5b7 = []byte{\\n\\t// 700 bytes of a gzipped FileDescriptorProto\\n\\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcf, 0x4f, 0xd3, 0x50,\\n\\t0x1c, 0x5f, 0x99, 0x8e, 0xec, 0x31, 0x25, 0x54, 0x22, 0xac, 0x90, 0x0e, 0x16, 0x43, 0x00, 0xa5,\\n\\t0x15, 0x34, 0x9a, 0xcc, 0x68, 0x74, 0x28, 0x89, 0x26, 0x8b, 0x66, 0xc4, 0x83, 0x5e, 0x96, 0xd7,\\n\\t0xf5, 0x51, 0x1a, 0xd6, 0xbe, 0xa6, 0xef, 0x95, 0xb0, 0x9b, 0x7a, 0x32, 0x9e, 0x3c, 0x7b, 0xe2,\\n\\t0x68, 0x8c, 0x07, 0x0e, 0x1e, 0x4d, 0xbc, 0x72, 0x24, 0x9e, 0x3c, 0xa9, 0x81, 0x03, 0xfa, 0x5f,\\n\\t0x98, 0xf7, 0xa3, 0xa5, 0x8c, 0x8d, 0x11, 0x2f, 0x6b, 0xf7, 0x3e, 0x3f, 0xbe, 0xef, 0xf3, 0xed,\\n\\t0xf7, 0x3d, 0x30, 0xd9, 0xc4, 0xc4, 0xc3, 0xc4, 0xb4, 0xa0, 0xbf, 0x61, 0x6e, 0x2e, 0x5a, 0x88,\\n\\t0xc2, 0x45, 0x93, 0x6e, 0x19, 0x41, 0x88, 0x29, 0x56, 0x2f, 0x09, 0xd4, 0x60, 0xa8, 0x21, 0x51,\\n\\t0x6d, 0xd4, 0xc1, 0x0e, 0xe6, 0xb8, 0xc9, 0xde, 0x04, 0x55, 0xd3, 0x13, 0x23, 0x82, 0x12, 0xa3,\\n\\t0x26, 0x76, 0xfd, 0x13, 0x78, 0xaa, 0x10, 0xf7, 0x15, 0x78, 0x51, 0xe0, 0x0d, 0x61, 0x2c, 0xeb,\\n\\t0x0a, 0x68, 0x4c, 0x4a, 0x3d, 0xe2, 0x98, 0x9b, 0x8b, 0xec, 0x21, 0x81, 0x11, 0xe8, 0xb9, 0x3e,\\n\\t0x36, 0xf9, 0xaf, 0x58, 0x2a, 0x7f, 0x1e, 0x00, 0x83, 0x35, 0xe2, 0xac, 0x22, 0xdf, 0x56, 0xef,\\n\\t0x80, 0xc2, 0x5a, 0x88, 0xbd, 0x06, 0xb4, 0xed, 0x10, 0x11, 0x32, 0xae, 0x4c, 0x29, 0xb3, 0xf9,\\n\\t0xea, 0xf8, 0xf7, 0x2f, 0x0b, 0xa3, 0xd2, 0xff, 0x81, 0x40, 0x56, 0x69, 0xe8, 0xfa, 0x4e, 0x7d,\\n\\t0x88, 0xb1, 0xe5, 0x92, 0x7a, 0x1b, 0x00, 0x8a, 0x13, 0xe9, 0x40, 0x1f, 0x69, 0x9e, 0xe2, 0x58,\\n\\t0xd8, 0x06, 0x39, 0xe8, 0xe1, 0xc8, 0xa7, 0xe3, 0xd9, 0xa9, 0xec, 0xec, 0xd0, 0x52, 0xd1, 0x48,\\n\\t0x9a, 0x48, 0x50, 0xdc, 0x44, 0x63, 0x19, 0xbb, 0x7e, 0x75, 0x65, 0xf7, 0x67, 0x29, 0xf3, 0xe9,\\n\\t0x57, 0x69, 0xd6, 0x71, 0xe9, 0x7a, 0x64, 0x19, 0x4d, 0xec, 0xc9, 0xe4, 0xf2, 0xb1, 0x40, 0xec,\\n\\t0x0d, 0x93, 0xb6, 0x03, 0x44, 0xb8, 0x80, 0x7c, 0x38, 0xdc, 0x99, 0x2f, 0xb4, 0x90, 0x03, 0x9b,\\n\\t0xed, 0x06, 0xeb, 0x2d, 0xf9, 0x78, 0xb8, 0x33, 0xaf, 0xd4, 0x65, 0xc1, 0xca, 0xf5, 0xb7, 0xdb,\\n\\t0xa5, 0xcc, 0x9f, 0xed, 0x52, 0xe6, 0x0d, 0xe3, 0xa5, 0xb3, 0xbf, 0x3b, 0xdc, 0x99, 0x57, 0x53,\\n\\t0x9e, 0xb2, 0x45, 0xe5, 0x11, 0x30, 0x2c, 0x5f, 0xeb, 0x88, 0x04, 0xd8, 0x27, 0xa8, 0xfc, 0x55,\\n\\t0x01, 0x85, 0x1a, 0x71, 0x6a, 0x51, 0x8b, 0xba, 0xbc, 0x8d, 0x77, 0x41, 0xce, 0xf5, 0x83, 0x88,\\n\\t0xb2, 0x06, 0xb2, 0x40, 0x9a, 0xd1, 0x65, 0x2a, 0x8c, 0xc7, 0x8c, 0x52, 0xcd, 0xb3, 0x44, 0x72,\\n\\t0x53, 0x42, 0xa4, 0xde, 0x07, 0x83, 0x38, 0xa2, 0x5c, 0x3f, 0xc0, 0xf5, 0x13, 0x5d, 0xf5, 0x4f,\\n\\t0x39, 0x27, 0x6d, 0x10, 0xcb, 0x2a, 0x57, 0xe3, 0x48, 0xd2, 0x92, 0x85, 0x19, 0x3b, 0x1e, 0x26,\\n\\t0xd9, 0x6d, 0xf9, 0x32, 0x18, 0x4d, 0xff, 0x4f, 0x62, 0x7d, 0x53, 0x78, 0xd4, 0xe7, 0x81, 0x0d,\\n\\t0x29, 0x7a, 0x06, 0x43, 0xe8, 0x11, 0xf5, 0x16, 0xc8, 0xc3, 0x88, 0xae, 0xe3, 0xd0, 0xa5, 0xed,\\n\\t0xbe, 0xd3, 0x71, 0x44, 0x55, 0xef, 0x81, 0x5c, 0xc0, 0x1d, 0xf8, 0x5c, 0xf4, 0x4a, 0x24, 0x8a,\\n\\t0x1c, 0x6b, 0x89, 0x50, 0x55, 0x6e, 0xb2, 0x30, 0x47, 0x7e, 0x2c, 0xcf, 0x74, 0x2a, 0xcf, 0x96,\\n\\t0x38, 0x24, 0x1d, 0xbb, 0x2d, 0x17, 0xc1, 0x58, 0xc7, 0x52, 0x12, 0xee, 0xaf, 0x02, 0x46, 0xf8,\\n\\t0x77, 0xa4, 0x2c, 0xf3, 0x23, 0x1f, 0x5a, 0x2d, 0x64, 0xff, 0x77, 0xbc, 0x65, 0x50, 0x20, 0xc8,\\n\\t0xb7, 0x1b, 0x48, 0xf8, 0xc8, 0xcf, 0x36, 0xd5, 0x35, 0x64, 0xaa, 0x5e, 0x7d, 0x88, 0xa4, 0x8a,\\n\\t0xcf, 0x80, 0xe1, 0x88, 0xa0, 0x86, 0x8d, 0xd6, 0x60, 0xd4, 0xa2, 0x8d, 0x35, 0x1c, 0xf2, 0xf3,\\n\\t0x90, 0xaf, 0x5f, 0x88, 0x08, 0x7a, 0x28, 0x56, 0x57, 0x70, 0x58, 0x31, 0x4f, 0xf6, 0x62, 0xb2,\\n\\t0x73, 0x50, 0xd3, 0xa9, 0xca, 0x13, 0xa0, 0x78, 0x62, 0x31, 0x6e, 0xc4, 0xd2, 0xeb, 0x2c, 0xc8,\\n\\t0xd6, 0x88, 0xa3, 0x3e, 0x01, 0xe7, 0xf8, 0xec, 0x4e, 0x76, 0xdd, 0xb4, 0x1c, 0x79, 0xed, 0xca,\\n\\t0x69, 0x68, 0xec, 0xa9, 0xbe, 0x00, 0xf9, 0xa3, 0xc3, 0x30, 0xdd, 0x4b, 0x92, 0x50, 0xb4, 0xb9,\\n\\t0xbe, 0x94, 0xc4, 0xda, 0x02, 0x85, 0x63, 0x03, 0xd9, 0x73, 0x43, 0x69, 0x96, 0x76, 0xed, 0x2c,\\n\\t0xac, 0xa4, 0xc6, 0x3a, 0xb8, 0xd8, 0x31, 0x17, 0x33, 0xbd, 0x63, 0xa7, 0x79, 0x9a, 0x71, 0x36,\\n\\t0x5e, 0x5c, 0x49, 0x3b, 0xff, 0x8a, 0x4d, 0x79, 0x75, 0x79, 0x77, 0x5f, 0x57, 0xf6, 0xf6, 0x75,\\n\\t0xe5, 0xf7, 0xbe, 0xae, 0xbc, 0x3f, 0xd0, 0x33, 0x7b, 0x07, 0x7a, 0xe6, 0xc7, 0x81, 0x9e, 0x79,\\n\\t0x39, 0x77, 0xea, 0x3d, 0x27, 0xc7, 0x9e, 0x5f, 0x77, 0x56, 0x8e, 0x5f, 0xe7, 0x37, 0xfe, 0x05,\\n\\t0x00, 0x00, 0xff, 0xff, 0x5b, 0x5b, 0x43, 0xa9, 0xa0, 0x06, 0x00, 0x00,\\n}\\n\\n// Reference imports to suppress errors if they are not otherwise used.\\nvar _ context.Context\\nvar _ grpc.ClientConn\\n\\n// This is a compile-time assertion to ensure that this generated file\\n// is compatible with the grpc package it is being compiled against.\\nconst _ = grpc.SupportPackageIsVersion4\\n\\n// MsgClient is the client API for Msg service.\\n//\\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.\\ntype MsgClient interface {\\n\\t// Send defines a method for sending coins from one account to another account.\\n\\tSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error)\\n\\t// MultiSend defines a method for sending coins from some accounts to other accounts.\\n\\tMultiSend(ctx context.Context, in *MsgMultiSend, opts ...grpc.CallOption) (*MsgMultiSendResponse, error)\\n\\t// UpdateParams defines a governance operation for updating the x/bank module parameters.\\n\\t// The authority is defined in the keeper.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tUpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)\\n\\t// SetSendEnabled is a governance operation for setting the SendEnabled flag\\n\\t// on any number of Denoms. Only the entries to add or update should be\\n\\t// included. Entries that already exist in the store, but that aren't\\n\\t// included in this message, will be left unchanged.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tSetSendEnabled(ctx context.Context, in *MsgSetSendEnabled, opts ...grpc.CallOption) (*MsgSetSendEnabledResponse, error)\\n}\\n\\ntype msgClient struct {\\n    cc grpc1.ClientConn\\n}\\n\\nfunc NewMsgClient(cc grpc1.ClientConn)\\n\\nMsgClient {\\n    return &msgClient{\\n    cc\\n}\\n}\\n\\nfunc (c *msgClient)\\n\\nSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error) {\\n    out := new(MsgSendResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/Send\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\nfunc (c *msgClient)\\n\\nMultiSend(ctx context.Context, in *MsgMultiSend, opts ...grpc.CallOption) (*MsgMultiSendResponse, error) {\\n    out := new(MsgMultiSendResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/MultiSend\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\nfunc (c *msgClient)\\n\\nUpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {\\n    out := new(MsgUpdateParamsResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/UpdateParams\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\nfunc (c *msgClient)\\n\\nSetSendEnabled(ctx context.Context, in *MsgSetSendEnabled, opts ...grpc.CallOption) (*MsgSetSendEnabledResponse, error) {\\n    out := new(MsgSetSendEnabledResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/SetSendEnabled\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\n// MsgServer is the server API for Msg service.\\ntype MsgServer interface {\\n\\t// Send defines a method for sending coins from one account to another account.\\n\\tSend(context.Context, *MsgSend) (*MsgSendResponse, error)\\n\\t// MultiSend defines a method for sending coins from some accounts to other accounts.\\n\\tMultiSend(context.Context, *MsgMultiSend) (*MsgMultiSendResponse, error)\\n\\t// UpdateParams defines a governance operation for updating the x/bank module parameters.\\n\\t// The authority is defined in the keeper.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tUpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)\\n\\t// SetSendEnabled is a governance operation for setting the SendEnabled flag\\n\\t// on any number of Denoms. Only the entries to add or update should be\\n\\t// included. Entries that already exist in the store, but that aren't\\n\\t// included in this message, will be left unchanged.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tSetSendEnabled(context.Context, *MsgSetSendEnabled) (*MsgSetSendEnabledResponse, error)\\n}\\n\\n// UnimplementedMsgServer can be embedded to have forward compatible implementations.\\ntype UnimplementedMsgServer struct {\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nSend(ctx context.Context, req *MsgSend) (*MsgSendResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method Send not implemented\\\")\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nMultiSend(ctx context.Context, req *MsgMultiSend) (*MsgMultiSendResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method MultiSend not implemented\\\")\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nUpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method UpdateParams not implemented\\\")\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nSetSendEnabled(ctx context.Context, req *MsgSetSendEnabled) (*MsgSetSendEnabledResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method SetSendEnabled not implemented\\\")\\n}\\n\\nfunc RegisterMsgServer(s grpc1.Server, srv MsgServer) {\\n    s.RegisterService(&_Msg_serviceDesc, srv)\\n}\\n\\nfunc _Msg_Send_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgSend)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).Send(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/Send\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).Send(ctx, req.(*MsgSend))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nfunc _Msg_MultiSend_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgMultiSend)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).MultiSend(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/MultiSend\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).MultiSend(ctx, req.(*MsgMultiSend))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nfunc _Msg_UpdateParams_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgUpdateParams)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).UpdateParams(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/UpdateParams\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nfunc _Msg_SetSendEnabled_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgSetSendEnabled)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).SetSendEnabled(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/SetSendEnabled\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).SetSendEnabled(ctx, req.(*MsgSetSendEnabled))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nvar _Msg_serviceDesc = grpc.ServiceDesc{\\n    ServiceName: \\\"cosmos.bank.v1beta1.Msg\\\",\\n    HandlerType: (*MsgServer)(nil),\\n    Methods: []grpc.MethodDesc{\\n\\t\\t{\\n    MethodName: \\\"Send\\\",\\n    Handler:    _Msg_Send_Handler,\\n},\\n\\t\\t{\\n    MethodName: \\\"MultiSend\\\",\\n    Handler:    _Msg_MultiSend_Handler,\\n},\\n\\t\\t{\\n    MethodName: \\\"UpdateParams\\\",\\n    Handler:    _Msg_UpdateParams_Handler,\\n},\\n\\t\\t{\\n    MethodName: \\\"SetSendEnabled\\\",\\n    Handler:    _Msg_SetSendEnabled_Handler,\\n},\\n},\\n    Streams:  []grpc.StreamDesc{\\n},\\n    Metadata: \\\"cosmos/bank/v1beta1/tx.proto\\\",\\n}\\n\\nfunc (m *MsgSend)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSend)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSend)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n    if len(m.Amount) > 0 {\\n    for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x1a\\n}\\n\\t\\n}\\n    if len(m.ToAddress) > 0 {\\n    i -= len(m.ToAddress)\\n\\ncopy(dAtA[i:], m.ToAddress)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.ToAddress)))\\n\\ni--\\n\\t\\tdAtA[i] = 0x12\\n}\\n    if len(m.FromAddress) > 0 {\\n    i -= len(m.FromAddress)\\n\\ncopy(dAtA[i:], m.FromAddress)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))\\n\\ni--\\n\\t\\tdAtA[i] = 0xa\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n    if len(m.Outputs) > 0 {\\n    for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x12\\n}\\n\\t\\n}\\n    if len(m.Inputs) > 0 {\\n    for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0xa\\n}\\n\\t\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\t{\\n    size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\tdAtA[i] = 0x12\\n    if len(m.Authority) > 0 {\\n    i -= len(m.Authority)\\n\\ncopy(dAtA[i:], m.Authority)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))\\n\\ni--\\n\\t\\tdAtA[i] = 0xa\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n    if len(m.UseDefaultFor) > 0 {\\n    for iNdEx := len(m.UseDefaultFor) - 1; iNdEx >= 0; iNdEx-- {\\n    i -= len(m.UseDefaultFor[iNdEx])\\n\\ncopy(dAtA[i:], m.UseDefaultFor[iNdEx])\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.UseDefaultFor[iNdEx])))\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x1a\\n}\\n\\t\\n}\\n    if len(m.SendEnabled) > 0 {\\n    for iNdEx := len(m.SendEnabled) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.SendEnabled[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x12\\n}\\n\\t\\n}\\n    if len(m.Authority) > 0 {\\n    i -= len(m.Authority)\\n\\ncopy(dAtA[i:], m.Authority)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))\\n\\ni--\\n\\t\\tdAtA[i] = 0xa\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc encodeVarintTx(dAtA []byte, offset int, v uint64)\\n\\nint {\\n    offset -= sovTx(v)\\n    base := offset\\n    for v >= 1<<7 {\\n    dAtA[offset] = uint8(v&0x7f | 0x80)\\n\\nv >>= 7\\n\\t\\toffset++\\n}\\n\\ndAtA[offset] = uint8(v)\\n\\nreturn base\\n}\\n\\nfunc (m *MsgSend)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\tl = len(m.FromAddress)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n\\nl = len(m.ToAddress)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n    if len(m.Amount) > 0 {\\n    for _, e := range m.Amount {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n\\nreturn n\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n    if len(m.Inputs) > 0 {\\n    for _, e := range m.Inputs {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n    if len(m.Outputs) > 0 {\\n    for _, e := range m.Outputs {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n\\nreturn n\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\tl = len(m.Authority)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n\\nl = m.Params.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n\\nreturn n\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\tl = len(m.Authority)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n    if len(m.SendEnabled) > 0 {\\n    for _, e := range m.SendEnabled {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n    if len(m.UseDefaultFor) > 0 {\\n    for _, s := range m.UseDefaultFor {\\n    l = len(s)\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n\\nreturn n\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc sovTx(x uint64) (n int) {\\n    return (math_bits.Len64(x|1) + 6) / 7\\n}\\n\\nfunc sozTx(x uint64) (n int) {\\n    return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))\\n}\\n\\nfunc (m *MsgSend)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSend: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSend: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field FromAddress\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.FromAddress = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field ToAddress\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.ToAddress = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 3:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Amount\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Amount = append(m.Amount, types.Coin{\\n})\\n    if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSendResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSendResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSend: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSend: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Inputs\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Inputs = append(m.Inputs, Input{\\n})\\n    if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Outputs\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Outputs = append(m.Outputs, Output{\\n})\\n    if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSendResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSendResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParams: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParams: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Authority\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Authority = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Params\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n    if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParamsResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabled: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabled: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Authority\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Authority = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field SendEnabled\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.SendEnabled = append(m.SendEnabled, &SendEnabled{\\n})\\n    if err := m.SendEnabled[len(m.SendEnabled)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n    case 3:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field UseDefaultFor\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.UseDefaultFor = append(m.UseDefaultFor, string(dAtA[iNdEx:postIndex]))\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabledResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabledResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc skipTx(dAtA []byte) (n int, err error) {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    depth := 0\\n    for iNdEx < l {\\n    var wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return 0, ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return 0, io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= (uint64(b) & 0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    wireType := int(wire & 0x7)\\n    switch wireType {\\n    case 0:\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return 0, ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return 0, io.ErrUnexpectedEOF\\n}\\n\\niNdEx++\\n    if dAtA[iNdEx-1] < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    case 1:\\n\\t\\t\\tiNdEx += 8\\n    case 2:\\n\\t\\t\\tvar length int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return 0, ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return 0, io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tlength |= (int(b) & 0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if length < 0 {\\n    return 0, ErrInvalidLengthTx\\n}\\n\\niNdEx += length\\n    case 3:\\n\\t\\t\\tdepth++\\n    case 4:\\n    if depth == 0 {\\n    return 0, ErrUnexpectedEndOfGroupTx\\n}\\n\\ndepth--\\n    case 5:\\n\\t\\t\\tiNdEx += 4\\n\\t\\tdefault:\\n\\t\\t\\treturn 0, fmt.Errorf(\\\"proto: illegal wireType %d\\\", wireType)\\n}\\n    if iNdEx < 0 {\\n    return 0, ErrInvalidLengthTx\\n}\\n    if depth == 0 {\\n    return iNdEx, nil\\n}\\n\\t\\n}\\n\\nreturn 0, io.ErrUnexpectedEOF\\n}\\n\\nvar (\\n\\tErrInvalidLengthTx        = fmt.Errorf(\\\"proto: negative length found during unmarshaling\\\")\\n\\nErrIntOverflowTx          = fmt.Errorf(\\\"proto: integer overflow\\\")\\n\\nErrUnexpectedEndOfGroupTx = fmt.Errorf(\\\"proto: unexpected end of group\\\")\\n)\\n\\n\", \"Title: Implementation of a module Msg service\\nLink: https://evm.cosmos.network/docs/sdk/v0.50/build/building-modules/msg-services\\nContent: Each module should define a Protobuf Msg service, which will be responsible for processing requests (implementing sdk.Msg ) and returning responses. As further described in ADR 031 , this approach has the advantage of clearly specifying return types and generating server and client code. Protobuf generates a MsgServer interface based on a definition of Msg service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each sdk.Msg . As an example, here is the generated MsgServer interface for x/bank , which exposes two sdk.Msg s: When possible, the existing module's Keeper should implement MsgServer , otherwise a msgServer struct that embeds the Keeper can be created, typically in ./keeper/msg_server.go: package keeper\\n\\nimport (\\n    \\n\\t\\\"context\\\"\\n    \\\"github.com/armon/go-metrics\\\"\\n\\n\\terrorsmod \\\"cosmossdk.io/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\tsdkerrors \\\"github.com/cosmos/cosmos-sdk/types/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/bank/types\\\"\\n\\tgovtypes \\\"github.com/cosmos/cosmos-sdk/x/gov/types\\\"\\n)\\n\\ntype msgServer struct {\\n    Keeper\\n}\\n\\nvar _ types.MsgServer = msgServer{\\n}\\n\\n// NewMsgServerImpl returns an implementation of the bank MsgServer interface\\n// for the provided Keeper.\\nfunc NewMsgServerImpl(keeper Keeper)\\n\\ntypes.MsgServer {\\n    return &msgServer{\\n    Keeper: keeper\\n}\\n}\\n\\nfunc (k msgServer)\\n\\nSend(goCtx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {\\n    var (\\n\\t\\tfrom, to []byte\\n\\t\\terr      error\\n\\t)\\n    if base, ok := k.Keeper.(BaseKeeper); ok {\\n    from, err = base.ak.AddressCodec().StringToBytes(msg.FromAddress)\\n    if err != nil {\\n    return nil, sdkerrors.ErrInvalidAddress.Wrapf(\\\"invalid from address: %s\\\", err)\\n}\\n\\nto, err = base.ak.AddressCodec().StringToBytes(msg.ToAddress)\\n    if err != nil {\\n    return nil, sdkerrors.ErrInvalidAddress.Wrapf(\\\"invalid to address: %s\\\", err)\\n}\\n\\t\\n}\\n\\nelse {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid keeper type: %T\\\", k.Keeper)\\n}\\n    if !msg.Amount.IsValid() {\\n    return nil, errorsmod.Wrap(sdkerrors.ErrInvalidCoins, msg.Amount.String())\\n}\\n    if !msg.Amount.IsAllPositive() {\\n    return nil, errorsmod.Wrap(sdkerrors.ErrInvalidCoins, msg.Amount.String())\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(to) {\\n    return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", msg.ToAddress)\\n}\\n\\nerr = k.SendCoins(ctx, from, to, msg.Amount)\\n    if err != nil {\\n    return nil, err\\n}\\n\\ndefer func() {\\n    for _, a := range msg.Amount {\\n    if a.Amount.IsInt64() {\\n    telemetry.SetGaugeWithLabels(\\n\\t\\t\\t\\t\\t[]string{\\\"tx\\\", \\\"msg\\\", \\\"send\\\"\\n},\\n\\t\\t\\t\\t\\tfloat32(a.Amount.Int64()),\\n\\t\\t\\t\\t\\t[]metrics.Label{\\n    telemetry.NewLabel(\\\"denom\\\", a.Denom)\\n},\\n\\t\\t\\t\\t)\\n}\\n\\t\\n}\\n\\t\\n}()\\n\\nreturn &types.MsgSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nMultiSend(goCtx context.Context, msg *types.MsgMultiSend) (*types.MsgMultiSendResponse, error) {\\n    if len(msg.Inputs) == 0 {\\n    return nil, types.ErrNoInputs\\n}\\n    if len(msg.Inputs) != 1 {\\n    return nil, types.ErrMultipleSenders\\n}\\n    if len(msg.Outputs) == 0 {\\n    return nil, types.ErrNoOutputs\\n}\\n    if err := types.ValidateInputOutputs(msg.Inputs[0], msg.Outputs); err != nil {\\n    return nil, err\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n\\n\\t// NOTE: totalIn == totalOut should already have been checked\\n    for _, in := range msg.Inputs {\\n    if err := k.IsSendEnabledCoins(ctx, in.Coins...); err != nil {\\n    return nil, err\\n}\\n\\t\\n}\\n    for _, out := range msg.Outputs {\\n    if base, ok := k.Keeper.(BaseKeeper); ok {\\n    accAddr, err := base.ak.AddressCodec().StringToBytes(out.Address)\\n    if err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(accAddr) {\\n    return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", out.Address)\\n}\\n\\t\\n}\\n\\nelse {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid keeper type: %T\\\", k.Keeper)\\n}\\n\\t\\n}\\n    err := k.InputOutputCoins(ctx, msg.Inputs[0], msg.Outputs)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgMultiSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nUpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) {\\n    if k.GetAuthority() != req.Authority {\\n    return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), req.Authority)\\n}\\n    if err := req.Params.Validate(); err != nil {\\n    return nil, err\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.SetParams(ctx, req.Params); err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgUpdateParamsResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nSetSendEnabled(goCtx context.Context, msg *types.MsgSetSendEnabled) (*types.MsgSetSendEnabledResponse, error) {\\n    if k.GetAuthority() != msg.Authority {\\n    return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), msg.Authority)\\n}\\n    seen := map[string]bool{\\n}\\n    for _, se := range msg.SendEnabled {\\n    if _, alreadySeen := seen[se.Denom]; alreadySeen {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"duplicate denom entries found for %q\\\", se.Denom)\\n}\\n\\nseen[se.Denom] = true\\n    if err := se.Validate(); err != nil {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid SendEnabled denom %q: %s\\\", se.Denom, err)\\n}\\n\\t\\n}\\n    for _, denom := range msg.UseDefaultFor {\\n    if err := sdk.ValidateDenom(denom); err != nil {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid UseDefaultFor denom %q: %s\\\", denom, err)\\n}\\n\\t\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if len(msg.SendEnabled) > 0 {\\n    k.SetAllSendEnabled(ctx, msg.SendEnabled)\\n}\\n    if len(msg.UseDefaultFor) > 0 {\\n    k.DeleteSendEnabled(ctx, msg.UseDefaultFor...)\\n}\\n\\nreturn &types.MsgSetSendEnabledResponse{\\n}, nil\\n}\\n\\nEach module should define a Protobuf Msg service, which will be responsible for processing requests (implementing sdk.Msg ) and returning responses. As further described in ADR 031 , this approach has the advantage of clearly specifying return types and generating server and client code. Protobuf generates a MsgServer interface based on a definition of Msg service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each sdk.Msg . As an example, here is the generated MsgServer interface for x/bank , which exposes two sdk.Msg s: When possible, the existing module's Keeper should implement MsgServer , otherwise a msgServer struct that embeds the Keeper can be created, typically in ./keeper/msg_server.go: msgServer methods can retrieve the context.Context from the context.Context parameter method using the sdk.UnwrapSDKContext: package keeper\\n\\nimport (\\n    \\n\\t\\\"context\\\"\\n    \\\"github.com/armon/go-metrics\\\"\\n\\n\\terrorsmod \\\"cosmossdk.io/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\tsdkerrors \\\"github.com/cosmos/cosmos-sdk/types/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/bank/types\\\"\\n\\tgovtypes \\\"github.com/cosmos/cosmos-sdk/x/gov/types\\\"\\n)\\n\\ntype msgServer struct {\\n    Keeper\\n}\\n\\nvar _ types.MsgServer = msgServer{\\n}\\n\\n// NewMsgServerImpl returns an implementation of the bank MsgServer interface\\n// for the provided Keeper.\\nfunc NewMsgServerImpl(keeper Keeper)\\n\\ntypes.MsgServer {\\n    return &msgServer{\\n    Keeper: keeper\\n}\\n}\\n\\nfunc (k msgServer)\\n\\nSend(goCtx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {\\n    var (\\n\\t\\tfrom, to []byte\\n\\t\\terr      error\\n\\t)\\n    if base, ok := k.Keeper.(BaseKeeper); ok {\\n    from, err = base.ak.AddressCodec().StringToBytes(msg.FromAddress)\\n    if err != nil {\\n    return nil, sdkerrors.ErrInvalidAddress.Wrapf(\\\"invalid from address: %s\\\", err)\\n}\\n\\nto, err = base.ak.AddressCodec().StringToBytes(msg.ToAddress)\\n    if err != nil {\\n    return nil, sdkerrors.ErrInvalidAddress.Wrapf(\\\"invalid to address: %s\\\", err)\\n}\\n\\t\\n}\\n\\nelse {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid keeper type: %T\\\", k.Keeper)\\n}\\n    if !msg.Amount.IsValid() {\\n    return nil, errorsmod.Wrap(sdkerrors.ErrInvalidCoins, msg.Amount.String())\\n}\\n    if !msg.Amount.IsAllPositive() {\\n    return nil, errorsmod.Wrap(sdkerrors.ErrInvalidCoins, msg.Amount.String())\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(to) {\\n    return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", msg.ToAddress)\\n}\\n\\nerr = k.SendCoins(ctx, from, to, msg.Amount)\\n    if err != nil {\\n    return nil, err\\n}\\n\\ndefer func() {\\n    for _, a := range msg.Amount {\\n    if a.Amount.IsInt64() {\\n    telemetry.SetGaugeWithLabels(\\n\\t\\t\\t\\t\\t[]string{\\\"tx\\\", \\\"msg\\\", \\\"send\\\"\\n},\\n\\t\\t\\t\\t\\tfloat32(a.Amount.Int64()),\\n\\t\\t\\t\\t\\t[]metrics.Label{\\n    telemetry.NewLabel(\\\"denom\\\", a.Denom)\\n},\\n\\t\\t\\t\\t)\\n}\\n\\t\\n}\\n\\t\\n}()\\n\\nreturn &types.MsgSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nMultiSend(goCtx context.Context, msg *types.MsgMultiSend) (*types.MsgMultiSendResponse, error) {\\n    if len(msg.Inputs) == 0 {\\n    return nil, types.ErrNoInputs\\n}\\n    if len(msg.Inputs) != 1 {\\n    return nil, types.ErrMultipleSenders\\n}\\n    if len(msg.Outputs) == 0 {\\n    return nil, types.ErrNoOutputs\\n}\\n    if err := types.ValidateInputOutputs(msg.Inputs[0], msg.Outputs); err != nil {\\n    return nil, err\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n\\n\\t// NOTE: totalIn == totalOut should already have been checked\\n    for _, in := range msg.Inputs {\\n    if err := k.IsSendEnabledCoins(ctx, in.Coins...); err != nil {\\n    return nil, err\\n}\\n\\t\\n}\\n    for _, out := range msg.Outputs {\\n    if base, ok := k.Keeper.(BaseKeeper); ok {\\n    accAddr, err := base.ak.AddressCodec().StringToBytes(out.Address)\\n    if err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(accAddr) {\\n    return nil, errorsmod.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", out.Address)\\n}\\n\\t\\n}\\n\\nelse {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid keeper type: %T\\\", k.Keeper)\\n}\\n\\t\\n}\\n    err := k.InputOutputCoins(ctx, msg.Inputs[0], msg.Outputs)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgMultiSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nUpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) {\\n    if k.GetAuthority() != req.Authority {\\n    return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), req.Authority)\\n}\\n    if err := req.Params.Validate(); err != nil {\\n    return nil, err\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.SetParams(ctx, req.Params); err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgUpdateParamsResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nSetSendEnabled(goCtx context.Context, msg *types.MsgSetSendEnabled) (*types.MsgSetSendEnabledResponse, error) {\\n    if k.GetAuthority() != msg.Authority {\\n    return nil, errorsmod.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), msg.Authority)\\n}\\n    seen := map[string]bool{\\n}\\n    for _, se := range msg.SendEnabled {\\n    if _, alreadySeen := seen[se.Denom]; alreadySeen {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"duplicate denom entries found for %q\\\", se.Denom)\\n}\\n\\nseen[se.Denom] = true\\n    if err := se.Validate(); err != nil {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid SendEnabled denom %q: %s\\\", se.Denom, err)\\n}\\n\\t\\n}\\n    for _, denom := range msg.UseDefaultFor {\\n    if err := sdk.ValidateDenom(denom); err != nil {\\n    return nil, sdkerrors.ErrInvalidRequest.Wrapf(\\\"invalid UseDefaultFor denom %q: %s\\\", denom, err)\\n}\\n\\t\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if len(msg.SendEnabled) > 0 {\\n    k.SetAllSendEnabled(ctx, msg.SendEnabled)\\n}\\n    if len(msg.UseDefaultFor) > 0 {\\n    k.DeleteSendEnabled(ctx, msg.UseDefaultFor...)\\n}\\n\\nreturn &types.MsgSetSendEnabledResponse{\\n}, nil\\n}\\n\\nEach module should define a Protobuf Msg service, which will be responsible for processing requests (implementing sdk.Msg ) and returning responses. As further described in ADR 031 , this approach has the advantage of clearly specifying return types and generating server and client code. Protobuf generates a MsgServer interface based on a definition of Msg service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each sdk.Msg . As an example, here is the generated MsgServer interface for x/bank , which exposes two sdk.Msg s: // Code generated by protoc-gen-gogo. DO NOT EDIT.\\n// source: cosmos/bank/v1beta1/tx.proto\\n\\npackage types\\n\\nimport (\\n    \\n\\tcontext \\\"context\\\"\\n\\tfmt \\\"fmt\\\"\\n\\t_ \\\"github.com/cosmos/cosmos-proto\\\"\\n\\tgithub_com_cosmos_cosmos_sdk_types \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\ttypes \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\t_ \\\"github.com/cosmos/cosmos-sdk/types/msgservice\\\"\\n\\t_ \\\"github.com/cosmos/cosmos-sdk/types/tx/amino\\\"\\n\\t_ \\\"github.com/cosmos/gogoproto/gogoproto\\\"\\n\\tgrpc1 \\\"github.com/cosmos/gogoproto/grpc\\\"\\n\\tproto \\\"github.com/cosmos/gogoproto/proto\\\"\\n\\tgrpc \\\"google.golang.org/grpc\\\"\\n\\tcodes \\\"google.golang.org/grpc/codes\\\"\\n\\tstatus \\\"google.golang.org/grpc/status\\\"\\n\\tio \\\"io\\\"\\n\\tmath \\\"math\\\"\\n\\tmath_bits \\\"math/bits\\\"\\n)\\n\\n// Reference imports to suppress errors if they are not otherwise used.\\nvar _ = proto.Marshal\\nvar _ = fmt.Errorf\\nvar _ = math.Inf\\n\\n// This is a compile-time assertion to ensure that this generated file\\n// is compatible with the proto package it is being compiled against.\\n// A compilation error at this line likely means your copy of the\\n// proto package needs to be updated.\\nconst _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package\\n\\n// MsgSend represents a message to send coins from one account to another.\\ntype MsgSend struct {\\n    FromAddress string                                   `protobuf:\\\"bytes,1,opt,name=from_address,json=fromAddress,proto3\\\" json:\\\"from_address,omitempty\\\"`\\n\\tToAddress   string                                   `protobuf:\\\"bytes,2,opt,name=to_address,json=toAddress,proto3\\\" json:\\\"to_address,omitempty\\\"`\\n\\tAmount      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:\\\"bytes,3,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins\\\" json:\\\"amount\\\"`\\n}\\n\\nfunc (m *MsgSend)\\n\\nReset() { *m = MsgSend{\\n} \\n}\\n\\nfunc (m *MsgSend)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSend)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSend)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{0\\n}\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSend.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSend.Merge(m, src)\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSend.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSend proto.InternalMessageInfo\\n\\n// MsgSendResponse defines the Msg/Send response type.\\ntype MsgSendResponse struct {\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nReset() { *m = MsgSendResponse{\\n} \\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSendResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSendResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{1\\n}\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSendResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSendResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSendResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSendResponse proto.InternalMessageInfo\\n\\n// MsgMultiSend represents an arbitrary multi-in, multi-out send message.\\ntype MsgMultiSend struct {\\n\\t// Inputs, despite being `repeated`, only allows one sender input. This is\\n\\t// checked in MsgMultiSend's ValidateBasic.\\n\\tInputs  []Input  `protobuf:\\\"bytes,1,rep,name=inputs,proto3\\\" json:\\\"inputs\\\"`\\n\\tOutputs []Output `protobuf:\\\"bytes,2,rep,name=outputs,proto3\\\" json:\\\"outputs\\\"`\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nReset() { *m = MsgMultiSend{\\n} \\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgMultiSend)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgMultiSend)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{2\\n}\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgMultiSend.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgMultiSend.Merge(m, src)\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgMultiSend.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgMultiSend proto.InternalMessageInfo\\n\\nfunc (m *MsgMultiSend)\\n\\nGetInputs() []Input {\\n    if m != nil {\\n    return m.Inputs\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nGetOutputs() []Output {\\n    if m != nil {\\n    return m.Outputs\\n}\\n\\nreturn nil\\n}\\n\\n// MsgMultiSendResponse defines the Msg/MultiSend response type.\\ntype MsgMultiSendResponse struct {\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nReset() { *m = MsgMultiSendResponse{\\n} \\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgMultiSendResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgMultiSendResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{3\\n}\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgMultiSendResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgMultiSendResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgMultiSendResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgMultiSendResponse proto.InternalMessageInfo\\n\\n// MsgUpdateParams is the Msg/UpdateParams request type.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgUpdateParams struct {\\n\\t// authority is the address that controls the module (defaults to x/gov unless overwritten).\\n\\tAuthority string `protobuf:\\\"bytes,1,opt,name=authority,proto3\\\" json:\\\"authority,omitempty\\\"`\\n\\t// params defines the x/bank parameters to update.\\n\\t//\\n\\t// NOTE: All parameters must be supplied.\\n\\tParams Params `protobuf:\\\"bytes,2,opt,name=params,proto3\\\" json:\\\"params\\\"`\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nReset() { *m = MsgUpdateParams{\\n} \\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgUpdateParams)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgUpdateParams)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{4\\n}\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgUpdateParams.Merge(m, src)\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo\\n\\nfunc (m *MsgUpdateParams)\\n\\nGetAuthority()\\n\\nstring {\\n    if m != nil {\\n    return m.Authority\\n}\\n\\nreturn \\\"\\\"\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nGetParams()\\n\\nParams {\\n    if m != nil {\\n    return m.Params\\n}\\n\\nreturn Params{\\n}\\n}\\n\\n// MsgUpdateParamsResponse defines the response structure for executing a\\n// MsgUpdateParams message.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgUpdateParamsResponse struct {\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nReset() { *m = MsgUpdateParamsResponse{\\n} \\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgUpdateParamsResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgUpdateParamsResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{5\\n}\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo\\n\\n// MsgSetSendEnabled is the Msg/SetSendEnabled request type.\\n//\\n// Only entries to add/update/delete need to be included.\\n// Existing SendEnabled entries that are not included in this\\n// message are left unchanged.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgSetSendEnabled struct {\\n    Authority string `protobuf:\\\"bytes,1,opt,name=authority,proto3\\\" json:\\\"authority,omitempty\\\"`\\n\\t// send_enabled is the list of entries to add or update.\\n\\tSendEnabled []*SendEnabled `protobuf:\\\"bytes,2,rep,name=send_enabled,json=sendEnabled,proto3\\\" json:\\\"send_enabled,omitempty\\\"`\\n\\t// use_default_for is a list of denoms that should use the params.default_send_enabled value.\\n\\t// Denoms listed here will have their SendEnabled entries deleted.\\n\\t// If a denom is included that doesn't have a SendEnabled entry,\\n\\t// it will be ignored.\\n\\tUseDefaultFor []string `protobuf:\\\"bytes,3,rep,name=use_default_for,json=useDefaultFor,proto3\\\" json:\\\"use_default_for,omitempty\\\"`\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nReset() { *m = MsgSetSendEnabled{\\n} \\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSetSendEnabled)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSetSendEnabled)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{6\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSetSendEnabled.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSetSendEnabled.Merge(m, src)\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSetSendEnabled.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSetSendEnabled proto.InternalMessageInfo\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nGetAuthority()\\n\\nstring {\\n    if m != nil {\\n    return m.Authority\\n}\\n\\nreturn \\\"\\\"\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nGetSendEnabled() []*SendEnabled {\\n    if m != nil {\\n    return m.SendEnabled\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nGetUseDefaultFor() []string {\\n    if m != nil {\\n    return m.UseDefaultFor\\n}\\n\\nreturn nil\\n}\\n\\n// MsgSetSendEnabledResponse defines the Msg/SetSendEnabled response type.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgSetSendEnabledResponse struct {\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nReset() { *m = MsgSetSendEnabledResponse{\\n} \\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSetSendEnabledResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSetSendEnabledResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{7\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSetSendEnabledResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSetSendEnabledResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSetSendEnabledResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSetSendEnabledResponse proto.InternalMessageInfo\\n\\nfunc init() {\\n    proto.RegisterType((*MsgSend)(nil), \\\"cosmos.bank.v1beta1.MsgSend\\\")\\n\\nproto.RegisterType((*MsgSendResponse)(nil), \\\"cosmos.bank.v1beta1.MsgSendResponse\\\")\\n\\nproto.RegisterType((*MsgMultiSend)(nil), \\\"cosmos.bank.v1beta1.MsgMultiSend\\\")\\n\\nproto.RegisterType((*MsgMultiSendResponse)(nil), \\\"cosmos.bank.v1beta1.MsgMultiSendResponse\\\")\\n\\nproto.RegisterType((*MsgUpdateParams)(nil), \\\"cosmos.bank.v1beta1.MsgUpdateParams\\\")\\n\\nproto.RegisterType((*MsgUpdateParamsResponse)(nil), \\\"cosmos.bank.v1beta1.MsgUpdateParamsResponse\\\")\\n\\nproto.RegisterType((*MsgSetSendEnabled)(nil), \\\"cosmos.bank.v1beta1.MsgSetSendEnabled\\\")\\n\\nproto.RegisterType((*MsgSetSendEnabledResponse)(nil), \\\"cosmos.bank.v1beta1.MsgSetSendEnabledResponse\\\")\\n}\\n\\nfunc init() {\\n    proto.RegisterFile(\\\"cosmos/bank/v1beta1/tx.proto\\\", fileDescriptor_1d8cb1613481f5b7)\\n}\\n\\nvar fileDescriptor_1d8cb1613481f5b7 = []byte{\\n\\t// 700 bytes of a gzipped FileDescriptorProto\\n\\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcf, 0x4f, 0xd3, 0x50,\\n\\t0x1c, 0x5f, 0x99, 0x8e, 0xec, 0x31, 0x25, 0x54, 0x22, 0xac, 0x90, 0x0e, 0x16, 0x43, 0x00, 0xa5,\\n\\t0x15, 0x34, 0x9a, 0xcc, 0x68, 0x74, 0x28, 0x89, 0x26, 0x8b, 0x66, 0xc4, 0x83, 0x5e, 0x96, 0xd7,\\n\\t0xf5, 0x51, 0x1a, 0xd6, 0xbe, 0xa6, 0xef, 0x95, 0xb0, 0x9b, 0x7a, 0x32, 0x9e, 0x3c, 0x7b, 0xe2,\\n\\t0x68, 0x8c, 0x07, 0x0e, 0x1e, 0x4d, 0xbc, 0x72, 0x24, 0x9e, 0x3c, 0xa9, 0x81, 0x03, 0xfa, 0x5f,\\n\\t0x98, 0xf7, 0xa3, 0xa5, 0x8c, 0x8d, 0x11, 0x2f, 0x6b, 0xf7, 0x3e, 0x3f, 0xbe, 0xef, 0xf3, 0xed,\\n\\t0xf7, 0x3d, 0x30, 0xd9, 0xc4, 0xc4, 0xc3, 0xc4, 0xb4, 0xa0, 0xbf, 0x61, 0x6e, 0x2e, 0x5a, 0x88,\\n\\t0xc2, 0x45, 0x93, 0x6e, 0x19, 0x41, 0x88, 0x29, 0x56, 0x2f, 0x09, 0xd4, 0x60, 0xa8, 0x21, 0x51,\\n\\t0x6d, 0xd4, 0xc1, 0x0e, 0xe6, 0xb8, 0xc9, 0xde, 0x04, 0x55, 0xd3, 0x13, 0x23, 0x82, 0x12, 0xa3,\\n\\t0x26, 0x76, 0xfd, 0x13, 0x78, 0xaa, 0x10, 0xf7, 0x15, 0x78, 0x51, 0xe0, 0x0d, 0x61, 0x2c, 0xeb,\\n\\t0x0a, 0x68, 0x4c, 0x4a, 0x3d, 0xe2, 0x98, 0x9b, 0x8b, 0xec, 0x21, 0x81, 0x11, 0xe8, 0xb9, 0x3e,\\n\\t0x36, 0xf9, 0xaf, 0x58, 0x2a, 0x7f, 0x1e, 0x00, 0x83, 0x35, 0xe2, 0xac, 0x22, 0xdf, 0x56, 0xef,\\n\\t0x80, 0xc2, 0x5a, 0x88, 0xbd, 0x06, 0xb4, 0xed, 0x10, 0x11, 0x32, 0xae, 0x4c, 0x29, 0xb3, 0xf9,\\n\\t0xea, 0xf8, 0xf7, 0x2f, 0x0b, 0xa3, 0xd2, 0xff, 0x81, 0x40, 0x56, 0x69, 0xe8, 0xfa, 0x4e, 0x7d,\\n\\t0x88, 0xb1, 0xe5, 0x92, 0x7a, 0x1b, 0x00, 0x8a, 0x13, 0xe9, 0x40, 0x1f, 0x69, 0x9e, 0xe2, 0x58,\\n\\t0xd8, 0x06, 0x39, 0xe8, 0xe1, 0xc8, 0xa7, 0xe3, 0xd9, 0xa9, 0xec, 0xec, 0xd0, 0x52, 0xd1, 0x48,\\n\\t0x9a, 0x48, 0x50, 0xdc, 0x44, 0x63, 0x19, 0xbb, 0x7e, 0x75, 0x65, 0xf7, 0x67, 0x29, 0xf3, 0xe9,\\n\\t0x57, 0x69, 0xd6, 0x71, 0xe9, 0x7a, 0x64, 0x19, 0x4d, 0xec, 0xc9, 0xe4, 0xf2, 0xb1, 0x40, 0xec,\\n\\t0x0d, 0x93, 0xb6, 0x03, 0x44, 0xb8, 0x80, 0x7c, 0x38, 0xdc, 0x99, 0x2f, 0xb4, 0x90, 0x03, 0x9b,\\n\\t0xed, 0x06, 0xeb, 0x2d, 0xf9, 0x78, 0xb8, 0x33, 0xaf, 0xd4, 0x65, 0xc1, 0xca, 0xf5, 0xb7, 0xdb,\\n\\t0xa5, 0xcc, 0x9f, 0xed, 0x52, 0xe6, 0x0d, 0xe3, 0xa5, 0xb3, 0xbf, 0x3b, 0xdc, 0x99, 0x57, 0x53,\\n\\t0x9e, 0xb2, 0x45, 0xe5, 0x11, 0x30, 0x2c, 0x5f, 0xeb, 0x88, 0x04, 0xd8, 0x27, 0xa8, 0xfc, 0x55,\\n\\t0x01, 0x85, 0x1a, 0x71, 0x6a, 0x51, 0x8b, 0xba, 0xbc, 0x8d, 0x77, 0x41, 0xce, 0xf5, 0x83, 0x88,\\n\\t0xb2, 0x06, 0xb2, 0x40, 0x9a, 0xd1, 0x65, 0x2a, 0x8c, 0xc7, 0x8c, 0x52, 0xcd, 0xb3, 0x44, 0x72,\\n\\t0x53, 0x42, 0xa4, 0xde, 0x07, 0x83, 0x38, 0xa2, 0x5c, 0x3f, 0xc0, 0xf5, 0x13, 0x5d, 0xf5, 0x4f,\\n\\t0x39, 0x27, 0x6d, 0x10, 0xcb, 0x2a, 0x57, 0xe3, 0x48, 0xd2, 0x92, 0x85, 0x19, 0x3b, 0x1e, 0x26,\\n\\t0xd9, 0x6d, 0xf9, 0x32, 0x18, 0x4d, 0xff, 0x4f, 0x62, 0x7d, 0x53, 0x78, 0xd4, 0xe7, 0x81, 0x0d,\\n\\t0x29, 0x7a, 0x06, 0x43, 0xe8, 0x11, 0xf5, 0x16, 0xc8, 0xc3, 0x88, 0xae, 0xe3, 0xd0, 0xa5, 0xed,\\n\\t0xbe, 0xd3, 0x71, 0x44, 0x55, 0xef, 0x81, 0x5c, 0xc0, 0x1d, 0xf8, 0x5c, 0xf4, 0x4a, 0x24, 0x8a,\\n\\t0x1c, 0x6b, 0x89, 0x50, 0x55, 0x6e, 0xb2, 0x30, 0x47, 0x7e, 0x2c, 0xcf, 0x74, 0x2a, 0xcf, 0x96,\\n\\t0x38, 0x24, 0x1d, 0xbb, 0x2d, 0x17, 0xc1, 0x58, 0xc7, 0x52, 0x12, 0xee, 0xaf, 0x02, 0x46, 0xf8,\\n\\t0x77, 0xa4, 0x2c, 0xf3, 0x23, 0x1f, 0x5a, 0x2d, 0x64, 0xff, 0x77, 0xbc, 0x65, 0x50, 0x20, 0xc8,\\n\\t0xb7, 0x1b, 0x48, 0xf8, 0xc8, 0xcf, 0x36, 0xd5, 0x35, 0x64, 0xaa, 0x5e, 0x7d, 0x88, 0xa4, 0x8a,\\n\\t0xcf, 0x80, 0xe1, 0x88, 0xa0, 0x86, 0x8d, 0xd6, 0x60, 0xd4, 0xa2, 0x8d, 0x35, 0x1c, 0xf2, 0xf3,\\n\\t0x90, 0xaf, 0x5f, 0x88, 0x08, 0x7a, 0x28, 0x56, 0x57, 0x70, 0x58, 0x31, 0x4f, 0xf6, 0x62, 0xb2,\\n\\t0x73, 0x50, 0xd3, 0xa9, 0xca, 0x13, 0xa0, 0x78, 0x62, 0x31, 0x6e, 0xc4, 0xd2, 0xeb, 0x2c, 0xc8,\\n\\t0xd6, 0x88, 0xa3, 0x3e, 0x01, 0xe7, 0xf8, 0xec, 0x4e, 0x76, 0xdd, 0xb4, 0x1c, 0x79, 0xed, 0xca,\\n\\t0x69, 0x68, 0xec, 0xa9, 0xbe, 0x00, 0xf9, 0xa3, 0xc3, 0x30, 0xdd, 0x4b, 0x92, 0x50, 0xb4, 0xb9,\\n\\t0xbe, 0x94, 0xc4, 0xda, 0x02, 0x85, 0x63, 0x03, 0xd9, 0x73, 0x43, 0x69, 0x96, 0x76, 0xed, 0x2c,\\n\\t0xac, 0xa4, 0xc6, 0x3a, 0xb8, 0xd8, 0x31, 0x17, 0x33, 0xbd, 0x63, 0xa7, 0x79, 0x9a, 0x71, 0x36,\\n\\t0x5e, 0x5c, 0x49, 0x3b, 0xff, 0x8a, 0x4d, 0x79, 0x75, 0x79, 0x77, 0x5f, 0x57, 0xf6, 0xf6, 0x75,\\n\\t0xe5, 0xf7, 0xbe, 0xae, 0xbc, 0x3f, 0xd0, 0x33, 0x7b, 0x07, 0x7a, 0xe6, 0xc7, 0x81, 0x9e, 0x79,\\n\\t0x39, 0x77, 0xea, 0x3d, 0x27, 0xc7, 0x9e, 0x5f, 0x77, 0x56, 0x8e, 0x5f, 0xe7, 0x37, 0xfe, 0x05,\\n\\t0x00, 0x00, 0xff, 0xff, 0x5b, 0x5b, 0x43, 0xa9, 0xa0, 0x06, 0x00, 0x00,\\n}\\n\\n// Reference imports to suppress errors if they are not otherwise used.\\nvar _ context.Context\\nvar _ grpc.ClientConn\\n\\n// This is a compile-time assertion to ensure that this generated file\\n// is compatible with the grpc package it is being compiled against.\\nconst _ = grpc.SupportPackageIsVersion4\\n\\n// MsgClient is the client API for Msg service.\\n//\\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.\\ntype MsgClient interface {\\n\\t// Send defines a method for sending coins from one account to another account.\\n\\tSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error)\\n\\t// MultiSend defines a method for sending coins from some accounts to other accounts.\\n\\tMultiSend(ctx context.Context, in *MsgMultiSend, opts ...grpc.CallOption) (*MsgMultiSendResponse, error)\\n\\t// UpdateParams defines a governance operation for updating the x/bank module parameters.\\n\\t// The authority is defined in the keeper.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tUpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)\\n\\t// SetSendEnabled is a governance operation for setting the SendEnabled flag\\n\\t// on any number of Denoms. Only the entries to add or update should be\\n\\t// included. Entries that already exist in the store, but that aren't\\n\\t// included in this message, will be left unchanged.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tSetSendEnabled(ctx context.Context, in *MsgSetSendEnabled, opts ...grpc.CallOption) (*MsgSetSendEnabledResponse, error)\\n}\\n\\ntype msgClient struct {\\n    cc grpc1.ClientConn\\n}\\n\\nfunc NewMsgClient(cc grpc1.ClientConn)\\n\\nMsgClient {\\n    return &msgClient{\\n    cc\\n}\\n}\\n\\nfunc (c *msgClient)\\n\\nSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error) {\\n    out := new(MsgSendResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/Send\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\nfunc (c *msgClient)\\n\\nMultiSend(ctx context.Context, in *MsgMultiSend, opts ...grpc.CallOption) (*MsgMultiSendResponse, error) {\\n    out := new(MsgMultiSendResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/MultiSend\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\nfunc (c *msgClient)\\n\\nUpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {\\n    out := new(MsgUpdateParamsResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/UpdateParams\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\nfunc (c *msgClient)\\n\\nSetSendEnabled(ctx context.Context, in *MsgSetSendEnabled, opts ...grpc.CallOption) (*MsgSetSendEnabledResponse, error) {\\n    out := new(MsgSetSendEnabledResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/SetSendEnabled\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\n// MsgServer is the server API for Msg service.\\ntype MsgServer interface {\\n\\t// Send defines a method for sending coins from one account to another account.\\n\\tSend(context.Context, *MsgSend) (*MsgSendResponse, error)\\n\\t// MultiSend defines a method for sending coins from some accounts to other accounts.\\n\\tMultiSend(context.Context, *MsgMultiSend) (*MsgMultiSendResponse, error)\\n\\t// UpdateParams defines a governance operation for updating the x/bank module parameters.\\n\\t// The authority is defined in the keeper.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tUpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)\\n\\t// SetSendEnabled is a governance operation for setting the SendEnabled flag\\n\\t// on any number of Denoms. Only the entries to add or update should be\\n\\t// included. Entries that already exist in the store, but that aren't\\n\\t// included in this message, will be left unchanged.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tSetSendEnabled(context.Context, *MsgSetSendEnabled) (*MsgSetSendEnabledResponse, error)\\n}\\n\\n// UnimplementedMsgServer can be embedded to have forward compatible implementations.\\ntype UnimplementedMsgServer struct {\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nSend(ctx context.Context, req *MsgSend) (*MsgSendResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method Send not implemented\\\")\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nMultiSend(ctx context.Context, req *MsgMultiSend) (*MsgMultiSendResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method MultiSend not implemented\\\")\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nUpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method UpdateParams not implemented\\\")\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nSetSendEnabled(ctx context.Context, req *MsgSetSendEnabled) (*MsgSetSendEnabledResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method SetSendEnabled not implemented\\\")\\n}\\n\\nfunc RegisterMsgServer(s grpc1.Server, srv MsgServer) {\\n    s.RegisterService(&_Msg_serviceDesc, srv)\\n}\\n\\nfunc _Msg_Send_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgSend)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).Send(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/Send\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).Send(ctx, req.(*MsgSend))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nfunc _Msg_MultiSend_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgMultiSend)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).MultiSend(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/MultiSend\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).MultiSend(ctx, req.(*MsgMultiSend))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nfunc _Msg_UpdateParams_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgUpdateParams)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).UpdateParams(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/UpdateParams\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nfunc _Msg_SetSendEnabled_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgSetSendEnabled)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).SetSendEnabled(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/SetSendEnabled\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).SetSendEnabled(ctx, req.(*MsgSetSendEnabled))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nvar _Msg_serviceDesc = grpc.ServiceDesc{\\n    ServiceName: \\\"cosmos.bank.v1beta1.Msg\\\",\\n    HandlerType: (*MsgServer)(nil),\\n    Methods: []grpc.MethodDesc{\\n\\t\\t{\\n    MethodName: \\\"Send\\\",\\n    Handler:    _Msg_Send_Handler,\\n},\\n\\t\\t{\\n    MethodName: \\\"MultiSend\\\",\\n    Handler:    _Msg_MultiSend_Handler,\\n},\\n\\t\\t{\\n    MethodName: \\\"UpdateParams\\\",\\n    Handler:    _Msg_UpdateParams_Handler,\\n},\\n\\t\\t{\\n    MethodName: \\\"SetSendEnabled\\\",\\n    Handler:    _Msg_SetSendEnabled_Handler,\\n},\\n},\\n    Streams:  []grpc.StreamDesc{\\n},\\n    Metadata: \\\"cosmos/bank/v1beta1/tx.proto\\\",\\n}\\n\\nfunc (m *MsgSend)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSend)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSend)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n    if len(m.Amount) > 0 {\\n    for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x1a\\n}\\n\\t\\n}\\n    if len(m.ToAddress) > 0 {\\n    i -= len(m.ToAddress)\\n\\ncopy(dAtA[i:], m.ToAddress)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.ToAddress)))\\n\\ni--\\n\\t\\tdAtA[i] = 0x12\\n}\\n    if len(m.FromAddress) > 0 {\\n    i -= len(m.FromAddress)\\n\\ncopy(dAtA[i:], m.FromAddress)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))\\n\\ni--\\n\\t\\tdAtA[i] = 0xa\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n    if len(m.Outputs) > 0 {\\n    for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x12\\n}\\n\\t\\n}\\n    if len(m.Inputs) > 0 {\\n    for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0xa\\n}\\n\\t\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\t{\\n    size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\tdAtA[i] = 0x12\\n    if len(m.Authority) > 0 {\\n    i -= len(m.Authority)\\n\\ncopy(dAtA[i:], m.Authority)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))\\n\\ni--\\n\\t\\tdAtA[i] = 0xa\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n    if len(m.UseDefaultFor) > 0 {\\n    for iNdEx := len(m.UseDefaultFor) - 1; iNdEx >= 0; iNdEx-- {\\n    i -= len(m.UseDefaultFor[iNdEx])\\n\\ncopy(dAtA[i:], m.UseDefaultFor[iNdEx])\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.UseDefaultFor[iNdEx])))\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x1a\\n}\\n\\t\\n}\\n    if len(m.SendEnabled) > 0 {\\n    for iNdEx := len(m.SendEnabled) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.SendEnabled[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x12\\n}\\n\\t\\n}\\n    if len(m.Authority) > 0 {\\n    i -= len(m.Authority)\\n\\ncopy(dAtA[i:], m.Authority)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))\\n\\ni--\\n\\t\\tdAtA[i] = 0xa\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc encodeVarintTx(dAtA []byte, offset int, v uint64)\\n\\nint {\\n    offset -= sovTx(v)\\n    base := offset\\n    for v >= 1<<7 {\\n    dAtA[offset] = uint8(v&0x7f | 0x80)\\n\\nv >>= 7\\n\\t\\toffset++\\n}\\n\\ndAtA[offset] = uint8(v)\\n\\nreturn base\\n}\\n\\nfunc (m *MsgSend)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\tl = len(m.FromAddress)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n\\nl = len(m.ToAddress)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n    if len(m.Amount) > 0 {\\n    for _, e := range m.Amount {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n\\nreturn n\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n    if len(m.Inputs) > 0 {\\n    for _, e := range m.Inputs {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n    if len(m.Outputs) > 0 {\\n    for _, e := range m.Outputs {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n\\nreturn n\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\tl = len(m.Authority)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n\\nl = m.Params.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n\\nreturn n\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\tl = len(m.Authority)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n    if len(m.SendEnabled) > 0 {\\n    for _, e := range m.SendEnabled {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n    if len(m.UseDefaultFor) > 0 {\\n    for _, s := range m.UseDefaultFor {\\n    l = len(s)\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n\\nreturn n\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc sovTx(x uint64) (n int) {\\n    return (math_bits.Len64(x|1) + 6) / 7\\n}\\n\\nfunc sozTx(x uint64) (n int) {\\n    return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))\\n}\\n\\nfunc (m *MsgSend)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSend: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSend: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field FromAddress\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.FromAddress = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field ToAddress\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.ToAddress = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 3:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Amount\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Amount = append(m.Amount, types.Coin{\\n})\\n    if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSendResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSendResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSend: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSend: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Inputs\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Inputs = append(m.Inputs, Input{\\n})\\n    if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Outputs\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Outputs = append(m.Outputs, Output{\\n})\\n    if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSendResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSendResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParams: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParams: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Authority\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Authority = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Params\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n    if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParamsResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabled: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabled: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Authority\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Authority = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field SendEnabled\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.SendEnabled = append(m.SendEnabled, &SendEnabled{\\n})\\n    if err := m.SendEnabled[len(m.SendEnabled)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n    case 3:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field UseDefaultFor\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.UseDefaultFor = append(m.UseDefaultFor, string(dAtA[iNdEx:postIndex]))\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabledResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabledResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc skipTx(dAtA []byte) (n int, err error) {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    depth := 0\\n    for iNdEx < l {\\n    var wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return 0, ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return 0, io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= (uint64(b) & 0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    wireType := int(wire & 0x7)\\n    switch wireType {\\n    case 0:\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return 0, ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return 0, io.ErrUnexpectedEOF\\n}\\n\\niNdEx++\\n    if dAtA[iNdEx-1] < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    case 1:\\n\\t\\t\\tiNdEx += 8\\n    case 2:\\n\\t\\t\\tvar length int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return 0, ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return 0, io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tlength |= (int(b) & 0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if length < 0 {\\n    return 0, ErrInvalidLengthTx\\n}\\n\\niNdEx += length\\n    case 3:\\n\\t\\t\\tdepth++\\n    case 4:\\n    if depth == 0 {\\n    return 0, ErrUnexpectedEndOfGroupTx\\n}\\n\\ndepth--\\n    case 5:\\n\\t\\t\\tiNdEx += 4\\n\\t\\tdefault:\\n\\t\\t\\treturn 0, fmt.Errorf(\\\"proto: illegal wireType %d\\\", wireType)\\n}\\n    if iNdEx < 0 {\\n    return 0, ErrInvalidLengthTx\\n}\\n    if depth == 0 {\\n    return iNdEx, nil\\n}\\n\\t\\n}\\n\\nreturn 0, io.ErrUnexpectedEOF\\n}\\n\\nvar (\\n\\tErrInvalidLengthTx        = fmt.Errorf(\\\"proto: negative length found during unmarshaling\\\")\\n\\nErrIntOverflowTx          = fmt.Errorf(\\\"proto: integer overflow\\\")\\n\\nErrUnexpectedEndOfGroupTx = fmt.Errorf(\\\"proto: unexpected end of group\\\")\\n)\\n\\n\", \"Title: Implementation of a module Msg service\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/build/building-modules/msg-services\\nContent: Each module should define a Protobuf Msg service, which will be responsible for processing requests (implementing sdk.Msg ) and returning responses. As further described in ADR 031 , this approach has the advantage of clearly specifying return types and generating server and client code. Protobuf generates a MsgServer interface based on a definition of Msg service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each sdk.Msg . As an example, here is the generated MsgServer interface for x/bank , which exposes two sdk.Msg s: When possible, the existing module's Keeper should implement MsgServer , otherwise a msgServer struct that embeds the Keeper can be created, typically in ./keeper/msg_server.go: msgServer methods can retrieve the sdk.Context from the context.Context parameter method using the sdk.UnwrapSDKContext: package keeper\\n\\nimport (\\n    \\n\\t\\\"context\\\"\\n    \\\"github.com/armon/go-metrics\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\tsdkerrors \\\"github.com/cosmos/cosmos-sdk/types/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/bank/types\\\"\\n\\tgovtypes \\\"github.com/cosmos/cosmos-sdk/x/gov/types\\\"\\n)\\n\\ntype msgServer struct {\\n    Keeper\\n}\\n\\nvar _ types.MsgServer = msgServer{\\n}\\n\\n// NewMsgServerImpl returns an implementation of the bank MsgServer interface\\n// for the provided Keeper.\\nfunc NewMsgServerImpl(keeper Keeper)\\n\\ntypes.MsgServer {\\n    return &msgServer{\\n    Keeper: keeper\\n}\\n}\\n\\nfunc (k msgServer)\\n\\nSend(goCtx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {\\n    return nil, err\\n}\\n\\nfrom, err := sdk.AccAddressFromBech32(msg.FromAddress)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nto, err := sdk.AccAddressFromBech32(msg.ToAddress)\\n    if err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(to) {\\n    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", msg.ToAddress)\\n}\\n\\nerr = k.SendCoins(ctx, from, to, msg.Amount)\\n    if err != nil {\\n    return nil, err\\n}\\n\\ndefer func() {\\n    for _, a := range msg.Amount {\\n    if a.Amount.IsInt64() {\\n    telemetry.SetGaugeWithLabels(\\n\\t\\t\\t\\t\\t[]string{\\\"tx\\\", \\\"msg\\\", \\\"send\\\"\\n},\\n\\t\\t\\t\\t\\tfloat32(a.Amount.Int64()),\\n\\t\\t\\t\\t\\t[]metrics.Label{\\n    telemetry.NewLabel(\\\"denom\\\", a.Denom)\\n},\\n\\t\\t\\t\\t)\\n}\\n\\t\\n}\\n\\t\\n}()\\n\\nreturn &types.MsgSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nMultiSend(goCtx context.Context, msg *types.MsgMultiSend) (*types.MsgMultiSendResponse, error) {\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n\\n\\t// NOTE: totalIn == totalOut should already have been checked\\n    for _, in := range msg.Inputs {\\n    if err := k.IsSendEnabledCoins(ctx, in.Coins...); err != nil {\\n    return nil, err\\n}\\n\\t\\n}\\n    for _, out := range msg.Outputs {\\n    accAddr := sdk.MustAccAddressFromBech32(out.Address)\\n    if k.BlockedAddr(accAddr) {\\n    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", out.Address)\\n}\\n\\t\\n}\\n    err := k.InputOutputCoins(ctx, msg.Inputs, msg.Outputs)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgMultiSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nUpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) {\\n    if k.GetAuthority() != req.Authority {\\n    return nil, sdkerrors.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), req.Authority)\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.SetParams(ctx, req.Params); err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgUpdateParamsResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nSetSendEnabled(goCtx context.Context, msg *types.MsgSetSendEnabled) (*types.MsgSetSendEnabledResponse, error) {\\n    if k.GetAuthority() != msg.Authority {\\n    return nil, sdkerrors.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), msg.Authority)\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if len(msg.SendEnabled) > 0 {\\n    k.SetAllSendEnabled(ctx, msg.SendEnabled)\\n}\\n    if len(msg.UseDefaultFor) > 0 {\\n    k.DeleteSendEnabled(ctx, msg.UseDefaultFor...)\\n}\\n\\nreturn &types.MsgSetSendEnabledResponse{\\n}, nil\\n}\\n\\nEach module should define a Protobuf Msg service, which will be responsible for processing requests (implementing sdk.Msg ) and returning responses. As further described in ADR 031 , this approach has the advantage of clearly specifying return types and generating server and client code. Protobuf generates a MsgServer interface based on a definition of Msg service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each sdk.Msg . As an example, here is the generated MsgServer interface for x/bank , which exposes two sdk.Msg s: When possible, the existing module's Keeper should implement MsgServer , otherwise a msgServer struct that embeds the Keeper can be created, typically in ./keeper/msg_server.go: package keeper\\n\\nimport (\\n    \\n\\t\\\"context\\\"\\n    \\\"github.com/armon/go-metrics\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\tsdkerrors \\\"github.com/cosmos/cosmos-sdk/types/errors\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/bank/types\\\"\\n\\tgovtypes \\\"github.com/cosmos/cosmos-sdk/x/gov/types\\\"\\n)\\n\\ntype msgServer struct {\\n    Keeper\\n}\\n\\nvar _ types.MsgServer = msgServer{\\n}\\n\\n// NewMsgServerImpl returns an implementation of the bank MsgServer interface\\n// for the provided Keeper.\\nfunc NewMsgServerImpl(keeper Keeper)\\n\\ntypes.MsgServer {\\n    return &msgServer{\\n    Keeper: keeper\\n}\\n}\\n\\nfunc (k msgServer)\\n\\nSend(goCtx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.IsSendEnabledCoins(ctx, msg.Amount...); err != nil {\\n    return nil, err\\n}\\n\\nfrom, err := sdk.AccAddressFromBech32(msg.FromAddress)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nto, err := sdk.AccAddressFromBech32(msg.ToAddress)\\n    if err != nil {\\n    return nil, err\\n}\\n    if k.BlockedAddr(to) {\\n    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", msg.ToAddress)\\n}\\n\\nerr = k.SendCoins(ctx, from, to, msg.Amount)\\n    if err != nil {\\n    return nil, err\\n}\\n\\ndefer func() {\\n    for _, a := range msg.Amount {\\n    if a.Amount.IsInt64() {\\n    telemetry.SetGaugeWithLabels(\\n\\t\\t\\t\\t\\t[]string{\\\"tx\\\", \\\"msg\\\", \\\"send\\\"\\n},\\n\\t\\t\\t\\t\\tfloat32(a.Amount.Int64()),\\n\\t\\t\\t\\t\\t[]metrics.Label{\\n    telemetry.NewLabel(\\\"denom\\\", a.Denom)\\n},\\n\\t\\t\\t\\t)\\n}\\n\\t\\n}\\n\\t\\n}()\\n\\nreturn &types.MsgSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nMultiSend(goCtx context.Context, msg *types.MsgMultiSend) (*types.MsgMultiSendResponse, error) {\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n\\n\\t// NOTE: totalIn == totalOut should already have been checked\\n    for _, in := range msg.Inputs {\\n    if err := k.IsSendEnabledCoins(ctx, in.Coins...); err != nil {\\n    return nil, err\\n}\\n\\t\\n}\\n    for _, out := range msg.Outputs {\\n    accAddr := sdk.MustAccAddressFromBech32(out.Address)\\n    if k.BlockedAddr(accAddr) {\\n    return nil, sdkerrors.Wrapf(sdkerrors.ErrUnauthorized, \\\"%s is not allowed to receive funds\\\", out.Address)\\n}\\n\\t\\n}\\n    err := k.InputOutputCoins(ctx, msg.Inputs, msg.Outputs)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgMultiSendResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nUpdateParams(goCtx context.Context, req *types.MsgUpdateParams) (*types.MsgUpdateParamsResponse, error) {\\n    if k.GetAuthority() != req.Authority {\\n    return nil, sdkerrors.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), req.Authority)\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if err := k.SetParams(ctx, req.Params); err != nil {\\n    return nil, err\\n}\\n\\nreturn &types.MsgUpdateParamsResponse{\\n}, nil\\n}\\n\\nfunc (k msgServer)\\n\\nSetSendEnabled(goCtx context.Context, msg *types.MsgSetSendEnabled) (*types.MsgSetSendEnabledResponse, error) {\\n    if k.GetAuthority() != msg.Authority {\\n    return nil, sdkerrors.Wrapf(govtypes.ErrInvalidSigner, \\\"invalid authority; expected %s, got %s\\\", k.GetAuthority(), msg.Authority)\\n}\\n    ctx := sdk.UnwrapSDKContext(goCtx)\\n    if len(msg.SendEnabled) > 0 {\\n    k.SetAllSendEnabled(ctx, msg.SendEnabled)\\n}\\n    if len(msg.UseDefaultFor) > 0 {\\n    k.DeleteSendEnabled(ctx, msg.UseDefaultFor...)\\n}\\n\\nreturn &types.MsgSetSendEnabledResponse{\\n}, nil\\n}\\n\\nEach module should define a Protobuf Msg service, which will be responsible for processing requests (implementing sdk.Msg ) and returning responses. As further described in ADR 031 , this approach has the advantage of clearly specifying return types and generating server and client code. Protobuf generates a MsgServer interface based on a definition of Msg service. It is the role of the module developer to implement this interface, by implementing the state transition logic that should happen upon receival of each sdk.Msg . As an example, here is the generated MsgServer interface for x/bank , which exposes two sdk.Msg s: // Code generated by protoc-gen-gogo. DO NOT EDIT.\\n// source: cosmos/bank/v1beta1/tx.proto\\n\\npackage types\\n\\nimport (\\n    \\n\\tcontext \\\"context\\\"\\n\\tfmt \\\"fmt\\\"\\n\\t_ \\\"github.com/cosmos/cosmos-proto\\\"\\n\\tgithub_com_cosmos_cosmos_sdk_types \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\ttypes \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\t_ \\\"github.com/cosmos/cosmos-sdk/types/msgservice\\\"\\n\\t_ \\\"github.com/cosmos/cosmos-sdk/types/tx/amino\\\"\\n\\t_ \\\"github.com/cosmos/gogoproto/gogoproto\\\"\\n\\tgrpc1 \\\"github.com/cosmos/gogoproto/grpc\\\"\\n\\tproto \\\"github.com/cosmos/gogoproto/proto\\\"\\n\\tgrpc \\\"google.golang.org/grpc\\\"\\n\\tcodes \\\"google.golang.org/grpc/codes\\\"\\n\\tstatus \\\"google.golang.org/grpc/status\\\"\\n\\tio \\\"io\\\"\\n\\tmath \\\"math\\\"\\n\\tmath_bits \\\"math/bits\\\"\\n)\\n\\n// Reference imports to suppress errors if they are not otherwise used.\\nvar _ = proto.Marshal\\nvar _ = fmt.Errorf\\nvar _ = math.Inf\\n\\n// This is a compile-time assertion to ensure that this generated file\\n// is compatible with the proto package it is being compiled against.\\n// A compilation error at this line likely means your copy of the\\n// proto package needs to be updated.\\nconst _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package\\n\\n// MsgSend represents a message to send coins from one account to another.\\ntype MsgSend struct {\\n    FromAddress string                                   `protobuf:\\\"bytes,1,opt,name=from_address,json=fromAddress,proto3\\\" json:\\\"from_address,omitempty\\\"`\\n\\tToAddress   string                                   `protobuf:\\\"bytes,2,opt,name=to_address,json=toAddress,proto3\\\" json:\\\"to_address,omitempty\\\"`\\n\\tAmount      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:\\\"bytes,3,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins\\\" json:\\\"amount\\\"`\\n}\\n\\nfunc (m *MsgSend)\\n\\nReset() { *m = MsgSend{\\n} \\n}\\n\\nfunc (m *MsgSend)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSend)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSend)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{0\\n}\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSend.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSend.Merge(m, src)\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSend)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSend.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSend proto.InternalMessageInfo\\n\\n// MsgSendResponse defines the Msg/Send response type.\\ntype MsgSendResponse struct {\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nReset() { *m = MsgSendResponse{\\n} \\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSendResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSendResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{1\\n}\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSendResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSendResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSendResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSendResponse proto.InternalMessageInfo\\n\\n// MsgMultiSend represents an arbitrary multi-in, multi-out send message.\\ntype MsgMultiSend struct {\\n\\t// Inputs, despite being `repeated`, only allows one sender input. This is\\n\\t// checked in MsgMultiSend's ValidateBasic.\\n\\tInputs  []Input  `protobuf:\\\"bytes,1,rep,name=inputs,proto3\\\" json:\\\"inputs\\\"`\\n\\tOutputs []Output `protobuf:\\\"bytes,2,rep,name=outputs,proto3\\\" json:\\\"outputs\\\"`\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nReset() { *m = MsgMultiSend{\\n} \\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgMultiSend)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgMultiSend)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{2\\n}\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgMultiSend.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgMultiSend.Merge(m, src)\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgMultiSend.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgMultiSend proto.InternalMessageInfo\\n\\nfunc (m *MsgMultiSend)\\n\\nGetInputs() []Input {\\n    if m != nil {\\n    return m.Inputs\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nGetOutputs() []Output {\\n    if m != nil {\\n    return m.Outputs\\n}\\n\\nreturn nil\\n}\\n\\n// MsgMultiSendResponse defines the Msg/MultiSend response type.\\ntype MsgMultiSendResponse struct {\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nReset() { *m = MsgMultiSendResponse{\\n} \\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgMultiSendResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgMultiSendResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{3\\n}\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgMultiSendResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgMultiSendResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgMultiSendResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgMultiSendResponse proto.InternalMessageInfo\\n\\n// MsgUpdateParams is the Msg/UpdateParams request type.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgUpdateParams struct {\\n\\t// authority is the address that controls the module (defaults to x/gov unless overwritten).\\n\\tAuthority string `protobuf:\\\"bytes,1,opt,name=authority,proto3\\\" json:\\\"authority,omitempty\\\"`\\n\\t// params defines the x/bank parameters to update.\\n\\t//\\n\\t// NOTE: All parameters must be supplied.\\n\\tParams Params `protobuf:\\\"bytes,2,opt,name=params,proto3\\\" json:\\\"params\\\"`\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nReset() { *m = MsgUpdateParams{\\n} \\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgUpdateParams)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgUpdateParams)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{4\\n}\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgUpdateParams.Merge(m, src)\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo\\n\\nfunc (m *MsgUpdateParams)\\n\\nGetAuthority()\\n\\nstring {\\n    if m != nil {\\n    return m.Authority\\n}\\n\\nreturn \\\"\\\"\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nGetParams()\\n\\nParams {\\n    if m != nil {\\n    return m.Params\\n}\\n\\nreturn Params{\\n}\\n}\\n\\n// MsgUpdateParamsResponse defines the response structure for executing a\\n// MsgUpdateParams message.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgUpdateParamsResponse struct {\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nReset() { *m = MsgUpdateParamsResponse{\\n} \\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgUpdateParamsResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgUpdateParamsResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{5\\n}\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo\\n\\n// MsgSetSendEnabled is the Msg/SetSendEnabled request type.\\n//\\n// Only entries to add/update/delete need to be included.\\n// Existing SendEnabled entries that are not included in this\\n// message are left unchanged.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgSetSendEnabled struct {\\n    Authority string `protobuf:\\\"bytes,1,opt,name=authority,proto3\\\" json:\\\"authority,omitempty\\\"`\\n\\t// send_enabled is the list of entries to add or update.\\n\\tSendEnabled []*SendEnabled `protobuf:\\\"bytes,2,rep,name=send_enabled,json=sendEnabled,proto3\\\" json:\\\"send_enabled,omitempty\\\"`\\n\\t// use_default_for is a list of denoms that should use the params.default_send_enabled value.\\n\\t// Denoms listed here will have their SendEnabled entries deleted.\\n\\t// If a denom is included that doesn't have a SendEnabled entry,\\n\\t// it will be ignored.\\n\\tUseDefaultFor []string `protobuf:\\\"bytes,3,rep,name=use_default_for,json=useDefaultFor,proto3\\\" json:\\\"use_default_for,omitempty\\\"`\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nReset() { *m = MsgSetSendEnabled{\\n} \\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSetSendEnabled)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSetSendEnabled)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{6\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSetSendEnabled.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSetSendEnabled.Merge(m, src)\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSetSendEnabled.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSetSendEnabled proto.InternalMessageInfo\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nGetAuthority()\\n\\nstring {\\n    if m != nil {\\n    return m.Authority\\n}\\n\\nreturn \\\"\\\"\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nGetSendEnabled() []*SendEnabled {\\n    if m != nil {\\n    return m.SendEnabled\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nGetUseDefaultFor() []string {\\n    if m != nil {\\n    return m.UseDefaultFor\\n}\\n\\nreturn nil\\n}\\n\\n// MsgSetSendEnabledResponse defines the Msg/SetSendEnabled response type.\\n//\\n// Since: cosmos-sdk 0.47\\ntype MsgSetSendEnabledResponse struct {\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nReset() { *m = MsgSetSendEnabledResponse{\\n} \\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nString()\\n\\nstring {\\n    return proto.CompactTextString(m)\\n}\\n\\nfunc (*MsgSetSendEnabledResponse)\\n\\nProtoMessage() {\\n}\\n\\nfunc (*MsgSetSendEnabledResponse)\\n\\nDescriptor() ([]byte, []int) {\\n    return fileDescriptor_1d8cb1613481f5b7, []int{7\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Unmarshal(b []byte)\\n\\nerror {\\n    return m.Unmarshal(b)\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Marshal(b []byte, deterministic bool) ([]byte, error) {\\n    if deterministic {\\n    return xxx_messageInfo_MsgSetSendEnabledResponse.Marshal(b, m, deterministic)\\n}\\n\\nelse {\\n    b = b[:cap(b)]\\n\\t\\tn, err := m.MarshalToSizedBuffer(b)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn b[:n], nil\\n}\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Merge(src proto.Message) {\\n    xxx_messageInfo_MsgSetSendEnabledResponse.Merge(m, src)\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_Size()\\n\\nint {\\n    return m.Size()\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nXXX_DiscardUnknown() {\\n    xxx_messageInfo_MsgSetSendEnabledResponse.DiscardUnknown(m)\\n}\\n\\nvar xxx_messageInfo_MsgSetSendEnabledResponse proto.InternalMessageInfo\\n\\nfunc init() {\\n    proto.RegisterType((*MsgSend)(nil), \\\"cosmos.bank.v1beta1.MsgSend\\\")\\n\\nproto.RegisterType((*MsgSendResponse)(nil), \\\"cosmos.bank.v1beta1.MsgSendResponse\\\")\\n\\nproto.RegisterType((*MsgMultiSend)(nil), \\\"cosmos.bank.v1beta1.MsgMultiSend\\\")\\n\\nproto.RegisterType((*MsgMultiSendResponse)(nil), \\\"cosmos.bank.v1beta1.MsgMultiSendResponse\\\")\\n\\nproto.RegisterType((*MsgUpdateParams)(nil), \\\"cosmos.bank.v1beta1.MsgUpdateParams\\\")\\n\\nproto.RegisterType((*MsgUpdateParamsResponse)(nil), \\\"cosmos.bank.v1beta1.MsgUpdateParamsResponse\\\")\\n\\nproto.RegisterType((*MsgSetSendEnabled)(nil), \\\"cosmos.bank.v1beta1.MsgSetSendEnabled\\\")\\n\\nproto.RegisterType((*MsgSetSendEnabledResponse)(nil), \\\"cosmos.bank.v1beta1.MsgSetSendEnabledResponse\\\")\\n}\\n\\nfunc init() {\\n    proto.RegisterFile(\\\"cosmos/bank/v1beta1/tx.proto\\\", fileDescriptor_1d8cb1613481f5b7)\\n}\\n\\nvar fileDescriptor_1d8cb1613481f5b7 = []byte{\\n\\t// 690 bytes of a gzipped FileDescriptorProto\\n\\t0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcd, 0x4f, 0xd4, 0x5e,\\n\\t0x14, 0x6d, 0x99, 0xdf, 0x6f, 0x48, 0x1f, 0xa3, 0x84, 0x4a, 0x84, 0x29, 0xa4, 0x03, 0x8d, 0x21,\\n\\t0x80, 0xd2, 0x0a, 0x7e, 0x25, 0x63, 0x34, 0x3a, 0xa8, 0x89, 0x26, 0x13, 0xcd, 0x10, 0x17, 0xba,\\n\\t0x99, 0xb4, 0xf4, 0xd1, 0x69, 0xa0, 0x7d, 0x4d, 0xdf, 0x2b, 0x81, 0x9d, 0xba, 0x32, 0xae, 0xdc,\\n\\t0xbb, 0x61, 0x69, 0x5c, 0xb1, 0x70, 0x69, 0xe2, 0x96, 0x25, 0x71, 0xe5, 0x4a, 0x0d, 0x2c, 0xd0,\\n\\t0xff, 0xc2, 0xbc, 0x8f, 0x96, 0xce, 0x30, 0xc3, 0x10, 0x37, 0xd3, 0xce, 0xbb, 0xe7, 0x9c, 0x7b,\\n\\t0xcf, 0xed, 0x69, 0xc1, 0xe4, 0x2a, 0xc2, 0x01, 0xc2, 0x96, 0x63, 0x87, 0xeb, 0xd6, 0xe6, 0xa2,\\n\\t0x03, 0x89, 0xbd, 0x68, 0x91, 0x2d, 0x33, 0x8a, 0x11, 0x41, 0xea, 0x05, 0x5e, 0x35, 0x69, 0xd5,\\n\\t0x14, 0x55, 0x6d, 0xd4, 0x43, 0x1e, 0x62, 0x75, 0x8b, 0xde, 0x71, 0xa8, 0xa6, 0x67, 0x42, 0x18,\\n\\t0x66, 0x42, 0xab, 0xc8, 0x0f, 0x4f, 0xd4, 0x73, 0x8d, 0x98, 0x2e, 0xaf, 0x97, 0x79, 0xbd, 0xc9,\\n\\t0x85, 0x45, 0x5f, 0x5e, 0x1a, 0x13, 0xd4, 0x00, 0x7b, 0xd6, 0xe6, 0x22, 0xbd, 0x88, 0xc2, 0x88,\\n\\t0x1d, 0xf8, 0x21, 0xb2, 0xd8, 0x2f, 0x3f, 0x32, 0x3e, 0x0c, 0x80, 0xc1, 0x3a, 0xf6, 0x56, 0x60,\\n\\t0xe8, 0xaa, 0xb7, 0x41, 0x69, 0x2d, 0x46, 0x41, 0xd3, 0x76, 0xdd, 0x18, 0x62, 0x3c, 0x2e, 0x4f,\\n\\t0xc9, 0xb3, 0x4a, 0x6d, 0xfc, 0xdb, 0xe7, 0x85, 0x51, 0xa1, 0x7f, 0x9f, 0x57, 0x56, 0x48, 0xec,\\n\\t0x87, 0x5e, 0x63, 0x88, 0xa2, 0xc5, 0x91, 0x7a, 0x0b, 0x00, 0x82, 0x32, 0xea, 0x40, 0x1f, 0xaa,\\n\\t0x42, 0x50, 0x4a, 0x6c, 0x81, 0xa2, 0x1d, 0xa0, 0x24, 0x24, 0xe3, 0x85, 0xa9, 0xc2, 0xec, 0xd0,\\n\\t0x52, 0xd9, 0xcc, 0x96, 0x88, 0x61, 0xba, 0x44, 0x73, 0x19, 0xf9, 0x61, 0xed, 0xc6, 0xde, 0x8f,\\n\\t0x8a, 0xf4, 0xe9, 0x67, 0x65, 0xd6, 0xf3, 0x49, 0x2b, 0x71, 0xcc, 0x55, 0x14, 0x08, 0xe7, 0xe2,\\n\\t0xb2, 0x80, 0xdd, 0x75, 0x8b, 0x6c, 0x47, 0x10, 0x33, 0x02, 0xfe, 0x78, 0xb4, 0x3b, 0x2f, 0x37,\\n\\t0x84, 0x7e, 0xf5, 0xea, 0xdb, 0x9d, 0x8a, 0xf4, 0x7b, 0xa7, 0x22, 0xbd, 0x39, 0xda, 0x9d, 0x6f,\\n\\t0xb3, 0xfa, 0xee, 0x68, 0x77, 0x5e, 0xcd, 0x49, 0x88, 0x8d, 0x18, 0x23, 0x60, 0x58, 0xdc, 0x36,\\n\\t0x20, 0x8e, 0x50, 0x88, 0xa1, 0xf1, 0x45, 0x06, 0xa5, 0x3a, 0xf6, 0xea, 0xc9, 0x06, 0xf1, 0xd9,\\n\\t0xd6, 0xee, 0x80, 0xa2, 0x1f, 0x46, 0x09, 0xa1, 0xfb, 0xa2, 0xf3, 0x6b, 0x66, 0x97, 0x10, 0x98,\\n\\t0x8f, 0x29, 0xa4, 0xa6, 0x50, 0x03, 0x62, 0x28, 0x4e, 0x52, 0xef, 0x81, 0x41, 0x94, 0x10, 0xc6,\\n\\t0x1f, 0x60, 0xfc, 0x89, 0xae, 0xfc, 0xa7, 0x0c, 0x93, 0x17, 0x48, 0x69, 0xd5, 0xcb, 0xa9, 0x25,\\n\\t0x21, 0x49, 0xcd, 0x8c, 0xb5, 0x9b, 0xc9, 0xa6, 0x35, 0x2e, 0x82, 0xd1, 0xfc, 0xff, 0xcc, 0xd6,\\n\\t0x57, 0x99, 0x59, 0x7d, 0x1e, 0xb9, 0x36, 0x81, 0xcf, 0xec, 0xd8, 0x0e, 0xb0, 0x7a, 0x13, 0x28,\\n\\t0x76, 0x42, 0x5a, 0x28, 0xf6, 0xc9, 0x76, 0xdf, 0x30, 0x1c, 0x43, 0xd5, 0xbb, 0xa0, 0x18, 0x31,\\n\\t0x05, 0x16, 0x83, 0x5e, 0x8e, 0x78, 0x93, 0xb6, 0x95, 0x70, 0x56, 0xf5, 0x3a, 0x35, 0x73, 0xac,\\n\\t0x47, 0xfd, 0x4c, 0xe7, 0xfc, 0x6c, 0xf1, 0x77, 0xa2, 0x63, 0x5a, 0xa3, 0x0c, 0xc6, 0x3a, 0x8e,\\n\\t0x32, 0x73, 0x7f, 0x64, 0x30, 0xc2, 0x9e, 0x23, 0xa1, 0x9e, 0x1f, 0x86, 0xb6, 0xb3, 0x01, 0xdd,\\n\\t0x7f, 0xb6, 0xb7, 0x0c, 0x4a, 0x18, 0x86, 0x6e, 0x13, 0x72, 0x1d, 0xf1, 0xd8, 0xa6, 0xba, 0x9a,\\n\\t0xcc, 0xf5, 0x6b, 0x0c, 0xe1, 0x5c, 0xf3, 0x19, 0x30, 0x9c, 0x60, 0xd8, 0x74, 0xe1, 0x9a, 0x9d,\\n\\t0x6c, 0x90, 0xe6, 0x1a, 0x8a, 0x59, 0xfc, 0x95, 0xc6, 0xb9, 0x04, 0xc3, 0x07, 0xfc, 0xf4, 0x11,\\n\\t0x8a, 0xab, 0xd6, 0xc9, 0x5d, 0x4c, 0x76, 0x06, 0x35, 0xef, 0xca, 0x98, 0x00, 0xe5, 0x13, 0x87,\\n\\t0xe9, 0x22, 0x96, 0x5e, 0x17, 0x40, 0xa1, 0x8e, 0x3d, 0xf5, 0x09, 0xf8, 0x8f, 0x65, 0x77, 0xb2,\\n\\t0xeb, 0xd0, 0x22, 0xf2, 0xda, 0xa5, 0xd3, 0xaa, 0xa9, 0xa6, 0xfa, 0x02, 0x28, 0xc7, 0x2f, 0xc3,\\n\\t0x74, 0x2f, 0x4a, 0x06, 0xd1, 0xe6, 0xfa, 0x42, 0x32, 0x69, 0x07, 0x94, 0xda, 0x02, 0xd9, 0x73,\\n\\t0xa0, 0x3c, 0x4a, 0xbb, 0x72, 0x16, 0x54, 0xd6, 0xa3, 0x05, 0xce, 0x77, 0xe4, 0x62, 0xa6, 0xb7,\\n\\t0xed, 0x3c, 0x4e, 0x33, 0xcf, 0x86, 0x4b, 0x3b, 0x69, 0xff, 0xbf, 0xa2, 0x29, 0xaf, 0x2d, 0xef,\\n\\t0x1d, 0xe8, 0xf2, 0xfe, 0x81, 0x2e, 0xff, 0x3a, 0xd0, 0xe5, 0xf7, 0x87, 0xba, 0xb4, 0x7f, 0xa8,\\n\\t0x4b, 0xdf, 0x0f, 0x75, 0xe9, 0xe5, 0xdc, 0xa9, 0x9f, 0x35, 0x11, 0x7b, 0xf6, 0x75, 0x73, 0x8a,\\n\\t0xec, 0xeb, 0x7d, 0xed, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x2f, 0xe8, 0x90, 0x24, 0x8f, 0x06,\\n\\t0x00, 0x00,\\n}\\n\\n// Reference imports to suppress errors if they are not otherwise used.\\nvar _ context.Context\\nvar _ grpc.ClientConn\\n\\n// This is a compile-time assertion to ensure that this generated file\\n// is compatible with the grpc package it is being compiled against.\\nconst _ = grpc.SupportPackageIsVersion4\\n\\n// MsgClient is the client API for Msg service.\\n//\\n// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.\\ntype MsgClient interface {\\n\\t// Send defines a method for sending coins from one account to another account.\\n\\tSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error)\\n\\t// MultiSend defines a method for sending coins from some accounts to other accounts.\\n\\tMultiSend(ctx context.Context, in *MsgMultiSend, opts ...grpc.CallOption) (*MsgMultiSendResponse, error)\\n\\t// UpdateParams defines a governance operation for updating the x/bank module parameters.\\n\\t// The authority is defined in the keeper.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tUpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)\\n\\t// SetSendEnabled is a governance operation for setting the SendEnabled flag\\n\\t// on any number of Denoms. Only the entries to add or update should be\\n\\t// included. Entries that already exist in the store, but that aren't\\n\\t// included in this message, will be left unchanged.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tSetSendEnabled(ctx context.Context, in *MsgSetSendEnabled, opts ...grpc.CallOption) (*MsgSetSendEnabledResponse, error)\\n}\\n\\ntype msgClient struct {\\n    cc grpc1.ClientConn\\n}\\n\\nfunc NewMsgClient(cc grpc1.ClientConn)\\n\\nMsgClient {\\n    return &msgClient{\\n    cc\\n}\\n}\\n\\nfunc (c *msgClient)\\n\\nSend(ctx context.Context, in *MsgSend, opts ...grpc.CallOption) (*MsgSendResponse, error) {\\n    out := new(MsgSendResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/Send\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\nfunc (c *msgClient)\\n\\nMultiSend(ctx context.Context, in *MsgMultiSend, opts ...grpc.CallOption) (*MsgMultiSendResponse, error) {\\n    out := new(MsgMultiSendResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/MultiSend\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\nfunc (c *msgClient)\\n\\nUpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {\\n    out := new(MsgUpdateParamsResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/UpdateParams\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\nfunc (c *msgClient)\\n\\nSetSendEnabled(ctx context.Context, in *MsgSetSendEnabled, opts ...grpc.CallOption) (*MsgSetSendEnabledResponse, error) {\\n    out := new(MsgSetSendEnabledResponse)\\n    err := c.cc.Invoke(ctx, \\\"/cosmos.bank.v1beta1.Msg/SetSendEnabled\\\", in, out, opts...)\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn out, nil\\n}\\n\\n// MsgServer is the server API for Msg service.\\ntype MsgServer interface {\\n\\t// Send defines a method for sending coins from one account to another account.\\n\\tSend(context.Context, *MsgSend) (*MsgSendResponse, error)\\n\\t// MultiSend defines a method for sending coins from some accounts to other accounts.\\n\\tMultiSend(context.Context, *MsgMultiSend) (*MsgMultiSendResponse, error)\\n\\t// UpdateParams defines a governance operation for updating the x/bank module parameters.\\n\\t// The authority is defined in the keeper.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tUpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)\\n\\t// SetSendEnabled is a governance operation for setting the SendEnabled flag\\n\\t// on any number of Denoms. Only the entries to add or update should be\\n\\t// included. Entries that already exist in the store, but that aren't\\n\\t// included in this message, will be left unchanged.\\n\\t//\\n\\t// Since: cosmos-sdk 0.47\\n\\tSetSendEnabled(context.Context, *MsgSetSendEnabled) (*MsgSetSendEnabledResponse, error)\\n}\\n\\n// UnimplementedMsgServer can be embedded to have forward compatible implementations.\\ntype UnimplementedMsgServer struct {\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nSend(ctx context.Context, req *MsgSend) (*MsgSendResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method Send not implemented\\\")\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nMultiSend(ctx context.Context, req *MsgMultiSend) (*MsgMultiSendResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method MultiSend not implemented\\\")\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nUpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method UpdateParams not implemented\\\")\\n}\\n\\nfunc (*UnimplementedMsgServer)\\n\\nSetSendEnabled(ctx context.Context, req *MsgSetSendEnabled) (*MsgSetSendEnabledResponse, error) {\\n    return nil, status.Errorf(codes.Unimplemented, \\\"method SetSendEnabled not implemented\\\")\\n}\\n\\nfunc RegisterMsgServer(s grpc1.Server, srv MsgServer) {\\n    s.RegisterService(&_Msg_serviceDesc, srv)\\n}\\n\\nfunc _Msg_Send_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgSend)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).Send(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/Send\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).Send(ctx, req.(*MsgSend))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nfunc _Msg_MultiSend_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgMultiSend)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).MultiSend(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/MultiSend\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).MultiSend(ctx, req.(*MsgMultiSend))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nfunc _Msg_UpdateParams_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgUpdateParams)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).UpdateParams(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/UpdateParams\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nfunc _Msg_SetSendEnabled_Handler(srv interface{\\n}, ctx context.Context, dec func(interface{\\n})\\n\\nerror, interceptor grpc.UnaryServerInterceptor) (interface{\\n}, error) {\\n    in := new(MsgSetSendEnabled)\\n    if err := dec(in); err != nil {\\n    return nil, err\\n}\\n    if interceptor == nil {\\n    return srv.(MsgServer).SetSendEnabled(ctx, in)\\n}\\n    info := &grpc.UnaryServerInfo{\\n    Server:     srv,\\n    FullMethod: \\\"/cosmos.bank.v1beta1.Msg/SetSendEnabled\\\",\\n}\\n    handler := func(ctx context.Context, req interface{\\n}) (interface{\\n}, error) {\\n    return srv.(MsgServer).SetSendEnabled(ctx, req.(*MsgSetSendEnabled))\\n}\\n\\nreturn interceptor(ctx, in, info, handler)\\n}\\n\\nvar _Msg_serviceDesc = grpc.ServiceDesc{\\n    ServiceName: \\\"cosmos.bank.v1beta1.Msg\\\",\\n    HandlerType: (*MsgServer)(nil),\\n    Methods: []grpc.MethodDesc{\\n\\t\\t{\\n    MethodName: \\\"Send\\\",\\n    Handler:    _Msg_Send_Handler,\\n},\\n\\t\\t{\\n    MethodName: \\\"MultiSend\\\",\\n    Handler:    _Msg_MultiSend_Handler,\\n},\\n\\t\\t{\\n    MethodName: \\\"UpdateParams\\\",\\n    Handler:    _Msg_UpdateParams_Handler,\\n},\\n\\t\\t{\\n    MethodName: \\\"SetSendEnabled\\\",\\n    Handler:    _Msg_SetSendEnabled_Handler,\\n},\\n},\\n    Streams:  []grpc.StreamDesc{\\n},\\n    Metadata: \\\"cosmos/bank/v1beta1/tx.proto\\\",\\n}\\n\\nfunc (m *MsgSend)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSend)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSend)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n    if len(m.Amount) > 0 {\\n    for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x1a\\n}\\n\\t\\n}\\n    if len(m.ToAddress) > 0 {\\n    i -= len(m.ToAddress)\\n\\ncopy(dAtA[i:], m.ToAddress)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.ToAddress)))\\n\\ni--\\n\\t\\tdAtA[i] = 0x12\\n}\\n    if len(m.FromAddress) > 0 {\\n    i -= len(m.FromAddress)\\n\\ncopy(dAtA[i:], m.FromAddress)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.FromAddress)))\\n\\ni--\\n\\t\\tdAtA[i] = 0xa\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n    if len(m.Outputs) > 0 {\\n    for iNdEx := len(m.Outputs) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.Outputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x12\\n}\\n\\t\\n}\\n    if len(m.Inputs) > 0 {\\n    for iNdEx := len(m.Inputs) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.Inputs[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0xa\\n}\\n\\t\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\t{\\n    size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\tdAtA[i] = 0x12\\n    if len(m.Authority) > 0 {\\n    i -= len(m.Authority)\\n\\ncopy(dAtA[i:], m.Authority)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))\\n\\ni--\\n\\t\\tdAtA[i] = 0xa\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n    if len(m.UseDefaultFor) > 0 {\\n    for iNdEx := len(m.UseDefaultFor) - 1; iNdEx >= 0; iNdEx-- {\\n    i -= len(m.UseDefaultFor[iNdEx])\\n\\ncopy(dAtA[i:], m.UseDefaultFor[iNdEx])\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.UseDefaultFor[iNdEx])))\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x1a\\n}\\n\\t\\n}\\n    if len(m.SendEnabled) > 0 {\\n    for iNdEx := len(m.SendEnabled) - 1; iNdEx >= 0; iNdEx-- {\\n\\t\\t\\t{\\n    size, err := m.SendEnabled[iNdEx].MarshalToSizedBuffer(dAtA[:i])\\n    if err != nil {\\n    return 0, err\\n}\\n\\ni -= size\\n\\t\\t\\t\\ti = encodeVarintTx(dAtA, i, uint64(size))\\n}\\n\\ni--\\n\\t\\t\\tdAtA[i] = 0x12\\n}\\n\\t\\n}\\n    if len(m.Authority) > 0 {\\n    i -= len(m.Authority)\\n\\ncopy(dAtA[i:], m.Authority)\\n\\ni = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))\\n\\ni--\\n\\t\\tdAtA[i] = 0xa\\n}\\n\\nreturn len(dAtA) - i, nil\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nMarshal() (dAtA []byte, err error) {\\n    size := m.Size()\\n\\ndAtA = make([]byte, size)\\n\\nn, err := m.MarshalToSizedBuffer(dAtA[:size])\\n    if err != nil {\\n    return nil, err\\n}\\n\\nreturn dAtA[:n], nil\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nMarshalTo(dAtA []byte) (int, error) {\\n    size := m.Size()\\n\\nreturn m.MarshalToSizedBuffer(dAtA[:size])\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nMarshalToSizedBuffer(dAtA []byte) (int, error) {\\n    i := len(dAtA)\\n\\t_ = i\\n\\tvar l int\\n\\t_ = l\\n\\treturn len(dAtA) - i, nil\\n}\\n\\nfunc encodeVarintTx(dAtA []byte, offset int, v uint64)\\n\\nint {\\n    offset -= sovTx(v)\\n    base := offset\\n    for v >= 1<<7 {\\n    dAtA[offset] = uint8(v&0x7f | 0x80)\\n\\nv >>= 7\\n\\t\\toffset++\\n}\\n\\ndAtA[offset] = uint8(v)\\n\\nreturn base\\n}\\n\\nfunc (m *MsgSend)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\tl = len(m.FromAddress)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n\\nl = len(m.ToAddress)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n    if len(m.Amount) > 0 {\\n    for _, e := range m.Amount {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n\\nreturn n\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n    if len(m.Inputs) > 0 {\\n    for _, e := range m.Inputs {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n    if len(m.Outputs) > 0 {\\n    for _, e := range m.Outputs {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n\\nreturn n\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\tl = len(m.Authority)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n\\nl = m.Params.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n\\nreturn n\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\tl = len(m.Authority)\\n    if l > 0 {\\n    n += 1 + l + sovTx(uint64(l))\\n}\\n    if len(m.SendEnabled) > 0 {\\n    for _, e := range m.SendEnabled {\\n    l = e.Size()\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n    if len(m.UseDefaultFor) > 0 {\\n    for _, s := range m.UseDefaultFor {\\n    l = len(s)\\n\\nn += 1 + l + sovTx(uint64(l))\\n}\\n\\t\\n}\\n\\nreturn n\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nSize() (n int) {\\n    if m == nil {\\n    return 0\\n}\\n\\nvar l int\\n\\t_ = l\\n\\treturn n\\n}\\n\\nfunc sovTx(x uint64) (n int) {\\n    return (math_bits.Len64(x|1) + 6) / 7\\n}\\n\\nfunc sozTx(x uint64) (n int) {\\n    return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))\\n}\\n\\nfunc (m *MsgSend)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSend: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSend: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field FromAddress\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.FromAddress = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field ToAddress\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.ToAddress = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 3:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Amount\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Amount = append(m.Amount, types.Coin{\\n})\\n    if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSendResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSendResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSendResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgMultiSend)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSend: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSend: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Inputs\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Inputs = append(m.Inputs, Input{\\n})\\n    if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Outputs\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Outputs = append(m.Outputs, Output{\\n})\\n    if err := m.Outputs[len(m.Outputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgMultiSendResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSendResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgMultiSendResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgUpdateParams)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParams: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParams: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Authority\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Authority = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Params\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n    if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgUpdateParamsResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParamsResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSetSendEnabled)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabled: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabled: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    case 1:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field Authority\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.Authority = string(dAtA[iNdEx:postIndex])\\n\\niNdEx = postIndex\\n    case 2:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field SendEnabled\\\", wireType)\\n}\\n\\nvar msglen int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tmsglen |= int(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if msglen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + msglen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.SendEnabled = append(m.SendEnabled, &SendEnabled{\\n})\\n    if err := m.SendEnabled[len(m.SendEnabled)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {\\n    return err\\n}\\n\\niNdEx = postIndex\\n    case 3:\\n    if wireType != 2 {\\n    return fmt.Errorf(\\\"proto: wrong wireType = %d for field UseDefaultFor\\\", wireType)\\n}\\n\\nvar stringLen uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tstringLen |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    intStringLen := int(stringLen)\\n    if intStringLen < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    postIndex := iNdEx + intStringLen\\n    if postIndex < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if postIndex > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nm.UseDefaultFor = append(m.UseDefaultFor, string(dAtA[iNdEx:postIndex]))\\n\\niNdEx = postIndex\\n\\t\\tdefault:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc (m *MsgSetSendEnabledResponse)\\n\\nUnmarshal(dAtA []byte)\\n\\nerror {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    for iNdEx < l {\\n    preIndex := iNdEx\\n\\t\\tvar wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= uint64(b&0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    fieldNum := int32(wire >> 3)\\n    wireType := int(wire & 0x7)\\n    if wireType == 4 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabledResponse: wiretype end group for non-group\\\")\\n}\\n    if fieldNum <= 0 {\\n    return fmt.Errorf(\\\"proto: MsgSetSendEnabledResponse: illegal tag %d (wire type %d)\\\", fieldNum, wire)\\n}\\n    switch fieldNum {\\n    default:\\n\\t\\t\\tiNdEx = preIndex\\n\\t\\t\\tskippy, err := skipTx(dAtA[iNdEx:])\\n    if err != nil {\\n    return err\\n}\\n    if (skippy < 0) || (iNdEx+skippy) < 0 {\\n    return ErrInvalidLengthTx\\n}\\n    if (iNdEx + skippy) > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\niNdEx += skippy\\n}\\n\\t\\n}\\n    if iNdEx > l {\\n    return io.ErrUnexpectedEOF\\n}\\n\\nreturn nil\\n}\\n\\nfunc skipTx(dAtA []byte) (n int, err error) {\\n    l := len(dAtA)\\n    iNdEx := 0\\n    depth := 0\\n    for iNdEx < l {\\n    var wire uint64\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return 0, ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return 0, io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\tiNdEx++\\n\\t\\t\\twire |= (uint64(b) & 0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    wireType := int(wire & 0x7)\\n    switch wireType {\\n    case 0:\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return 0, ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return 0, io.ErrUnexpectedEOF\\n}\\n\\niNdEx++\\n    if dAtA[iNdEx-1] < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    case 1:\\n\\t\\t\\tiNdEx += 8\\n    case 2:\\n\\t\\t\\tvar length int\\n    for shift := uint(0); ; shift += 7 {\\n    if shift >= 64 {\\n    return 0, ErrIntOverflowTx\\n}\\n    if iNdEx >= l {\\n    return 0, io.ErrUnexpectedEOF\\n}\\n    b := dAtA[iNdEx]\\n\\t\\t\\t\\tiNdEx++\\n\\t\\t\\t\\tlength |= (int(b) & 0x7F) << shift\\n    if b < 0x80 {\\n    break\\n}\\n\\t\\n}\\n    if length < 0 {\\n    return 0, ErrInvalidLengthTx\\n}\\n\\niNdEx += length\\n    case 3:\\n\\t\\t\\tdepth++\\n    case 4:\\n    if depth == 0 {\\n    return 0, ErrUnexpectedEndOfGroupTx\\n}\\n\\ndepth--\\n    case 5:\\n\\t\\t\\tiNdEx += 4\\n\\t\\tdefault:\\n\\t\\t\\treturn 0, fmt.Errorf(\\\"proto: illegal wireType %d\\\", wireType)\\n}\\n    if iNdEx < 0 {\\n    return 0, ErrInvalidLengthTx\\n}\\n    if depth == 0 {\\n    return iNdEx, nil\\n}\\n\\t\\n}\\n\\nreturn 0, io.ErrUnexpectedEOF\\n}\\n\\nvar (\\n\\tErrInvalidLengthTx        = fmt.Errorf(\\\"proto: negative length found during unmarshaling\\\")\\n\\nErrIntOverflowTx          = fmt.Errorf(\\\"proto: integer overflow\\\")\\n\\nErrUnexpectedEndOfGroupTx = fmt.Errorf(\\\"proto: unexpected end of group\\\")\\n)\\n\\n\", \"Title: MsgServer and QueryServer registration\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/build/architecture/adr-063-core-module-api\\nContent: MsgServer and QueryServer registration is done by implementing the HasServices extension interface: Because of the cosmos.msg.v1.service protobuf option, required for Msg services, the same ServiceRegitrar can be\\nused to register both Msg and query services.\\n\\nMsgServer and QueryServer registration is done by implementing the HasServices extension interface: type HasServices interface {\\n    AppModule\\n\\n\\tRegisterServices(grpc.ServiceRegistrar)\\n}\\n\\nStore Services\\nStore services will be defined in the cosmossdk.io/core/store package. The generic store.KVStore interface is the same as current SDK KVStore interface. Store keys have been refactored\\ninto store services which, instead of expecting the context to know about stores, invert the pattern and allow\\nretrieving a store from a generic context. There are three store services for the three types of currently supported\\nstores - regular kv-store, memory, and transient: Modules can use these services like this: func (k msgServer)\\n\\nSend(ctx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {\\n    store := k.kvStoreSvc.OpenKVStore(ctx)\\n}\\n\\n\", \"Title: MsgServer and QueryServer registration\\nLink: https://evm.cosmos.network/docs/sdk/v0.50/build/architecture/adr-063-core-module-api\\nContent: MsgServer and QueryServer registration is done by implementing the HasServices extension interface: Because of the cosmos.msg.v1.service protobuf option, required for Msg services, the same ServiceRegitrar can be\\nused to register both Msg and query services.\\n\\nMsgServer and QueryServer registration is done by implementing the HasServices extension interface: type HasServices interface {\\n    AppModule\\n\\n\\tRegisterServices(grpc.ServiceRegistrar)\\n}\\n\\nStore Services\\nStore services will be defined in the cosmossdk.io/core/store package. The generic store.KVStore interface is the same as current SDK KVStore interface. Store keys have been refactored\\ninto store services which, instead of expecting the context to know about stores, invert the pattern and allow\\nretrieving a store from a generic context. There are three store services for the three types of currently supported\\nstores - regular kv-store, memory, and transient: Modules can use these services like this: func (k msgServer)\\n\\nSend(ctx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {\\n    store := k.kvStoreSvc.OpenKVStore(ctx)\\n}\\n\\n\", \"Title: MsgServer and QueryServer registration\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/build/architecture/adr-063-core-module-api\\nContent: MsgServer and QueryServer registration is done by implementing the HasServices extension interface: Because of the cosmos.msg.v1.service protobuf option, required for Msg services, the same ServiceRegitrar can be\\nused to register both Msg and query services.\\n\\nMsgServer and QueryServer registration is done by implementing the HasServices extension interface: type HasServices interface {\\n    AppModule\\n\\n\\tRegisterServices(grpc.ServiceRegistrar)\\n}\\n\\nStore Services\\nStore services will be defined in the cosmossdk.io/core/store package. The generic store.KVStore interface is the same as current SDK KVStore interface. Store keys have been refactored\\ninto store services which, instead of expecting the context to know about stores, invert the pattern and allow\\nretrieving a store from a generic context. There are three store services for the three types of currently supported\\nstores - regular kv-store, memory, and transient: Modules can use these services like this: func (k msgServer)\\n\\nSend(ctx context.Context, msg *types.MsgSend) (*types.MsgSendResponse, error) {\\n    store := k.kvStoreSvc.OpenKVStore(ctx)\\n}\\n\\n\", \"Title: sdk.Msg Interface\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/build/building-modules/messages-and-queries\\nContent: sdk.Msg is a alias of proto.Message. To attach a ValidateBasic() method to a message then you must add methods to the type adhereing to the HasValidateBasic. In 0.50+ signers from the GetSigners() call is automated via a protobuf annotation. Read more about the signer field here. If there is a need for custom signers then there is an alternative path which can be taken. A function which returns signing.CustomGetSigner for a specific message can be defined. When using dependency injection (depinject) this can be provided to the application via the provide method. The Cosmos SDK uses Protobuf definitions to generate client and server code: MsgServer interface defines the server API for the Msg service and its implementation is described as part of the Msg services documentation. Structures are generated for all RPC request and response types. A RegisterMsgServer method is also generated and should be used to register the module's MsgServer implementation in RegisterServices method from the AppModule interface. In order for clients (CLI and grpc-gateway) to have these URLs registered, the Cosmos SDK provides the function RegisterMsgServiceDesc(registry codectypes.InterfaceRegistry, sd *grpc.ServiceDesc) that should be called inside module's RegisterInterfaces method, using the proto-generated &_Msg_serviceDesc as *grpc.ServiceDesc argument.\\n\\nMsg Services\\nDefining Protobuf Msg services is the recommended way to handle messages. A Protobuf Msg service should be created for each module, typically in tx.proto (see more info about conventions and naming ). It must have an RPC service method defined for each message in the module. Each Msg service method must have exactly one argument, which must implement the sdk.Msg interface, and a Protobuf response. The naming convention is to call the RPC argument Msg<service-rpc-name> and the RPC response Msg<service-rpc-name>Response . For example: See an example of a Msg service definition from x/bank module: // Reference: https://github.com/cosmos/cosmos-sdk/blob/v0.50.0-alpha.0/proto/cosmos/bank/v1beta1/tx.proto#L13-L36\\n\\nsdk.Msg is a alias of proto.Message. To attach a ValidateBasic() method to a message then you must add methods to the type adhereing to the HasValidateBasic. In 0.50+ signers from the GetSigners() call is automated via a protobuf annotation. Read more about the signer field here. // Reference: https://github.com/cosmos/cosmos-sdk/blob/e6848d99b55a65d014375b295bdd7f9641aac95e/proto/cosmos/bank/v1beta1/tx.proto#L40\\n\\n\"]",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "tool",
            "name": "SearchCosmosDocumentation",
            "id": "a5f9b90a-72b1-4c71-bc22-6ed8cfff566f",
            "tool_call_id": "call_VjxOwixvYLpkyeToFsVC8f83",
            "artifact": null,
            "status": "success"
        },
        {
            "content": "[\n  {\n    \"intent\": \"Learn how to register the Msg service for the bank module in a Cosmos SDK chain\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"SearchCosmosDocumentation\",\n        \"description\": \"Search for \u201cMsgServer registration bank module RegisterServices HasServices interface\u201d to locate the official guide and example code (v0.50+).\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"SearchCosmosDocumentation\",\n        \"description\": \"Search for \u201cx/bank tx.proto Msg service example\u201d to obtain the service definition snippet.\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"compose_response\",\n        \"description\": \"Aggregate the two search results, extract the RegisterServices implementation pattern, and present the user with (a) the HasServices interface usage, (b) the call to RegisterMsgServer, and (c) a minimal code snippet showing how the bank keeper implements MsgServer and is wired in app.go.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Response contains a Go code block with RegisterServices that calls types.RegisterMsgServer.\",\n      \"At least one documentation link is included for further reading.\"\n    ]\n  },\n  {\n    \"intent\": \"Learn how to register the Query (gRPC) service for the staking module\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"SearchCosmosDocumentation\",\n        \"description\": \"Query \u201cRegister Query service staking module RegisterServices\u201d to fetch the staking module\u2019s RegisterServices example.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"SearchCosmosDocumentation\",\n        \"description\": \"Lookup \u201cHasServices interface staking QueryServer implementation\u201d for additional context on QueryServer wiring.\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"compose_response\",\n        \"description\": \"Merge results and show: (a) proto\u2010generated RegisterQueryServer, (b) how the staking keeper satisfies the QueryServer, and (c) the RegisterServices function snippet used inside the staking AppModule.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Explanation shows RegisterServices with types.RegisterQueryServer for x/staking.\",\n      \"Links to ADR-063 or the \u2018messages-and-queries\u2019 docs are provided.\"\n    ]\n  },\n  {\n    \"intent\": \"Configure a custom application encoding config (InterfaceRegistry + TxConfig) in app.go\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"SearchCosmosDocumentation\",\n        \"description\": \"Search for \u201cencoding config cosmos sdk app.go MakeEncodingConfig\u201d to retrieve the recommended helper.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"SearchCosmosDocumentation\",\n        \"description\": \"Search for \u201cRegisterInterfaces InterfaceRegistry example\u201d to collect the interface registration steps.\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"compose_response\",\n        \"description\": \"Explain how to build an EncodingConfig (legacyAmino, interfaceRegistry, txCfg) and return a code snippet that: (i) invokes MakeEncodingConfig, (ii) registers module interfaces, and (iii) injects the config into the app constructor.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Delivered code defines MakeEncodingConfig or its equivalent and plugs it into NewApp(...).\",\n      \"Mentions both legacy amino (if needed) and proto TxConfig.\"\n    ]\n  },\n  {\n    \"intent\": \"Build the appd binary from source\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"SearchCosmosDocumentation\",\n        \"description\": \"Search for \u201cCosmos SDK make install build binary appd\u201d to fetch the official build instructions.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"compose_response\",\n        \"description\": \"Summarise prerequisites (Go version, git, make), clone command, checkout tag, and `make install` which produces `$GOBIN/appd`.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Instructions list Go \u2265 1.21, git clone URL, git checkout <tag>, and `make install`.\",\n      \"`appd version` verification step is included.\"\n    ]\n  },\n  {\n    \"intent\": \"Create a staking delegate transaction (MsgDelegate) with CLI or programmatically\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"SearchCosmosDocumentation\",\n        \"description\": \"Query \u201cstaking delegate transaction MsgDelegate example tx staking\u201d to retrieve CLI and Go examples.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"compose_response\",\n        \"description\": \"Describe both approaches: (a) CLI (`appd tx staking delegate <val-addr> <amount> --from <delegator>`), and (b) Go code building a MsgDelegate, signing, and broadcasting via tx.Config.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Response shows full CLI command with required flags.\",\n      \"Go example includes MsgDelegate struct fill-in, txf, and BroadcastTx call.\",\n      \"Links to staking tx.proto or CLI docs provided.\"\n    ]\n  }\n]",
            "additional_kwargs": {
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 2151,
                    "prompt_tokens": 85278,
                    "total_tokens": 87429,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 1024,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CQEWcpAxSX88jdAjdgRMSyTM1LJWy",
                "service_tier": "default",
                "finish_reason": "stop",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--6e4fb238-c980-4440-a6e9-7feaa45f9a2c-0",
            "example": false,
            "tool_calls": [],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 85278,
                "output_tokens": 2151,
                "total_tokens": 87429,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 1024
                }
            }
        }
    ]
}