{
    "messages": [
        {
            "content": "[{\"label\": \"EthereumJSON_RPC\", \"query\": \"Get filter changes for a filter id\"}, {\"label\": \"EthereumJSON_RPC\", \"query\": \"Uninstall a filter by id\"}, {\"label\": \"EthereumJSON_RPC\", \"query\": \"Get logs matching a topic from the latest block\"}, {\"label\": \"EthereumJSON_RPC\", \"query\": \"Get all receipts for the latest block\"}, {\"label\": \"EthereumJSON_RPC\", \"query\": \"Get transaction logs for a specific transaction\"}]",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "human",
            "name": null,
            "id": "3d1a3109-a5b8-4e8b-a440-91dc054e165a",
            "example": false
        },
        {
            "content": "",
            "additional_kwargs": {
                "tool_calls": [
                    {
                        "id": "call_HRZbKAaUD0OuzfVd9aE3EvdU",
                        "function": {
                            "arguments": "{\"query\":\"Tendermint websocket subscribe example\"}",
                            "name": "SearchCosmosDocumentation"
                        },
                        "type": "function"
                    }
                ],
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 863,
                    "prompt_tokens": 704,
                    "total_tokens": 1567,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 832,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CPvizJkPRSEPv42DeoIrrFxpp0dDb",
                "service_tier": "default",
                "finish_reason": "tool_calls",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--a25323f3-4644-4e01-914e-3c03963fd6f4-0",
            "example": false,
            "tool_calls": [
                {
                    "name": "SearchCosmosDocumentation",
                    "args": {
                        "query": "Tendermint websocket subscribe example"
                    },
                    "id": "call_HRZbKAaUD0OuzfVd9aE3EvdU",
                    "type": "tool_call"
                }
            ],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 704,
                "output_tokens": 863,
                "total_tokens": 1567,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 832
                }
            }
        },
        {
            "content": "[\"Title: Subscribing to Events via WebSocket\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/api-reference/ethereum-json-rpc/index\\nContent: The WebSocket endpoint allows your application to subscribe to real-time events, such as new blocks or logs, without needing to poll the node constantly. Example: Subscribe to New Block Headers Connect to the WebSocket : Use a tool like wscat or ws to connect to the WebSocket endpoint. Send Subscription Request : Send an eth_subscribe request. The parameter newHeads tells the server you want to listen for new blocks. > {\\\"id\\\": 1, \\\"method\\\": \\\"eth_subscribe\\\", \\\"params\\\": [\\\"newHeads\\\"]}\\n\\nThe WebSocket endpoint allows your application to subscribe to real-time events, such as new blocks or logs, without needing to poll the node constantly. Example: Subscribe to New Block Headers Connect to the WebSocket : Use a tool like wscat or ws to connect to the WebSocket endpoint. Send Subscription Request : Send an eth_subscribe request. The parameter newHeads tells the server you want to listen for new blocks. Receive Subscription ID : The server responds with a unique subscription ID. {\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"id\\\": 1,\\n  \\\"result\\\": \\\"0x9cef36b2817151b1686a73bcec17eff0\\\"\\n}\\n\\nThe WebSocket endpoint allows your application to subscribe to real-time events, such as new blocks or logs, without needing to poll the node constantly. Example: Subscribe to New Block Headers Connect to the WebSocket : Use a tool like wscat or ws to connect to the WebSocket endpoint. Send Subscription Request : Send an eth_subscribe request. The parameter newHeads tells the server you want to listen for new blocks. Receive Subscription ID : The server responds with a unique subscription ID. Receive Notifications : As new blocks are created, the server will push notifications to your client with the block header details.\\n\\n\", \"Title: Subscribing to Events via WebSocket\\nLink: https://evm.cosmos.network/docs/evm/next/api-reference/ethereum-json-rpc/index\\nContent: The WebSocket endpoint allows your application to subscribe to real-time events, such as new blocks or logs, without needing to poll the node constantly. Example: Subscribe to New Block Headers Connect to the WebSocket : Use a tool like wscat or ws to connect to the WebSocket endpoint. Send Subscription Request : Send an eth_subscribe request. The parameter newHeads tells the server you want to listen for new blocks. > {\\\"id\\\": 1, \\\"method\\\": \\\"eth_subscribe\\\", \\\"params\\\": [\\\"newHeads\\\"]}\\n\\nThe WebSocket endpoint allows your application to subscribe to real-time events, such as new blocks or logs, without needing to poll the node constantly. Example: Subscribe to New Block Headers Connect to the WebSocket : Use a tool like wscat or ws to connect to the WebSocket endpoint. Send Subscription Request : Send an eth_subscribe request. The parameter newHeads tells the server you want to listen for new blocks. Receive Subscription ID : The server responds with a unique subscription ID. {\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"id\\\": 1,\\n  \\\"result\\\": \\\"0x9cef36b2817151b1686a73bcec17eff0\\\"\\n}\\n\\nThe WebSocket endpoint allows your application to subscribe to real-time events, such as new blocks or logs, without needing to poll the node constantly. Example: Subscribe to New Block Headers Connect to the WebSocket : Use a tool like wscat or ws to connect to the WebSocket endpoint. Send Subscription Request : Send an eth_subscribe request. The parameter newHeads tells the server you want to listen for new blocks. Receive Subscription ID : The server responds with a unique subscription ID. Receive Notifications : As new blocks are created, the server will push notifications to your client with the block header details.\\n\\n\", \"Title: Subscribing to Events\\nLink: https://evm.cosmos.network/docs/sdk/v0.50/learn/advanced/events\\nContent: You can use CometBFT's Websocket to subscribe to Events by calling the subscribe RPC method: The main eventCategory you can subscribe to are: NewBlock : Contains Events triggered during BeginBlock and EndBlock. Tx : Contains Events triggered during DeliverTx (i.e. transaction processing). ValidatorSetUpdates : Contains validator set updates for the block. These Events are triggered from the state package after a block is committed. You can get the\\nfull list of Event categories on the CometBFT Go documentation. The type and attribute value of the query allow you to filter the specific Event you are looking for. For example, a Mint transaction triggers an Event of type EventMint and has an Id and an Owner as attributes (as defined in the events.proto file of the NFT module ). Subscribing to this Event would be done like so: where ownerAddress is an address following the AccAddress format. The same way can be used to subscribe to legacy events.\\n\\nYou can use CometBFT's Websocket to subscribe to Events by calling the subscribe RPC method: The main eventCategory you can subscribe to are: NewBlock : Contains Events triggered during BeginBlock and EndBlock. Tx : Contains Events triggered during DeliverTx (i.e. transaction processing). ValidatorSetUpdates : Contains validator set updates for the block. These Events are triggered from the state package after a block is committed. You can get the\\nfull list of Event categories on the CometBFT Go documentation. The type and attribute value of the query allow you to filter the specific Event you are looking for. For example, a Mint transaction triggers an Event of type EventMint and has an Id and an Owner as attributes (as defined in the events.proto file of the NFT module ). Subscribing to this Event would be done like so: {\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"method\\\": \\\"subscribe\\\",\\n  \\\"id\\\": \\\"0\\\",\\n  \\\"params\\\": {\\n    \\\"query\\\": \\\"tm.event='Tx' AND mint.owner='ownerAddress'\\\"\\n  }\\n}\\n\\nYou can use CometBFT's Websocket to subscribe to Events by calling the subscribe RPC method: {\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"method\\\": \\\"subscribe\\\",\\n  \\\"id\\\": \\\"0\\\",\\n  \\\"params\\\": {\\n    \\\"query\\\": \\\"tm.event='eventCategory' AND eventType.eventAttribute='attributeValue'\\\"\\n  }\\n}\\n\\n\", \"Title: Subscribing to Events\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/learn/advanced/events\\nContent: You can use CometBFT's Websocket to subscribe to Events by calling the subscribe RPC method: The main eventCategory you can subscribe to are: NewBlock : Contains Events triggered during BeginBlock and EndBlock. Tx : Contains Events triggered during DeliverTx (i.e. transaction processing). ValidatorSetUpdates : Contains validator set updates for the block. These Events are triggered from the state package after a block is committed. You can get the\\nfull list of Event categories on the CometBFT Go documentation. The type and attribute value of the query allow you to filter the specific Event you are looking for. For example, a Mint transaction triggers an Event of type EventMint and has an Id and an Owner as attributes (as defined in the events.proto file of the NFT module ). Subscribing to this Event would be done like so: where ownerAddress is an address following the AccAddress format. The same way can be used to subscribe to legacy events.\\n\\nYou can use CometBFT's Websocket to subscribe to Events by calling the subscribe RPC method: The main eventCategory you can subscribe to are: NewBlock : Contains Events triggered during BeginBlock and EndBlock. Tx : Contains Events triggered during DeliverTx (i.e. transaction processing). ValidatorSetUpdates : Contains validator set updates for the block. These Events are triggered from the state package after a block is committed. You can get the\\nfull list of Event categories on the CometBFT Go documentation. The type and attribute value of the query allow you to filter the specific Event you are looking for. For example, a Mint transaction triggers an Event of type EventMint and has an Id and an Owner as attributes (as defined in the events.proto file of the NFT module ). Subscribing to this Event would be done like so: {\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"method\\\": \\\"subscribe\\\",\\n  \\\"id\\\": \\\"0\\\",\\n  \\\"params\\\": {\\n    \\\"query\\\": \\\"tm.event='Tx' AND mint.owner='ownerAddress'\\\"\\n  }\\n}\\n\\nYou can use CometBFT's Websocket to subscribe to Events by calling the subscribe RPC method: {\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"method\\\": \\\"subscribe\\\",\\n  \\\"id\\\": \\\"0\\\",\\n  \\\"params\\\": {\\n    \\\"query\\\": \\\"tm.event='eventCategory' AND eventType.eventAttribute='attributeValue'\\\"\\n  }\\n}\\n\\n\", \"Title: Subscribing to Events\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/learn/advanced/events\\nContent: You can use CometBFT's Websocket to subscribe to Events by calling the subscribe RPC method: The main eventCategory you can subscribe to are: NewBlock : Contains Events triggered during BeginBlock and EndBlock. Tx : Contains Events triggered during DeliverTx (i.e. transaction processing). ValidatorSetUpdates : Contains validator set updates for the block. These Events are triggered from the state package after a block is committed. You can get the\\nfull list of Event categories on the CometBFT Go documentation. The type and attribute value of the query allow you to filter the specific Event you are looking for. For example, a Mint transaction triggers an Event of type EventMint and has an Id and an Owner as attributes (as defined in the events.proto file of the NFT module ). Subscribing to this Event would be done like so: where ownerAddress is an address following the AccAddress format. The same way can be used to subscribe to legacy events.\\n\\nYou can use CometBFT's Websocket to subscribe to Events by calling the subscribe RPC method: The main eventCategory you can subscribe to are: NewBlock : Contains Events triggered during BeginBlock and EndBlock. Tx : Contains Events triggered during DeliverTx (i.e. transaction processing). ValidatorSetUpdates : Contains validator set updates for the block. These Events are triggered from the state package after a block is committed. You can get the\\nfull list of Event categories on the CometBFT Go documentation. The type and attribute value of the query allow you to filter the specific Event you are looking for. For example, a Mint transaction triggers an Event of type EventMint and has an Id and an Owner as attributes (as defined in the events.proto file of the NFT module ). Subscribing to this Event would be done like so: {\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"method\\\": \\\"subscribe\\\",\\n  \\\"id\\\": \\\"0\\\",\\n  \\\"params\\\": {\\n    \\\"query\\\": \\\"tm.event='Tx' AND mint.owner='ownerAddress'\\\"\\n  }\\n}\\n\\nYou can use CometBFT's Websocket to subscribe to Events by calling the subscribe RPC method: {\\n  \\\"jsonrpc\\\": \\\"2.0\\\",\\n  \\\"method\\\": \\\"subscribe\\\",\\n  \\\"id\\\": \\\"0\\\",\\n  \\\"params\\\": {\\n    \\\"query\\\": \\\"tm.event='eventCategory' AND eventType.eventAttribute='attributeValue'\\\"\\n  }\\n}\\n\\n\", \"Title: Client Examples\\nLink: https://evm.cosmos.network/docs/evm/next/api-reference/ethereum-json-rpc/methods\\nContent: Shell HTTP Websocket Javascript Console await provider.send(\\\"eth_createAccessList\\\", [{\\n  from: \\\"0x8ba1f109551bD432803012645Hac136c5dd7E3D40\\\",\\n  to: \\\"0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2\\\",\\n  data: \\\"0xa9059cbb000000000000000000000000a0b86a33e6d1cde81f9c1ce51dd74f3d1111bb9e0000000000000000000000000000000000000000000000000de0b6b3a7640000\\\"\\n}, \\\"latest\\\"]);\\n\\nShell HTTP Websocket Javascript (web3.js) web3.eth.createAccessList({\\n  from: \\\"0x8D97689C9818892B700e27F316cc3E41e17fBeb9\\\",\\n  to: \\\"0xd3CdA913deB6f67967B99D67aCDFa1712C293601\\\",\\n  data: \\\"0x70a08231000000000000000000000000d3CdA913deB6f67967B99D67aCDFa1712C293601\\\"\\n}, \\\"latest\\\");\\n\\nShell HTTP Websocket Javascript Console txpool.contentFrom(\\\"0x1234567890abcdef1234567890abcdef12345678\\\");\\n\\n\", \"Title: Client Examples\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/api-reference/ethereum-json-rpc/methods\\nContent: Shell HTTP Websocket Javascript Console txpool.contentFrom(\\\"0x1234567890abcdef1234567890abcdef12345678\\\");\\n\\nShell HTTP WebSocket Javascript Console personal.unpair(url,pin);\\n\\nShell HTTP Websocket Javascript Console personal.initializeWallet(url);\\n\\n\", \"Title: start command\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/learn/advanced/node\\nContent: The start command is defined in the /server folder of the Cosmos SDK. It is added to the root command of the full-node client in the main function and called by the end-user to start their node: As a reminder, the full-node is composed of three conceptual layers: the networking layer, the consensus layer and the application layer. The first two are generally bundled together in an entity called the consensus engine (CometBFT by default), while the third is the state-machine defined with the help of the Cosmos SDK. Currently, the Cosmos SDK uses CometBFT as the default consensus engine, meaning the start command is implemented to boot up a CometBFT node. The flow of the start command is pretty straightforward. First, it retrieves the config from the context in order to open the db (a leveldb instance by default). This db contains the latest known state of the application (empty if the application is started from the first time. With the db , the start command creates a new instance of the application using an appCreator function: Note that an appCreator is a function that fulfills the AppCreator signature: In practice, the constructor of the application is passed as the appCreator. Then, the instance of app is used to instantiate a new CometBFT node: package server\\n\\n// DONTCOVER\\n\\nimport (\\n    \\n\\t\\\"errors\\\"\\n    \\\"fmt\\\"\\n    \\\"net\\\"\\n    \\\"net/http\\\"\\n    \\\"os\\\"\\n    \\\"runtime/pprof\\\"\\n    \\\"time\\\"\\n    \\\"github.com/spf13/cobra\\\"\\n    \\\"github.com/tendermint/tendermint/abci/server\\\"\\n\\ttcmd \\\"github.com/tendermint/tendermint/cmd/tendermint/commands\\\"\\n    \\\"github.com/tendermint/tendermint/node\\\"\\n    \\\"github.com/tendermint/tendermint/p2p\\\"\\n\\tpvm \\\"github.com/tendermint/tendermint/privval\\\"\\n    \\\"github.com/tendermint/tendermint/proxy\\\"\\n    \\\"github.com/tendermint/tendermint/rpc/client/local\\\"\\n    \\\"google.golang.org/grpc\\\"\\n    \\\"google.golang.org/grpc/credentials/insecure\\\"\\n    \\\"cosmossdk.io/tools/rosetta\\\"\\n\\tcrgserver \\\"cosmossdk.io/tools/rosetta/lib/server\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/flags\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/codec\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server/api\\\"\\n\\tserverconfig \\\"github.com/cosmos/cosmos-sdk/server/config\\\"\\n\\tservergrpc \\\"github.com/cosmos/cosmos-sdk/server/grpc\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server/types\\\"\\n\\tpruningtypes \\\"github.com/cosmos/cosmos-sdk/store/pruning/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/types/mempool\\\"\\n)\\n\\nconst (\\n\\t// Tendermint full-node start flags\\n\\tflagWithTendermint     = \\\"with-tendermint\\\"\\n\\tflagAddress            = \\\"address\\\"\\n\\tflagTransport          = \\\"transport\\\"\\n\\tflagTraceStore         = \\\"trace-store\\\"\\n\\tflagCPUProfile         = \\\"cpu-profile\\\"\\n\\tFlagMinGasPrices       = \\\"minimum-gas-prices\\\"\\n\\tFlagHaltHeight         = \\\"halt-height\\\"\\n\\tFlagHaltTime           = \\\"halt-time\\\"\\n\\tFlagInterBlockCache    = \\\"inter-block-cache\\\"\\n\\tFlagUnsafeSkipUpgrades = \\\"unsafe-skip-upgrades\\\"\\n\\tFlagTrace              = \\\"trace\\\"\\n\\tFlagInvCheckPeriod     = \\\"inv-check-period\\\"\\n\\n\\tFlagPruning             = \\\"pruning\\\"\\n\\tFlagPruningKeepRecent   = \\\"pruning-keep-recent\\\"\\n\\tFlagPruningInterval     = \\\"pruning-interval\\\"\\n\\tFlagIndexEvents         = \\\"index-events\\\"\\n\\tFlagMinRetainBlocks     = \\\"min-retain-blocks\\\"\\n\\tFlagIAVLCacheSize       = \\\"iavl-cache-size\\\"\\n\\tFlagDisableIAVLFastNode = \\\"iavl-disable-fastnode\\\"\\n\\n\\t// state sync-related flags\\n\\tFlagStateSyncSnapshotInterval   = \\\"state-sync.snapshot-interval\\\"\\n\\tFlagStateSyncSnapshotKeepRecent = \\\"state-sync.snapshot-keep-recent\\\"\\n\\n\\t// api-related flags\\n\\tFlagAPIEnable             = \\\"api.enable\\\"\\n\\tFlagAPISwagger            = \\\"api.swagger\\\"\\n\\tFlagAPIAddress            = \\\"api.address\\\"\\n\\tFlagAPIMaxOpenConnections = \\\"api.max-open-connections\\\"\\n\\tFlagRPCReadTimeout        = \\\"api.rpc-read-timeout\\\"\\n\\tFlagRPCWriteTimeout       = \\\"api.rpc-write-timeout\\\"\\n\\tFlagRPCMaxBodyBytes       = \\\"api.rpc-max-body-bytes\\\"\\n\\tFlagAPIEnableUnsafeCORS   = \\\"api.enabled-unsafe-cors\\\"\\n\\n\\t// gRPC-related flags\\n\\tflagGRPCOnly       = \\\"grpc-only\\\"\\n\\tflagGRPCEnable     = \\\"grpc.enable\\\"\\n\\tflagGRPCAddress    = \\\"grpc.address\\\"\\n\\tflagGRPCWebEnable  = \\\"grpc-web.enable\\\"\\n\\tflagGRPCWebAddress = \\\"grpc-web.address\\\"\\n\\n\\t// mempool flags\\n\\tFlagMempoolMaxTxs = \\\"mempool.max-txs\\\"\\n)\\n\\n// StartCmd runs the service passed in, either stand-alone or in-process with\\n// Tendermint.\\nfunc StartCmd(appCreator types.AppCreator, defaultNodeHome string) *cobra.Command {\\n    cmd := &cobra.Command{\\n    Use:   \\\"start\\\",\\n    Short: \\\"Run the full node\\\",\\n    Long: `Run the full node application with Tendermint in or out of process. By\\ndefault, the application will run with Tendermint in process.\\n\\nPruning options can be provided via the '--pruning' flag or alternatively with '--pruning-keep-recent', and\\n'pruning-interval' together.\\n\\nFor '--pruning' the options are as follows:\\n\\ndefault: the last 362880 states are kept, pruning at 10 block intervals\\nnothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)\\n\\neverything: 2 latest states will be kept; pruning at 10 block intervals.\\ncustom: allow pruning options to be manually specified through 'pruning-keep-recent', and 'pruning-interval'\\n\\nNode halting configurations exist in the form of two flags: '--halt-height' and '--halt-time'. During\\nthe ABCI Commit phase, the node will check if the current block height is greater than or equal to\\nthe halt-height or if the current block time is greater than or equal to the halt-time. If so, the\\nnode will attempt to gracefully shutdown and the block will not be committed. In addition, the node\\nwill not be able to commit subsequent blocks.\\n\\nFor profiling and benchmarking purposes, CPU profiling can be enabled via the '--cpu-profile' flag\\nwhich accepts a path for the resulting pprof file.\\n\\nThe node may be started in a 'query only' mode where only the gRPC and JSON HTTP\\nAPI services are enabled via the 'grpc-only' flag. In this mode, Tendermint is\\nbypassed and can be used when legacy queries are needed after an on-chain upgrade\\nis performed. Note, when enabled, gRPC will also be automatically enabled.\\n`,\\n    PreRunE: func(cmd *cobra.Command, _ []string)\\n\\nerror {\\n    serverCtx := GetServerContextFromCmd(cmd)\\n\\n\\t\\t\\t// Bind flags to the Context's Viper so the app construction can set\\n\\t\\t\\t// options accordingly.\\n    if err := serverCtx.Viper.BindPFlags(cmd.Flags()); err != nil {\\n    return err\\n}\\n\\n\\t\\t\\t_, err := GetPruningOptionsFromFlags(serverCtx.Viper)\\n\\nreturn err\\n},\\n    RunE: func(cmd *cobra.Command, _ []string)\\n\\nerror {\\n    serverCtx := GetServerContextFromCmd(cmd)\\n\\nclientCtx, err := client.GetClientQueryContext(cmd)\\n    if err != nil {\\n    return err\\n}\\n\\nwithTM, _ := cmd.Flags().GetBool(flagWithTendermint)\\n    if !withTM {\\n    serverCtx.Logger.Info(\\\"starting ABCI without Tendermint\\\")\\n\\nreturn startStandAlone(serverCtx, appCreator)\\n}\\n\\n\\t\\t\\t// amino is needed here for backwards compatibility of REST routes\\n\\t\\t\\terr = startInProcess(serverCtx, clientCtx, appCreator)\\n\\nerrCode, ok := err.(ErrorCode)\\n    if !ok {\\n    return err\\n}\\n\\nserverCtx.Logger.Debug(fmt.Sprintf(\\\"received quit signal: %d\\\", errCode.Code))\\n\\nreturn nil\\n},\\n}\\n\\ncmd.Flags().String(flags.FlagHome, defaultNodeHome, \\\"The application home directory\\\")\\n\\ncmd.Flags().Bool(flagWithTendermint, true, \\\"Run abci app embedded in-process with tendermint\\\")\\n\\ncmd.Flags().String(flagAddress, \\\"tcp://0.0.0.0:26658\\\", \\\"Listen address\\\")\\n\\ncmd.Flags().String(flagTransport, \\\"socket\\\", \\\"Transport protocol: socket, grpc\\\")\\n\\ncmd.Flags().String(flagTraceStore, \\\"\\\", \\\"Enable KVStore tracing to an output file\\\")\\n\\ncmd.Flags().String(FlagMinGasPrices, \\\"\\\", \\\"Minimum gas prices to accept for transactions; Any fee in a tx must meet this minimum (e.g. 0.01photino;0.0001stake)\\\")\\n\\ncmd.Flags().IntSlice(FlagUnsafeSkipUpgrades, []int{\\n}, \\\"Skip a set of upgrade heights to continue the old binary\\\")\\n\\ncmd.Flags().Uint64(FlagHaltHeight, 0, \\\"Block height at which to gracefully halt the chain and shutdown the node\\\")\\n\\ncmd.Flags().Uint64(FlagHaltTime, 0, \\\"Minimum block time (in Unix seconds)\\n\\nat which to gracefully halt the chain and shutdown the node\\\")\\n\\ncmd.Flags().Bool(FlagInterBlockCache, true, \\\"Enable inter-block caching\\\")\\n\\ncmd.Flags().String(flagCPUProfile, \\\"\\\", \\\"Enable CPU profiling and write to the provided file\\\")\\n\\ncmd.Flags().Bool(FlagTrace, false, \\\"Provide full stack traces for errors in ABCI Log\\\")\\n\\ncmd.Flags().String(FlagPruning, pruningtypes.PruningOptionDefault, \\\"Pruning strategy (default|nothing|everything|custom)\\\")\\n\\ncmd.Flags().Uint64(FlagPruningKeepRecent, 0, \\\"Number of recent heights to keep on disk (ignored if pruning is not 'custom')\\\")\\n\\ncmd.Flags().Uint64(FlagPruningInterval, 0, \\\"Height interval at which pruned heights are removed from disk (ignored if pruning is not 'custom')\\\")\\n\\ncmd.Flags().Uint(FlagInvCheckPeriod, 0, \\\"Assert registered invariants every N blocks\\\")\\n\\ncmd.Flags().Uint64(FlagMinRetainBlocks, 0, \\\"Minimum block height offset during ABCI commit to prune Tendermint blocks\\\")\\n\\ncmd.Flags().Bool(FlagAPIEnable, false, \\\"Define if the API server should be enabled\\\")\\n\\ncmd.Flags().Bool(FlagAPISwagger, false, \\\"Define if swagger documentation should automatically be registered (Note: the API must also be enabled)\\\")\\n\\ncmd.Flags().String(FlagAPIAddress, serverconfig.DefaultAPIAddress, \\\"the API server address to listen on\\\")\\n\\ncmd.Flags().Uint(FlagAPIMaxOpenConnections, 1000, \\\"Define the number of maximum open connections\\\")\\n\\ncmd.Flags().Uint(FlagRPCReadTimeout, 10, \\\"Define the Tendermint RPC read timeout (in seconds)\\\")\\n\\ncmd.Flags().Uint(FlagRPCWriteTimeout, 0, \\\"Define the Tendermint RPC write timeout (in seconds)\\\")\\n\\ncmd.Flags().Uint(FlagRPCMaxBodyBytes, 1000000, \\\"Define the Tendermint maximum response body (in bytes)\\\")\\n\\ncmd.Flags().Bool(FlagAPIEnableUnsafeCORS, false, \\\"Define if CORS should be enabled (unsafe - use it at your own risk)\\\")\\n\\ncmd.Flags().Bool(flagGRPCOnly, false, \\\"Start the node in gRPC query only mode (no Tendermint process is started)\\\")\\n\\ncmd.Flags().Bool(flagGRPCEnable, true, \\\"Define if the gRPC server should be enabled\\\")\\n\\ncmd.Flags().String(flagGRPCAddress, serverconfig.DefaultGRPCAddress, \\\"the gRPC server address to listen on\\\")\\n\\ncmd.Flags().Bool(flagGRPCWebEnable, true, \\\"Define if the gRPC-Web server should be enabled. (Note: gRPC must also be enabled)\\\")\\n\\ncmd.Flags().String(flagGRPCWebAddress, serverconfig.DefaultGRPCWebAddress, \\\"The gRPC-Web server address to listen on\\\")\\n\\ncmd.Flags().Uint64(FlagStateSyncSnapshotInterval, 0, \\\"State sync snapshot interval\\\")\\n\\ncmd.Flags().Uint32(FlagStateSyncSnapshotKeepRecent, 2, \\\"State sync snapshot to keep\\\")\\n\\ncmd.Flags().Bool(FlagDisableIAVLFastNode, false, \\\"Disable fast node for IAVL tree\\\")\\n\\ncmd.Flags().Int(FlagMempoolMaxTxs, mempool.DefaultMaxTx, \\\"Sets MaxTx value for the app-side mempool\\\")\\n\\n\\t// add support for all Tendermint-specific command line options\\n\\ttcmd.AddNodeFlags(cmd)\\n\\nreturn cmd\\n}\\n\\nfunc startStandAlone(ctx *Context, appCreator types.AppCreator)\\n\\nerror {\\n    addr := ctx.Viper.GetString(flagAddress)\\n    transport := ctx.Viper.GetString(flagTransport)\\n    home := ctx.Viper.GetString(flags.FlagHome)\\n\\ndb, err := openDB(home, GetAppDBBackend(ctx.Viper))\\n    if err != nil {\\n    return err\\n}\\n    traceWriterFile := ctx.Viper.GetString(flagTraceStore)\\n\\ntraceWriter, err := openTraceWriter(traceWriterFile)\\n    if err != nil {\\n    return err\\n}\\n    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)\\n\\nconfig, err := serverconfig.GetConfig(ctx.Viper)\\n    if err != nil {\\n    return err\\n}\\n\\n\\t_, err = startTelemetry(config)\\n    if err != nil {\\n    return err\\n}\\n\\nsvr, err := server.NewServer(addr, transport, app)\\n    if err != nil {\\n    return fmt.Errorf(\\\"error creating listener: %v\\\", err)\\n}\\n\\nsvr.SetLogger(ctx.Logger.With(\\\"module\\\", \\\"abci-server\\\"))\\n\\nerr = svr.Start()\\n    if err != nil {\\n    fmt.Println(err.Error())\\n\\nos.Exit(1)\\n}\\n\\ndefer func() {\\n    if err = svr.Stop(); err != nil {\\n    fmt.Println(err.Error())\\n\\nos.Exit(1)\\n}\\n\\t\\n}()\\n\\n\\t// Wait for SIGINT or SIGTERM signal\\n\\treturn WaitForQuitSignals()\\n}\\n\\nfunc startInProcess(ctx *Context, clientCtx client.Context, appCreator types.AppCreator)\\n\\nerror {\\n    cfg := ctx.Config\\n    home := cfg.RootDir\\n\\tvar cpuProfileCleanup func()\\n    if cpuProfile := ctx.Viper.GetString(flagCPUProfile); cpuProfile != \\\"\\\" {\\n    f, err := os.Create(cpuProfile)\\n    if err != nil {\\n    return err\\n}\\n\\nctx.Logger.Info(\\\"starting CPU profiler\\\", \\\"profile\\\", cpuProfile)\\n    if err := pprof.StartCPUProfile(f); err != nil {\\n    return err\\n}\\n\\ncpuProfileCleanup = func() {\\n    ctx.Logger.Info(\\\"stopping CPU profiler\\\", \\\"profile\\\", cpuProfile)\\n\\npprof.StopCPUProfile()\\n    if err := f.Close(); err != nil {\\n    ctx.Logger.Info(\\\"failed to close cpu-profile file\\\", \\\"profile\\\", cpuProfile, \\\"err\\\", err.Error())\\n}\\n\\t\\n}\\n\\t\\n}\\n\\ndb, err := openDB(home, GetAppDBBackend(ctx.Viper))\\n    if err != nil {\\n    return err\\n}\\n    traceWriterFile := ctx.Viper.GetString(flagTraceStore)\\n\\ntraceWriter, err := openTraceWriter(traceWriterFile)\\n    if err != nil {\\n    return err\\n}\\n\\n\\t// Clean up the traceWriter in the cpuProfileCleanup routine that is invoked\\n\\t// when the server is shutting down.\\n    fn := cpuProfileCleanup\\n\\tcpuProfileCleanup = func() {\\n    if fn != nil {\\n    fn()\\n}\\n\\n\\t\\t// if flagTraceStore is not used then traceWriter is nil\\n    if traceWriter != nil {\\n    if err = traceWriter.Close(); err != nil {\\n    ctx.Logger.Error(\\\"failed to close trace writer\\\", \\\"err\\\", err)\\n}\\n\\t\\n}\\n\\t\\n}\\n\\nconfig, err := serverconfig.GetConfig(ctx.Viper)\\n    if err != nil {\\n    return err\\n}\\n    if err := config.ValidateBasic(); err != nil {\\n    return err\\n}\\n    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)\\n\\nnodeKey, err := p2p.LoadOrGenNodeKey(cfg.NodeKeyFile())\\n    if err != nil {\\n    return err\\n}\\n    genDocProvider := node.DefaultGenesisDocProviderFunc(cfg)\\n\\nvar (\\n\\t\\ttmNode   *node.Node\\n\\t\\tgRPCOnly = ctx.Viper.GetBool(flagGRPCOnly)\\n\\t)\\n    if gRPCOnly {\\n    ctx.Logger.Info(\\\"starting node in gRPC only mode; Tendermint is disabled\\\")\\n\\nconfig.GRPC.Enable = true\\n}\\n\\nelse {\\n    ctx.Logger.Info(\\\"starting node with ABCI Tendermint in-process\\\")\\n\\ntmNode, err = node.NewNode(\\n\\t\\t\\tcfg,\\n\\t\\t\\tpvm.LoadOrGenFilePV(cfg.PrivValidatorKeyFile(), cfg.PrivValidatorStateFile()),\\n\\t\\t\\tnodeKey,\\n\\t\\t\\tproxy.NewLocalClientCreator(app),\\n\\t\\t\\tgenDocProvider,\\n\\t\\t\\tnode.DefaultDBProvider,\\n\\t\\t\\tnode.DefaultMetricsProvider(cfg.Instrumentation),\\n\\t\\t\\tctx.Logger,\\n\\t\\t)\\n    if err != nil {\\n    return err\\n}\\n    if err := tmNode.Start(); err != nil {\\n    return err\\n}\\n\\t\\n}\\n\\n\\t// Add the tx service to the gRPC router. We only need to register this\\n\\t// service if API or gRPC is enabled, and avoid doing so in the general\\n\\t// case, because it spawns a new local tendermint RPC client.\\n    if (config.API.Enable || config.GRPC.Enable) && tmNode != nil {\\n\\t\\t// re-assign for making the client available below\\n\\t\\t// do not use := to avoid shadowing clientCtx\\n\\t\\tclientCtx = clientCtx.WithClient(local.New(tmNode))\\n\\napp.RegisterTxService(clientCtx)\\n\\napp.RegisterTendermintService(clientCtx)\\n\\napp.RegisterNodeService(clientCtx)\\n}\\n\\nmetrics, err := startTelemetry(config)\\n    if err != nil {\\n    return err\\n}\\n\\nvar apiSrv *api.Server\\n    if config.API.Enable {\\n    genDoc, err := genDocProvider()\\n    if err != nil {\\n    return err\\n}\\n    clientCtx := clientCtx.WithHomeDir(home).WithChainID(genDoc.ChainID)\\n    if config.GRPC.Enable {\\n\\t\\t\\t_, port, err := net.SplitHostPort(config.GRPC.Address)\\n    if err != nil {\\n    return err\\n}\\n    maxSendMsgSize := config.GRPC.MaxSendMsgSize\\n    if maxSendMsgSize == 0 {\\n    maxSendMsgSize = serverconfig.DefaultGRPCMaxSendMsgSize\\n}\\n    maxRecvMsgSize := config.GRPC.MaxRecvMsgSize\\n    if maxRecvMsgSize == 0 {\\n    maxRecvMsgSize = serverconfig.DefaultGRPCMaxRecvMsgSize\\n}\\n    grpcAddress := fmt.Sprintf(\\\"127.0.0.1:%s\\\", port)\\n\\n\\t\\t\\t// If grpc is enabled, configure grpc client for grpc gateway.\\n\\t\\t\\tgrpcClient, err := grpc.Dial(\\n\\t\\t\\t\\tgrpcAddress,\\n\\t\\t\\t\\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\\n\\t\\t\\t\\tgrpc.WithDefaultCallOptions(\\n\\t\\t\\t\\t\\tgrpc.ForceCodec(codec.NewProtoCodec(clientCtx.InterfaceRegistry).GRPCCodec()),\\n\\t\\t\\t\\t\\tgrpc.MaxCallRecvMsgSize(maxRecvMsgSize),\\n\\t\\t\\t\\t\\tgrpc.MaxCallSendMsgSize(maxSendMsgSize),\\n\\t\\t\\t\\t),\\n\\t\\t\\t)\\n    if err != nil {\\n    return err\\n}\\n\\nclientCtx = clientCtx.WithGRPCClient(grpcClient)\\n\\nctx.Logger.Debug(\\\"grpc client assigned to client context\\\", \\\"target\\\", grpcAddress)\\n}\\n\\napiSrv = api.New(clientCtx, ctx.Logger.With(\\\"module\\\", \\\"api-server\\\"))\\n\\napp.RegisterAPIRoutes(apiSrv, config.API)\\n    if config.Telemetry.Enabled {\\n    apiSrv.SetTelemetry(metrics)\\n}\\n    errCh := make(chan error)\\n\\ngo func() {\\n    if err := apiSrv.Start(config); err != nil {\\n    errCh <- err\\n}\\n\\t\\n}()\\n\\nselect {\\n    case err := <-errCh:\\n\\t\\t\\treturn err\\n    case <-time.After(types.ServerStartTime): // assume server started successfully\\n}\\n\\t\\n}\\n\\nvar (\\n\\t\\tgrpcSrv    *grpc.Server\\n\\t\\tgrpcWebSrv *http.Server\\n\\t)\\n    if config.GRPC.Enable {\\n    grpcSrv, err = servergrpc.StartGRPCServer(clientCtx, app, config.GRPC)\\n    if err != nil {\\n    return err\\n}\\n\\ndefer grpcSrv.Stop()\\n    if config.GRPCWeb.Enable {\\n    grpcWebSrv, err = servergrpc.StartGRPCWeb(grpcSrv, config)\\n    if err != nil {\\n    ctx.Logger.Error(\\\"failed to start grpc-web http server: \\\", err)\\n\\nreturn err\\n}\\n\\ndefer func() {\\n    if err := grpcWebSrv.Close(); err != nil {\\n    ctx.Logger.Error(\\\"failed to close grpc-web http server: \\\", err)\\n}\\n\\t\\n}()\\n}\\n\\t\\n}\\n\\n\\t// At this point it is safe to block the process if we're in gRPC only mode as\\n\\t// we do not need to start Rosetta or handle any Tendermint related processes.\\n    if gRPCOnly {\\n\\t\\t// wait for signal capture and gracefully return\\n\\t\\treturn WaitForQuitSignals()\\n}\\n\\nvar rosettaSrv crgserver.Server\\n    if config.Rosetta.Enable {\\n    offlineMode := config.Rosetta.Offline\\n\\n\\t\\t// If GRPC is not enabled rosetta cannot work in online mode, so we throw an error.\\n    if !config.GRPC.Enable && !offlineMode {\\n    return errors.New(\\\"'grpc' must be enable in online mode for Rosetta to work\\\")\\n}\\n\\nminGasPrices, err := sdk.ParseDecCoins(config.MinGasPrices)\\n    if err != nil {\\n    ctx.Logger.Error(\\\"failed to parse minimum-gas-prices: \\\", err)\\n\\nreturn err\\n}\\n    conf := &rosetta.Config{\\n    Blockchain:          config.Rosetta.Blockchain,\\n    Network:             config.Rosetta.Network,\\n    TendermintRPC:       ctx.Config.RPC.ListenAddress,\\n    GRPCEndpoint:        config.GRPC.Address,\\n    Addr:                config.Rosetta.Address,\\n    Retries:             config.Rosetta.Retries,\\n    Offline:             offlineMode,\\n    GasToSuggest:        config.Rosetta.GasToSuggest,\\n    EnableFeeSuggestion: config.Rosetta.EnableFeeSuggestion,\\n    GasPrices:           minGasPrices.Sort(),\\n    Codec:               clientCtx.Codec.(*codec.ProtoCodec),\\n    InterfaceRegistry:   clientCtx.InterfaceRegistry,\\n}\\n\\nrosettaSrv, err = rosetta.ServerFromConfig(conf)\\n    if err != nil {\\n    return err\\n}\\n    errCh := make(chan error)\\n\\ngo func() {\\n    if err := rosettaSrv.Start(); err != nil {\\n    errCh <- err\\n}\\n\\t\\n}()\\n\\nselect {\\n    case err := <-errCh:\\n\\t\\t\\treturn err\\n    case <-time.After(types.ServerStartTime): // assume server started successfully\\n}\\n\\t\\n}\\n\\ndefer func() {\\n    if tmNode != nil && tmNode.IsRunning() {\\n\\t\\t\\t_ = tmNode.Stop()\\n}\\n    if cpuProfileCleanup != nil {\\n    cpuProfileCleanup()\\n}\\n    if apiSrv != nil {\\n\\t\\t\\t_ = apiSrv.Close()\\n}\\n\\nctx.Logger.Info(\\\"exiting...\\\")\\n}()\\n\\n\\t// wait for signal capture and gracefully return\\n\\treturn WaitForQuitSignals()\\n}\\n\\nfunc startTelemetry(cfg serverconfig.Config) (*telemetry.Metrics, error) {\\n    if !cfg.Telemetry.Enabled {\\n    return nil, nil\\n}\\n\\nreturn telemetry.New(cfg.Telemetry)\\n}\\n\\nThe start command is defined in the /server folder of the Cosmos SDK. It is added to the root command of the full-node client in the main function and called by the end-user to start their node: As a reminder, the full-node is composed of three conceptual layers: the networking layer, the consensus layer and the application layer. The first two are generally bundled together in an entity called the consensus engine (CometBFT by default), while the third is the state-machine defined with the help of the Cosmos SDK. Currently, the Cosmos SDK uses CometBFT as the default consensus engine, meaning the start command is implemented to boot up a CometBFT node. The flow of the start command is pretty straightforward. First, it retrieves the config from the context in order to open the db (a leveldb instance by default). This db contains the latest known state of the application (empty if the application is started from the first time. With the db , the start command creates a new instance of the application using an appCreator function: package server\\n\\n// DONTCOVER\\n\\nimport (\\n    \\n\\t\\\"errors\\\"\\n    \\\"fmt\\\"\\n    \\\"net\\\"\\n    \\\"net/http\\\"\\n    \\\"os\\\"\\n    \\\"runtime/pprof\\\"\\n    \\\"time\\\"\\n    \\\"github.com/spf13/cobra\\\"\\n    \\\"github.com/tendermint/tendermint/abci/server\\\"\\n\\ttcmd \\\"github.com/tendermint/tendermint/cmd/tendermint/commands\\\"\\n    \\\"github.com/tendermint/tendermint/node\\\"\\n    \\\"github.com/tendermint/tendermint/p2p\\\"\\n\\tpvm \\\"github.com/tendermint/tendermint/privval\\\"\\n    \\\"github.com/tendermint/tendermint/proxy\\\"\\n    \\\"github.com/tendermint/tendermint/rpc/client/local\\\"\\n    \\\"google.golang.org/grpc\\\"\\n    \\\"google.golang.org/grpc/credentials/insecure\\\"\\n    \\\"cosmossdk.io/tools/rosetta\\\"\\n\\tcrgserver \\\"cosmossdk.io/tools/rosetta/lib/server\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/flags\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/codec\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server/api\\\"\\n\\tserverconfig \\\"github.com/cosmos/cosmos-sdk/server/config\\\"\\n\\tservergrpc \\\"github.com/cosmos/cosmos-sdk/server/grpc\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server/types\\\"\\n\\tpruningtypes \\\"github.com/cosmos/cosmos-sdk/store/pruning/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/types/mempool\\\"\\n)\\n\\nconst (\\n\\t// Tendermint full-node start flags\\n\\tflagWithTendermint     = \\\"with-tendermint\\\"\\n\\tflagAddress            = \\\"address\\\"\\n\\tflagTransport          = \\\"transport\\\"\\n\\tflagTraceStore         = \\\"trace-store\\\"\\n\\tflagCPUProfile         = \\\"cpu-profile\\\"\\n\\tFlagMinGasPrices       = \\\"minimum-gas-prices\\\"\\n\\tFlagHaltHeight         = \\\"halt-height\\\"\\n\\tFlagHaltTime           = \\\"halt-time\\\"\\n\\tFlagInterBlockCache    = \\\"inter-block-cache\\\"\\n\\tFlagUnsafeSkipUpgrades = \\\"unsafe-skip-upgrades\\\"\\n\\tFlagTrace              = \\\"trace\\\"\\n\\tFlagInvCheckPeriod     = \\\"inv-check-period\\\"\\n\\n\\tFlagPruning             = \\\"pruning\\\"\\n\\tFlagPruningKeepRecent   = \\\"pruning-keep-recent\\\"\\n\\tFlagPruningInterval     = \\\"pruning-interval\\\"\\n\\tFlagIndexEvents         = \\\"index-events\\\"\\n\\tFlagMinRetainBlocks     = \\\"min-retain-blocks\\\"\\n\\tFlagIAVLCacheSize       = \\\"iavl-cache-size\\\"\\n\\tFlagDisableIAVLFastNode = \\\"iavl-disable-fastnode\\\"\\n\\n\\t// state sync-related flags\\n\\tFlagStateSyncSnapshotInterval   = \\\"state-sync.snapshot-interval\\\"\\n\\tFlagStateSyncSnapshotKeepRecent = \\\"state-sync.snapshot-keep-recent\\\"\\n\\n\\t// api-related flags\\n\\tFlagAPIEnable             = \\\"api.enable\\\"\\n\\tFlagAPISwagger            = \\\"api.swagger\\\"\\n\\tFlagAPIAddress            = \\\"api.address\\\"\\n\\tFlagAPIMaxOpenConnections = \\\"api.max-open-connections\\\"\\n\\tFlagRPCReadTimeout        = \\\"api.rpc-read-timeout\\\"\\n\\tFlagRPCWriteTimeout       = \\\"api.rpc-write-timeout\\\"\\n\\tFlagRPCMaxBodyBytes       = \\\"api.rpc-max-body-bytes\\\"\\n\\tFlagAPIEnableUnsafeCORS   = \\\"api.enabled-unsafe-cors\\\"\\n\\n\\t// gRPC-related flags\\n\\tflagGRPCOnly       = \\\"grpc-only\\\"\\n\\tflagGRPCEnable     = \\\"grpc.enable\\\"\\n\\tflagGRPCAddress    = \\\"grpc.address\\\"\\n\\tflagGRPCWebEnable  = \\\"grpc-web.enable\\\"\\n\\tflagGRPCWebAddress = \\\"grpc-web.address\\\"\\n\\n\\t// mempool flags\\n\\tFlagMempoolMaxTxs = \\\"mempool.max-txs\\\"\\n)\\n\\n// StartCmd runs the service passed in, either stand-alone or in-process with\\n// Tendermint.\\nfunc StartCmd(appCreator types.AppCreator, defaultNodeHome string) *cobra.Command {\\n    cmd := &cobra.Command{\\n    Use:   \\\"start\\\",\\n    Short: \\\"Run the full node\\\",\\n    Long: `Run the full node application with Tendermint in or out of process. By\\ndefault, the application will run with Tendermint in process.\\n\\nPruning options can be provided via the '--pruning' flag or alternatively with '--pruning-keep-recent', and\\n'pruning-interval' together.\\n\\nFor '--pruning' the options are as follows:\\n\\ndefault: the last 362880 states are kept, pruning at 10 block intervals\\nnothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)\\n\\neverything: 2 latest states will be kept; pruning at 10 block intervals.\\ncustom: allow pruning options to be manually specified through 'pruning-keep-recent', and 'pruning-interval'\\n\\nNode halting configurations exist in the form of two flags: '--halt-height' and '--halt-time'. During\\nthe ABCI Commit phase, the node will check if the current block height is greater than or equal to\\nthe halt-height or if the current block time is greater than or equal to the halt-time. If so, the\\nnode will attempt to gracefully shutdown and the block will not be committed. In addition, the node\\nwill not be able to commit subsequent blocks.\\n\\nFor profiling and benchmarking purposes, CPU profiling can be enabled via the '--cpu-profile' flag\\nwhich accepts a path for the resulting pprof file.\\n\\nThe node may be started in a 'query only' mode where only the gRPC and JSON HTTP\\nAPI services are enabled via the 'grpc-only' flag. In this mode, Tendermint is\\nbypassed and can be used when legacy queries are needed after an on-chain upgrade\\nis performed. Note, when enabled, gRPC will also be automatically enabled.\\n`,\\n    PreRunE: func(cmd *cobra.Command, _ []string)\\n\\nerror {\\n    serverCtx := GetServerContextFromCmd(cmd)\\n\\n\\t\\t\\t// Bind flags to the Context's Viper so the app construction can set\\n\\t\\t\\t// options accordingly.\\n    if err := serverCtx.Viper.BindPFlags(cmd.Flags()); err != nil {\\n    return err\\n}\\n\\n\\t\\t\\t_, err := GetPruningOptionsFromFlags(serverCtx.Viper)\\n\\nreturn err\\n},\\n    RunE: func(cmd *cobra.Command, _ []string)\\n\\nerror {\\n    serverCtx := GetServerContextFromCmd(cmd)\\n\\nclientCtx, err := client.GetClientQueryContext(cmd)\\n    if err != nil {\\n    return err\\n}\\n\\nwithTM, _ := cmd.Flags().GetBool(flagWithTendermint)\\n    if !withTM {\\n    serverCtx.Logger.Info(\\\"starting ABCI without Tendermint\\\")\\n\\nreturn startStandAlone(serverCtx, appCreator)\\n}\\n\\n\\t\\t\\t// amino is needed here for backwards compatibility of REST routes\\n\\t\\t\\terr = startInProcess(serverCtx, clientCtx, appCreator)\\n\\nerrCode, ok := err.(ErrorCode)\\n    if !ok {\\n    return err\\n}\\n\\nserverCtx.Logger.Debug(fmt.Sprintf(\\\"received quit signal: %d\\\", errCode.Code))\\n\\nreturn nil\\n},\\n}\\n\\ncmd.Flags().String(flags.FlagHome, defaultNodeHome, \\\"The application home directory\\\")\\n\\ncmd.Flags().Bool(flagWithTendermint, true, \\\"Run abci app embedded in-process with tendermint\\\")\\n\\ncmd.Flags().String(flagAddress, \\\"tcp://0.0.0.0:26658\\\", \\\"Listen address\\\")\\n\\ncmd.Flags().String(flagTransport, \\\"socket\\\", \\\"Transport protocol: socket, grpc\\\")\\n\\ncmd.Flags().String(flagTraceStore, \\\"\\\", \\\"Enable KVStore tracing to an output file\\\")\\n\\ncmd.Flags().String(FlagMinGasPrices, \\\"\\\", \\\"Minimum gas prices to accept for transactions; Any fee in a tx must meet this minimum (e.g. 0.01photino;0.0001stake)\\\")\\n\\ncmd.Flags().IntSlice(FlagUnsafeSkipUpgrades, []int{\\n}, \\\"Skip a set of upgrade heights to continue the old binary\\\")\\n\\ncmd.Flags().Uint64(FlagHaltHeight, 0, \\\"Block height at which to gracefully halt the chain and shutdown the node\\\")\\n\\ncmd.Flags().Uint64(FlagHaltTime, 0, \\\"Minimum block time (in Unix seconds)\\n\\nat which to gracefully halt the chain and shutdown the node\\\")\\n\\ncmd.Flags().Bool(FlagInterBlockCache, true, \\\"Enable inter-block caching\\\")\\n\\ncmd.Flags().String(flagCPUProfile, \\\"\\\", \\\"Enable CPU profiling and write to the provided file\\\")\\n\\ncmd.Flags().Bool(FlagTrace, false, \\\"Provide full stack traces for errors in ABCI Log\\\")\\n\\ncmd.Flags().String(FlagPruning, pruningtypes.PruningOptionDefault, \\\"Pruning strategy (default|nothing|everything|custom)\\\")\\n\\ncmd.Flags().Uint64(FlagPruningKeepRecent, 0, \\\"Number of recent heights to keep on disk (ignored if pruning is not 'custom')\\\")\\n\\ncmd.Flags().Uint64(FlagPruningInterval, 0, \\\"Height interval at which pruned heights are removed from disk (ignored if pruning is not 'custom')\\\")\\n\\ncmd.Flags().Uint(FlagInvCheckPeriod, 0, \\\"Assert registered invariants every N blocks\\\")\\n\\ncmd.Flags().Uint64(FlagMinRetainBlocks, 0, \\\"Minimum block height offset during ABCI commit to prune Tendermint blocks\\\")\\n\\ncmd.Flags().Bool(FlagAPIEnable, false, \\\"Define if the API server should be enabled\\\")\\n\\ncmd.Flags().Bool(FlagAPISwagger, false, \\\"Define if swagger documentation should automatically be registered (Note: the API must also be enabled)\\\")\\n\\ncmd.Flags().String(FlagAPIAddress, serverconfig.DefaultAPIAddress, \\\"the API server address to listen on\\\")\\n\\ncmd.Flags().Uint(FlagAPIMaxOpenConnections, 1000, \\\"Define the number of maximum open connections\\\")\\n\\ncmd.Flags().Uint(FlagRPCReadTimeout, 10, \\\"Define the Tendermint RPC read timeout (in seconds)\\\")\\n\\ncmd.Flags().Uint(FlagRPCWriteTimeout, 0, \\\"Define the Tendermint RPC write timeout (in seconds)\\\")\\n\\ncmd.Flags().Uint(FlagRPCMaxBodyBytes, 1000000, \\\"Define the Tendermint maximum response body (in bytes)\\\")\\n\\ncmd.Flags().Bool(FlagAPIEnableUnsafeCORS, false, \\\"Define if CORS should be enabled (unsafe - use it at your own risk)\\\")\\n\\ncmd.Flags().Bool(flagGRPCOnly, false, \\\"Start the node in gRPC query only mode (no Tendermint process is started)\\\")\\n\\ncmd.Flags().Bool(flagGRPCEnable, true, \\\"Define if the gRPC server should be enabled\\\")\\n\\ncmd.Flags().String(flagGRPCAddress, serverconfig.DefaultGRPCAddress, \\\"the gRPC server address to listen on\\\")\\n\\ncmd.Flags().Bool(flagGRPCWebEnable, true, \\\"Define if the gRPC-Web server should be enabled. (Note: gRPC must also be enabled)\\\")\\n\\ncmd.Flags().String(flagGRPCWebAddress, serverconfig.DefaultGRPCWebAddress, \\\"The gRPC-Web server address to listen on\\\")\\n\\ncmd.Flags().Uint64(FlagStateSyncSnapshotInterval, 0, \\\"State sync snapshot interval\\\")\\n\\ncmd.Flags().Uint32(FlagStateSyncSnapshotKeepRecent, 2, \\\"State sync snapshot to keep\\\")\\n\\ncmd.Flags().Bool(FlagDisableIAVLFastNode, false, \\\"Disable fast node for IAVL tree\\\")\\n\\ncmd.Flags().Int(FlagMempoolMaxTxs, mempool.DefaultMaxTx, \\\"Sets MaxTx value for the app-side mempool\\\")\\n\\n\\t// add support for all Tendermint-specific command line options\\n\\ttcmd.AddNodeFlags(cmd)\\n\\nreturn cmd\\n}\\n\\nfunc startStandAlone(ctx *Context, appCreator types.AppCreator)\\n\\nerror {\\n    addr := ctx.Viper.GetString(flagAddress)\\n    transport := ctx.Viper.GetString(flagTransport)\\n    home := ctx.Viper.GetString(flags.FlagHome)\\n\\ndb, err := openDB(home, GetAppDBBackend(ctx.Viper))\\n    if err != nil {\\n    return err\\n}\\n    traceWriterFile := ctx.Viper.GetString(flagTraceStore)\\n\\ntraceWriter, err := openTraceWriter(traceWriterFile)\\n    if err != nil {\\n    return err\\n}\\n    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)\\n\\nconfig, err := serverconfig.GetConfig(ctx.Viper)\\n    if err != nil {\\n    return err\\n}\\n\\n\\t_, err = startTelemetry(config)\\n    if err != nil {\\n    return err\\n}\\n\\nsvr, err := server.NewServer(addr, transport, app)\\n    if err != nil {\\n    return fmt.Errorf(\\\"error creating listener: %v\\\", err)\\n}\\n\\nsvr.SetLogger(ctx.Logger.With(\\\"module\\\", \\\"abci-server\\\"))\\n\\nerr = svr.Start()\\n    if err != nil {\\n    fmt.Println(err.Error())\\n\\nos.Exit(1)\\n}\\n\\ndefer func() {\\n    if err = svr.Stop(); err != nil {\\n    fmt.Println(err.Error())\\n\\nos.Exit(1)\\n}\\n\\t\\n}()\\n\\n\\t// Wait for SIGINT or SIGTERM signal\\n\\treturn WaitForQuitSignals()\\n}\\n\\nfunc startInProcess(ctx *Context, clientCtx client.Context, appCreator types.AppCreator)\\n\\nerror {\\n    cfg := ctx.Config\\n    home := cfg.RootDir\\n\\tvar cpuProfileCleanup func()\\n    if cpuProfile := ctx.Viper.GetString(flagCPUProfile); cpuProfile != \\\"\\\" {\\n    f, err := os.Create(cpuProfile)\\n    if err != nil {\\n    return err\\n}\\n\\nctx.Logger.Info(\\\"starting CPU profiler\\\", \\\"profile\\\", cpuProfile)\\n    if err := pprof.StartCPUProfile(f); err != nil {\\n    return err\\n}\\n\\ncpuProfileCleanup = func() {\\n    ctx.Logger.Info(\\\"stopping CPU profiler\\\", \\\"profile\\\", cpuProfile)\\n\\npprof.StopCPUProfile()\\n    if err := f.Close(); err != nil {\\n    ctx.Logger.Info(\\\"failed to close cpu-profile file\\\", \\\"profile\\\", cpuProfile, \\\"err\\\", err.Error())\\n}\\n\\t\\n}\\n\\t\\n}\\n\\ndb, err := openDB(home, GetAppDBBackend(ctx.Viper))\\n    if err != nil {\\n    return err\\n}\\n    traceWriterFile := ctx.Viper.GetString(flagTraceStore)\\n\\ntraceWriter, err := openTraceWriter(traceWriterFile)\\n    if err != nil {\\n    return err\\n}\\n\\n\\t// Clean up the traceWriter in the cpuProfileCleanup routine that is invoked\\n\\t// when the server is shutting down.\\n    fn := cpuProfileCleanup\\n\\tcpuProfileCleanup = func() {\\n    if fn != nil {\\n    fn()\\n}\\n\\n\\t\\t// if flagTraceStore is not used then traceWriter is nil\\n    if traceWriter != nil {\\n    if err = traceWriter.Close(); err != nil {\\n    ctx.Logger.Error(\\\"failed to close trace writer\\\", \\\"err\\\", err)\\n}\\n\\t\\n}\\n\\t\\n}\\n\\nconfig, err := serverconfig.GetConfig(ctx.Viper)\\n    if err != nil {\\n    return err\\n}\\n    if err := config.ValidateBasic(); err != nil {\\n    return err\\n}\\n    app := appCreator(ctx.Logger, db, traceWriter, ctx.Viper)\\n\\nnodeKey, err := p2p.LoadOrGenNodeKey(cfg.NodeKeyFile())\\n    if err != nil {\\n    return err\\n}\\n    genDocProvider := node.DefaultGenesisDocProviderFunc(cfg)\\n\\nvar (\\n\\t\\ttmNode   *node.Node\\n\\t\\tgRPCOnly = ctx.Viper.GetBool(flagGRPCOnly)\\n\\t)\\n    if gRPCOnly {\\n    ctx.Logger.Info(\\\"starting node in gRPC only mode; Tendermint is disabled\\\")\\n\\nconfig.GRPC.Enable = true\\n}\\n\\nelse {\\n    ctx.Logger.Info(\\\"starting node with ABCI Tendermint in-process\\\")\\n\\ntmNode, err = node.NewNode(\\n\\t\\t\\tcfg,\\n\\t\\t\\tpvm.LoadOrGenFilePV(cfg.PrivValidatorKeyFile(), cfg.PrivValidatorStateFile()),\\n\\t\\t\\tnodeKey,\\n\\t\\t\\tproxy.NewLocalClientCreator(app),\\n\\t\\t\\tgenDocProvider,\\n\\t\\t\\tnode.DefaultDBProvider,\\n\\t\\t\\tnode.DefaultMetricsProvider(cfg.Instrumentation),\\n\\t\\t\\tctx.Logger,\\n\\t\\t)\\n    if err != nil {\\n    return err\\n}\\n    if err := tmNode.Start(); err != nil {\\n    return err\\n}\\n\\t\\n}\\n\\n\\t// Add the tx service to the gRPC router. We only need to register this\\n\\t// service if API or gRPC is enabled, and avoid doing so in the general\\n\\t// case, because it spawns a new local tendermint RPC client.\\n    if (config.API.Enable || config.GRPC.Enable) && tmNode != nil {\\n\\t\\t// re-assign for making the client available below\\n\\t\\t// do not use := to avoid shadowing clientCtx\\n\\t\\tclientCtx = clientCtx.WithClient(local.New(tmNode))\\n\\napp.RegisterTxService(clientCtx)\\n\\napp.RegisterTendermintService(clientCtx)\\n\\napp.RegisterNodeService(clientCtx)\\n}\\n\\nmetrics, err := startTelemetry(config)\\n    if err != nil {\\n    return err\\n}\\n\\nvar apiSrv *api.Server\\n    if config.API.Enable {\\n    genDoc, err := genDocProvider()\\n    if err != nil {\\n    return err\\n}\\n    clientCtx := clientCtx.WithHomeDir(home).WithChainID(genDoc.ChainID)\\n    if config.GRPC.Enable {\\n\\t\\t\\t_, port, err := net.SplitHostPort(config.GRPC.Address)\\n    if err != nil {\\n    return err\\n}\\n    maxSendMsgSize := config.GRPC.MaxSendMsgSize\\n    if maxSendMsgSize == 0 {\\n    maxSendMsgSize = serverconfig.DefaultGRPCMaxSendMsgSize\\n}\\n    maxRecvMsgSize := config.GRPC.MaxRecvMsgSize\\n    if maxRecvMsgSize == 0 {\\n    maxRecvMsgSize = serverconfig.DefaultGRPCMaxRecvMsgSize\\n}\\n    grpcAddress := fmt.Sprintf(\\\"127.0.0.1:%s\\\", port)\\n\\n\\t\\t\\t// If grpc is enabled, configure grpc client for grpc gateway.\\n\\t\\t\\tgrpcClient, err := grpc.Dial(\\n\\t\\t\\t\\tgrpcAddress,\\n\\t\\t\\t\\tgrpc.WithTransportCredentials(insecure.NewCredentials()),\\n\\t\\t\\t\\tgrpc.WithDefaultCallOptions(\\n\\t\\t\\t\\t\\tgrpc.ForceCodec(codec.NewProtoCodec(clientCtx.InterfaceRegistry).GRPCCodec()),\\n\\t\\t\\t\\t\\tgrpc.MaxCallRecvMsgSize(maxRecvMsgSize),\\n\\t\\t\\t\\t\\tgrpc.MaxCallSendMsgSize(maxSendMsgSize),\\n\\t\\t\\t\\t),\\n\\t\\t\\t)\\n    if err != nil {\\n    return err\\n}\\n\\nclientCtx = clientCtx.WithGRPCClient(grpcClient)\\n\\nctx.Logger.Debug(\\\"grpc client assigned to client context\\\", \\\"target\\\", grpcAddress)\\n}\\n\\napiSrv = api.New(clientCtx, ctx.Logger.With(\\\"module\\\", \\\"api-server\\\"))\\n\\napp.RegisterAPIRoutes(apiSrv, config.API)\\n    if config.Telemetry.Enabled {\\n    apiSrv.SetTelemetry(metrics)\\n}\\n    errCh := make(chan error)\\n\\ngo func() {\\n    if err := apiSrv.Start(config); err != nil {\\n    errCh <- err\\n}\\n\\t\\n}()\\n\\nselect {\\n    case err := <-errCh:\\n\\t\\t\\treturn err\\n    case <-time.After(types.ServerStartTime): // assume server started successfully\\n}\\n\\t\\n}\\n\\nvar (\\n\\t\\tgrpcSrv    *grpc.Server\\n\\t\\tgrpcWebSrv *http.Server\\n\\t)\\n    if config.GRPC.Enable {\\n    grpcSrv, err = servergrpc.StartGRPCServer(clientCtx, app, config.GRPC)\\n    if err != nil {\\n    return err\\n}\\n\\ndefer grpcSrv.Stop()\\n    if config.GRPCWeb.Enable {\\n    grpcWebSrv, err = servergrpc.StartGRPCWeb(grpcSrv, config)\\n    if err != nil {\\n    ctx.Logger.Error(\\\"failed to start grpc-web http server: \\\", err)\\n\\nreturn err\\n}\\n\\ndefer func() {\\n    if err := grpcWebSrv.Close(); err != nil {\\n    ctx.Logger.Error(\\\"failed to close grpc-web http server: \\\", err)\\n}\\n\\t\\n}()\\n}\\n\\t\\n}\\n\\n\\t// At this point it is safe to block the process if we're in gRPC only mode as\\n\\t// we do not need to start Rosetta or handle any Tendermint related processes.\\n    if gRPCOnly {\\n\\t\\t// wait for signal capture and gracefully return\\n\\t\\treturn WaitForQuitSignals()\\n}\\n\\nvar rosettaSrv crgserver.Server\\n    if config.Rosetta.Enable {\\n    offlineMode := config.Rosetta.Offline\\n\\n\\t\\t// If GRPC is not enabled rosetta cannot work in online mode, so we throw an error.\\n    if !config.GRPC.Enable && !offlineMode {\\n    return errors.New(\\\"'grpc' must be enable in online mode for Rosetta to work\\\")\\n}\\n\\nminGasPrices, err := sdk.ParseDecCoins(config.MinGasPrices)\\n    if err != nil {\\n    ctx.Logger.Error(\\\"failed to parse minimum-gas-prices: \\\", err)\\n\\nreturn err\\n}\\n    conf := &rosetta.Config{\\n    Blockchain:          config.Rosetta.Blockchain,\\n    Network:             config.Rosetta.Network,\\n    TendermintRPC:       ctx.Config.RPC.ListenAddress,\\n    GRPCEndpoint:        config.GRPC.Address,\\n    Addr:                config.Rosetta.Address,\\n    Retries:             config.Rosetta.Retries,\\n    Offline:             offlineMode,\\n    GasToSuggest:        config.Rosetta.GasToSuggest,\\n    EnableFeeSuggestion: config.Rosetta.EnableFeeSuggestion,\\n    GasPrices:           minGasPrices.Sort(),\\n    Codec:               clientCtx.Codec.(*codec.ProtoCodec),\\n    InterfaceRegistry:   clientCtx.InterfaceRegistry,\\n}\\n\\nrosettaSrv, err = rosetta.ServerFromConfig(conf)\\n    if err != nil {\\n    return err\\n}\\n    errCh := make(chan error)\\n\\ngo func() {\\n    if err := rosettaSrv.Start(); err != nil {\\n    errCh <- err\\n}\\n\\t\\n}()\\n\\nselect {\\n    case err := <-errCh:\\n\\t\\t\\treturn err\\n    case <-time.After(types.ServerStartTime): // assume server started successfully\\n}\\n\\t\\n}\\n\\ndefer func() {\\n    if tmNode != nil && tmNode.IsRunning() {\\n\\t\\t\\t_ = tmNode.Stop()\\n}\\n    if cpuProfileCleanup != nil {\\n    cpuProfileCleanup()\\n}\\n    if apiSrv != nil {\\n\\t\\t\\t_ = apiSrv.Close()\\n}\\n\\nctx.Logger.Info(\\\"exiting...\\\")\\n}()\\n\\n\\t// wait for signal capture and gracefully return\\n\\treturn WaitForQuitSignals()\\n}\\n\\nfunc startTelemetry(cfg serverconfig.Config) (*telemetry.Metrics, error) {\\n    if !cfg.Telemetry.Enabled {\\n    return nil, nil\\n}\\n\\nreturn telemetry.New(cfg.Telemetry)\\n}\\n\\nThe start command is defined in the /server folder of the Cosmos SDK. It is added to the root command of the full-node client in the main function and called by the end-user to start their node: As a reminder, the full-node is composed of three conceptual layers: the networking layer, the consensus layer and the application layer. The first two are generally bundled together in an entity called the consensus engine (CometBFT by default), while the third is the state-machine defined with the help of the Cosmos SDK. Currently, the Cosmos SDK uses CometBFT as the default consensus engine, meaning the start command is implemented to boot up a CometBFT node. The flow of the start command is pretty straightforward. First, it retrieves the config from the context in order to open the db (a leveldb instance by default). This db contains the latest known state of the application (empty if the application is started from the first time. With the db , the start command creates a new instance of the application using an appCreator function: Note that an appCreator is a function that fulfills the AppCreator signature: package types\\n\\nimport (\\n    \\n\\t\\\"encoding/json\\\"\\n    \\\"io\\\"\\n    \\\"time\\\"\\n    \\\"github.com/cosmos/gogoproto/grpc\\\"\\n    \\\"github.com/spf13/cobra\\\"\\n\\tabci \\\"github.com/tendermint/tendermint/abci/types\\\"\\n    \\\"github.com/tendermint/tendermint/libs/log\\\"\\n\\ttmproto \\\"github.com/tendermint/tendermint/proto/tendermint/types\\\"\\n\\ttmtypes \\\"github.com/tendermint/tendermint/types\\\"\\n\\tdbm \\\"github.com/tendermint/tm-db\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server/api\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server/config\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n)\\n\\n// ServerStartTime defines the time duration that the server need to stay running after startup\\n// for the startup be considered successful\\nconst ServerStartTime = 5 * time.Second\\n\\ntype (\\n\\t// AppOptions defines an interface that is passed into an application\\n\\t// constructor, typically used to set BaseApp options that are either supplied\\n\\t// via config file or through CLI arguments/flags. The underlying implementation\\n\\t// is defined by the server package and is typically implemented via a Viper\\n\\t// literal defined on the server Context. Note, casting Get calls may not yield\\n\\t// the expected types and could result in type assertion errors. It is recommend\\n\\t// to either use the cast package or perform manual conversion for safety.\\n\\tAppOptions interface {\\n    Get(string)\\n\\ninterface{\\n}\\n\\t\\n}\\n\\n\\t// Application defines an application interface that wraps abci.Application.\\n\\t// The interface defines the necessary contracts to be implemented in order\\n\\t// to fully bootstrap and start an application.\\n\\tApplication interface {\\n    abci.Application\\n\\n\\t\\tRegisterAPIRoutes(*api.Server, config.APIConfig)\\n\\n\\t\\t// RegisterGRPCServer registers gRPC services directly with the gRPC\\n\\t\\t// server.\\n\\t\\tRegisterGRPCServer(grpc.Server)\\n\\n\\t\\t// RegisterTxService registers the gRPC Query service for tx (such as tx\\n\\t\\t// simulation, fetching txs by hash...).\\n\\t\\tRegisterTxService(client.Context)\\n\\n\\t\\t// RegisterTendermintService registers the gRPC Query service for tendermint queries.\\n\\t\\tRegisterTendermintService(client.Context)\\n\\n\\t\\t// RegisterNodeService registers the node gRPC Query service.\\n\\t\\tRegisterNodeService(client.Context)\\n\\n\\t\\t// CommitMultiStore return the multistore instance\\n\\t\\tCommitMultiStore()\\n\\nsdk.CommitMultiStore\\n}\\n\\n\\t// AppCreator is a function that allows us to lazily initialize an\\n\\t// application using various configurations.\\n\\tAppCreator func(log.Logger, dbm.DB, io.Writer, AppOptions)\\n\\nApplication\\n\\n\\t// ModuleInitFlags takes a start command and adds modules specific init flags.\\n\\tModuleInitFlags func(startCmd *cobra.Command)\\n\\n\\t// ExportedApp represents an exported app state, along with\\n\\t// validators, consensus params and latest app height.\\n\\tExportedApp struct {\\n\\t\\t// AppState is the application state as JSON.\\n\\t\\tAppState json.RawMessage\\n\\t\\t// Validators is the exported validator set.\\n\\t\\tValidators []tmtypes.GenesisValidator\\n\\t\\t// Height is the app's latest block height.\\n\\t\\tHeight int64\\n\\t\\t// ConsensusParams are the exported consensus params for ABCI.\\n\\t\\tConsensusParams *tmproto.ConsensusParams\\n}\\n\\n\\t// AppExporter is a function that dumps all app state to\\n\\t// JSON-serializable structure and returns the current validator set.\\n\\tAppExporter func(log.Logger, dbm.DB, io.Writer, int64, bool, []string, AppOptions, []string) (ExportedApp, error)\\n)\\n\\n\", \"Title: Root Command\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/learn/advanced/cli\\nContent: The root command (called rootCmd ) is what the user first types into the command line to indicate which application they wish to interact with. The string used to invoke the command (the \\\"Use\\\" field) is typically the name of the application suffixed with -d , e.g. simd or gaiad . The root command typically includes the following commands to support basic functionality in the application. Status command from the Cosmos SDK rpc client tools, which prints information about the status of the connected Node . The Status of a node includes NodeInfo, SyncInfo and ValidatorInfo. Keys commands from the Cosmos SDK client tools, which includes a collection of subcommands for using the key functions in the Cosmos SDK crypto tools, including adding a new key and saving it to the keyring, listing all public keys stored in the keyring, and deleting a key. For example, users can type simd keys add <name> to add a new key and save an encrypted copy to the keyring, using the flag --recover to recover a private key from a seed phrase or the flag --multisig to group multiple keys together to create a multisig key. For full details on the add key command, see the code here . For more details about usage of --keyring-backend for storage of key credentials look at the keyring docs. Server commands from the Cosmos SDK server package. These commands are responsible for providing the mechanisms necessary to start an ABCI CometBFT application and provides the CLI framework (based on cobra ) necessary to fully bootstrap an application. The package exposes two core functions: StartCmd and ExportCmd which creates commands to start the application and export state respectively.\\nLearn more here. Transaction commands. Query commands. Next is an example rootCmd function from the simapp application. It instantiates the root command, adds a persistent flag and PreRun function to be run before every execution, and adds all of the necessary subcommands. package cmd\\n\\nimport (\\n    \\n\\t\\\"errors\\\"\\n    \\\"io\\\"\\n    \\\"os\\\"\\n\\n\\trosettaCmd \\\"cosmossdk.io/tools/rosetta/cmd\\\"\\n    \\\"github.com/spf13/cobra\\\"\\n    \\\"github.com/spf13/viper\\\"\\n\\ttmcfg \\\"github.com/tendermint/tendermint/config\\\"\\n    \\\"github.com/tendermint/tendermint/libs/log\\\"\\n\\tdbm \\\"github.com/tendermint/tm-db\\\"\\n    \\\"cosmossdk.io/simapp\\\"\\n    \\\"cosmossdk.io/simapp/params\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/config\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/debug\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/flags\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/keys\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/pruning\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/rpc\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server\\\"\\n\\tserverconfig \\\"github.com/cosmos/cosmos-sdk/server/config\\\"\\n\\tservertypes \\\"github.com/cosmos/cosmos-sdk/server/types\\\"\\n\\tsimtestutil \\\"github.com/cosmos/cosmos-sdk/testutil/sims\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\tauthcmd \\\"github.com/cosmos/cosmos-sdk/x/auth/client/cli\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/auth/types\\\"\\n\\tbanktypes \\\"github.com/cosmos/cosmos-sdk/x/bank/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/crisis\\\"\\n\\tgenutilcli \\\"github.com/cosmos/cosmos-sdk/x/genutil/client/cli\\\"\\n)\\n\\n// NewRootCmd creates a new root command for simd. It is called once in the\\n// main function.\\nfunc NewRootCmd() *cobra.Command {\\n\\t// we \\\"pre\\\"-instantiate the application for getting the injected/configured encoding configuration\\n    tempApp := simapp.NewSimApp(log.NewNopLogger(), dbm.NewMemDB(), nil, true, simtestutil.NewAppOptionsWithFlagHome(simapp.DefaultNodeHome))\\n    encodingConfig := params.EncodingConfig{\\n    InterfaceRegistry: tempApp.InterfaceRegistry(),\\n    Codec:             tempApp.AppCodec(),\\n    TxConfig:          tempApp.TxConfig(),\\n    Amino:             tempApp.LegacyAmino(),\\n}\\n    initClientCtx := client.Context{\\n}.\\n\\t\\tWithCodec(encodingConfig.Codec).\\n\\t\\tWithInterfaceRegistry(encodingConfig.InterfaceRegistry).\\n\\t\\tWithTxConfig(encodingConfig.TxConfig).\\n\\t\\tWithLegacyAmino(encodingConfig.Amino).\\n\\t\\tWithInput(os.Stdin).\\n\\t\\tWithAccountRetriever(types.AccountRetriever{\\n}).\\n\\t\\tWithHomeDir(simapp.DefaultNodeHome).\\n\\t\\tWithViper(\\\"\\\") // In simapp, we don't use any prefix for env variables.\\n    rootCmd := &cobra.Command{\\n    Use:   \\\"simd\\\",\\n    Short: \\\"simulation app\\\",\\n    PersistentPreRunE: func(cmd *cobra.Command, _ []string)\\n\\nerror {\\n\\t\\t\\t// set the default command outputs\\n\\t\\t\\tcmd.SetOut(cmd.OutOrStdout())\\n\\ncmd.SetErr(cmd.ErrOrStderr())\\n\\ninitClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())\\n    if err != nil {\\n    return err\\n}\\n\\ninitClientCtx, err = config.ReadFromClientConfig(initClientCtx)\\n    if err != nil {\\n    return err\\n}\\n    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {\\n    return err\\n}\\n\\ncustomAppTemplate, customAppConfig := initAppConfig()\\n    customTMConfig := initTendermintConfig()\\n\\nreturn server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customTMConfig)\\n},\\n}\\n\\ninitRootCmd(rootCmd, encodingConfig)\\n\\nreturn rootCmd\\n}\\n\\n// initTendermintConfig helps to override default Tendermint Config values.\\n// return tmcfg.DefaultConfig if no custom configuration is required for the application.\\nfunc initTendermintConfig() *tmcfg.Config {\\n    cfg := tmcfg.DefaultConfig()\\n\\n\\t// these values put a higher strain on node memory\\n\\t// cfg.P2P.MaxNumInboundPeers = 100\\n\\t// cfg.P2P.MaxNumOutboundPeers = 40\\n\\n\\treturn cfg\\n}\\n\\n// initAppConfig helps to override default appConfig template and configs.\\n// return \\\"\\\", nil if no custom configuration is required for the application.\\nfunc initAppConfig() (string, interface{\\n}) {\\n\\t// The following code snippet is just for reference.\\n\\n\\t// WASMConfig defines configuration for the wasm module.\\n\\ttype WASMConfig struct {\\n\\t\\t// This is the maximum sdk gas (wasm and storage)\\n\\nthat we allow for any x/wasm \\\"smart\\\" queries\\n\\t\\tQueryGasLimit uint64 `mapstructure:\\\"query_gas_limit\\\"`\\n\\n\\t\\t// Address defines the gRPC-web server to listen on\\n\\t\\tLruSize uint64 `mapstructure:\\\"lru_size\\\"`\\n}\\n\\ntype CustomAppConfig struct {\\n    serverconfig.Config\\n\\n\\t\\tWASM WASMConfig `mapstructure:\\\"wasm\\\"`\\n}\\n\\n\\t// Optionally allow the chain developer to overwrite the SDK's default\\n\\t// server config.\\n    srvCfg := serverconfig.DefaultConfig()\\n\\t// The SDK's default minimum gas price is set to \\\"\\\" (empty value)\\n\\ninside\\n\\t// app.toml. If left empty by validators, the node will halt on startup.\\n\\t// However, the chain developer can set a default app.toml value for their\\n\\t// validators here.\\n\\t//\\n\\t// In summary:\\n\\t// - if you leave srvCfg.MinGasPrices = \\\"\\\", all validators MUST tweak their\\n\\t//   own app.toml config,\\n\\t// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their\\n\\t//   own app.toml to override, or use this default value.\\n\\t//\\n\\t// In simapp, we set the min gas prices to 0.\\n\\tsrvCfg.MinGasPrices = \\\"0stake\\\"\\n\\t// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default\\n    customAppConfig := CustomAppConfig{\\n    Config: *srvCfg,\\n    WASM: WASMConfig{\\n    LruSize:       1,\\n    QueryGasLimit: 300000,\\n},\\n}\\n    customAppTemplate := serverconfig.DefaultConfigTemplate + `\\n[wasm]\\n# This is the maximum sdk gas (wasm and storage)\\n\\nthat we allow for any x/wasm \\\"smart\\\" queries\\nquery_gas_limit = 300000\\n# This is the number of wasm vm instances we keep cached in memory for speed-up\\n# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally\\nlru_size = 0`\\n\\n\\treturn customAppTemplate, customAppConfig\\n}\\n\\nfunc initRootCmd(rootCmd *cobra.Command, encodingConfig params.EncodingConfig) {\\n    cfg := sdk.GetConfig()\\n\\ncfg.Seal()\\n\\nrootCmd.AddCommand(\\n\\t\\tgenutilcli.InitCmd(simapp.ModuleBasics, simapp.DefaultNodeHome),\\n\\t\\tNewTestnetCmd(simapp.ModuleBasics, banktypes.GenesisBalancesIterator{\\n}),\\n\\t\\tdebug.Cmd(),\\n\\t\\tconfig.Cmd(),\\n\\t\\tpruning.PruningCmd(newApp),\\n\\t)\\n\\nserver.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)\\n\\n\\t// add keybase, auxiliary RPC, query, genesis, and tx child commands\\n\\trootCmd.AddCommand(\\n\\t\\trpc.StatusCommand(),\\n\\t\\tgenesisCommand(encodingConfig),\\n\\t\\tqueryCommand(),\\n\\t\\ttxCommand(),\\n\\t\\tkeys.Commands(simapp.DefaultNodeHome),\\n\\t)\\n\\n\\t// add rosetta\\n\\trootCmd.AddCommand(rosettaCmd.RosettaCommand(encodingConfig.InterfaceRegistry, encodingConfig.Codec))\\n}\\n\\nfunc addModuleInitFlags(startCmd *cobra.Command) {\\n    crisis.AddModuleInitFlags(startCmd)\\n}\\n\\n// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter\\nfunc genesisCommand(encodingConfig params.EncodingConfig, cmds ...*cobra.Command) *cobra.Command {\\n    cmd := genutilcli.GenesisCoreCommand(encodingConfig.TxConfig, simapp.ModuleBasics, simapp.DefaultNodeHome)\\n    for _, sub_cmd := range cmds {\\n    cmd.AddCommand(sub_cmd)\\n}\\n\\nreturn cmd\\n}\\n\\nfunc queryCommand() *cobra.Command {\\n    cmd := &cobra.Command{\\n    Use:                        \\\"query\\\",\\n    Aliases:                    []string{\\\"q\\\"\\n},\\n    Short:                      \\\"Querying subcommands\\\",\\n    DisableFlagParsing:         false,\\n    SuggestionsMinimumDistance: 2,\\n    RunE:                       client.ValidateCmd,\\n}\\n\\ncmd.AddCommand(\\n\\t\\tauthcmd.GetAccountCmd(),\\n\\t\\trpc.ValidatorCommand(),\\n\\t\\trpc.BlockCommand(),\\n\\t\\tauthcmd.QueryTxsByEventsCmd(),\\n\\t\\tauthcmd.QueryTxCmd(),\\n\\t)\\n\\nsimapp.ModuleBasics.AddQueryCommands(cmd)\\n\\nreturn cmd\\n}\\n\\nfunc txCommand() *cobra.Command {\\n    cmd := &cobra.Command{\\n    Use:                        \\\"tx\\\",\\n    Short:                      \\\"Transactions subcommands\\\",\\n    DisableFlagParsing:         false,\\n    SuggestionsMinimumDistance: 2,\\n    RunE:                       client.ValidateCmd,\\n}\\n\\ncmd.AddCommand(\\n\\t\\tauthcmd.GetSignCommand(),\\n\\t\\tauthcmd.GetSignBatchCommand(),\\n\\t\\tauthcmd.GetMultiSignCommand(),\\n\\t\\tauthcmd.GetMultiSignBatchCmd(),\\n\\t\\tauthcmd.GetValidateSignaturesCommand(),\\n\\t\\tauthcmd.GetBroadcastCommand(),\\n\\t\\tauthcmd.GetEncodeCommand(),\\n\\t\\tauthcmd.GetDecodeCommand(),\\n\\t\\tauthcmd.GetAuxToFeeCommand(),\\n\\t)\\n\\nsimapp.ModuleBasics.AddTxCommands(cmd)\\n\\nreturn cmd\\n}\\n\\n// newApp creates the application\\nfunc newApp(\\n\\tlogger log.Logger,\\n\\tdb dbm.DB,\\n\\ttraceStore io.Writer,\\n\\tappOpts servertypes.AppOptions,\\n)\\n\\nservertypes.Application {\\n    baseappOptions := server.DefaultBaseappOptions(appOpts)\\n\\nreturn simapp.NewSimApp(\\n\\t\\tlogger, db, traceStore, true,\\n\\t\\tappOpts,\\n\\t\\tbaseappOptions...,\\n\\t)\\n}\\n\\n// appExport creates a new simapp (optionally at a given height)\\n\\nand exports state.\\nfunc appExport(\\n\\tlogger log.Logger,\\n\\tdb dbm.DB,\\n\\ttraceStore io.Writer,\\n\\theight int64,\\n    forZeroHeight bool,\\n\\tjailAllowedAddrs []string,\\n\\tappOpts servertypes.AppOptions,\\n\\tmodulesToExport []string,\\n) (servertypes.ExportedApp, error) {\\n    var simApp *simapp.SimApp\\n\\n\\t// this check is necessary as we use the flag in x/upgrade.\\n\\t// we can exit more gracefully by checking the flag here.\\n\\thomePath, ok := appOpts.Get(flags.FlagHome).(string)\\n    if !ok || homePath == \\\"\\\" {\\n    return servertypes.ExportedApp{\\n}, errors.New(\\\"application home not set\\\")\\n}\\n\\nviperAppOpts, ok := appOpts.(*viper.Viper)\\n    if !ok {\\n    return servertypes.ExportedApp{\\n}, errors.New(\\\"appOpts is not viper.Viper\\\")\\n}\\n\\n\\t// overwrite the FlagInvCheckPeriod\\n\\tviperAppOpts.Set(server.FlagInvCheckPeriod, 1)\\n\\nappOpts = viperAppOpts\\n    if height != -1 {\\n    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)\\n    if err := simApp.LoadHeight(height); err != nil {\\n    return servertypes.ExportedApp{\\n}, err\\n}\\n\\t\\n}\\n\\nelse {\\n    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)\\n}\\n\\nreturn simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)\\n}\\n\\nQuery Commands\\nQueries are objects that allow users to retrieve information about the application's state. To enable the creation of queries using the CLI interface, a function queryCommand is generally added to the rootCmd: This queryCommand function adds all the queries available to end-users for the application. This typically includes: QueryTx and/or other transaction query commands] from the auth module which allow the user to search for a transaction by inputting its hash, a list of tags, or a block height. These queries allow users to see if transactions have been included in a block. Account command from the auth module, which displays the state (e.g. account balance) of an account given an address. Validator command from the Cosmos SDK rpc client tools, which displays the validator set of a given height. Block command from the Cosmos SDK RPC client tools, which displays the block data for a given height. All module query commands the application is dependent on, retrieved by using the basic module manager's AddQueryCommands() function. Here is an example of a queryCommand aggregating subcommands from the simapp application: package cmd\\n\\nimport (\\n    \\n\\t\\\"errors\\\"\\n    \\\"io\\\"\\n    \\\"os\\\"\\n\\n\\trosettaCmd \\\"cosmossdk.io/tools/rosetta/cmd\\\"\\n    \\\"github.com/spf13/cobra\\\"\\n    \\\"github.com/spf13/viper\\\"\\n\\ttmcfg \\\"github.com/tendermint/tendermint/config\\\"\\n    \\\"github.com/tendermint/tendermint/libs/log\\\"\\n\\tdbm \\\"github.com/tendermint/tm-db\\\"\\n    \\\"cosmossdk.io/simapp\\\"\\n    \\\"cosmossdk.io/simapp/params\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/config\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/debug\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/flags\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/keys\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/pruning\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/rpc\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server\\\"\\n\\tserverconfig \\\"github.com/cosmos/cosmos-sdk/server/config\\\"\\n\\tservertypes \\\"github.com/cosmos/cosmos-sdk/server/types\\\"\\n\\tsimtestutil \\\"github.com/cosmos/cosmos-sdk/testutil/sims\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n\\tauthcmd \\\"github.com/cosmos/cosmos-sdk/x/auth/client/cli\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/auth/types\\\"\\n\\tbanktypes \\\"github.com/cosmos/cosmos-sdk/x/bank/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/crisis\\\"\\n\\tgenutilcli \\\"github.com/cosmos/cosmos-sdk/x/genutil/client/cli\\\"\\n)\\n\\n// NewRootCmd creates a new root command for simd. It is called once in the\\n// main function.\\nfunc NewRootCmd() *cobra.Command {\\n\\t// we \\\"pre\\\"-instantiate the application for getting the injected/configured encoding configuration\\n    tempApp := simapp.NewSimApp(log.NewNopLogger(), dbm.NewMemDB(), nil, true, simtestutil.NewAppOptionsWithFlagHome(simapp.DefaultNodeHome))\\n    encodingConfig := params.EncodingConfig{\\n    InterfaceRegistry: tempApp.InterfaceRegistry(),\\n    Codec:             tempApp.AppCodec(),\\n    TxConfig:          tempApp.TxConfig(),\\n    Amino:             tempApp.LegacyAmino(),\\n}\\n    initClientCtx := client.Context{\\n}.\\n\\t\\tWithCodec(encodingConfig.Codec).\\n\\t\\tWithInterfaceRegistry(encodingConfig.InterfaceRegistry).\\n\\t\\tWithTxConfig(encodingConfig.TxConfig).\\n\\t\\tWithLegacyAmino(encodingConfig.Amino).\\n\\t\\tWithInput(os.Stdin).\\n\\t\\tWithAccountRetriever(types.AccountRetriever{\\n}).\\n\\t\\tWithHomeDir(simapp.DefaultNodeHome).\\n\\t\\tWithViper(\\\"\\\") // In simapp, we don't use any prefix for env variables.\\n    rootCmd := &cobra.Command{\\n    Use:   \\\"simd\\\",\\n    Short: \\\"simulation app\\\",\\n    PersistentPreRunE: func(cmd *cobra.Command, _ []string)\\n\\nerror {\\n\\t\\t\\t// set the default command outputs\\n\\t\\t\\tcmd.SetOut(cmd.OutOrStdout())\\n\\ncmd.SetErr(cmd.ErrOrStderr())\\n\\ninitClientCtx, err := client.ReadPersistentCommandFlags(initClientCtx, cmd.Flags())\\n    if err != nil {\\n    return err\\n}\\n\\ninitClientCtx, err = config.ReadFromClientConfig(initClientCtx)\\n    if err != nil {\\n    return err\\n}\\n    if err := client.SetCmdClientContextHandler(initClientCtx, cmd); err != nil {\\n    return err\\n}\\n\\ncustomAppTemplate, customAppConfig := initAppConfig()\\n    customTMConfig := initTendermintConfig()\\n\\nreturn server.InterceptConfigsPreRunHandler(cmd, customAppTemplate, customAppConfig, customTMConfig)\\n},\\n}\\n\\ninitRootCmd(rootCmd, encodingConfig)\\n\\nreturn rootCmd\\n}\\n\\n// initTendermintConfig helps to override default Tendermint Config values.\\n// return tmcfg.DefaultConfig if no custom configuration is required for the application.\\nfunc initTendermintConfig() *tmcfg.Config {\\n    cfg := tmcfg.DefaultConfig()\\n\\n\\t// these values put a higher strain on node memory\\n\\t// cfg.P2P.MaxNumInboundPeers = 100\\n\\t// cfg.P2P.MaxNumOutboundPeers = 40\\n\\n\\treturn cfg\\n}\\n\\n// initAppConfig helps to override default appConfig template and configs.\\n// return \\\"\\\", nil if no custom configuration is required for the application.\\nfunc initAppConfig() (string, interface{\\n}) {\\n\\t// The following code snippet is just for reference.\\n\\n\\t// WASMConfig defines configuration for the wasm module.\\n\\ttype WASMConfig struct {\\n\\t\\t// This is the maximum sdk gas (wasm and storage)\\n\\nthat we allow for any x/wasm \\\"smart\\\" queries\\n\\t\\tQueryGasLimit uint64 `mapstructure:\\\"query_gas_limit\\\"`\\n\\n\\t\\t// Address defines the gRPC-web server to listen on\\n\\t\\tLruSize uint64 `mapstructure:\\\"lru_size\\\"`\\n}\\n\\ntype CustomAppConfig struct {\\n    serverconfig.Config\\n\\n\\t\\tWASM WASMConfig `mapstructure:\\\"wasm\\\"`\\n}\\n\\n\\t// Optionally allow the chain developer to overwrite the SDK's default\\n\\t// server config.\\n    srvCfg := serverconfig.DefaultConfig()\\n\\t// The SDK's default minimum gas price is set to \\\"\\\" (empty value)\\n\\ninside\\n\\t// app.toml. If left empty by validators, the node will halt on startup.\\n\\t// However, the chain developer can set a default app.toml value for their\\n\\t// validators here.\\n\\t//\\n\\t// In summary:\\n\\t// - if you leave srvCfg.MinGasPrices = \\\"\\\", all validators MUST tweak their\\n\\t//   own app.toml config,\\n\\t// - if you set srvCfg.MinGasPrices non-empty, validators CAN tweak their\\n\\t//   own app.toml to override, or use this default value.\\n\\t//\\n\\t// In simapp, we set the min gas prices to 0.\\n\\tsrvCfg.MinGasPrices = \\\"0stake\\\"\\n\\t// srvCfg.BaseConfig.IAVLDisableFastNode = true // disable fastnode by default\\n    customAppConfig := CustomAppConfig{\\n    Config: *srvCfg,\\n    WASM: WASMConfig{\\n    LruSize:       1,\\n    QueryGasLimit: 300000,\\n},\\n}\\n    customAppTemplate := serverconfig.DefaultConfigTemplate + `\\n[wasm]\\n# This is the maximum sdk gas (wasm and storage)\\n\\nthat we allow for any x/wasm \\\"smart\\\" queries\\nquery_gas_limit = 300000\\n# This is the number of wasm vm instances we keep cached in memory for speed-up\\n# Warning: this is currently unstable and may lead to crashes, best to keep for 0 unless testing locally\\nlru_size = 0`\\n\\n\\treturn customAppTemplate, customAppConfig\\n}\\n\\nfunc initRootCmd(rootCmd *cobra.Command, encodingConfig params.EncodingConfig) {\\n    cfg := sdk.GetConfig()\\n\\ncfg.Seal()\\n\\nrootCmd.AddCommand(\\n\\t\\tgenutilcli.InitCmd(simapp.ModuleBasics, simapp.DefaultNodeHome),\\n\\t\\tNewTestnetCmd(simapp.ModuleBasics, banktypes.GenesisBalancesIterator{\\n}),\\n\\t\\tdebug.Cmd(),\\n\\t\\tconfig.Cmd(),\\n\\t\\tpruning.PruningCmd(newApp),\\n\\t)\\n\\nserver.AddCommands(rootCmd, simapp.DefaultNodeHome, newApp, appExport, addModuleInitFlags)\\n\\n\\t// add keybase, auxiliary RPC, query, genesis, and tx child commands\\n\\trootCmd.AddCommand(\\n\\t\\trpc.StatusCommand(),\\n\\t\\tgenesisCommand(encodingConfig),\\n\\t\\tqueryCommand(),\\n\\t\\ttxCommand(),\\n\\t\\tkeys.Commands(simapp.DefaultNodeHome),\\n\\t)\\n\\n\\t// add rosetta\\n\\trootCmd.AddCommand(rosettaCmd.RosettaCommand(encodingConfig.InterfaceRegistry, encodingConfig.Codec))\\n}\\n\\nfunc addModuleInitFlags(startCmd *cobra.Command) {\\n    crisis.AddModuleInitFlags(startCmd)\\n}\\n\\n// genesisCommand builds genesis-related `simd genesis` command. Users may provide application specific commands as a parameter\\nfunc genesisCommand(encodingConfig params.EncodingConfig, cmds ...*cobra.Command) *cobra.Command {\\n    cmd := genutilcli.GenesisCoreCommand(encodingConfig.TxConfig, simapp.ModuleBasics, simapp.DefaultNodeHome)\\n    for _, sub_cmd := range cmds {\\n    cmd.AddCommand(sub_cmd)\\n}\\n\\nreturn cmd\\n}\\n\\nfunc queryCommand() *cobra.Command {\\n    cmd := &cobra.Command{\\n    Use:                        \\\"query\\\",\\n    Aliases:                    []string{\\\"q\\\"\\n},\\n    Short:                      \\\"Querying subcommands\\\",\\n    DisableFlagParsing:         false,\\n    SuggestionsMinimumDistance: 2,\\n    RunE:                       client.ValidateCmd,\\n}\\n\\ncmd.AddCommand(\\n\\t\\tauthcmd.GetAccountCmd(),\\n\\t\\trpc.ValidatorCommand(),\\n\\t\\trpc.BlockCommand(),\\n\\t\\tauthcmd.QueryTxsByEventsCmd(),\\n\\t\\tauthcmd.QueryTxCmd(),\\n\\t)\\n\\nsimapp.ModuleBasics.AddQueryCommands(cmd)\\n\\nreturn cmd\\n}\\n\\nfunc txCommand() *cobra.Command {\\n    cmd := &cobra.Command{\\n    Use:                        \\\"tx\\\",\\n    Short:                      \\\"Transactions subcommands\\\",\\n    DisableFlagParsing:         false,\\n    SuggestionsMinimumDistance: 2,\\n    RunE:                       client.ValidateCmd,\\n}\\n\\ncmd.AddCommand(\\n\\t\\tauthcmd.GetSignCommand(),\\n\\t\\tauthcmd.GetSignBatchCommand(),\\n\\t\\tauthcmd.GetMultiSignCommand(),\\n\\t\\tauthcmd.GetMultiSignBatchCmd(),\\n\\t\\tauthcmd.GetValidateSignaturesCommand(),\\n\\t\\tauthcmd.GetBroadcastCommand(),\\n\\t\\tauthcmd.GetEncodeCommand(),\\n\\t\\tauthcmd.GetDecodeCommand(),\\n\\t\\tauthcmd.GetAuxToFeeCommand(),\\n\\t)\\n\\nsimapp.ModuleBasics.AddTxCommands(cmd)\\n\\nreturn cmd\\n}\\n\\n// newApp creates the application\\nfunc newApp(\\n\\tlogger log.Logger,\\n\\tdb dbm.DB,\\n\\ttraceStore io.Writer,\\n\\tappOpts servertypes.AppOptions,\\n)\\n\\nservertypes.Application {\\n    baseappOptions := server.DefaultBaseappOptions(appOpts)\\n\\nreturn simapp.NewSimApp(\\n\\t\\tlogger, db, traceStore, true,\\n\\t\\tappOpts,\\n\\t\\tbaseappOptions...,\\n\\t)\\n}\\n\\n// appExport creates a new simapp (optionally at a given height)\\n\\nand exports state.\\nfunc appExport(\\n\\tlogger log.Logger,\\n\\tdb dbm.DB,\\n\\ttraceStore io.Writer,\\n\\theight int64,\\n    forZeroHeight bool,\\n\\tjailAllowedAddrs []string,\\n\\tappOpts servertypes.AppOptions,\\n\\tmodulesToExport []string,\\n) (servertypes.ExportedApp, error) {\\n    var simApp *simapp.SimApp\\n\\n\\t// this check is necessary as we use the flag in x/upgrade.\\n\\t// we can exit more gracefully by checking the flag here.\\n\\thomePath, ok := appOpts.Get(flags.FlagHome).(string)\\n    if !ok || homePath == \\\"\\\" {\\n    return servertypes.ExportedApp{\\n}, errors.New(\\\"application home not set\\\")\\n}\\n\\nviperAppOpts, ok := appOpts.(*viper.Viper)\\n    if !ok {\\n    return servertypes.ExportedApp{\\n}, errors.New(\\\"appOpts is not viper.Viper\\\")\\n}\\n\\n\\t// overwrite the FlagInvCheckPeriod\\n\\tviperAppOpts.Set(server.FlagInvCheckPeriod, 1)\\n\\nappOpts = viperAppOpts\\n    if height != -1 {\\n    simApp = simapp.NewSimApp(logger, db, traceStore, false, appOpts)\\n    if err := simApp.LoadHeight(height); err != nil {\\n    return servertypes.ExportedApp{\\n}, err\\n}\\n\\t\\n}\\n\\nelse {\\n    simApp = simapp.NewSimApp(logger, db, traceStore, true, appOpts)\\n}\\n\\nreturn simApp.ExportAppStateAndValidators(forZeroHeight, jailAllowedAddrs, modulesToExport)\\n}\\n\\nExample Command\\nThere is no set way to create a CLI, but Cosmos SDK modules typically use the Cobra Library . Building a CLI with Cobra entails defining commands, arguments, and flags. Commands understand the actions users wish to take, such as tx for creating a transaction and query for querying the application. Each command can also have nested subcommands, necessary for naming the specific transaction type. Users also supply Arguments , such as account numbers to send coins to, and Flags to modify various aspects of the commands, such as gas prices or which node to broadcast to. Here is an example of a command a user might enter to interact with the simapp CLI simd in order to send some tokens: The first four strings specify the command: The root command for the entire application simd. The subcommand tx , which contains all commands that let users create transactions. The subcommand bank to indicate which module to route the command to ( x/bank module in this case). The type of transaction send. The next two strings are arguments: the from_address the user wishes to send from, the to_address of the recipient, and the amount they want to send. Finally, the last few strings of the command are optional flags to indicate how much the user is willing to pay in fees (calculated using the amount of gas used to execute the transaction and the gas prices provided by the user). The CLI interacts with a node to handle this command. The interface itself is defined in a main.go file.\\n\\n\", \"Title: Transactions\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/build/modules/staking/README\\nContent: The tx commands allows users to interact with the staking module. create-validator The command create-validator allows users to create new validator initialized with a self-delegation to it. Usage: Example: where validator.json contains: and pubkey can be obtained by using simd tendermint show-validator command. delegate The command delegate allows users to delegate liquid tokens to a validator. Usage: Example: edit-validator The command edit-validator allows users to edit an existing validator account. Usage: Example: simd tx staking edit-validator --moniker \\\"new_moniker_name\\\" --website \\\"new_webiste_url\\\" --from mykey\\n\\nThe tx commands allows users to interact with the staking module. create-validator The command create-validator allows users to create new validator initialized with a self-delegation to it. Usage: Example: where validator.json contains: and pubkey can be obtained by using simd tendermint show-validator command. delegate The command delegate allows users to delegate liquid tokens to a validator. Usage: Example: edit-validator The command edit-validator allows users to edit an existing validator account. Usage: simd tx staking edit-validator [flags]\\n\\nThe tx commands allows users to interact with the staking module. create-validator The command create-validator allows users to create new validator initialized with a self-delegation to it. Usage: Example: where validator.json contains: and pubkey can be obtained by using simd tendermint show-validator command. delegate The command delegate allows users to delegate liquid tokens to a validator. Usage: Example: edit-validator The command edit-validator allows users to edit an existing validator account. Usage: Example: redelegate The command redelegate allows users to redelegate illiquid tokens from one validator to another. Usage: Example: unbond The command unbond allows users to unbond shares from a validator. Usage: Example: cancel unbond The command cancel-unbond allow users to cancel the unbonding delegation entry and delegate back to the original validator. Usage: simd tx staking cancel-unbond [validator-addr] [amount] [creation-height]\\n\\n\"]",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "tool",
            "name": "SearchCosmosDocumentation",
            "id": "cb6660b9-4ad7-4c2b-bb20-6a4a07dc09bc",
            "tool_call_id": "call_HRZbKAaUD0OuzfVd9aE3EvdU",
            "artifact": null,
            "status": "success"
        },
        {
            "content": "",
            "additional_kwargs": {
                "tool_calls": [
                    {
                        "id": "call_GE0cpJz1eiXhTHfeNIONgZUR",
                        "function": {
                            "arguments": "{\"query\":\"eth_getFilterChanges evm cosmos\"}",
                            "name": "SearchCosmosDocumentation"
                        },
                        "type": "function"
                    }
                ],
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 479,
                    "prompt_tokens": 26651,
                    "total_tokens": 27130,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 448,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CPvjHVzYmBuAsKvLTBoECUMYbubrg",
                "service_tier": "default",
                "finish_reason": "tool_calls",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--fe324569-9bdb-40b5-b602-f9a4a34469df-0",
            "example": false,
            "tool_calls": [
                {
                    "name": "SearchCosmosDocumentation",
                    "args": {
                        "query": "eth_getFilterChanges evm cosmos"
                    },
                    "id": "call_GE0cpJz1eiXhTHfeNIONgZUR",
                    "type": "tool_call"
                }
            ],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 26651,
                "output_tokens": 479,
                "total_tokens": 27130,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 448
                }
            }
        },
        {
            "content": "[\"Title: eth_getFilterChanges\\nLink: https://evm.cosmos.network/docs/evm/next/api-reference/ethereum-json-rpc/methods\\nContent: Polling method for a filter, which returns an array of logs which occurred since last poll.\\n\\neth_getFilterLogs\\nReturns an array of all logs matching filter with given id.\\n\\neth_newPendingTransactionFilter\\nCreates a filter in the node, to notify when new pending transactions arrive.\\n\\n\", \"Title: eth_getFilterChanges\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/api-reference/ethereum-json-rpc/methods\\nContent: Polling method for a filter, which returns an array of logs which occurred since last poll.\\n\\neth_getFilterLogs\\nReturns an array of all logs matching filter with given id.\\n\\neth_newPendingTransactionFilter\\nCreates a filter in the node, to notify when new pending transactions arrive.\\n\\n\", \"Title: Filters\u200b\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/api-reference/ethereum-json-rpc/index\\nContent: Cosmos EVM also supports the Ethereum JSON-RPC filters calls to subscribe to state logs , blocks or pending transactions changes. Under the hood, it uses the CometBFT RPC client's event system to process subscriptions that are then formatted to Ethereum-compatible events. Then you can check if the state changes with the eth_getFilterChanges call:\\n\\nCosmos EVM also supports the Ethereum JSON-RPC filters calls to subscribe to state logs , blocks or pending transactions changes. Under the hood, it uses the CometBFT RPC client's event system to process subscriptions that are then formatted to Ethereum-compatible events. Then you can check if the state changes with the eth_getFilterChanges call: curl -X POST --data '{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_getFilterChanges\\\",\\\"params\\\":[\\\"0x3503de5f0c766c68f78a03a3b05036a5\\\"],\\\"id\\\":1}' -H \\\"Content-Type: application/json\\\" http://localhost:8545{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"result\\\":[\\\"0x7d44dceff05d5963b5bc81df7e9f79b27e777b0a03a6feca09f3447b99c6fa71\\\",\\\"0x3961e4050c27ce0145d375255b3cb829a5b4e795ac475c05a219b3733723d376\\\",\\\"0xd7a497f95167d63e6feca70f344d9f6e843d097b62729b8f43bdcd5febf142ab\\\",\\\"0x55d80a4ba6ef54f2a8c0b99589d017b810ed13a1fda6a111e1b87725bc8ceb0e\\\",\\\"0x9e8b92c17280dd05f2562af6eea3285181c562ebf41fc758527d4c30364bcbc4\\\",\\\"0x7353a4b9d6b35c9eafeccaf9722dd293c46ae2ffd4093b2367165c3620a0c7c9\\\",\\\"0x026d91bda61c8789c59632c349b38fd7e7557e6b598b94879654a644cfa75f30\\\",\\\"0x73e3245d4ddc3bba48fa67633f9993c6e11728a36401fa1206437f8be94ef1d3\\\"]}\\n\\nNamespaces supported on Cosmos EVM\\nSee the methods page for an exhaustive list and working examples. Namespace Description Supported Enabled by Default eth Core Ethereum JSON-RPC methods for interacting with the EVM Y Y web3 Utility functions for the web3 client Y Y net Network information about the node Y Y txpool Transaction pool inspection Y N debug Debugging and tracing functionality Y N personal Private key management Y N admin Node administration Y N miner Mining operations (stub for PoS) Y N clique Proof-of-Authority consensus N N les Light Ethereum Subprotocol N N You should only expose the debug endpoint in non production settings as it could impact network performance and uptime under certain conditions.\\n\\n\", \"Title: Filters\u200b\\nLink: https://evm.cosmos.network/docs/evm/next/api-reference/ethereum-json-rpc/index\\nContent: Cosmos EVM also supports the Ethereum JSON-RPC filters calls to subscribe to state logs , blocks or pending transactions changes. Under the hood, it uses the CometBFT RPC client's event system to process subscriptions that are then formatted to Ethereum-compatible events. Then you can check if the state changes with the eth_getFilterChanges call:\\n\\nCosmos EVM also supports the Ethereum JSON-RPC filters calls to subscribe to state logs , blocks or pending transactions changes. Under the hood, it uses the CometBFT RPC client's event system to process subscriptions that are then formatted to Ethereum-compatible events. Then you can check if the state changes with the eth_getFilterChanges call: curl -X POST --data '{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"eth_getFilterChanges\\\",\\\"params\\\":[\\\"0x3503de5f0c766c68f78a03a3b05036a5\\\"],\\\"id\\\":1}' -H \\\"Content-Type: application/json\\\" http://localhost:8545{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"result\\\":[\\\"0x7d44dceff05d5963b5bc81df7e9f79b27e777b0a03a6feca09f3447b99c6fa71\\\",\\\"0x3961e4050c27ce0145d375255b3cb829a5b4e795ac475c05a219b3733723d376\\\",\\\"0xd7a497f95167d63e6feca70f344d9f6e843d097b62729b8f43bdcd5febf142ab\\\",\\\"0x55d80a4ba6ef54f2a8c0b99589d017b810ed13a1fda6a111e1b87725bc8ceb0e\\\",\\\"0x9e8b92c17280dd05f2562af6eea3285181c562ebf41fc758527d4c30364bcbc4\\\",\\\"0x7353a4b9d6b35c9eafeccaf9722dd293c46ae2ffd4093b2367165c3620a0c7c9\\\",\\\"0x026d91bda61c8789c59632c349b38fd7e7557e6b598b94879654a644cfa75f30\\\",\\\"0x73e3245d4ddc3bba48fa67633f9993c6e11728a36401fa1206437f8be94ef1d3\\\"]}\\n\\nNamespaces supported on Cosmos EVM\\nSee the methods page for an exhaustive list and working examples. Namespace Description Supported Enabled by Default eth Core Ethereum JSON-RPC methods for interacting with the EVM Y Y web3 Utility functions for the web3 client Y Y net Network information about the node Y Y txpool Transaction pool inspection Y N debug Debugging and tracing functionality Y N personal Private key management Y N admin Node administration Y N miner Mining operations (stub for PoS) Y N clique Proof-of-Authority consensus N N les Light Ethereum Subprotocol N N You should only expose the debug endpoint in non production settings as it could impact network performance and uptime under certain conditions.\\n\\n\", \"Title: Adding the EVM Module to Your Cosmos SDK Chain\\nLink: https://evm.cosmos.network/docs/evm/next/documentation/integration/evm-module-integration\\nContent: Big thanks to Reece & the Spawn team for their valuable contributions to this guide. This guide provides instructions for adding EVM compatibility to a new Cosmos SDK chain. It targets chains being built from scratch with EVM support. For existing live chains , adding EVM compatibility involves significant additional considerations: Account system changes requiring address migration or mapping between Cosmos and Ethereum formats Token decimal changes (from Cosmos standard 6 to Ethereum standard 18) impacting all existing balances Asset migration where existing assets need to be initialized and mirrored in the EVM Contact Interchain Labs for production chain upgrade guidance.\\n\\nIntegrating the Cosmos EVM module into Cosmos SDK v0.53.x chains\\n\\nStep 5: Create EVM Configuration File\\nCreate app/config.go to set up global EVM configuration: package app\\n\\nimport (\\n    \\\"fmt\\\"\\n    \\\"math/big\\\"\\n\\n    \\\"cosmossdk.io/math\\\"\\n    sdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    evmtypes \\\"github.com/cosmos/evm/x/vm/types\\\"\\n)\\n\\ntype EVMOptionsFn func(string) error\\n\\nfunc NoOpEVMOptions(_ string) error {\\n    return nil\\n}\\n\\nvar sealed = false\\n\\n// ChainsCoinInfo maps EVM chain IDs to coin configuration\\n// IMPORTANT: Uses uint64 EVM chain IDs as keys, not Cosmos chain ID strings\\nvar ChainsCoinInfo = map[uint64]evmtypes.EvmCoinInfo{\\n    EVMChainID: { // Your numeric EVM chain ID (e.g., 9000)\\n        Denom:        BaseDenom,\\n        DisplayDenom: DisplayDenom,\\n        Decimals:     evmtypes.EighteenDecimals,\\n    },\\n}\\n\\n// EVMAppOptions sets up global configuration\\nfunc EVMAppOptions(chainID string) error {\\n    if sealed {\\n        return nil\\n    }\\n\\n    // IMPORTANT: Lookup uses numeric EVMChainID, not Cosmos chainID string\\n    coinInfo, found := ChainsCoinInfo[EVMChainID]\\n    if !found {\\n        return fmt.Errorf(\\\"unknown EVM chain id: %d\\\", EVMChainID)\\n    }\\n\\n    // Set denom info for the chain\\n    if err := setBaseDenom(coinInfo); err != nil {\\n        return err\\n    }\\n\\n    baseDenom, err := sdk.GetBaseDenom()\\n    if err != nil {\\n        return err\\n    }\\n\\n    ethCfg := evmtypes.DefaultChainConfig(EVMChainID)\\n\\n    err = evmtypes.NewEVMConfigurator().\\n        WithChainConfig(ethCfg).\\n        WithEVMCoinInfo(baseDenom, uint8(coinInfo.Decimals)).\\n        Configure()\\n    if err != nil {\\n        return err\\n    }\\n\\n    sealed = true\\n    return nil\\n}\\n\\n// setBaseDenom registers display and base denoms\\nfunc setBaseDenom(ci evmtypes.EvmCoinInfo) error {\\n    if err := sdk.RegisterDenom(ci.DisplayDenom, math.LegacyOneDec()); err != nil {\\n        return err\\n    }\\n    return sdk.RegisterDenom(ci.Denom, math.LegacyNewDecWithPrec(1, int64(ci.Decimals)))\\n}\\n\\n\", \"Title: Adding the EVM Module to Your Cosmos SDK Chain\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/documentation/integration/evm-module-integration\\nContent: Big thanks to Reece & the Spawn team for their valuable contributions to this guide. This guide provides instructions for adding EVM compatibility to a new Cosmos SDK chain. It targets chains being built from scratch with EVM support. For existing live chains , adding EVM compatibility involves significant additional considerations: Account system changes requiring address migration or mapping between Cosmos and Ethereum formats Token decimal changes (from Cosmos standard 6 to Ethereum standard 18) impacting all existing balances Asset migration where existing assets need to be initialized and mirrored in the EVM Contact Interchain Labs for production chain upgrade guidance.\\n\\nIntegrating the Cosmos EVM module into Cosmos SDK v0.53.x chains\\n\\nStep 5: Create EVM Configuration File\\nCreate app/config.go to set up global EVM configuration: package app\\n\\nimport (\\n    \\\"fmt\\\"\\n    \\\"math/big\\\"\\n\\n    \\\"cosmossdk.io/math\\\"\\n    sdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    evmtypes \\\"github.com/cosmos/evm/x/vm/types\\\"\\n)\\n\\ntype EVMOptionsFn func(string) error\\n\\nfunc NoOpEVMOptions(_ string) error {\\n    return nil\\n}\\n\\nvar sealed = false\\n\\n// ChainsCoinInfo maps EVM chain IDs to coin configuration\\n// IMPORTANT: Uses uint64 EVM chain IDs as keys, not Cosmos chain ID strings\\nvar ChainsCoinInfo = map[uint64]evmtypes.EvmCoinInfo{\\n    EVMChainID: { // Your numeric EVM chain ID (e.g., 9000)\\n        Denom:        BaseDenom,\\n        DisplayDenom: DisplayDenom,\\n        Decimals:     evmtypes.EighteenDecimals,\\n    },\\n}\\n\\n// EVMAppOptions sets up global configuration\\nfunc EVMAppOptions(chainID string) error {\\n    if sealed {\\n        return nil\\n    }\\n\\n    // IMPORTANT: Lookup uses numeric EVMChainID, not Cosmos chainID string\\n    coinInfo, found := ChainsCoinInfo[EVMChainID]\\n    if !found {\\n        return fmt.Errorf(\\\"unknown EVM chain id: %d\\\", EVMChainID)\\n    }\\n\\n    // Set denom info for the chain\\n    if err := setBaseDenom(coinInfo); err != nil {\\n        return err\\n    }\\n\\n    baseDenom, err := sdk.GetBaseDenom()\\n    if err != nil {\\n        return err\\n    }\\n\\n    ethCfg := evmtypes.DefaultChainConfig(EVMChainID)\\n\\n    err = evmtypes.NewEVMConfigurator().\\n        WithChainConfig(ethCfg).\\n        WithEVMCoinInfo(baseDenom, uint8(coinInfo.Decimals)).\\n        Configure()\\n    if err != nil {\\n        return err\\n    }\\n\\n    sealed = true\\n    return nil\\n}\\n\\n// setBaseDenom registers display and base denoms\\nfunc setBaseDenom(ci evmtypes.EvmCoinInfo) error {\\n    if err := sdk.RegisterDenom(ci.DisplayDenom, math.LegacyOneDec()); err != nil {\\n        return err\\n    }\\n    return sdk.RegisterDenom(ci.Denom, math.LegacyNewDecWithPrec(1, int64(ci.Decimals)))\\n}\\n\\n\", \"Title: EVM Accounts\\nLink: https://evm.cosmos.network/docs/evm/next/documentation/concepts/accounts\\nContent: Cosmos EVM defines its own custom Account type to implement a HD wallet that is compatible with Ethereum type addresses. It uses Ethereum's ECDSA secp256k1 curve for keys ( eth_secp265k1 ) and satisfies the EIP84 for full BIP44 paths. This cryptographic curve is not to be confused with Bitcoin's ECDSA secp256k1 curve. The root HD path for EVM-based accounts is m/44'/60'/0'/0 . It is recommended to use the Coin type 60 to support Ethereum type accounts, unlike many other Cosmos chains that use Coin type 118 ( list of coin types The custom Cosmos EVM EthAccount satisfies the AccountI interface from the Cosmos SDK auth module and includes additional fields that are required for Ethereum type addresses: EIP-7702 Support : Cosmos EVM supports EIP-7702 code delegation , allowing EOAs to temporarily delegate code execution to smart contracts through the SetCodeHash functionality. For more information on Ethereum accounts head over to the x/vm module.\\n\\nCosmos EVM defines its own custom Account type to implement a HD wallet that is compatible with Ethereum type addresses. It uses Ethereum's ECDSA secp256k1 curve for keys ( eth_secp265k1 ) and satisfies the EIP84 for full BIP44 paths. This cryptographic curve is not to be confused with Bitcoin's ECDSA secp256k1 curve. The root HD path for EVM-based accounts is m/44'/60'/0'/0 . It is recommended to use the Coin type 60 to support Ethereum type accounts, unlike many other Cosmos chains that use Coin type 118 ( list of coin types The custom Cosmos EVM EthAccount satisfies the AccountI interface from the Cosmos SDK auth module and includes additional fields that are required for Ethereum type addresses: // EthAccountI represents the interface of an EVM compatible account\\ntype EthAccountI interface {\\n    authtypes.AccountI\\n    \\n    // EthAddress returns the ethereum Address representation of the AccAddress\\n    EthAddress() common.Address\\n    \\n    // CodeHash is the keccak256 hash of the contract code (if any)\\n    GetCodeHash() common.Hash\\n    \\n    // SetCodeHash sets the code hash to the account fields\\n    SetCodeHash(code common.Hash) error\\n    \\n    // Type returns the type of Ethereum Account (EOA or Contract)\\n    Type() int8\\n}\\n\\nAddresses and Public Keys\\nBIP-0173 defines a new format for segregated witness output addresses that contains a human-readable part that identifies the Bech32 usage. There are 3 main types of HRP for the Addresses/ PubKeys available by default on the Cosmos EVM: Purpose : Identify users (e.g., transaction senders) Curve : eth_secp256k1 Address Prefix : cosmos Pubkey Prefix : cosmospub Address Length : 20 bytes Pubkey Length : 33 bytes (compressed) Purpose : Identify validator operators Curve : eth_secp256k1 Address Prefix : cosmosvaloper Pubkey Prefix : cosmosvaloperpub Address Length : 20 bytes Pubkey Length : 33 bytes (compressed) Purpose : Identify nodes participating in consensus Curve : ed25519 Address Prefix : cosmosvalcons Pubkey Prefix : cosmosvalconspub Address Length : 20 bytes Pubkey Length : 32 bytes\\n\\n\", \"Title: EVM Accounts\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/documentation/concepts/accounts\\nContent: Cosmos EVM defines its own custom Account type to implement a HD wallet that is compatible with Ethereum type addresses. It uses Ethereum's ECDSA secp256k1 curve for keys ( eth_secp265k1 ) and satisfies the EIP84 for full BIP44 paths. This cryptographic curve is not to be confused with Bitcoin's ECDSA secp256k1 curve. The root HD path for EVM-based accounts is m/44'/60'/0'/0 . It is recommended to use the Coin type 60 to support Ethereum type accounts, unlike many other Cosmos chains that use Coin type 118 ( list of coin types The custom Cosmos EVM EthAccount satisfies the AccountI interface from the Cosmos SDK auth module and includes additional fields that are required for Ethereum type addresses: For more information on Ethereum accounts head over to the x/vm module.\\n\\nCosmos EVM defines its own custom Account type to implement a HD wallet that is compatible with Ethereum type addresses. It uses Ethereum's ECDSA secp256k1 curve for keys ( eth_secp265k1 ) and satisfies the EIP84 for full BIP44 paths. This cryptographic curve is not to be confused with Bitcoin's ECDSA secp256k1 curve. The root HD path for EVM-based accounts is m/44'/60'/0'/0 . It is recommended to use the Coin type 60 to support Ethereum type accounts, unlike many other Cosmos chains that use Coin type 118 ( list of coin types The custom Cosmos EVM EthAccount satisfies the AccountI interface from the Cosmos SDK auth module and includes additional fields that are required for Ethereum type addresses: // EthAccountI represents the interface of an EVM compatible accounttype EthAccountI interface {    authtypes.AccountI    // EthAddress returns the ethereum Address representation of the AccAddress    EthAddress() common.Address    // CodeHash is the keccak256 hash of the contract code (if any)    GetCodeHash() common.Hash    // SetCodeHash sets the code hash to the account fields    SetCodeHash(code common.Hash) error    // Type returns the type of Ethereum Account (EOA or Contract)    Type() int8}\\n\\nAddresses and Public Keys\\nBIP-0173 defines a new format for segregated witness output addresses that contains a human-readable part that identifies the Bech32 usage. There are 3 main types of HRP for the Addresses/ PubKeys available by default on the Cosmos EVM: Purpose : Identify users (e.g., transaction senders) Curve : eth_secp256k1 Address Prefix : cosmos Pubkey Prefix : cosmospub Address Length : 20 bytes Pubkey Length : 33 bytes (compressed) Purpose : Identify validator operators Curve : eth_secp256k1 Address Prefix : cosmosvaloper Pubkey Prefix : cosmosvaloperpub Address Length : 20 bytes Pubkey Length : 33 bytes (compressed) Purpose : Identify nodes participating in consensus Curve : ed25519 Address Prefix : cosmosvalcons Pubkey Prefix : cosmosvalconspub Address Length : 20 bytes Pubkey Length : 32 bytes\\n\\n\", \"Title: Technical Architecture\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/documentation/cosmos-sdk/protocol\\nContent: This architecture allows users to perform both Cosmos and EVM formatted transactions, developers to scale EVM dApps cross-chain via IBC , and tokens and assets in the network to come from different independent sources. Cosmos EVM enables these key features by: Leveraging modules and other mechanisms implemented by the Cosmos SDK. Implementing CometBFT's Application Blockchain Interface ( ABCI ) to manage the blockchain. Utilizing geth as a library to promote code reuse and improve maintainability. Exposing a fully compatible Web3 JSON-RPC layer for interacting with existing Ethereum clients and tooling (Metamask, Remix, etc). The sum of these features allows developers to leverage existing Ethereum ecosystem tooling and software to seamlessly deploy smart contracts which interact with the rest of the Cosmos ecosystem.\\n\\nCosmos EVM is a framework that allows you to add Ethereum Virtual Machine (EVM) compatibility to any Cosmos SDK-based chain. It is built using the  which runs on top of the  (a fork of ) consensus engine, to accomplish fast finality, high transaction throughput and short block times (~2 seconds).\\n\\nEVM Compatibility\u200b\\nCosmos EVM enables EVM compatibility by implementing various components that together support all the EVM state transitions while ensuring the same developer experience as Ethereum: Ethereum's transaction format as a Cosmos SDK Tx and Msg interface Ethereum's secp256k1 curve for the Cosmos Keyring StateDB interface for state updates and queries JSON-RPC client for interacting with the EVM Most components are implemented in the VM module To achieve a seamless developer UX, however, some of the components are implemented outside of the module. If you want to learn more about how Cosmos EVM achieves EVM compatibility as a Cosmos chain, we recommend understanding the following concepts: Accounts Gas and Fees Token representations Transactions\\n\\n\", \"Title: Technical Architecture\\nLink: https://evm.cosmos.network/docs/evm/next/documentation/cosmos-sdk/protocol\\nContent: This architecture allows users to perform both Cosmos and EVM formatted transactions, developers to scale EVM dApps cross-chain via IBC , and tokens and assets in the network to come from different independent sources. Cosmos EVM enables these key features by: Leveraging modules and other mechanisms implemented by the Cosmos SDK. Implementing CometBFT's Application Blockchain Interface ( ABCI ) to manage the blockchain. Utilizing geth as a library to promote code reuse and improve maintainability. Exposing a fully compatible Web3 JSON-RPC layer for interacting with existing Ethereum clients and tooling (Metamask, Remix, etc). The sum of these features allows developers to leverage existing Ethereum ecosystem tooling and software to seamlessly deploy smart contracts which interact with the rest of the Cosmos ecosystem.\\n\\nCosmos EVM is a framework that allows you to add Ethereum Virtual Machine (EVM) compatibility to any Cosmos SDK-based chain. It is built using the  which runs on top of the  (a fork of ) consensus engine, to accomplish fast finality, high transaction throughput and short block times (~2 seconds).\\n\\nEVM Compatibility\u200b\\nCosmos EVM enables EVM compatibility by implementing various components that together support all the EVM state transitions while ensuring the same developer experience as Ethereum: Ethereum's transaction format as a Cosmos SDK Tx and Msg interface Ethereum's secp256k1 curve for the Cosmos Keyring StateDB interface for state updates and queries JSON-RPC client for interacting with the EVM Most components are implemented in the VM module To achieve a seamless developer UX, however, some of the components are implemented outside of the module. If you want to learn more about how Cosmos EVM achieves EVM compatibility as a Cosmos chain, we recommend understanding the following concepts: Accounts Gas and Fees Token representations Transactions\\n\\n\"]",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "tool",
            "name": "SearchCosmosDocumentation",
            "id": "a9a5ef32-789d-4d4e-854c-348b727ed9f2",
            "tool_call_id": "call_GE0cpJz1eiXhTHfeNIONgZUR",
            "artifact": null,
            "status": "success"
        },
        {
            "content": "[\n  {\n    \"intent\": \"Get recent changes (logs / tx hashes) for an existing JSON-RPC filter ID\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"collect_filter_id\",\n        \"description\": \"Prompt or read the hexadecimal filter ID (e.g. \\\"0x3503de5f\u2026\\\") that was returned by a previous eth_newFilter / eth_newBlockFilter / eth_newPendingTransactionFilter call.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"validate_filter_id_format\",\n        \"description\": \"Ensure the filter ID is a non-empty 0x-prefixed hex string; reject if it does not match /^0x[0-9a-fA-F]+$/.\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"construct_rpc_eth_getFilterChanges\",\n        \"description\": \"Build the JSON-RPC body {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"eth_getFilterChanges\\\",\\\"params\\\":[<filterId>]}.\"\n      },\n      {\n        \"step\": 4,\n        \"tool\": \"send_json_rpc_request\",\n        \"description\": \"POST the body to the node\u2019s HTTP endpoint (default http://localhost:8545) or over WebSocket if already connected.\"\n      },\n      {\n        \"step\": 5,\n        \"tool\": \"parse_filter_changes_response\",\n        \"description\": \"Read the result array. Depending on the original filter type it returns log objects, block hashes, or tx hashes.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"HTTP status 200 and JSON-RPC \\\"error\\\" field is null / absent.\",\n      \"\\\"result\\\" is an array (possibly empty).\",\n      \"For log filters, each element contains topics[], data, blockNumber, txHash, etc.\"\n    ]\n  },\n  {\n    \"intent\": \"Uninstall / remove a JSON-RPC filter by ID\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"collect_filter_id\",\n        \"description\": \"Obtain the hexadecimal filter ID to be removed.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"validate_filter_id_format\",\n        \"description\": \"Reject if the supplied ID is not a valid 0x-prefixed hex string.\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"construct_rpc_eth_uninstallFilter\",\n        \"description\": \"Create the JSON-RPC body {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"eth_uninstallFilter\\\",\\\"params\\\":[<filterId>]}.\"\n      },\n      {\n        \"step\": 4,\n        \"tool\": \"send_json_rpc_request\",\n        \"description\": \"POST the request to the node.\"\n      },\n      {\n        \"step\": 5,\n        \"tool\": \"confirm_uninstall_response\",\n        \"description\": \"Expect the result field to be the boolean true.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Response result === true.\",\n      \"Subsequent eth_getFilterChanges calls with the same ID return an error (filter not found).\"\n    ]\n  },\n  {\n    \"intent\": \"Get logs from the latest block that match a specific topic\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"collect_topic_hash\",\n        \"description\": \"Ask the user for the 32-byte topic hash they want to filter on (0x\u2026 format).\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"validate_topic_hash\",\n        \"description\": \"Verify the topic is a 0x-prefixed 64-hex-character string.\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"construct_filter_object\",\n        \"description\": \"Create the filter object {\\\"fromBlock\\\":\\\"latest\\\",\\\"toBlock\\\":\\\"latest\\\",\\\"topics\\\":[[<topicHash>]]}.\"\n      },\n      {\n        \"step\": 4,\n        \"tool\": \"construct_rpc_eth_getLogs\",\n        \"description\": \"Wrap the filter object in {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"eth_getLogs\\\",\\\"params\\\":[<filterObject>]}.\"\n      },\n      {\n        \"step\": 5,\n        \"tool\": \"send_json_rpc_request\",\n        \"description\": \"POST to the Ethereum JSON-RPC endpoint.\"\n      },\n      {\n        \"step\": 6,\n        \"tool\": \"parse_logs_array\",\n        \"description\": \"Extract the array of log objects from the result field.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"HTTP 200 and no JSON-RPC error.\",\n      \"\\\"result\\\" is an array of zero or more log objects.\",\n      \"Each returned log\u2019s topics[0] equals the requested topic hash.\"\n    ]\n  },\n  {\n    \"intent\": \"Retrieve all transaction receipts for the latest block\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"construct_rpc_eth_blockNumber\",\n        \"description\": \"Prepare {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"eth_blockNumber\\\",\\\"params\\\":[]} to find the current latest block height.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"send_json_rpc_request\",\n        \"description\": \"POST the eth_blockNumber request and parse the hex block number (e.g. \\\"0x10fb34\\\").\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"construct_rpc_eth_getBlockReceipts\",\n        \"description\": \"Build {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":2,\\\"method\\\":\\\"eth_getBlockReceipts\\\",\\\"params\\\":[<blockNumberHex>]} using the value from Step 2.\"\n      },\n      {\n        \"step\": 4,\n        \"tool\": \"send_json_rpc_request\",\n        \"description\": \"POST the eth_getBlockReceipts call.\"\n      },\n      {\n        \"step\": 5,\n        \"tool\": \"parse_receipts_array\",\n        \"description\": \"Read the result array containing receipt objects for every tx in that block.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"No JSON-RPC error field in either call.\",\n      \"\\\"result\\\" from eth_getBlockReceipts is an array whose length equals the block\u2019s transaction count.\",\n      \"Each receipt object contains status, gasUsed, logs[], etc.\"\n    ]\n  },\n  {\n    \"intent\": \"Get the logs emitted by a specific transaction\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"collect_transaction_hash\",\n        \"description\": \"Receive the 0x-prefixed transaction hash from the user.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"validate_tx_hash\",\n        \"description\": \"Ensure the hash is a 66-character 0x-prefixed hex string.\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"construct_rpc_eth_getTransactionReceipt\",\n        \"description\": \"Create {\\\"jsonrpc\\\":\\\"2.0\\\",\\\"id\\\":1,\\\"method\\\":\\\"eth_getTransactionReceipt\\\",\\\"params\\\":[<txHash>]}.\"\n      },\n      {\n        \"step\": 4,\n        \"tool\": \"send_json_rpc_request\",\n        \"description\": \"POST the request to the node.\"\n      },\n      {\n        \"step\": 5,\n        \"tool\": \"extract_logs_from_receipt\",\n        \"description\": \"From the returned receipt object, read the logs[] array.\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Receipt object exists (non-null).\",\n      \"Receipt.logs is an array (possibly empty).\",\n      \"Each log\u2019s transactionHash matches the requested hash.\"\n    ]\n  }\n]",
            "additional_kwargs": {
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 3329,
                    "prompt_tokens": 32821,
                    "total_tokens": 36150,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 1664,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 26624
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CPvjXa2S39NR24w3CP7vND62txPkV",
                "service_tier": "default",
                "finish_reason": "stop",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--463f574a-a581-4cb0-beb7-24394cbcc85d-0",
            "example": false,
            "tool_calls": [],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 32821,
                "output_tokens": 3329,
                "total_tokens": 36150,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 26624
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 1664
                }
            }
        }
    ]
}