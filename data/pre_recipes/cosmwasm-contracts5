[
    {
        "intent": "Query contract smart state with payload {\"abcde\": {}} to discover schema",
        "workflow": [
            {
                "step": 1,
                "tool": "resolve_contract_address",
                "description": "Obtain the target CosmWasm contract address (e.g., from user input, environment variable CONTRACT_ADDRESS, or a previous instantiate response)."
            },
            {
                "step": 2,
                "tool": "build_smart_query_payload",
                "description": "Construct the JSON payload {\"abcde\": {}} and base64-encode it to produce the query_data string required by the CosmWasm smart query endpoint."
            },
            {
                "step": 3,
                "tool": "lcd_query_wasm_smart",
                "description": "Send an HTTP GET request to https://lcd-archive.junonetwork.io/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_data}, replacing {contract_address} and {query_data} with the resolved address and encoded payload."
            },
            {
                "step": 4,
                "tool": "decode_and_analyze_contract_response",
                "description": "Read the 'data' field from the LCD response, base64-decode it into raw bytes, interpret those bytes as UTF-8 JSON, and inspect the resulting object structure to infer aspects of the contract's query schema (field names, nested objects, etc.)."
            }
        ],
        "outcome_checks": [
            "The LCD call to /cosmwasm/wasm/v1/contract/{address}/smart/{query_data} returns HTTP 200 with a non-empty 'data' field.",
            "The base64-decoded 'data' is valid JSON.",
            "The decoded JSON reveals keys and structures that can be used to infer the contract's query schema."
        ]
    },
    {
        "intent": "Execute reset on contract CONTRACT_ADDRESS setting count to 0",
        "workflow": [
            {
                "step": 1,
                "tool": "get_sender_address",
                "description": "Determine the bech32 address that will sign and pay fees for the transaction (e.g., from a connected wallet or backend configuration)."
            },
            {
                "step": 2,
                "tool": "lcd_get_account_info",
                "description": "Query https://lcd-archive.junonetwork.io/cosmos/auth/v1beta1/accounts/{sender_address} to obtain the account_number and sequence needed for transaction signing."
            },
            {
                "step": 3,
                "tool": "lcd_check_spendable_balance",
                "description": "Query https://lcd-archive.junonetwork.io/cosmos/bank/v1beta1/spendable_balances/{sender_address} to confirm the sender has sufficient JUNO (or appropriate fee denom) to cover gas and fees."
            },
            {
                "step": 4,
                "tool": "construct_msg_execute_reset",
                "description": "Create a CosmWasm MsgExecuteContract message with fields: sender = sender_address, contract = CONTRACT_ADDRESS, msg = {\"reset\": {\"count\": 0}}, funds = []. Serialize this message using the correct protobuf type_url for MsgExecuteContract."
            },
            {
                "step": 5,
                "tool": "build_unsigned_tx",
                "description": "Wrap the MsgExecuteContract in a Tx body (including optional memo), set an initial gas_limit and fee amount in auth_info.fee, and prepare an unsigned transaction with appropriate signer_infos (public key, sequence, sign mode)."
            },
            {
                "step": 6,
                "tool": "simulate_tx_via_lcd",
                "description": "POST the unsigned transaction (tx or tx_bytes) to https://lcd-archive.junonetwork.io/cosmos/tx/v1beta1/simulate to estimate gas usage, then update the transaction's gas_limit and fee based on the returned gas_info.gas_used."
            },
            {
                "step": 7,
                "tool": "sign_tx",
                "description": "On the backend, sign the adjusted transaction with the sender's private key, producing raw tx_bytes ready for broadcast."
            },
            {
                "step": 8,
                "tool": "broadcast_tx_via_lcd",
                "description": "Broadcast the signed transaction by POSTing tx_bytes and mode=BROADCAST_MODE_BLOCK (or SYNC) to https://lcd-archive.junonetwork.io/cosmos/tx/v1beta1/txs, capturing the returned tx_response including txhash and code."
            },
            {
                "step": 9,
                "tool": "verify_reset_effect",
                "description": "After the transaction is included in a block, query the contract's current count using the \"Get current count from contract\" workflow and confirm that the on-chain count is now 0."
            }
        ],
        "outcome_checks": [
            "The broadcast endpoint /cosmos/tx/v1beta1/txs returns tx_response.code == 0 and a valid txhash.",
            "A subsequent query of the contract's current count returns exactly 0."
        ]
    },
    {
        "intent": "Get current count from contract CONTRACT_ADDRESS",
        "workflow": [
            {
                "step": 1,
                "tool": "resolve_contract_address",
                "description": "Obtain the target counter contract's bech32 address (e.g., from environment variable CONTRACT_ADDRESS or from a previous instantiate response)."
            },
            {
                "step": 2,
                "tool": "build_get_count_query_payload",
                "description": "Construct the contract-specific JSON query to fetch the count (for a standard counter contract, {\"get_count\": {}}), then base64-encode this JSON to form query_data."
            },
            {
                "step": 3,
                "tool": "lcd_query_wasm_smart",
                "description": "Send an HTTP GET request to https://lcd-archive.junonetwork.io/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_data}, filling in the contract address and encoded payload."
            },
            {
                "step": 4,
                "tool": "decode_and_extract_count",
                "description": "Base64-decode the 'data' field from the LCD response, parse it as JSON, and read the 'count' field from the resulting object as an integer."
            }
        ],
        "outcome_checks": [
            "The smart query endpoint returns HTTP 200 and includes a 'data' field.",
            "The decoded JSON contains a 'count' field.",
            "The 'count' value is numeric and can be used in subsequent logic (e.g., comparisons before and after increment/reset)."
        ]
    },
    {
        "intent": "Store the returned code id in shell variable CODE_ID",
        "workflow": [
            {
                "step": 1,
                "tool": "retrieve_last_tx_output",
                "description": "Access the JSON output from the last contract code upload or related command (for example, the response from a wasm store transaction that includes a code_id field or emits it in logs)."
            },
            {
                "step": 2,
                "tool": "parse_code_id_from_output",
                "description": "Parse the captured JSON (using a shell tool like jq or backend JSON parser) to extract the numeric code_id value from the appropriate field or log event."
            },
            {
                "step": 3,
                "tool": "export_shell_variable_CODE_ID",
                "description": "In the shell environment, assign the extracted code_id to an environment variable named CODE_ID so that subsequent commands can reference it (e.g., CODE_ID=<extracted value>)."
            }
        ],
        "outcome_checks": [
            "The parsed code_id is non-empty and numeric.",
            "Echoing $CODE_ID in the shell prints the same value as found in the original transaction output.",
            "Subsequent commands that rely on CODE_ID (such as contract instantiation or queries that use CODE_ID-derived addresses) behave as expected."
        ]
    },
    {
        "intent": "Connect a SigningCosmWasmClient to RPC https://rpc.juno.strange.love and execute increment on the contract",
        "workflow": [
            {
                "step": 1,
                "tool": "prepare_backend_signer",
                "description": "On the backend, load or configure an offline signer for the user's Juno account (e.g., from mnemonic, keyring, or remote signer) that can be used by SigningCosmWasmClient to sign transactions."
            },
            {
                "step": 2,
                "tool": "init_signing_cosmwasm_client",
                "description": "Initialize a SigningCosmWasmClient (or equivalent backend client) connected to the RPC endpoint https://rpc.juno.strange.love using the prepared signer."
            },
            {
                "step": 3,
                "tool": "resolve_contract_address",
                "description": "Determine the target counter contract address (e.g., from environment variable CONTRACT_ADDRESS or a stored instantiate result)."
            },
            {
                "step": 4,
                "tool": "execute_increment_msg_over_rpc",
                "description": "Using the initialized SigningCosmWasmClient, execute the contract by sending msg {\"increment\": {}} with an appropriate fee and optional memo, returning a transaction hash or detailed result from the RPC call."
            },
            {
                "step": 5,
                "tool": "confirm_tx_via_lcd",
                "description": "With the returned txhash, query https://lcd-archive.junonetwork.io/cosmos/tx/v1beta1/txs/{txhash} to confirm the transaction was included in a block and that tx_response.code == 0."
            },
            {
                "step": 6,
                "tool": "verify_incremented_count",
                "description": "Use the \"Get current count from contract CONTRACT_ADDRESS\" workflow both before and after the increment (or compare to a previously stored value) to verify that the count increased by 1."
            }
        ],
        "outcome_checks": [
            "The SigningCosmWasmClient successfully connects to https://rpc.juno.strange.love and can fetch chain information without error.",
            "The LCD tx lookup at /cosmos/tx/v1beta1/txs/{txhash} returns tx_response.code == 0 for the increment transaction.",
            "The contract's count queried after execution is exactly one greater than its value before the increment."
        ]
    }
]