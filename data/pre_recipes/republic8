[
    {
        "intent": "Filter Republic blockchain transactions related to compute job scheduling, execution, and validation",
        "workflow": [
            {
                "step": 1,
                "tool": "load_chain_config_for_label",
                "description": "Given the 'republic' label, load RPC/gRPC and indexer endpoints plus relevant module names (compute, staking, rewards) needed to query transactions."
            },
            {
                "step": 2,
                "tool": "normalize_compute_tx_filter_params",
                "description": "From the caller\u2019s request or UI form, build a normalized filter object for compute-related activity (e.g., optional address, job_id, validator_address, height or time range, and pagination settings)."
            },
            {
                "step": 3,
                "tool": "build_compute_tx_search_query",
                "description": "Translate the normalized filter into a transaction search query that targets compute-job-related messages and events (e.g., job scheduling, assignment, result submission, and validation/proof submission) in the Republic transaction index."
            },
            {
                "step": 4,
                "tool": "query_transaction_index",
                "description": "Execute the built query against the Republic transaction indexer or /cosmos/tx gRPC API, retrieving matching transactions and their events with server-side pagination."
            },
            {
                "step": 5,
                "tool": "postprocess_compute_transactions",
                "description": "From the raw transaction results, keep only those that contain compute job scheduling or validation messages; extract structured fields such as tx_hash, block_height, timestamp, message type (e.g., schedule_job, submit_job_result, validate_job), job_id, sender, and validator."
            },
            {
                "step": 6,
                "tool": "format_paginated_tx_response",
                "description": "Assemble a paginated response object that contains the filtered compute-related transactions, along with pagination cursors or next-page tokens for the caller."
            }
        ],
        "outcome_checks": [
            "Every returned transaction contains at least one compute-module message or event related to job scheduling, execution, or validation.",
            "Each transaction entry exposes tx_hash, block_height, timestamp, and any discovered job_id and validator_address fields.",
            "Pagination information (such as total count, page size, or next-page cursor) is present so the caller can request additional results as needed."
        ]
    },
    {
        "intent": "List all active compute jobs on Republic and their assigned validators",
        "workflow": [
            {
                "step": 1,
                "tool": "load_chain_config_for_label",
                "description": "Use the 'republic' label to load chain configuration, including compute module query endpoints and staking/validator query endpoints."
            },
            {
                "step": 2,
                "tool": "query_active_compute_jobs_state",
                "description": "Call the Republic compute module\u2019s state/query interface (via gRPC, REST, or internal SDK) to fetch all jobs with an active status (e.g., queued, scheduled, assigned, or running but not yet completed or cancelled). Apply pagination for large result sets."
            },
            {
                "step": 3,
                "tool": "hydrate_validator_metadata_for_jobs",
                "description": "For each active job, use the assigned_validator_address to query the staking/validator module and enrich the job record with validator metadata such as moniker, reputation score, and current stake."
            },
            {
                "step": 4,
                "tool": "sort_and_paginate_jobs",
                "description": "Sort active jobs according to a default policy (e.g., by creation height or priority) and apply pagination (page size, page token) before returning results."
            },
            {
                "step": 5,
                "tool": "format_active_job_list_response",
                "description": "Return a structured list of active jobs where each entry includes at minimum job_id, job_type, status, assigned_validator_address, validator metadata, creation height/timestamp, and any available compute benchmark requirements."
            }
        ],
        "outcome_checks": [
            "All jobs in the response have a non-terminal, active status (e.g., not completed, failed, or cancelled).",
            "Each job includes an assigned_validator_address, and where possible, enriched validator metadata (moniker, reputation, stake).",
            "The response includes pagination data so callers can traverse the full set of active jobs without overloading a single request."
        ]
    },
    {
        "intent": "Show execution outputs and proof details for a specific Republic compute job identified by {job_id}",
        "workflow": [
            {
                "step": 1,
                "tool": "load_chain_config_for_label",
                "description": "Load the Republic chain configuration, including compute module and any dedicated proof/benchmark query endpoints."
            },
            {
                "step": 2,
                "tool": "validate_job_id_parameter",
                "description": "Validate that the provided {job_id} is present and conforms to the expected job identifier format (e.g., numeric ID or UUID used by the Republic compute module). Reject the request with a clear error if invalid."
            },
            {
                "step": 3,
                "tool": "query_compute_job_by_id",
                "description": "Query the compute module for the job metadata corresponding to {job_id}, retrieving fields such as creator, assigned_validator_address, job_type, status, and any stored references to execution or proof records."
            },
            {
                "step": 4,
                "tool": "query_job_execution_and_proof_records",
                "description": "Using the job record and {job_id}, query the chain state and/or indexed events for associated execution outputs and proof-of-model-execution (PoME) details, including root hash, checkpoint/hash commitments (if available), verification status, benchmark scores, and any related reward or slashing records."
            },
            {
                "step": 5,
                "tool": "assemble_job_execution_view",
                "description": "Combine job metadata with the execution and proof records into a single structured object containing outputs (e.g., model inference results or benchmark metrics), PoME root hash, any checkpoint metadata, verification results, and timestamps."
            },
            {
                "step": 6,
                "tool": "format_job_execution_response",
                "description": "Format the assembled data into a response optimized for the caller, clearly separating job metadata, execution outputs, proof details (root hash, checkpoints, verification status), and any economic outcomes (rewards or slashing)."
            }
        ],
        "outcome_checks": [
            "If the job exists, the response includes a single job record whose job_id matches the requested {job_id}.",
            "For completed jobs, the response includes non-empty execution outputs and at least basic proof details (such as a PoME root hash or equivalent proof identifier).",
            "If the job is still pending or running, the response clearly indicates that full execution outputs or proofs are not yet available instead of returning empty or misleading values."
        ]
    },
    {
        "intent": "Search for Republic compute jobs that were submitted by a specific address {address}",
        "workflow": [
            {
                "step": 1,
                "tool": "load_chain_config_for_label",
                "description": "Load Republic chain configuration, including Bech32 address settings and compute module query/index endpoints, using the 'republic' label."
            },
            {
                "step": 2,
                "tool": "validate_republic_address_format",
                "description": "Validate that the provided {address} is a syntactically correct Republic account address (e.g., Bech32 with the correct human-readable prefix and checksum). Reject the request with a clear error if invalid."
            },
            {
                "step": 3,
                "tool": "query_jobs_by_creator_address",
                "description": "Query the compute module state and/or an indexed event store for jobs where the creator/submitter field equals {address}. Support optional filters from the caller (e.g., status, time range, job_type) and apply pagination."
            },
            {
                "step": 4,
                "tool": "enrich_jobs_with_basic_metadata",
                "description": "For each job, ensure that essential fields are present: job_id, status, job_type, creator address, assigned_validator_address (if any), creation height/timestamp, and latest known execution status."
            },
            {
                "step": 5,
                "tool": "sort_and_paginate_jobs",
                "description": "Sort the jobs (e.g., by creation time descending) and apply the requested pagination parameters before returning results to avoid overlong responses."
            },
            {
                "step": 6,
                "tool": "format_job_search_response",
                "description": "Return a structured list of jobs submitted by {address}, along with pagination metadata, making it easy for the caller to navigate large histories."
            }
        ],
        "outcome_checks": [
            "Every job in the response has its creator or submitter field equal to the provided {address}.",
            "Each job entry includes at least job_id, status, job_type, creator, and, if assigned, assigned_validator_address.",
            "The response includes pagination information so that a user with many submitted jobs can page through their full history."
        ]
    },
    {
        "intent": "Show pending and completed Republic compute jobs that belong to the currently authenticated user",
        "workflow": [
            {
                "step": 1,
                "tool": "resolve_authenticated_republic_address",
                "description": "From the backend authentication context (e.g., session, API key mapping, or wallet-linking record), resolve the current user\u2019s primary Republic address to be used as the job creator/owner identifier."
            },
            {
                "step": 2,
                "tool": "validate_republic_address_format",
                "description": "Validate that the resolved user address is a valid Republic address (correct format and checksum). If invalid or missing, return an authentication/authorization error."
            },
            {
                "step": 3,
                "tool": "query_jobs_by_creator_address",
                "description": "Query the compute module or indexed event store for all jobs where the creator/submitter equals the authenticated user\u2019s address. Fetch enough fields to classify each job by lifecycle status."
            },
            {
                "step": 4,
                "tool": "partition_jobs_by_lifecycle_status",
                "description": "Classify the retrieved jobs into at least two groups: 'pending' (e.g., queued, scheduled, assigned, running) and 'completed' (e.g., successfully completed or terminally failed). Optionally track other states like 'cancelled' separately if present."
            },
            {
                "step": 5,
                "tool": "paginate_grouped_jobs",
                "description": "Apply pagination independently to the pending and completed groups if necessary, to avoid returning excessively large payloads for users with many jobs."
            },
            {
                "step": 6,
                "tool": "format_my_jobs_response",
                "description": "Return a response object that clearly separates the user\u2019s jobs into 'pending' and 'completed' lists, with each job including job_id, status, job_type, assigned_validator_address, creation timestamp, and last update timestamp."
            }
        ],
        "outcome_checks": [
            "The user address used for querying jobs is derived from the authenticated context, not from arbitrary client input.",
            "All jobs in both 'pending' and 'completed' sections have creator fields matching the authenticated user\u2019s address.",
            "Lifecycle classifications are consistent with on-chain status codes (e.g., no job marked as 'completed' if it is still queued or running)."
        ]
    }
]