{
    "messages": [
        {
            "content": "[{\"label\": \"EthereumJSON_RPC\", \"query\": \"Write memory profile to mem.prof\"}, {\"label\": \"EthereumJSON_RPC\", \"query\": \"Set block profiling rate to 1\"}, {\"label\": \"EthereumJSON_RPC\", \"query\": \"Trace block number 0xe with debug_traceBlockByNumber\"}, {\"label\": \"EthereumJSON_RPC\", \"query\": \"Trace a block by hash with debug_traceBlockByHash\"}, {\"label\": \"EthereumJSON_RPC\", \"query\": \"Get intermediate state roots for a transaction\"}]",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "human",
            "name": null,
            "id": "18a5d9c7-ac2a-46da-9c23-82c84bbf930c",
            "example": false
        },
        {
            "content": "",
            "additional_kwargs": {
                "tool_calls": [
                    {
                        "id": "call_Vy8JyaAymYlpVDGyuKZdNPi0",
                        "function": {
                            "arguments": "{\"query\":\"debug_traceBlockByNumber cosmos\"}",
                            "name": "SearchCosmosDocumentation"
                        },
                        "type": "function"
                    }
                ],
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 542,
                    "prompt_tokens": 712,
                    "total_tokens": 1254,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 512,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CPw4QlTiYCfxZ3G4rNqSvSbCTOBZM",
                "service_tier": "default",
                "finish_reason": "tool_calls",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--8401a5af-8dfb-4496-bbf1-e25afd14d906-0",
            "example": false,
            "tool_calls": [
                {
                    "name": "SearchCosmosDocumentation",
                    "args": {
                        "query": "debug_traceBlockByNumber cosmos"
                    },
                    "id": "call_Vy8JyaAymYlpVDGyuKZdNPi0",
                    "type": "tool_call"
                }
            ],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 712,
                "output_tokens": 542,
                "total_tokens": 1254,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 512
                }
            }
        },
        {
            "content": "[\"Title: debug_traceBlockByNumber\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/api-reference/ethereum-json-rpc/methods\\nContent: The traceBlockByNumber endpoint accepts a block number and will replay the block that is already present in the database. Stub Implementation : This method is implemented but currently returns an empty array for all requests. The tracing functionality is not fully operational in Cosmos EVM.\\n\\ndebug_traceBlockByHash\\nSimilar to  , this method accepts a block hash and will replay the block that is already present in the database. Stub Implementation : This method is implemented but currently returns an empty array for all requests. The tracing functionality is not fully operational in Cosmos EVM.\\n\\neth_getBlockTransactionCountByNumber\\nReturns the total transaction count for a given block number.\\n\\n\", \"Title: debug_traceBlockByNumber\\nLink: https://evm.cosmos.network/docs/evm/next/api-reference/ethereum-json-rpc/methods\\nContent: The traceBlockByNumber endpoint accepts a block number and will replay the block that is already present in the database. Stub Implementation : This method is implemented but currently returns an empty array for all requests. The tracing functionality is not fully operational in Cosmos EVM.\\n\\ndebug_traceBlockByHash\\nSimilar to  , this method accepts a block hash and will replay the block that is already present in the database. Stub Implementation : This method is implemented but currently returns an empty array for all requests. The tracing functionality is not fully operational in Cosmos EVM.\\n\\neth_getBlockTransactionCountByNumber\\nReturns the total transaction count for a given block number.\\n\\n\", \"Title: debug namespace\\nLink: https://evm.cosmos.network/docs/evm/next/documentation/cosmos-sdk/modules/vm\\nContent: Method Description debug_traceTransaction Detailed tx trace debug_traceBlockByNumber Trace all txs in block debug_traceBlockByHash Trace all txs by hash debug_getBadBlocks Get invalid blocks debug_storageRangeAt Get storage range debug_intermediateRoots Get intermediate state roots\\n\\nSupported Methods\\nMethod Description eth_accounts List accounts eth_blockNumber Current block number eth_call Execute call without tx eth_chainId Get chain ID eth_createAccessList Generate access list for tx optimization (v0.5.0+) eth_estimateGas Estimate gas usage (optimized in v0.5.0+) eth_gasPrice Current gas price eth_getBalance Get account balance eth_getBlockByHash Get block by hash eth_getBlockByNumber Get block by number eth_getCode Get contract code eth_getLogs Get filtered logs eth_getStorageAt Get storage value eth_getTransactionByHash Get tx by hash eth_getTransactionCount Get account nonce eth_getTransactionReceipt Get tx receipt (enhanced with max_used_gas in v0.5.0+) eth_sendRawTransaction Submit signed tx eth_syncing Sync status Method Description web3_clientVersion Client version web3_sha3 Keccak-256 hash Method Description net_version Network ID net_listening Node accepting connections net_peerCount Number of peers Method Description debug_traceTransaction Detailed tx trace debug_traceBlockByNumber Trace all txs in block debug_traceBlockByHash Trace all txs by hash debug_getBadBlocks Get invalid blocks debug_storageRangeAt Get storage range debug_intermediateRoots Get intermediate state roots\\n\\nDebug Commands\\n# Check EVM parameters\\nevmd query vm params\\n\\n# Trace failed transaction\\nevmd query vm trace-tx 0xFailedTxHash\\n\\n# Check account state\\nevmd query vm account 0xAddress\\n\\n\", \"Title: debug namespace\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/documentation/cosmos-sdk/modules/vm\\nContent: Method Description debug_traceTransaction Detailed tx trace debug_traceBlockByNumber Trace all txs in block debug_traceBlockByHash Trace all txs by hash debug_getBadBlocks Get invalid blocks debug_storageRangeAt Get storage range debug_intermediateRoots Get intermediate state roots\\n\\nSupported Methods\\nMethod Description eth_accounts List accounts eth_blockNumber Current block number eth_call Execute call without tx eth_chainId Get chain ID eth_estimateGas Estimate gas usage eth_gasPrice Current gas price eth_getBalance Get account balance eth_getBlockByHash Get block by hash eth_getBlockByNumber Get block by number eth_getCode Get contract code eth_getLogs Get filtered logs eth_getStorageAt Get storage value eth_getTransactionByHash Get tx by hash eth_getTransactionCount Get account nonce eth_getTransactionReceipt Get tx receipt eth_sendRawTransaction Submit signed tx eth_syncing Sync status Method Description web3_clientVersion Client version web3_sha3 Keccak-256 hash Method Description net_version Network ID net_listening Node accepting connections net_peerCount Number of peers Method Description debug_traceTransaction Detailed tx trace debug_traceBlockByNumber Trace all txs in block debug_traceBlockByHash Trace all txs by hash debug_getBadBlocks Get invalid blocks debug_storageRangeAt Get storage range debug_intermediateRoots Get intermediate state roots\\n\\nDebug Commands\\n# Check EVM parameters\\nevmd query vm params\\n\\n# Trace failed transaction\\nevmd query vm trace-tx 0xFailedTxHash\\n\\n# Check account state\\nevmd query vm account 0xAddress\\n\\n\", \"Title: BeginBlocker and EndBlocker\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/build/building-modules/beginblock-endblock\\nContent: BeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. When needed, BeginBlocker and EndBlocker are implemented as part of the BeginBlockAppModule and BeginBlockAppModule interfaces . This means either can be left-out if not required. The BeginBlock and EndBlock methods of the interface implemented in module.go generally defer to BeginBlocker and EndBlocker methods respectively, which are usually implemented in abci.go. The actual implementation of BeginBlocker and EndBlocker in abci.go are very similar to that of a Msg service: They generally use the keeper and ctx to retrieve information about the latest state. If needed, they use the keeper and ctx to trigger state-transitions. If needed, they can emit events via the ctx 's EventManager. A specificity of the EndBlocker is that it can return validator updates to the underlying consensus engine in the form of an []abci.ValidatorUpdates . This is the preferred way to implement custom validator changes. It is possible for developers to define the order of execution between the BeginBlocker/ EndBlocker functions of each of their application's modules via the module's manager SetOrderBeginBlocker/ SetOrderEndBlocker methods. For more on the module manager, click here. See an example implementation of BeginBlocker from the distribution module: and an example implementation of EndBlocker from the staking module: package staking\\n\\nimport (\\n    \\n\\t\\\"time\\\"\\n\\n\\tabci \\\"github.com/tendermint/tendermint/abci/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/staking/keeper\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/staking/types\\\"\\n)\\n\\n// BeginBlocker will persist the current header and validator set as a historical entry\\n// and prune the oldest entry based on the HistoricalEntries parameter\\nfunc BeginBlocker(ctx sdk.Context, k *keeper.Keeper) {\\n    defer telemetry.ModuleMeasureSince(types.ModuleName, time.Now(), telemetry.MetricKeyBeginBlocker)\\n\\nk.TrackHistoricalInfo(ctx)\\n}\\n\\n// Called every block, update validator set\\nfunc EndBlocker(ctx sdk.Context, k *keeper.Keeper) []abci.ValidatorUpdate {\\n    defer telemetry.ModuleMeasureSince(types.ModuleName, time.Now(), telemetry.MetricKeyEndBlocker)\\n\\nreturn k.BlockValidatorUpdates(ctx)\\n}\\n\\nBeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. When needed, BeginBlocker and EndBlocker are implemented as part of the BeginBlockAppModule and BeginBlockAppModule interfaces . This means either can be left-out if not required. The BeginBlock and EndBlock methods of the interface implemented in module.go generally defer to BeginBlocker and EndBlocker methods respectively, which are usually implemented in abci.go. The actual implementation of BeginBlocker and EndBlocker in abci.go are very similar to that of a Msg service: They generally use the keeper and ctx to retrieve information about the latest state. If needed, they use the keeper and ctx to trigger state-transitions. If needed, they can emit events via the ctx 's EventManager. A specificity of the EndBlocker is that it can return validator updates to the underlying consensus engine in the form of an []abci.ValidatorUpdates . This is the preferred way to implement custom validator changes. It is possible for developers to define the order of execution between the BeginBlocker/ EndBlocker functions of each of their application's modules via the module's manager SetOrderBeginBlocker/ SetOrderEndBlocker methods. For more on the module manager, click here. See an example implementation of BeginBlocker from the distribution module: package distribution\\n\\nimport (\\n    \\n\\t\\\"time\\\"\\n\\n\\tabci \\\"github.com/tendermint/tendermint/abci/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/distribution/keeper\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/distribution/types\\\"\\n)\\n\\n// BeginBlocker sets the proposer for determining distribution during endblock\\n// and distribute rewards for the previous block.\\nfunc BeginBlocker(ctx sdk.Context, req abci.RequestBeginBlock, k keeper.Keeper) {\\n    defer telemetry.ModuleMeasureSince(types.ModuleName, time.Now(), telemetry.MetricKeyBeginBlocker)\\n\\n\\t// determine the total power signing the block\\n\\tvar previousTotalPower int64\\n    for _, voteInfo := range req.LastCommitInfo.GetVotes() {\\n    previousTotalPower += voteInfo.Validator.Power\\n}\\n\\n\\t// TODO this is Tendermint-dependent\\n\\t// ref https://github.com/cosmos/cosmos-sdk/issues/3095\\n    if ctx.BlockHeight() > 1 {\\n    k.AllocateTokens(ctx, previousTotalPower, req.LastCommitInfo.GetVotes())\\n}\\n\\n\\t// record the proposer for when we payout on the next block\\n    consAddr := sdk.ConsAddress(req.Header.ProposerAddress)\\n\\nk.SetPreviousProposerConsAddr(ctx, consAddr)\\n}\\n\\nBeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. When needed, BeginBlocker and EndBlocker are implemented as part of the BeginBlockAppModule and BeginBlockAppModule interfaces . This means either can be left-out if not required. The BeginBlock and EndBlock methods of the interface implemented in module.go generally defer to BeginBlocker and EndBlocker methods respectively, which are usually implemented in abci.go. The actual implementation of BeginBlocker and EndBlocker in abci.go are very similar to that of a Msg service: They generally use the keeper and ctx to retrieve information about the latest state. If needed, they use the keeper and ctx to trigger state-transitions. If needed, they can emit events via the ctx 's EventManager. A specificity of the EndBlocker is that it can return validator updates to the underlying consensus engine in the form of an []abci.ValidatorUpdates . This is the preferred way to implement custom validator changes. It is possible for developers to define the order of execution between the BeginBlocker/ EndBlocker functions of each of their application's modules via the module's manager SetOrderBeginBlocker/ SetOrderEndBlocker methods. For more on the module manager, click here. See an example implementation of BeginBlocker from the distribution module: and an example implementation of EndBlocker from the staking module:\\n\\n\", \"Title: BeginBlocker and EndBlocker\\nLink: https://evm.cosmos.network/docs/sdk/v0.50/build/building-modules/beginblock-endblock\\nContent: BeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. In 0.47.0, Prepare and Process Proposal were added that allow app developers to do arbitrary work at those phases, but they do not influence the work that will be done in BeginBlock. If an application required BeginBlock to execute prior to any sort of work is done then this is not possible today (0.50.0). When needed, BeginBlocker and EndBlocker are implemented as part of the HasBeginBlocker , HasABCIEndBlocker and EndBlocker interfaces . This means either can be left-out if not required. The BeginBlock and EndBlock methods of the interface implemented in module.go generally defer to BeginBlocker and EndBlocker methods respectively, which are usually implemented in abci.go. The actual implementation of BeginBlocker and EndBlocker in abci.go are very similar to that of a Msg service: They generally use the keeper and ctx to retrieve information about the latest state. If needed, they use the keeper and ctx to trigger state-transitions. If needed, they can emit events via the ctx 's EventManager. A specific type of EndBlocker is available to return validator updates to the underlying consensus engine in the form of an []abci.ValidatorUpdates . This is the preferred way to implement custom validator changes. It is possible for developers to define the order of execution between the BeginBlocker/ EndBlocker functions of each of their application's modules via the module's manager SetOrderBeginBlocker/ SetOrderEndBlocker methods. For more on the module manager, click here. See an example implementation of BeginBlocker from the distribution module: package distribution\\n\\nimport (\\n    \\n\\t\\\"time\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/distribution/keeper\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/distribution/types\\\"\\n)\\n\\n// BeginBlocker sets the proposer for determining distribution during endblock\\n// and distribute rewards for the previous block.\\nfunc BeginBlocker(ctx sdk.Context, k keeper.Keeper)\\n\\nerror {\\n    defer telemetry.ModuleMeasureSince(types.ModuleName, time.Now(), telemetry.MetricKeyBeginBlocker)\\n\\n\\t// determine the total power signing the block\\n\\tvar previousTotalPower int64\\n    for _, voteInfo := range ctx.VoteInfos() {\\n    previousTotalPower += voteInfo.Validator.Power\\n}\\n\\n\\t// TODO this is Tendermint-dependent\\n\\t// ref https://github.com/cosmos/cosmos-sdk/issues/3095\\n    if ctx.BlockHeight() > 1 {\\n    k.AllocateTokens(ctx, previousTotalPower, ctx.VoteInfos())\\n}\\n\\n\\t// record the proposer for when we payout on the next block\\n    consAddr := sdk.ConsAddress(ctx.BlockHeader().ProposerAddress)\\n\\nk.SetPreviousProposerConsAddr(ctx, consAddr)\\n\\nreturn nil\\n}\\n\\nBeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. In 0.47.0, Prepare and Process Proposal were added that allow app developers to do arbitrary work at those phases, but they do not influence the work that will be done in BeginBlock. If an application required BeginBlock to execute prior to any sort of work is done then this is not possible today (0.50.0). When needed, BeginBlocker and EndBlocker are implemented as part of the HasBeginBlocker , HasABCIEndBlocker and EndBlocker interfaces . This means either can be left-out if not required. The BeginBlock and EndBlock methods of the interface implemented in module.go generally defer to BeginBlocker and EndBlocker methods respectively, which are usually implemented in abci.go. The actual implementation of BeginBlocker and EndBlocker in abci.go are very similar to that of a Msg service: They generally use the keeper and ctx to retrieve information about the latest state. If needed, they use the keeper and ctx to trigger state-transitions. If needed, they can emit events via the ctx 's EventManager. A specific type of EndBlocker is available to return validator updates to the underlying consensus engine in the form of an []abci.ValidatorUpdates . This is the preferred way to implement custom validator changes. It is possible for developers to define the order of execution between the BeginBlocker/ EndBlocker functions of each of their application's modules via the module's manager SetOrderBeginBlocker/ SetOrderEndBlocker methods. For more on the module manager, click here. See an example implementation of BeginBlocker from the distribution module: and an example implementation of EndBlocker from the staking module: package keeper\\n\\nimport (\\n    \\n\\t\\\"context\\\"\\n    \\\"time\\\"\\n\\n\\tabci \\\"github.com/cometbft/cometbft/abci/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/staking/types\\\"\\n)\\n\\n// BeginBlocker will persist the current header and validator set as a historical entry\\n// and prune the oldest entry based on the HistoricalEntries parameter\\nfunc (k *Keeper)\\n\\nBeginBlocker(ctx sdk.Context) {\\n    defer telemetry.ModuleMeasureSince(types.ModuleName, time.Now(), telemetry.MetricKeyBeginBlocker)\\n\\nk.TrackHistoricalInfo(ctx)\\n}\\n\\n// Called every block, update validator set\\nfunc (k *Keeper)\\n\\nEndBlocker(ctx context.Context) ([]abci.ValidatorUpdate, error) {\\n    defer telemetry.ModuleMeasureSince(types.ModuleName, time.Now(), telemetry.MetricKeyEndBlocker)\\n\\nreturn k.BlockValidatorUpdates(sdk.UnwrapSDKContext(ctx)), nil\\n}\\n\\nBeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. In 0.47.0, Prepare and Process Proposal were added that allow app developers to do arbitrary work at those phases, but they do not influence the work that will be done in BeginBlock. If an application required BeginBlock to execute prior to any sort of work is done then this is not possible today (0.50.0). When needed, BeginBlocker and EndBlocker are implemented as part of the HasBeginBlocker , HasABCIEndBlocker and EndBlocker interfaces . This means either can be left-out if not required. The BeginBlock and EndBlock methods of the interface implemented in module.go generally defer to BeginBlocker and EndBlocker methods respectively, which are usually implemented in abci.go. The actual implementation of BeginBlocker and EndBlocker in abci.go are very similar to that of a Msg service: They generally use the keeper and ctx to retrieve information about the latest state. If needed, they use the keeper and ctx to trigger state-transitions. If needed, they can emit events via the ctx 's EventManager. A specific type of EndBlocker is available to return validator updates to the underlying consensus engine in the form of an []abci.ValidatorUpdates . This is the preferred way to implement custom validator changes. It is possible for developers to define the order of execution between the BeginBlocker/ EndBlocker functions of each of their application's modules via the module's manager SetOrderBeginBlocker/ SetOrderEndBlocker methods. For more on the module manager, click here. See an example implementation of BeginBlocker from the distribution module: and an example implementation of EndBlocker from the staking module:\\n\\n\", \"Title: BeginBlocker and EndBlocker\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/build/building-modules/beginblock-endblock\\nContent: BeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. In 0.47.0, Prepare and Process Proposal were added that allow app developers to do arbitrary work at those phases, but they do not influence the work that will be done in BeginBlock. If an application required BeginBlock to execute prior to any sort of work is done then this is not possible today (0.50.0). When needed, BeginBlocker and EndBlocker are implemented as part of the HasBeginBlocker , HasABCIEndBlocker and EndBlocker interfaces . This means either can be left-out if not required. The BeginBlock and EndBlock methods of the interface implemented in module.go generally defer to BeginBlocker and EndBlocker methods respectively, which are usually implemented in abci.go. The actual implementation of BeginBlocker and EndBlocker in abci.go are very similar to that of a Msg service: They generally use the keeper and ctx to retrieve information about the latest state. If needed, they use the keeper and ctx to trigger state-transitions. If needed, they can emit events via the ctx 's EventManager. A specific type of EndBlocker is available to return validator updates to the underlying consensus engine in the form of an []abci.ValidatorUpdates . This is the preferred way to implement custom validator changes. It is possible for developers to define the order of execution between the BeginBlocker/ EndBlocker functions of each of their application's modules via the module's manager SetOrderBeginBlocker/ SetOrderEndBlocker methods. For more on the module manager, click here. See an example implementation of BeginBlocker from the distribution module: package distribution\\n\\nimport (\\n    \\n\\t\\\"time\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/distribution/keeper\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/distribution/types\\\"\\n)\\n\\n// BeginBlocker sets the proposer for determining distribution during endblock\\n// and distribute rewards for the previous block.\\nfunc BeginBlocker(ctx sdk.Context, k keeper.Keeper)\\n\\nerror {\\n    defer telemetry.ModuleMeasureSince(types.ModuleName, time.Now(), telemetry.MetricKeyBeginBlocker)\\n\\n\\t// determine the total power signing the block\\n\\tvar previousTotalPower int64\\n    for _, voteInfo := range ctx.VoteInfos() {\\n    previousTotalPower += voteInfo.Validator.Power\\n}\\n\\n\\t// TODO this is Tendermint-dependent\\n\\t// ref https://github.com/cosmos/cosmos-sdk/issues/3095\\n    if ctx.BlockHeight() > 1 {\\n    k.AllocateTokens(ctx, previousTotalPower, ctx.VoteInfos())\\n}\\n\\n\\t// record the proposer for when we payout on the next block\\n    consAddr := sdk.ConsAddress(ctx.BlockHeader().ProposerAddress)\\n\\nk.SetPreviousProposerConsAddr(ctx, consAddr)\\n\\nreturn nil\\n}\\n\\nBeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. In 0.47.0, Prepare and Process Proposal were added that allow app developers to do arbitrary work at those phases, but they do not influence the work that will be done in BeginBlock. If an application required BeginBlock to execute prior to any sort of work is done then this is not possible today (0.50.0). When needed, BeginBlocker and EndBlocker are implemented as part of the HasBeginBlocker , HasABCIEndBlocker and EndBlocker interfaces . This means either can be left-out if not required. The BeginBlock and EndBlock methods of the interface implemented in module.go generally defer to BeginBlocker and EndBlocker methods respectively, which are usually implemented in abci.go. The actual implementation of BeginBlocker and EndBlocker in abci.go are very similar to that of a Msg service: They generally use the keeper and ctx to retrieve information about the latest state. If needed, they use the keeper and ctx to trigger state-transitions. If needed, they can emit events via the ctx 's EventManager. A specific type of EndBlocker is available to return validator updates to the underlying consensus engine in the form of an []abci.ValidatorUpdates . This is the preferred way to implement custom validator changes. It is possible for developers to define the order of execution between the BeginBlocker/ EndBlocker functions of each of their application's modules via the module's manager SetOrderBeginBlocker/ SetOrderEndBlocker methods. For more on the module manager, click here. See an example implementation of BeginBlocker from the distribution module: and an example implementation of EndBlocker from the staking module: package keeper\\n\\nimport (\\n    \\n\\t\\\"context\\\"\\n    \\\"time\\\"\\n\\n\\tabci \\\"github.com/cometbft/cometbft/abci/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/telemetry\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/staking/types\\\"\\n)\\n\\n// BeginBlocker will persist the current header and validator set as a historical entry\\n// and prune the oldest entry based on the HistoricalEntries parameter\\nfunc (k *Keeper)\\n\\nBeginBlocker(ctx sdk.Context) {\\n    defer telemetry.ModuleMeasureSince(types.ModuleName, time.Now(), telemetry.MetricKeyBeginBlocker)\\n\\nk.TrackHistoricalInfo(ctx)\\n}\\n\\n// Called every block, update validator set\\nfunc (k *Keeper)\\n\\nEndBlocker(ctx context.Context) ([]abci.ValidatorUpdate, error) {\\n    defer telemetry.ModuleMeasureSince(types.ModuleName, time.Now(), telemetry.MetricKeyEndBlocker)\\n\\nreturn k.BlockValidatorUpdates(sdk.UnwrapSDKContext(ctx)), nil\\n}\\n\\nBeginBlocker and EndBlocker are a way for module developers to add automatic execution of logic to their module. This is a powerful tool that should be used carefully, as complex automatic functions can slow down or even halt the chain. In 0.47.0, Prepare and Process Proposal were added that allow app developers to do arbitrary work at those phases, but they do not influence the work that will be done in BeginBlock. If an application required BeginBlock to execute prior to any sort of work is done then this is not possible today (0.50.0). When needed, BeginBlocker and EndBlocker are implemented as part of the HasBeginBlocker , HasABCIEndBlocker and EndBlocker interfaces . This means either can be left-out if not required. The BeginBlock and EndBlock methods of the interface implemented in module.go generally defer to BeginBlocker and EndBlocker methods respectively, which are usually implemented in abci.go. The actual implementation of BeginBlocker and EndBlocker in abci.go are very similar to that of a Msg service: They generally use the keeper and ctx to retrieve information about the latest state. If needed, they use the keeper and ctx to trigger state-transitions. If needed, they can emit events via the ctx 's EventManager. A specific type of EndBlocker is available to return validator updates to the underlying consensus engine in the form of an []abci.ValidatorUpdates . This is the preferred way to implement custom validator changes. It is possible for developers to define the order of execution between the BeginBlocker/ EndBlocker functions of each of their application's modules via the module's manager SetOrderBeginBlocker/ SetOrderEndBlocker methods. For more on the module manager, click here. See an example implementation of BeginBlocker from the distribution module: and an example implementation of EndBlocker from the staking module:\\n\\n\", \"Title: What is the Cosmos SDK\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/learn/intro/overview\\nContent: The Cosmos SDK is an open-source framework for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains. We envision the Cosmos SDK as the npm-like framework to build secure blockchain applications on top of CometBFT . SDK-based blockchains are built out of composable modules , most of which are open-source and readily available for any developers to use. Anyone can create a module for the Cosmos SDK, and integrating already-built modules is as simple as importing them into your blockchain application. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model.\\n\\nWhat is the Cosmos SDK\\nThe Cosmos SDK is an open-source framework for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains. We envision the Cosmos SDK as the npm-like framework to build secure blockchain applications on top of CometBFT . SDK-based blockchains are built out of composable modules , most of which are open-source and readily available for any developers to use. Anyone can create a module for the Cosmos SDK, and integrating already-built modules is as simple as importing them into your blockchain application. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model.\\n\\nWhy the Cosmos SDK\\nThe Cosmos SDK is the most advanced framework for building custom application-specific blockchains today. Here are a few reasons why you might want to consider building your decentralized application with the Cosmos SDK: The default consensus engine available within the Cosmos SDK is CometBFT . CometBFT is the most (and only) mature BFT consensus engine in existence. It is widely used across the industry and is considered the gold standard consensus engine for building Proof-of-Stake systems. The Cosmos SDK is open-source and designed to make it easy to build blockchains out of composable modules . As the ecosystem of open-source Cosmos SDK modules grows, it will become increasingly easier to build complex decentralized platforms with it. The Cosmos SDK is inspired by capabilities-based security, and informed by years of wrestling with blockchain state-machines. This makes the Cosmos SDK a very secure environment to build blockchains. Most importantly, the Cosmos SDK has already been used to build many application-specific blockchains that are already in production. Among others, we can cite Cosmos Hub , IRIS Hub , Binance Chain , Terra or Kava . Many more are building on the Cosmos SDK.\\n\\n\", \"Title: What is the Cosmos SDK\\nLink: https://evm.cosmos.network/docs/sdk/v0.50/learn/intro/overview\\nContent: The Cosmos SDK is an open-source toolkit for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains.\\nWe further this modular approach by allowing developers to plug and play with different consensus engines this can range from the CometBFT or Rollkit. SDK-based blockchains have the choice to use the predefined modules or to build their own modules. What this means is that developers can build a blockchain that is tailored to their specific use case, without having to worry about the low-level details of building a blockchain from scratch. Predefined modules include staking, governance, and token issuance, among others. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model. How you can look at this is if we imagine that the SDK is like a lego kit. You can choose to build the basic house from the instructions or you can choose to modify your house and add more floors, more doors, more windows. The choice is yours.\\n\\nWhat is the Cosmos SDK\\nThe Cosmos SDK is an open-source toolkit for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains.\\nWe further this modular approach by allowing developers to plug and play with different consensus engines this can range from the CometBFT or Rollkit. SDK-based blockchains have the choice to use the predefined modules or to build their own modules. What this means is that developers can build a blockchain that is tailored to their specific use case, without having to worry about the low-level details of building a blockchain from scratch. Predefined modules include staking, governance, and token issuance, among others. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model. How you can look at this is if we imagine that the SDK is like a lego kit. You can choose to build the basic house from the instructions or you can choose to modify your house and add more floors, more doors, more windows. The choice is yours.\\n\\nWhy the Cosmos SDK\\nThe Cosmos SDK is the most advanced framework for building custom modular application-specific blockchains today. Here are a few reasons why you might want to consider building your decentralized application with the Cosmos SDK: It allows you to plug and play and customize your consensus layer. As above you can use Rollkit and Celestia as your consensus and data availability layer. This offers a lot of flexibility and customisation. Previously the default consensus engine available within the Cosmos SDK is CometBFT . CometBFT is the most (and only) mature BFT consensus engine in existence. It is widely used across the industry and is considered the gold standard consensus engine for building Proof-of-Stake systems. The Cosmos SDK is open-source and designed to make it easy to build blockchains out of composable modules . As the ecosystem of open-source Cosmos SDK modules grows, it will become increasingly easier to build complex decentralized platforms with it. The Cosmos SDK is inspired by capabilities-based security, and informed by years of wrestling with blockchain state-machines. This makes the Cosmos SDK a very secure environment to build blockchains. Most importantly, the Cosmos SDK has already been used to build many application-specific blockchains that are already in production. Among others, we can cite Cosmos Hub , IRIS Hub , Binance Chain , Terra or Kava . Many more are building on the Cosmos SDK.\\n\\n\", \"Title: What is the Cosmos SDK\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/learn/intro/overview\\nContent: The Cosmos SDK is an open-source toolkit for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains.\\nWe further this modular approach by allowing developers to plug and play with different consensus engines this can range from the CometBFT or Rollkit. SDK-based blockchains have the choice to use the predefined modules or to build their own modules. What this means is that developers can build a blockchain that is tailored to their specific use case, without having to worry about the low-level details of building a blockchain from scratch. Predefined modules include staking, governance, and token issuance, among others. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model. How you can look at this is if we imagine that the SDK is like a lego kit. You can choose to build the basic house from the instructions or you can choose to modify your house and add more floors, more doors, more windows. The choice is yours.\\n\\nWhat is the Cosmos SDK\\nThe Cosmos SDK is an open-source toolkit for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains.\\nWe further this modular approach by allowing developers to plug and play with different consensus engines this can range from the CometBFT or Rollkit. SDK-based blockchains have the choice to use the predefined modules or to build their own modules. What this means is that developers can build a blockchain that is tailored to their specific use case, without having to worry about the low-level details of building a blockchain from scratch. Predefined modules include staking, governance, and token issuance, among others. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model. How you can look at this is if we imagine that the SDK is like a lego kit. You can choose to build the basic house from the instructions or you can choose to modify your house and add more floors, more doors, more windows. The choice is yours.\\n\\nWhy the Cosmos SDK\\nThe Cosmos SDK is the most advanced framework for building custom modular application-specific blockchains today. Here are a few reasons why you might want to consider building your decentralized application with the Cosmos SDK: It allows you to plug and play and customize your consensus layer. As above you can use Rollkit and Celestia as your consensus and data availability layer. This offers a lot of flexibility and customisation. Previously the default consensus engine available within the Cosmos SDK is CometBFT . CometBFT is the most (and only) mature BFT consensus engine in existence. It is widely used across the industry and is considered the gold standard consensus engine for building Proof-of-Stake systems. The Cosmos SDK is open-source and designed to make it easy to build blockchains out of composable modules . As the ecosystem of open-source Cosmos SDK modules grows, it will become increasingly easier to build complex decentralized platforms with it. The Cosmos SDK is inspired by capabilities-based security, and informed by years of wrestling with blockchain state-machines. This makes the Cosmos SDK a very secure environment to build blockchains. Most importantly, the Cosmos SDK has already been used to build many application-specific blockchains that are already in production. Among others, we can cite Cosmos Hub , IRIS Hub , Binance Chain , Terra or Kava . Many more are building on the Cosmos SDK.\\n\\n\"]",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "tool",
            "name": "SearchCosmosDocumentation",
            "id": "61c0ae99-acdb-43d6-88de-c64285c074b4",
            "tool_call_id": "call_Vy8JyaAymYlpVDGyuKZdNPi0",
            "artifact": null,
            "status": "success"
        },
        {
            "content": "",
            "additional_kwargs": {
                "tool_calls": [
                    {
                        "id": "call_8zxrSkzdRBOJVsyqNh361lwJ",
                        "function": {
                            "arguments": "{\"query\": \"debug_writeMemProfile Cosmos\"}",
                            "name": "SearchCosmosDocumentation"
                        },
                        "type": "function"
                    }
                ],
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 542,
                    "prompt_tokens": 10069,
                    "total_tokens": 10611,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 512,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CPw4ZvdJ9fvPhfbFtvgSt2WYG9IDe",
                "service_tier": "default",
                "finish_reason": "tool_calls",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--1bb7c1f0-deb2-402a-b062-ea37d9821a97-0",
            "example": false,
            "tool_calls": [
                {
                    "name": "SearchCosmosDocumentation",
                    "args": {
                        "query": "debug_writeMemProfile Cosmos"
                    },
                    "id": "call_8zxrSkzdRBOJVsyqNh361lwJ",
                    "type": "tool_call"
                }
            ],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 10069,
                "output_tokens": 542,
                "total_tokens": 10611,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 512
                }
            }
        },
        {
            "content": "[\"Title: debug_writeMemProfile\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/api-reference/ethereum-json-rpc/methods\\nContent: Writes an allocation profile to the specified file. Private : Requires authentication.\\n\\ndebug_writeBlockProfile\\nWrites a goroutine blocking profile to the specified file. Private : Requires authentication.\\n\\ndebug_writeMutexProfile\\nWrites a mutex contention profile to the specified file. Private : Requires authentication.\\n\\n\", \"Title: debug_writeMemProfile\\nLink: https://evm.cosmos.network/docs/evm/next/api-reference/ethereum-json-rpc/methods\\nContent: Writes an allocation profile to the specified file. Private : Requires authentication.\\n\\ndebug_writeBlockProfile\\nWrites a goroutine blocking profile to the specified file. Private : Requires authentication.\\n\\ndebug_writeMutexProfile\\nWrites a mutex contention profile to the specified file. Private : Requires authentication.\\n\\n\", \"Title: CosmosPoolConfig Parameters\\nLink: https://evm.cosmos.network/docs/evm/next/documentation/concepts/mempool\\nContent: Source: Cosmos SDK mempool types type PriorityNonceMempoolConfig[C comparable] struct {\\n    TxPriority    TxPriority[C]    // Custom priority calculation function\\n    OnRead        func(tx sdk.Tx)  // Callback when transaction is read\\n    TxReplacement TxReplacement[C] // Transaction replacement rules\\n}\\n\\n// Priority calculation interface\\ntype TxPriority[C comparable] struct {\\n    GetTxPriority func(context.Context, sdk.Tx) C // Calculate transaction priority\\n    Compare       func(a, b C) int                // Compare two priorities  \\n    MinValue      C                               // Minimum priority value\\n}\\n\\nSource: Cosmos SDK mempool types\\n\\nAdvanced Configuration\\n// Custom configuration for high-throughput chains\\nmempoolConfig := &evmmempool.EVMMempoolConfig{\\n    LegacyPoolConfig: &legacypool.Config{\\n        AccountSlots: 32,           // Transactions per account (default: 16)\\n        GlobalSlots:  8192,         // Total pending transactions (default: 5120)  \\n        AccountQueue: 128,          // Queued per account (default: 64)\\n        GlobalQueue:  2048,         // Total queued transactions (default: 1024)\\n        Lifetime:     6*time.Hour,  // Transaction lifetime (default: 3h)\\n        PriceLimit:   2,            // Min gas price in wei (default: 1)\\n        PriceBump:    15,           // Replacement bump % (default: 10)\\n        // Source: mempool/txpool/legacypool/legacypool.go:168-178\\n        Journal:      \\\"txpool.rlp\\\", // Persistence file (default: \\\"transactions.rlp\\\")\\n        Rejournal:    2*time.Hour,  // Journal refresh interval (default: 1h)\\n    },\\n    CosmosPoolConfig: &sdkmempool.PriorityNonceMempoolConfig[math.Int]{\\n        TxPriority: sdkmempool.TxPriority[math.Int]{\\n            GetTxPriority: customPriorityFunction,\\n            Compare:       math.IntComparator,\\n            MinValue:      math.ZeroInt(),\\n        },\\n    },\\n    AnteHandler:   app.GetAnteHandler(),\\n    BroadcastTxFn: customBroadcastFunction, // Optional custom broadcast logic\\n    BlockGasLimit: 200_000_000,             // Custom block gas limit\\n}\\n\\n\", \"Title: Cosmos Transactions\\nLink: https://evm.cosmos.network/docs/evm/next/documentation/concepts/transactions\\nContent: On Cosmos chains, transactions are comprised of metadata held in contexts and sdk.Msg s that trigger state changes within a module through the module's Protobuf Msg service. When users want to interact with an application and make state changes (e.g. sending coins), they create transactions. Cosmos transactions can have multiple sdk.Msg s. Each of these must be signed using the private key associated with the appropriate account(s), before the transaction is broadcasted to the network. A Cosmos transaction includes the following information: Msgs : an array of msgs ( sdk.Msg) GasLimit : option chosen by the users for how to calculate how much gas they will need to pay FeeAmount : max amount user is willing to pay in fees TimeoutHeight : block height until which the transaction is valid Signatures : array of signatures from all signers of the tx Memo : a note or comment to send with the transaction To submit a Cosmos transaction, users must use one of the provided clients.\\n\\nDeliverTx Phase\\nMessage unwrapping : msg.AsTransaction() extracts Ethereum transaction from MsgEthereumTx ( x/vm/keeper/msg_server.go:32) State transition : ApplyTransaction() executes EVM logic with gas isolation ( x/vm/keeper/state_transition.go:165-199) Cache contexts : Isolated execution with rollback capability ( x/vm/keeper/state_transition.go:182) State commitment : Successful transactions committed to Cosmos SDK store For detailed transaction flow and mempool behavior, see the Mempool documentation and Cosmos SDK lifecycle. The transaction hash is a unique identifier and can be used to check transaction information, for example, the events emitted, if was successful or not. Transactions can fail for various reasons. For example, the provided gas or fees may be insufficient. Also, the transaction validation may fail. Each transaction has specific conditions that must fullfil to be considered valid. A widespread validation is that the sender is the transaction signer. In such a case, if you send a transaction where the sender address is different than the signer's address, the transation will fail, even if the fees are sufficient. Nowadays, transactions can not only perform state transitions on the chain in which are submitted, but also can execute transactions on another blockchains. Interchain transactions are possible through the Inter-Blockchain Communication protocol (IBC) . Find a more detailed explanation on the section below.\\n\\nTransaction Types\\nCosmos EVM supports two transaction types: Cosmos transactions Ethereum transactions This is possible because the Cosmos EVM uses the Cosmos-SDK and implements the Ethereum Virtual Machine as a module. In this way, Cosmos EVM provides the features and functionalities of Ethereum and Cosmos chains combined, and more. Although most of the information included on both of these transaction types is similar, there are differences among them. An important difference, is that Cosmos transactions allow multiple messages on the same transaction. Conversely, Ethereum transactions don't have this possibility. Cosmos EVM implements Ethereum transactions by wrapping them in MsgEthereumTx ( x/vm/types/tx.pb.go:36-43 ), which contains: From : Ethereum signer address bytes for signature verification Raw : Complete Ethereum transaction data This wrapper uniquely implements both sdk.Msg and sdk.Tx interfaces, bypassing standard SDK transaction bundling to use go-ethereum validation logic directly. Find more information about these two types on the following sections.\\n\\n\", \"Title: Cosmos Transactions\\nLink: https://evm.cosmos.network/docs/evm/v0.4.x/documentation/concepts/transactions\\nContent: On Cosmos chains, transactions are comprised of metadata held in contexts and sdk.Msg s that trigger state changes within a module through the module's Protobuf Msg service. When users want to interact with an application and make state changes (e.g. sending coins), they create transactions. Cosmos transactions can have multiple sdk.Msg s. Each of these must be signed using the private key associated with the appropriate account(s), before the transaction is broadcasted to the network. A Cosmos transaction includes the following information: Msgs : an array of msgs ( sdk.Msg) GasLimit : option chosen by the users for how to calculate how much gas they will need to pay FeeAmount : max amount user is willing to pay in fees TimeoutHeight : block height until which the transaction is valid Signatures : array of signatures from all signers of the tx Memo : a note or comment to send with the transaction To submit a Cosmos transaction, users must use one of the provided clients.\\n\\nTransaction Types\\nCosmos EVM supports two transaction types: Cosmos transactions Ethereum transactions This is possible because the Cosmos EVM uses the Cosmos-SDK and implements the Ethereum Virtual Machine as a module. In this way, Cosmos EVM provides the features and functionalities of Ethereum and Cosmos chains combined, and more. Although most of the information included on both of these transaction types is similar, there are differences among them. An important difference, is that Cosmos transactions allow multiple messages on the same transaction. Conversely, Ethereum transactions don't have this possibility. To bring these two types together, Cosmos EVM implements Ethereum transactions as a single sdk.Msg contained in an auth.StdTx . All relevant Ethereum transaction information is contained in this message. This includes the signature, gas, payload, etc. Find more information about these two types on the following sections.\\n\\nTransaction Ordering and Prioritization\\nIn Cosmos EVM, both Ethereum and Cosmos transactions compete fairly for block inclusion: Transactions are ordered by their effective tips: Ethereum : gas_tip_cap or min(gas_tip_cap, gas_fee_cap - base_fee) Cosmos : (fee_amount / gas_limit) - base_fee Higher tips = higher priority, regardless of transaction type Ethereum transactions support nonce gaps: Correct nonce \u2192 immediate broadcast Nonce gap \u2192 queued locally Gap filled \u2192 automatic promotion Cosmos transactions require sequential nonces. For detailed mempool behavior and flow diagrams, see Mempool Architecture.\\n\\n\", \"Title: Main Components of the Cosmos SDK\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/learn/intro/sdk-design\\nContent: The Cosmos SDK is a framework that facilitates the development of secure state-machines on top of CometBFT. At its core, the Cosmos SDK is a boilerplate implementation of the ABCI in Golang. It comes with a multistore to persist data and a router to handle transactions. Here is a simplified view of how transactions are handled by an application built on top of the Cosmos SDK when transferred from CometBFT via DeliverTx: Decode transactions received from the CometBFT consensus engine (remember that CometBFT only deals with []bytes ). Extract messages from transactions and do basic sanity checks. Route each message to the appropriate module so that it can be processed. Commit state changes.\\n\\nMain Components of the Cosmos SDK\\nThe Cosmos SDK is a framework that facilitates the development of secure state-machines on top of CometBFT. At its core, the Cosmos SDK is a boilerplate implementation of the ABCI in Golang. It comes with a multistore to persist data and a router to handle transactions. Here is a simplified view of how transactions are handled by an application built on top of the Cosmos SDK when transferred from CometBFT via DeliverTx: Decode transactions received from the CometBFT consensus engine (remember that CometBFT only deals with []bytes ). Extract messages from transactions and do basic sanity checks. Route each message to the appropriate module so that it can be processed. Commit state changes.\\n\\nModules\\nThe power of the Cosmos SDK lies in its modularity. Cosmos SDK applications are built by aggregating a collection of interoperable modules. Each module defines a subset of the state and contains its own message/transaction processor, while the Cosmos SDK is responsible for routing each message to its respective module. Here is a simplified view of how a transaction is processed by the application of each full-node when it is received in a valid block: Each module can be seen as a little state-machine. Developers need to define the subset of the state handled by the module, as well as custom message types that modify the state ( Note: messages are extracted from transactions by baseapp ). In general, each module declares its own KVStore in the multistore to persist the subset of the state it defines. Most developers will need to access other 3rd party modules when building their own modules. Given that the Cosmos SDK is an open framework, some of the modules may be malicious, which means there is a need for security principles to reason about inter-module interactions. These principles are based on object-capabilities . In practice, this means that instead of having each module keep an access control list for other modules, each module implements special objects called keepers that can be passed to other modules to grant a pre-defined set of capabilities. Cosmos SDK modules are defined in the x/ folder of the Cosmos SDK. Some core modules include: x/auth : Used to manage accounts and signatures. x/bank : Used to enable tokens and token transfers. x/staking + x/slashing : Used to build Proof-of-Stake blockchains. In addition to the already existing modules in x/ , which anyone can use in their app, the Cosmos SDK lets you build your own custom modules. You can check an example of that in the tutorial.\\n\\n\", \"Title: Main Components of the Cosmos SDK\\nLink: https://evm.cosmos.network/docs/sdk/v0.50/learn/intro/sdk-design\\nContent: The Cosmos SDK is a framework that facilitates the development of secure state-machines on top of CometBFT. At its core, the Cosmos SDK is a boilerplate implementation of the ABCI in Golang. It comes with a multistore to persist data and a router to handle transactions. Here is a simplified view of how transactions are handled by an application built on top of the Cosmos SDK when transferred from CometBFT via DeliverTx: Decode transactions received from the CometBFT consensus engine (remember that CometBFT only deals with []bytes ). Extract messages from transactions and do basic sanity checks. Route each message to the appropriate module so that it can be processed. Commit state changes.\\n\\nMain Components of the Cosmos SDK\\nThe Cosmos SDK is a framework that facilitates the development of secure state-machines on top of CometBFT. At its core, the Cosmos SDK is a boilerplate implementation of the ABCI in Golang. It comes with a multistore to persist data and a router to handle transactions. Here is a simplified view of how transactions are handled by an application built on top of the Cosmos SDK when transferred from CometBFT via DeliverTx: Decode transactions received from the CometBFT consensus engine (remember that CometBFT only deals with []bytes ). Extract messages from transactions and do basic sanity checks. Route each message to the appropriate module so that it can be processed. Commit state changes.\\n\\nModules\\nThe power of the Cosmos SDK lies in its modularity. Cosmos SDK applications are built by aggregating a collection of interoperable modules. Each module defines a subset of the state and contains its own message/transaction processor, while the Cosmos SDK is responsible for routing each message to its respective module. Here is a simplified view of how a transaction is processed by the application of each full-node when it is received in a valid block: Each module can be seen as a little state-machine. Developers need to define the subset of the state handled by the module, as well as custom message types that modify the state ( Note: messages are extracted from transactions by baseapp ). In general, each module declares its own KVStore in the multistore to persist the subset of the state it defines. Most developers will need to access other 3rd party modules when building their own modules. Given that the Cosmos SDK is an open framework, some of the modules may be malicious, which means there is a need for security principles to reason about inter-module interactions. These principles are based on object-capabilities . In practice, this means that instead of having each module keep an access control list for other modules, each module implements special objects called keepers that can be passed to other modules to grant a pre-defined set of capabilities. Cosmos SDK modules are defined in the x/ folder of the Cosmos SDK. Some core modules include: x/auth : Used to manage accounts and signatures. x/bank : Used to enable tokens and token transfers. x/staking + x/slashing : Used to build Proof-Of-Stake blockchains. In addition to the already existing modules in x/ , that anyone can use in their app, the Cosmos SDK lets you build your own custom modules. You can check an example of that in the tutorial.\\n\\n\", \"Title: Main Components of the Cosmos SDK\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/learn/intro/sdk-design\\nContent: The Cosmos SDK is a framework that facilitates the development of secure state-machines on top of CometBFT. At its core, the Cosmos SDK is a boilerplate implementation of the ABCI in Golang. It comes with a multistore to persist data and a router to handle transactions. Here is a simplified view of how transactions are handled by an application built on top of the Cosmos SDK when transferred from CometBFT via DeliverTx: Decode transactions received from the CometBFT consensus engine (remember that CometBFT only deals with []bytes ). Extract messages from transactions and do basic sanity checks. Route each message to the appropriate module so that it can be processed. Commit state changes.\\n\\nMain Components of the Cosmos SDK\\nThe Cosmos SDK is a framework that facilitates the development of secure state-machines on top of CometBFT. At its core, the Cosmos SDK is a boilerplate implementation of the ABCI in Golang. It comes with a multistore to persist data and a router to handle transactions. Here is a simplified view of how transactions are handled by an application built on top of the Cosmos SDK when transferred from CometBFT via DeliverTx: Decode transactions received from the CometBFT consensus engine (remember that CometBFT only deals with []bytes ). Extract messages from transactions and do basic sanity checks. Route each message to the appropriate module so that it can be processed. Commit state changes.\\n\\nbaseapp\\nbaseapp is the boilerplate implementation of a Cosmos SDK application. It comes with an implementation of the ABCI to handle the connection with the underlying consensus engine. Typically, a Cosmos SDK application extends baseapp by embedding it in app.go. Here is an example of this from simapp , the Cosmos SDK demonstration app: //go:build app_v1\\n\\npackage simapp\\n\\nimport (\\n    \\n\\t\\\"encoding/json\\\"\\n    \\\"io\\\"\\n    \\\"os\\\"\\n    \\\"path/filepath\\\"\\n\\n\\tautocliv1 \\\"cosmossdk.io/api/cosmos/autocli/v1\\\"\\n\\treflectionv1 \\\"cosmossdk.io/api/cosmos/reflection/v1\\\"\\n    \\\"github.com/spf13/cast\\\"\\n\\tabci \\\"github.com/tendermint/tendermint/abci/types\\\"\\n    \\\"github.com/tendermint/tendermint/libs/log\\\"\\n\\tdbm \\\"github.com/tendermint/tm-db\\\"\\n\\n\\tsimappparams \\\"cosmossdk.io/simapp/params\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/baseapp\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/flags\\\"\\n\\tnodeservice \\\"github.com/cosmos/cosmos-sdk/client/grpc/node\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/client/grpc/tmservice\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/codec\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/codec/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/runtime\\\"\\n\\truntimeservices \\\"github.com/cosmos/cosmos-sdk/runtime/services\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server/api\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/server/config\\\"\\n\\tservertypes \\\"github.com/cosmos/cosmos-sdk/server/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/std\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/store/streaming\\\"\\n\\tstoretypes \\\"github.com/cosmos/cosmos-sdk/store/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/testutil/testdata_pulsar\\\"\\n\\tsdk \\\"github.com/cosmos/cosmos-sdk/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/types/module\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/version\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/auth\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/auth/ante\\\"\\n\\tauthkeeper \\\"github.com/cosmos/cosmos-sdk/x/auth/keeper\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/auth/posthandler\\\"\\n\\tauthsims \\\"github.com/cosmos/cosmos-sdk/x/auth/simulation\\\"\\n\\tauthtx \\\"github.com/cosmos/cosmos-sdk/x/auth/tx\\\"\\n\\tauthtypes \\\"github.com/cosmos/cosmos-sdk/x/auth/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/auth/vesting\\\"\\n\\tvestingtypes \\\"github.com/cosmos/cosmos-sdk/x/auth/vesting/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/authz\\\"\\n\\tauthzkeeper \\\"github.com/cosmos/cosmos-sdk/x/authz/keeper\\\"\\n\\tauthzmodule \\\"github.com/cosmos/cosmos-sdk/x/authz/module\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/bank\\\"\\n\\tbankkeeper \\\"github.com/cosmos/cosmos-sdk/x/bank/keeper\\\"\\n\\tbanktypes \\\"github.com/cosmos/cosmos-sdk/x/bank/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/capability\\\"\\n\\tcapabilitykeeper \\\"github.com/cosmos/cosmos-sdk/x/capability/keeper\\\"\\n\\tcapabilitytypes \\\"github.com/cosmos/cosmos-sdk/x/capability/types\\\"\\n\\tconsensus \\\"github.com/cosmos/cosmos-sdk/x/consensus\\\"\\n\\tconsensusparamkeeper \\\"github.com/cosmos/cosmos-sdk/x/consensus/keeper\\\"\\n\\tconsensusparamtypes \\\"github.com/cosmos/cosmos-sdk/x/consensus/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/crisis\\\"\\n\\tcrisiskeeper \\\"github.com/cosmos/cosmos-sdk/x/crisis/keeper\\\"\\n\\tcrisistypes \\\"github.com/cosmos/cosmos-sdk/x/crisis/types\\\"\\n\\tdistr \\\"github.com/cosmos/cosmos-sdk/x/distribution\\\"\\n\\tdistrkeeper \\\"github.com/cosmos/cosmos-sdk/x/distribution/keeper\\\"\\n\\tdistrtypes \\\"github.com/cosmos/cosmos-sdk/x/distribution/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/evidence\\\"\\n\\tevidencekeeper \\\"github.com/cosmos/cosmos-sdk/x/evidence/keeper\\\"\\n\\tevidencetypes \\\"github.com/cosmos/cosmos-sdk/x/evidence/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/feegrant\\\"\\n\\tfeegrantkeeper \\\"github.com/cosmos/cosmos-sdk/x/feegrant/keeper\\\"\\n\\tfeegrantmodule \\\"github.com/cosmos/cosmos-sdk/x/feegrant/module\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/genutil\\\"\\n\\tgenutiltypes \\\"github.com/cosmos/cosmos-sdk/x/genutil/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/gov\\\"\\n\\tgovclient \\\"github.com/cosmos/cosmos-sdk/x/gov/client\\\"\\n\\tgovkeeper \\\"github.com/cosmos/cosmos-sdk/x/gov/keeper\\\"\\n\\tgovtypes \\\"github.com/cosmos/cosmos-sdk/x/gov/types\\\"\\n\\tgovv1 \\\"github.com/cosmos/cosmos-sdk/x/gov/types/v1\\\"\\n\\tgovv1beta1 \\\"github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/group\\\"\\n\\tgroupkeeper \\\"github.com/cosmos/cosmos-sdk/x/group/keeper\\\"\\n\\tgroupmodule \\\"github.com/cosmos/cosmos-sdk/x/group/module\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/mint\\\"\\n\\tmintkeeper \\\"github.com/cosmos/cosmos-sdk/x/mint/keeper\\\"\\n\\tminttypes \\\"github.com/cosmos/cosmos-sdk/x/mint/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/nft\\\"\\n\\tnftkeeper \\\"github.com/cosmos/cosmos-sdk/x/nft/keeper\\\"\\n\\tnftmodule \\\"github.com/cosmos/cosmos-sdk/x/nft/module\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/params\\\"\\n\\tparamsclient \\\"github.com/cosmos/cosmos-sdk/x/params/client\\\"\\n\\tparamskeeper \\\"github.com/cosmos/cosmos-sdk/x/params/keeper\\\"\\n\\tparamstypes \\\"github.com/cosmos/cosmos-sdk/x/params/types\\\"\\n\\tparamproposal \\\"github.com/cosmos/cosmos-sdk/x/params/types/proposal\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/slashing\\\"\\n\\tslashingkeeper \\\"github.com/cosmos/cosmos-sdk/x/slashing/keeper\\\"\\n\\tslashingtypes \\\"github.com/cosmos/cosmos-sdk/x/slashing/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/staking\\\"\\n\\tstakingkeeper \\\"github.com/cosmos/cosmos-sdk/x/staking/keeper\\\"\\n\\tstakingtypes \\\"github.com/cosmos/cosmos-sdk/x/staking/types\\\"\\n    \\\"github.com/cosmos/cosmos-sdk/x/upgrade\\\"\\n\\tupgradeclient \\\"github.com/cosmos/cosmos-sdk/x/upgrade/client\\\"\\n\\tupgradekeeper \\\"github.com/cosmos/cosmos-sdk/x/upgrade/keeper\\\"\\n\\tupgradetypes \\\"github.com/cosmos/cosmos-sdk/x/upgrade/types\\\"\\n)\\n\\nconst appName = \\\"SimApp\\\"\\n\\nvar (\\n\\t// DefaultNodeHome default home directories for the application daemon\\n\\tDefaultNodeHome string\\n\\n\\t// ModuleBasics defines the module BasicManager is in charge of setting up basic,\\n\\t// non-dependant module elements, such as codec registration\\n\\t// and genesis verification.\\n\\tModuleBasics = module.NewBasicManager(\\n\\t\\tauth.AppModuleBasic{\\n},\\n\\t\\tgenutil.NewAppModuleBasic(genutiltypes.DefaultMessageValidator),\\n\\t\\tbank.AppModuleBasic{\\n},\\n\\t\\tcapability.AppModuleBasic{\\n},\\n\\t\\tstaking.AppModuleBasic{\\n},\\n\\t\\tmint.AppModuleBasic{\\n},\\n\\t\\tdistr.AppModuleBasic{\\n},\\n\\t\\tgov.NewAppModuleBasic(\\n\\t\\t\\t[]govclient.ProposalHandler{\\n    paramsclient.ProposalHandler,\\n\\t\\t\\t\\tupgradeclient.LegacyProposalHandler,\\n\\t\\t\\t\\tupgradeclient.LegacyCancelProposalHandler,\\n},\\n\\t\\t),\\n\\t\\tparams.AppModuleBasic{\\n},\\n\\t\\tcrisis.AppModuleBasic{\\n},\\n\\t\\tslashing.AppModuleBasic{\\n},\\n\\t\\tfeegrantmodule.AppModuleBasic{\\n},\\n\\t\\tupgrade.AppModuleBasic{\\n},\\n\\t\\tevidence.AppModuleBasic{\\n},\\n\\t\\tauthzmodule.AppModuleBasic{\\n},\\n\\t\\tgroupmodule.AppModuleBasic{\\n},\\n\\t\\tvesting.AppModuleBasic{\\n},\\n\\t\\tnftmodule.AppModuleBasic{\\n},\\n\\t\\tconsensus.AppModuleBasic{\\n},\\n\\t)\\n\\n\\t// module account permissions\\n\\tmaccPerms = map[string][]string{\\n    authtypes.FeeCollectorName:     nil,\\n\\t\\tdistrtypes.ModuleName:          nil,\\n\\t\\tminttypes.ModuleName:           {\\n    authtypes.Minter\\n},\\n\\t\\tstakingtypes.BondedPoolName:    {\\n    authtypes.Burner, authtypes.Staking\\n},\\n\\t\\tstakingtypes.NotBondedPoolName: {\\n    authtypes.Burner, authtypes.Staking\\n},\\n\\t\\tgovtypes.ModuleName:            {\\n    authtypes.Burner\\n},\\n\\t\\tnft.ModuleName:                 nil,\\n}\\n)\\n\\nvar (\\n\\t_ runtime.AppI            = (*SimApp)(nil)\\n\\t_ servertypes.Application = (*SimApp)(nil)\\n)\\n\\n// SimApp extends an ABCI application, but with most of its parameters exported.\\n// They are exported for convenience in creating helper functions, as object\\n// capabilities aren't needed for testing.\\ntype SimApp struct {\\n\\t*baseapp.BaseApp\\n\\tlegacyAmino       *codec.LegacyAmino\\n\\tappCodec          codec.Codec\\n\\ttxConfig          client.TxConfig\\n\\tinterfaceRegistry types.InterfaceRegistry\\n\\n\\t// keys to access the substores\\n\\tkeys    map[string]*storetypes.KVStoreKey\\n\\ttkeys   map[string]*storetypes.TransientStoreKey\\n\\tmemKeys map[string]*storetypes.MemoryStoreKey\\n\\n\\t// keepers\\n\\tAccountKeeper         authkeeper.AccountKeeper\\n\\tBankKeeper            bankkeeper.Keeper\\n\\tCapabilityKeeper      *capabilitykeeper.Keeper\\n\\tStakingKeeper         *stakingkeeper.Keeper\\n\\tSlashingKeeper        slashingkeeper.Keeper\\n\\tMintKeeper            mintkeeper.Keeper\\n\\tDistrKeeper           distrkeeper.Keeper\\n\\tGovKeeper             govkeeper.Keeper\\n\\tCrisisKeeper          *crisiskeeper.Keeper\\n\\tUpgradeKeeper         *upgradekeeper.Keeper\\n\\tParamsKeeper          paramskeeper.Keeper\\n\\tAuthzKeeper           authzkeeper.Keeper\\n\\tEvidenceKeeper        evidencekeeper.Keeper\\n\\tFeeGrantKeeper        feegrantkeeper.Keeper\\n\\tGroupKeeper           groupkeeper.Keeper\\n\\tNFTKeeper             nftkeeper.Keeper\\n\\tConsensusParamsKeeper consensusparamkeeper.Keeper\\n\\n\\t// the module manager\\n\\tModuleManager *module.Manager\\n\\n\\t// simulation manager\\n\\tsm *module.SimulationManager\\n\\n\\t// module configurator\\n\\tconfigurator module.Configurator\\n}\\n\\nfunc init() {\\n    userHomeDir, err := os.UserHomeDir()\\n    if err != nil {\\n    panic(err)\\n}\\n\\nDefaultNodeHome = filepath.Join(userHomeDir, \\\".simapp\\\")\\n}\\n\\n// NewSimApp returns a reference to an initialized SimApp.\\nfunc NewSimApp(\\n\\tlogger log.Logger,\\n\\tdb dbm.DB,\\n\\ttraceStore io.Writer,\\n\\tloadLatest bool,\\n\\tappOpts servertypes.AppOptions,\\n\\tbaseAppOptions ...func(*baseapp.BaseApp),\\n) *SimApp {\\n    encodingConfig := makeEncodingConfig()\\n    appCodec := encodingConfig.Codec\\n    legacyAmino := encodingConfig.Amino\\n    interfaceRegistry := encodingConfig.InterfaceRegistry\\n    txConfig := encodingConfig.TxConfig\\n\\n\\t// Below we could construct and set an application specific mempool and ABCI 1.0 Prepare and Process Proposal\\n\\t// handlers. These defaults are already set in the SDK's BaseApp, this shows an example of how to override\\n\\t// them.\\n\\t//\\n\\t// nonceMempool := mempool.NewSenderNonceMempool()\\n\\t// mempoolOpt   := baseapp.SetMempool(nonceMempool)\\n\\t// prepareOpt   := func(app *baseapp.BaseApp) {\\n\\t// \\tapp.SetPrepareProposal(app.DefaultPrepareProposal())\\n\\t//\\n}\\n\\t// processOpt := func(app *baseapp.BaseApp) {\\n\\t// \\tapp.SetProcessProposal(app.DefaultProcessProposal())\\n\\t//\\n}\\n\\t//\\n\\t// Further down we'd set the options in the AppBuilder like below.\\n\\t// baseAppOptions = append(baseAppOptions, mempoolOpt, prepareOpt, processOpt)\\n    bApp := baseapp.NewBaseApp(appName, logger, db, txConfig.TxDecoder(), baseAppOptions...)\\n\\nbApp.SetCommitMultiStoreTracer(traceStore)\\n\\nbApp.SetVersion(version.Version)\\n\\nbApp.SetInterfaceRegistry(interfaceRegistry)\\n\\nbApp.SetTxEncoder(txConfig.TxEncoder())\\n    keys := sdk.NewKVStoreKeys(\\n\\t\\tauthtypes.StoreKey, banktypes.StoreKey, stakingtypes.StoreKey, crisistypes.StoreKey,\\n\\t\\tminttypes.StoreKey, distrtypes.StoreKey, slashingtypes.StoreKey,\\n\\t\\tgovtypes.StoreKey, paramstypes.StoreKey, consensusparamtypes.StoreKey, upgradetypes.StoreKey, feegrant.StoreKey,\\n\\t\\tevidencetypes.StoreKey, capabilitytypes.StoreKey,\\n\\t\\tauthzkeeper.StoreKey, nftkeeper.StoreKey, group.StoreKey,\\n\\t)\\n    tkeys := sdk.NewTransientStoreKeys(paramstypes.TStoreKey)\\n\\t// NOTE: The testingkey is just mounted for testing purposes. Actual applications should\\n\\t// not include this key.\\n    memKeys := sdk.NewMemoryStoreKeys(capabilitytypes.MemStoreKey, \\\"testingkey\\\")\\n\\n\\t// load state streaming if enabled\\n    if _, _, err := streaming.LoadStreamingServices(bApp, appOpts, appCodec, logger, keys); err != nil {\\n    logger.Error(\\\"failed to load state streaming\\\", \\\"err\\\", err)\\n\\nos.Exit(1)\\n}\\n    app := &SimApp{\\n    BaseApp:           bApp,\\n\\t\\tlegacyAmino:       legacyAmino,\\n\\t\\tappCodec:          appCodec,\\n\\t\\ttxConfig:          txConfig,\\n\\t\\tinterfaceRegistry: interfaceRegistry,\\n\\t\\tkeys:              keys,\\n\\t\\ttkeys:             tkeys,\\n\\t\\tmemKeys:           memKeys,\\n}\\n\\napp.ParamsKeeper = initParamsKeeper(appCodec, legacyAmino, keys[paramstypes.StoreKey], tkeys[paramstypes.TStoreKey])\\n\\n\\t// set the BaseApp's parameter store\\n\\tapp.ConsensusParamsKeeper = consensusparamkeeper.NewKeeper(appCodec, keys[upgradetypes.StoreKey], authtypes.NewModuleAddress(govtypes.ModuleName).String())\\n\\nbApp.SetParamStore(&app.ConsensusParamsKeeper)\\n\\napp.CapabilityKeeper = capabilitykeeper.NewKeeper(appCodec, keys[capabilitytypes.StoreKey], memKeys[capabilitytypes.MemStoreKey])\\n\\t// Applications that wish to enforce statically created ScopedKeepers should call `Seal` after creating\\n\\t// their scoped modules in `NewApp` with `ScopeToModule`\\n\\tapp.CapabilityKeeper.Seal()\\n\\n\\t// add keepers\\n\\tapp.AccountKeeper = authkeeper.NewAccountKeeper(appCodec, keys[authtypes.StoreKey], authtypes.ProtoBaseAccount, maccPerms, sdk.Bech32MainPrefix, authtypes.NewModuleAddress(govtypes.ModuleName).String())\\n\\napp.BankKeeper = bankkeeper.NewBaseKeeper(\\n\\t\\tappCodec,\\n\\t\\tkeys[banktypes.StoreKey],\\n\\t\\tapp.AccountKeeper,\\n\\t\\tBlockedAddresses(),\\n\\t\\tauthtypes.NewModuleAddress(govtypes.ModuleName).String(),\\n\\t)\\n\\napp.StakingKeeper = stakingkeeper.NewKeeper(\\n\\t\\tappCodec, keys[stakingtypes.StoreKey], app.AccountKeeper, app.BankKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(),\\n\\t)\\n\\napp.MintKeeper = mintkeeper.NewKeeper(appCodec, keys[minttypes.StoreKey], app.StakingKeeper, app.AccountKeeper, app.BankKeeper, authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String())\\n\\napp.DistrKeeper = distrkeeper.NewKeeper(appCodec, keys[distrtypes.StoreKey], app.AccountKeeper, app.BankKeeper, app.StakingKeeper, authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String())\\n\\napp.SlashingKeeper = slashingkeeper.NewKeeper(\\n\\t\\tappCodec, legacyAmino, keys[slashingtypes.StoreKey], app.StakingKeeper, authtypes.NewModuleAddress(govtypes.ModuleName).String(),\\n\\t)\\n    invCheckPeriod := cast.ToUint(appOpts.Get(server.FlagInvCheckPeriod))\\n\\napp.CrisisKeeper = crisiskeeper.NewKeeper(appCodec, keys[crisistypes.StoreKey], invCheckPeriod,\\n\\t\\tapp.BankKeeper, authtypes.FeeCollectorName, authtypes.NewModuleAddress(govtypes.ModuleName).String())\\n\\napp.FeeGrantKeeper = feegrantkeeper.NewKeeper(appCodec, keys[feegrant.StoreKey], app.AccountKeeper)\\n\\n\\t// register the staking hooks\\n\\t// NOTE: stakingKeeper above is passed by reference, so that it will contain these hooks\\n\\tapp.StakingKeeper.SetHooks(\\n\\t\\tstakingtypes.NewMultiStakingHooks(app.DistrKeeper.Hooks(), app.SlashingKeeper.Hooks()),\\n\\t)\\n\\napp.AuthzKeeper = authzkeeper.NewKeeper(keys[authzkeeper.StoreKey], appCodec, app.MsgServiceRouter(), app.AccountKeeper)\\n    groupConfig := group.DefaultConfig()\\n\\t/*\\n\\t\\tExample of setting group params:\\n\\t\\tgroupConfig.MaxMetadataLen = 1000\\n\\t*/\\n\\tapp.GroupKeeper = groupkeeper.NewKeeper(keys[group.StoreKey], appCodec, app.MsgServiceRouter(), app.AccountKeeper, groupConfig)\\n\\n\\t// get skipUpgradeHeights from the app options\\n    skipUpgradeHeights := map[int64]bool{\\n}\\n    for _, h := range cast.ToIntSlice(appOpts.Get(server.FlagUnsafeSkipUpgrades)) {\\n    skipUpgradeHeights[int64(h)] = true\\n}\\n    homePath := cast.ToString(appOpts.Get(flags.FlagHome))\\n\\t// set the governance module account as the authority for conducting upgrades\\n\\tapp.UpgradeKeeper = upgradekeeper.NewKeeper(skipUpgradeHeights, keys[upgradetypes.StoreKey], appCodec, homePath, app.BaseApp, authtypes.NewModuleAddress(govtypes.ModuleName).String())\\n\\n\\t// Register the proposal types\\n\\t// Deprecated: Avoid adding new handlers, instead use the new proposal flow\\n\\t// by granting the governance module the right to execute the message.\\n\\t// See: https://github.com/cosmos/cosmos-sdk/blob/release/v0.46.x/x/gov/spec/01_concepts.md#proposal-messages\\n    govRouter := govv1beta1.NewRouter()\\n\\ngovRouter.AddRoute(govtypes.RouterKey, govv1beta1.ProposalHandler).\\n\\t\\tAddRoute(paramproposal.RouterKey, params.NewParamChangeProposalHandler(app.ParamsKeeper)).\\n\\t\\tAddRoute(upgradetypes.RouterKey, upgrade.NewSoftwareUpgradeProposalHandler(app.UpgradeKeeper))\\n    govConfig := govtypes.DefaultConfig()\\n\\t/*\\n\\t\\tExample of setting gov params:\\n\\t\\tgovConfig.MaxMetadataLen = 10000\\n\\t*/\\n    govKeeper := govkeeper.NewKeeper(\\n\\t\\tappCodec, keys[govtypes.StoreKey], app.AccountKeeper, app.BankKeeper,\\n\\t\\tapp.StakingKeeper, app.MsgServiceRouter(), govConfig, authtypes.NewModuleAddress(govtypes.ModuleName).String(),\\n\\t)\\n\\n\\t// Set legacy router for backwards compatibility with gov v1beta1\\n\\tgovKeeper.SetLegacyRouter(govRouter)\\n\\napp.GovKeeper = *govKeeper.SetHooks(\\n\\t\\tgovtypes.NewMultiGovHooks(\\n\\t\\t// register the governance hooks\\n\\t\\t),\\n\\t)\\n\\napp.NFTKeeper = nftkeeper.NewKeeper(keys[nftkeeper.StoreKey], appCodec, app.AccountKeeper, app.BankKeeper)\\n\\n\\t// create evidence keeper with router\\n    evidenceKeeper := evidencekeeper.NewKeeper(\\n\\t\\tappCodec, keys[evidencetypes.StoreKey], app.StakingKeeper, app.SlashingKeeper,\\n\\t)\\n\\t// If evidence needs to be handled for the app, set routes in router here and seal\\n\\tapp.EvidenceKeeper = *evidenceKeeper\\n\\n\\t/****  Module Options ****/\\n\\n\\t// NOTE: we may consider parsing `appOpts` inside module constructors. For the moment\\n\\t// we prefer to be more strict in what arguments the modules expect.\\n    skipGenesisInvariants := cast.ToBool(appOpts.Get(crisis.FlagSkipGenesisInvariants))\\n\\n\\t// NOTE: Any module instantiated in the module manager that is later modified\\n\\t// must be passed by reference here.\\n\\tapp.ModuleManager = module.NewManager(\\n\\t\\tgenutil.NewAppModule(\\n\\t\\t\\tapp.AccountKeeper, app.StakingKeeper, app.BaseApp.DeliverTx,\\n\\t\\t\\tencodingConfig.TxConfig,\\n\\t\\t),\\n\\t\\tauth.NewAppModule(appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, app.GetSubspace(authtypes.ModuleName)),\\n\\t\\tvesting.NewAppModule(app.AccountKeeper, app.BankKeeper),\\n\\t\\tbank.NewAppModule(appCodec, app.BankKeeper, app.AccountKeeper, app.GetSubspace(banktypes.ModuleName)),\\n\\t\\tcapability.NewAppModule(appCodec, *app.CapabilityKeeper, false),\\n\\t\\tcrisis.NewAppModule(app.CrisisKeeper, skipGenesisInvariants, app.GetSubspace(crisistypes.ModuleName)),\\n\\t\\tfeegrantmodule.NewAppModule(appCodec, app.AccountKeeper, app.BankKeeper, app.FeeGrantKeeper, app.interfaceRegistry),\\n\\t\\tgov.NewAppModule(appCodec, &app.GovKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(govtypes.ModuleName)),\\n\\t\\tmint.NewAppModule(appCodec, app.MintKeeper, app.AccountKeeper, nil, app.GetSubspace(minttypes.ModuleName)),\\n\\t\\tslashing.NewAppModule(appCodec, app.SlashingKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, app.GetSubspace(slashingtypes.ModuleName)),\\n\\t\\tdistr.NewAppModule(appCodec, app.DistrKeeper, app.AccountKeeper, app.BankKeeper, app.StakingKeeper, app.GetSubspace(distrtypes.ModuleName)),\\n\\t\\tstaking.NewAppModule(appCodec, app.StakingKeeper, app.AccountKeeper, app.BankKeeper, app.GetSubspace(stakingtypes.ModuleName)),\\n\\t\\tupgrade.NewAppModule(app.UpgradeKeeper),\\n\\t\\tevidence.NewAppModule(app.EvidenceKeeper),\\n\\t\\tparams.NewAppModule(app.ParamsKeeper),\\n\\t\\tauthzmodule.NewAppModule(appCodec, app.AuthzKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\\n\\t\\tgroupmodule.NewAppModule(appCodec, app.GroupKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\\n\\t\\tnftmodule.NewAppModule(appCodec, app.NFTKeeper, app.AccountKeeper, app.BankKeeper, app.interfaceRegistry),\\n\\t\\tconsensus.NewAppModule(appCodec, app.ConsensusParamsKeeper),\\n\\t)\\n\\n\\t// During begin block slashing happens after distr.BeginBlocker so that\\n\\t// there is nothing left over in the validator fee pool, so as to keep the\\n\\t// CanWithdrawInvariant invariant.\\n\\t// NOTE: staking module is required if HistoricalEntries param > 0\\n\\t// NOTE: capability module's beginblocker must come before any modules using capabilities (e.g. IBC)\\n\\napp.ModuleManager.SetOrderBeginBlockers(\\n\\t\\tupgradetypes.ModuleName, capabilitytypes.ModuleName, minttypes.ModuleName, distrtypes.ModuleName, slashingtypes.ModuleName,\\n\\t\\tevidencetypes.ModuleName, stakingtypes.ModuleName,\\n\\t\\tauthtypes.ModuleName, banktypes.ModuleName, govtypes.ModuleName, crisistypes.ModuleName, genutiltypes.ModuleName,\\n\\t\\tauthz.ModuleName, feegrant.ModuleName, nft.ModuleName, group.ModuleName,\\n\\t\\tparamstypes.ModuleName, vestingtypes.ModuleName, consensusparamtypes.ModuleName,\\n\\t)\\n\\napp.ModuleManager.SetOrderEndBlockers(\\n\\t\\tcrisistypes.ModuleName, govtypes.ModuleName, stakingtypes.ModuleName,\\n\\t\\tcapabilitytypes.ModuleName, authtypes.ModuleName, banktypes.ModuleName, distrtypes.ModuleName,\\n\\t\\tslashingtypes.ModuleName, minttypes.ModuleName,\\n\\t\\tgenutiltypes.ModuleName, evidencetypes.ModuleName, authz.ModuleName,\\n\\t\\tfeegrant.ModuleName, nft.ModuleName, group.ModuleName,\\n\\t\\tparamstypes.ModuleName, upgradetypes.ModuleName, vestingtypes.ModuleName, consensusparamtypes.ModuleName,\\n\\t)\\n\\n\\t// NOTE: The genutils module must occur after staking so that pools are\\n\\t// properly initialized with tokens from genesis accounts.\\n\\t// NOTE: The genutils module must also occur after auth so that it can access the params from auth.\\n\\t// NOTE: Capability module must occur first so that it can initialize any capabilities\\n\\t// so that other modules that want to create or claim capabilities afterwards in InitChain\\n\\t// can do so safely.\\n    genesisModuleOrder := []string{\\n    capabilitytypes.ModuleName, authtypes.ModuleName, banktypes.ModuleName,\\n\\t\\tdistrtypes.ModuleName, stakingtypes.ModuleName, slashingtypes.ModuleName, govtypes.ModuleName,\\n\\t\\tminttypes.ModuleName, crisistypes.ModuleName, genutiltypes.ModuleName, evidencetypes.ModuleName, authz.ModuleName,\\n\\t\\tfeegrant.ModuleName, nft.ModuleName, group.ModuleName, paramstypes.ModuleName, upgradetypes.ModuleName,\\n\\t\\tvestingtypes.ModuleName, consensusparamtypes.ModuleName,\\n}\\n\\napp.ModuleManager.SetOrderInitGenesis(genesisModuleOrder...)\\n\\napp.ModuleManager.SetOrderExportGenesis(genesisModuleOrder...)\\n\\n\\t// Uncomment if you want to set a custom migration order here.\\n\\t// app.ModuleManager.SetOrderMigrations(custom order)\\n\\napp.ModuleManager.RegisterInvariants(app.CrisisKeeper)\\n\\napp.configurator = module.NewConfigurator(app.appCodec, app.MsgServiceRouter(), app.GRPCQueryRouter())\\n\\napp.ModuleManager.RegisterServices(app.configurator)\\n\\n\\t// RegisterUpgradeHandlers is used for registering any on-chain upgrades.\\n\\t// Make sure it's called after `app.ModuleManager` and `app.configurator` are set.\\n\\tapp.RegisterUpgradeHandlers()\\n\\nautocliv1.RegisterQueryServer(app.GRPCQueryRouter(), runtimeservices.NewAutoCLIQueryService(app.ModuleManager.Modules))\\n\\nreflectionSvc, err := runtimeservices.NewReflectionService()\\n    if err != nil {\\n    panic(err)\\n}\\n\\nreflectionv1.RegisterReflectionServiceServer(app.GRPCQueryRouter(), reflectionSvc)\\n\\n\\t// add test gRPC service for testing gRPC queries in isolation\\n\\ttestdata_pulsar.RegisterQueryServer(app.GRPCQueryRouter(), testdata_pulsar.QueryImpl{\\n})\\n\\n\\t// create the simulation manager and define the order of the modules for deterministic simulations\\n\\t//\\n\\t// NOTE: this is not required apps that don't use the simulator for fuzz testing\\n\\t// transactions\\n    overrideModules := map[string]module.AppModuleSimulation{\\n    authtypes.ModuleName: auth.NewAppModule(app.appCodec, app.AccountKeeper, authsims.RandomGenesisAccounts, app.GetSubspace(authtypes.ModuleName)),\\n}\\n\\napp.sm = module.NewSimulationManagerFromAppModules(app.ModuleManager.Modules, overrideModules)\\n\\napp.sm.RegisterStoreDecoders()\\n\\n\\t// initialize stores\\n\\tapp.MountKVStores(keys)\\n\\napp.MountTransientStores(tkeys)\\n\\napp.MountMemoryStores(memKeys)\\n\\n\\t// initialize BaseApp\\n\\tapp.SetInitChainer(app.InitChainer)\\n\\napp.SetBeginBlocker(app.BeginBlocker)\\n\\napp.SetEndBlocker(app.EndBlocker)\\n\\napp.setAnteHandler(encodingConfig.TxConfig)\\n\\n\\t// In v0.46, the SDK introduces _postHandlers_. PostHandlers are like\\n\\t// antehandlers, but are run _after_ the `runMsgs` execution. They are also\\n\\t// defined as a chain, and have the same signature as antehandlers.\\n\\t//\\n\\t// In baseapp, postHandlers are run in the same store branch as `runMsgs`,\\n\\t// meaning that both `runMsgs` and `postHandler` state will be committed if\\n\\t// both are successful, and both will be reverted if any of the two fails.\\n\\t//\\n\\t// The SDK exposes a default postHandlers chain, which comprises of only\\n\\t// one decorator: the Transaction Tips decorator. However, some chains do\\n\\t// not need it by default, so feel free to comment the next line if you do\\n\\t// not need tips.\\n\\t// To read more about tips:\\n\\t// https://docs.cosmos.network/main/core/tips.html\\n\\t//\\n\\t// Please note that changing any of the anteHandler or postHandler chain is\\n\\t// likely to be a state-machine breaking change, which needs a coordinated\\n\\t// upgrade.\\n\\tapp.setPostHandler()\\n    if loadLatest {\\n    if err := app.LoadLatestVersion(); err != nil {\\n    logger.Error(\\\"error on loading last version\\\", \\\"err\\\", err)\\n\\nos.Exit(1)\\n}\\n\\t\\n}\\n\\nreturn app\\n}\\n\\nfunc (app *SimApp)\\n\\nsetAnteHandler(txConfig client.TxConfig) {\\n    anteHandler, err := ante.NewAnteHandler(\\n\\t\\tante.HandlerOptions{\\n    AccountKeeper:   app.AccountKeeper,\\n    BankKeeper:      app.BankKeeper,\\n    SignModeHandler: txConfig.SignModeHandler(),\\n    FeegrantKeeper:  app.FeeGrantKeeper,\\n    SigGasConsumer:  ante.DefaultSigVerificationGasConsumer,\\n},\\n\\t)\\n    if err != nil {\\n    panic(err)\\n}\\n\\napp.SetAnteHandler(anteHandler)\\n}\\n\\nfunc (app *SimApp)\\n\\nsetPostHandler() {\\n    postHandler, err := posthandler.NewPostHandler(\\n\\t\\tposthandler.HandlerOptions{\\n},\\n\\t)\\n    if err != nil {\\n    panic(err)\\n}\\n\\napp.SetPostHandler(postHandler)\\n}\\n\\n// Name returns the name of the App\\nfunc (app *SimApp)\\n\\nName()\\n\\nstring {\\n    return app.BaseApp.Name()\\n}\\n\\n// BeginBlocker application updates every begin block\\nfunc (app *SimApp)\\n\\nBeginBlocker(ctx sdk.Context, req abci.RequestBeginBlock)\\n\\nabci.ResponseBeginBlock {\\n    return app.ModuleManager.BeginBlock(ctx, req)\\n}\\n\\n// EndBlocker application updates every end block\\nfunc (app *SimApp)\\n\\nEndBlocker(ctx sdk.Context, req abci.RequestEndBlock)\\n\\nabci.ResponseEndBlock {\\n    return app.ModuleManager.EndBlock(ctx, req)\\n}\\n\\nfunc (a *SimApp)\\n\\nConfigurator()\\n\\nmodule.Configurator {\\n    return a.configurator\\n}\\n\\n// InitChainer application update at chain initialization\\nfunc (app *SimApp)\\n\\nInitChainer(ctx sdk.Context, req abci.RequestInitChain)\\n\\nabci.ResponseInitChain {\\n    var genesisState GenesisState\\n    if err := json.Unmarshal(req.AppStateBytes, &genesisState); err != nil {\\n    panic(err)\\n}\\n\\napp.UpgradeKeeper.SetModuleVersionMap(ctx, app.ModuleManager.GetVersionMap())\\n\\nreturn app.ModuleManager.InitGenesis(ctx, app.appCodec, genesisState)\\n}\\n\\n// LoadHeight loads a particular height\\nfunc (app *SimApp)\\n\\nLoadHeight(height int64)\\n\\nerror {\\n    return app.LoadVersion(height)\\n}\\n\\n// LegacyAmino returns SimApp's amino codec.\\n//\\n// NOTE: This is solely to be used for testing purposes as it may be desirable\\n// for modules to register their own custom testing types.\\nfunc (app *SimApp)\\n\\nLegacyAmino() *codec.LegacyAmino {\\n    return app.legacyAmino\\n}\\n\\n// AppCodec returns SimApp's app codec.\\n//\\n// NOTE: This is solely to be used for testing purposes as it may be desirable\\n// for modules to register their own custom testing types.\\nfunc (app *SimApp)\\n\\nAppCodec()\\n\\ncodec.Codec {\\n    return app.appCodec\\n}\\n\\n// InterfaceRegistry returns SimApp's InterfaceRegistry\\nfunc (app *SimApp)\\n\\nInterfaceRegistry()\\n\\ntypes.InterfaceRegistry {\\n    return app.interfaceRegistry\\n}\\n\\n// TxConfig returns SimApp's TxConfig\\nfunc (app *SimApp)\\n\\nTxConfig()\\n\\nclient.TxConfig {\\n    return app.txConfig\\n}\\n\\n// DefaultGenesis returns a default genesis from the registered AppModuleBasic's.\\nfunc (a *SimApp)\\n\\nDefaultGenesis()\\n\\nmap[string]json.RawMessage {\\n    return ModuleBasics.DefaultGenesis(a.appCodec)\\n}\\n\\n// GetKey returns the KVStoreKey for the provided store key.\\n//\\n// NOTE: This is solely to be used for testing purposes.\\nfunc (app *SimApp)\\n\\nGetKey(storeKey string) *storetypes.KVStoreKey {\\n    return app.keys[storeKey]\\n}\\n\\n// GetTKey returns the TransientStoreKey for the provided store key.\\n//\\n// NOTE: This is solely to be used for testing purposes.\\nfunc (app *SimApp)\\n\\nGetTKey(storeKey string) *storetypes.TransientStoreKey {\\n    return app.tkeys[storeKey]\\n}\\n\\n// GetMemKey returns the MemStoreKey for the provided mem key.\\n//\\n// NOTE: This is solely used for testing purposes.\\nfunc (app *SimApp)\\n\\nGetMemKey(storeKey string) *storetypes.MemoryStoreKey {\\n    return app.memKeys[storeKey]\\n}\\n\\n// GetSubspace returns a param subspace for a given module name.\\n//\\n// NOTE: This is solely to be used for testing purposes.\\nfunc (app *SimApp)\\n\\nGetSubspace(moduleName string)\\n\\nparamstypes.Subspace {\\n    subspace, _ := app.ParamsKeeper.GetSubspace(moduleName)\\n\\nreturn subspace\\n}\\n\\n// SimulationManager implements the SimulationApp interface\\nfunc (app *SimApp)\\n\\nSimulationManager() *module.SimulationManager {\\n    return app.sm\\n}\\n\\n// RegisterAPIRoutes registers all application module routes with the provided\\n// API server.\\nfunc (app *SimApp)\\n\\nRegisterAPIRoutes(apiSvr *api.Server, apiConfig config.APIConfig) {\\n    clientCtx := apiSvr.ClientCtx\\n\\t// Register new tx routes from grpc-gateway.\\n\\tauthtx.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\\n\\n\\t// Register new tendermint queries routes from grpc-gateway.\\n\\ttmservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\\n\\n\\t// Register node gRPC service for grpc-gateway.\\n\\tnodeservice.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\\n\\n\\t// Register grpc-gateway routes for all modules.\\n\\tModuleBasics.RegisterGRPCGatewayRoutes(clientCtx, apiSvr.GRPCGatewayRouter)\\n\\n\\t// register swagger API from root so that other applications can override easily\\n    if err := server.RegisterSwaggerAPI(apiSvr.ClientCtx, apiSvr.Router, apiConfig.Swagger); err != nil {\\n    panic(err)\\n}\\n}\\n\\n// RegisterTxService implements the Application.RegisterTxService method.\\nfunc (app *SimApp)\\n\\nRegisterTxService(clientCtx client.Context) {\\n    authtx.RegisterTxService(app.BaseApp.GRPCQueryRouter(), clientCtx, app.BaseApp.Simulate, app.interfaceRegistry)\\n}\\n\\n// RegisterTendermintService implements the Application.RegisterTendermintService method.\\nfunc (app *SimApp)\\n\\nRegisterTendermintService(clientCtx client.Context) {\\n    tmservice.RegisterTendermintService(\\n\\t\\tclientCtx,\\n\\t\\tapp.BaseApp.GRPCQueryRouter(),\\n\\t\\tapp.interfaceRegistry,\\n\\t\\tapp.Query,\\n\\t)\\n}\\n\\nfunc (app *SimApp)\\n\\nRegisterNodeService(clientCtx client.Context) {\\n    nodeservice.RegisterNodeService(clientCtx, app.GRPCQueryRouter())\\n}\\n\\n// GetMaccPerms returns a copy of the module account permissions\\n//\\n// NOTE: This is solely to be used for testing purposes.\\nfunc GetMaccPerms()\\n\\nmap[string][]string {\\n    dupMaccPerms := make(map[string][]string)\\n    for k, v := range maccPerms {\\n    dupMaccPerms[k] = v\\n}\\n\\nreturn dupMaccPerms\\n}\\n\\n// BlockedAddresses returns all the app's blocked account addresses.\\nfunc BlockedAddresses()\\n\\nmap[string]bool {\\n    modAccAddrs := make(map[string]bool)\\n    for acc := range GetMaccPerms() {\\n    modAccAddrs[authtypes.NewModuleAddress(acc).String()] = true\\n}\\n\\n\\t// allow the following addresses to receive funds\\n\\tdelete(modAccAddrs, authtypes.NewModuleAddress(govtypes.ModuleName).String())\\n\\nreturn modAccAddrs\\n}\\n\\n// initParamsKeeper init params keeper and its subspaces\\nfunc initParamsKeeper(appCodec codec.BinaryCodec, legacyAmino *codec.LegacyAmino, key, tkey storetypes.StoreKey)\\n\\nparamskeeper.Keeper {\\n    paramsKeeper := paramskeeper.NewKeeper(appCodec, legacyAmino, key, tkey)\\n\\nparamsKeeper.Subspace(authtypes.ModuleName)\\n\\nparamsKeeper.Subspace(banktypes.ModuleName)\\n\\nparamsKeeper.Subspace(stakingtypes.ModuleName)\\n\\nparamsKeeper.Subspace(minttypes.ModuleName)\\n\\nparamsKeeper.Subspace(distrtypes.ModuleName)\\n\\nparamsKeeper.Subspace(slashingtypes.ModuleName)\\n\\nparamsKeeper.Subspace(govtypes.ModuleName).WithKeyTable(govv1.ParamKeyTable())\\n\\nparamsKeeper.Subspace(crisistypes.ModuleName)\\n\\nreturn paramsKeeper\\n}\\n\\nfunc makeEncodingConfig()\\n\\nsimappparams.EncodingConfig {\\n    encodingConfig := simappparams.MakeTestEncodingConfig()\\n\\nstd.RegisterLegacyAminoCodec(encodingConfig.Amino)\\n\\nstd.RegisterInterfaces(encodingConfig.InterfaceRegistry)\\n\\nModuleBasics.RegisterLegacyAminoCodec(encodingConfig.Amino)\\n\\nModuleBasics.RegisterInterfaces(encodingConfig.InterfaceRegistry)\\n\\nreturn encodingConfig\\n}\\n\\n\", \"Title: What is the Cosmos SDK\\nLink: https://evm.cosmos.network/docs/sdk/v0.47/learn/intro/overview\\nContent: The Cosmos SDK is an open-source framework for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains. We envision the Cosmos SDK as the npm-like framework to build secure blockchain applications on top of CometBFT . SDK-based blockchains are built out of composable modules , most of which are open-source and readily available for any developers to use. Anyone can create a module for the Cosmos SDK, and integrating already-built modules is as simple as importing them into your blockchain application. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model.\\n\\nWhat is the Cosmos SDK\\nThe Cosmos SDK is an open-source framework for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains. We envision the Cosmos SDK as the npm-like framework to build secure blockchain applications on top of CometBFT . SDK-based blockchains are built out of composable modules , most of which are open-source and readily available for any developers to use. Anyone can create a module for the Cosmos SDK, and integrating already-built modules is as simple as importing them into your blockchain application. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model.\\n\\nWhy the Cosmos SDK\\nThe Cosmos SDK is the most advanced framework for building custom application-specific blockchains today. Here are a few reasons why you might want to consider building your decentralized application with the Cosmos SDK: The default consensus engine available within the Cosmos SDK is CometBFT . CometBFT is the most (and only) mature BFT consensus engine in existence. It is widely used across the industry and is considered the gold standard consensus engine for building Proof-of-Stake systems. The Cosmos SDK is open-source and designed to make it easy to build blockchains out of composable modules . As the ecosystem of open-source Cosmos SDK modules grows, it will become increasingly easier to build complex decentralized platforms with it. The Cosmos SDK is inspired by capabilities-based security, and informed by years of wrestling with blockchain state-machines. This makes the Cosmos SDK a very secure environment to build blockchains. Most importantly, the Cosmos SDK has already been used to build many application-specific blockchains that are already in production. Among others, we can cite Cosmos Hub , IRIS Hub , Binance Chain , Terra or Kava . Many more are building on the Cosmos SDK.\\n\\n\", \"Title: What is the Cosmos SDK\\nLink: https://evm.cosmos.network/docs/sdk/v0.53/learn/intro/overview\\nContent: The Cosmos SDK is an open-source toolkit for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains.\\nWe further this modular approach by allowing developers to plug and play with different consensus engines this can range from the CometBFT or Rollkit. SDK-based blockchains have the choice to use the predefined modules or to build their own modules. What this means is that developers can build a blockchain that is tailored to their specific use case, without having to worry about the low-level details of building a blockchain from scratch. Predefined modules include staking, governance, and token issuance, among others. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model. How you can look at this is if we imagine that the SDK is like a lego kit. You can choose to build the basic house from the instructions or you can choose to modify your house and add more floors, more doors, more windows. The choice is yours.\\n\\nWhat is the Cosmos SDK\\nThe Cosmos SDK is an open-source toolkit for building multi-asset public Proof-of-Stake (PoS) blockchains , like the Cosmos Hub, as well as permissioned Proof-of-Authority (PoA) blockchains. Blockchains built with the Cosmos SDK are generally referred to as application-specific blockchains. The goal of the Cosmos SDK is to allow developers to easily create custom blockchains from scratch that can natively interoperate with other blockchains.\\nWe further this modular approach by allowing developers to plug and play with different consensus engines this can range from the CometBFT or Rollkit. SDK-based blockchains have the choice to use the predefined modules or to build their own modules. What this means is that developers can build a blockchain that is tailored to their specific use case, without having to worry about the low-level details of building a blockchain from scratch. Predefined modules include staking, governance, and token issuance, among others. What's more, the Cosmos SDK is a capabilities-based system that allows developers to better reason about the security of interactions between modules. For a deeper look at capabilities, jump to Object-Capability Model. How you can look at this is if we imagine that the SDK is like a lego kit. You can choose to build the basic house from the instructions or you can choose to modify your house and add more floors, more doors, more windows. The choice is yours.\\n\\nWhy the Cosmos SDK\\nThe Cosmos SDK is the most advanced framework for building custom modular application-specific blockchains today. Here are a few reasons why you might want to consider building your decentralized application with the Cosmos SDK: It allows you to plug and play and customize your consensus layer. As above you can use Rollkit and Celestia as your consensus and data availability layer. This offers a lot of flexibility and customisation. Previously the default consensus engine available within the Cosmos SDK is CometBFT . CometBFT is the most (and only) mature BFT consensus engine in existence. It is widely used across the industry and is considered the gold standard consensus engine for building Proof-of-Stake systems. The Cosmos SDK is open-source and designed to make it easy to build blockchains out of composable modules . As the ecosystem of open-source Cosmos SDK modules grows, it will become increasingly easier to build complex decentralized platforms with it. The Cosmos SDK is inspired by capabilities-based security, and informed by years of wrestling with blockchain state-machines. This makes the Cosmos SDK a very secure environment to build blockchains. Most importantly, the Cosmos SDK has already been used to build many application-specific blockchains that are already in production. Among others, we can cite Cosmos Hub , IRIS Hub , Binance Chain , Terra or Kava . Many more are building on the Cosmos SDK.\\n\\n\"]",
            "additional_kwargs": {},
            "response_metadata": {},
            "type": "tool",
            "name": "SearchCosmosDocumentation",
            "id": "c850106c-969c-4bb0-b93f-39711bdcac8d",
            "tool_call_id": "call_8zxrSkzdRBOJVsyqNh361lwJ",
            "artifact": null,
            "status": "success"
        },
        {
            "content": "[\n  {\n    \"intent\": \"Write a memory allocation profile to mem.prof on a Cosmos-EVM node\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"select_rpc_endpoint\",\n        \"description\": \"Identify the JSON-RPC URL of the Cosmos-EVM full node (e.g. http://localhost:8545).\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"authenticate_debug_namespace\",\n        \"description\": \"Provide the node\u2019s configured credentials or JWT token because debug_writeMemProfile is marked Private and requires authentication.\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"json_rpc_call\",\n        \"description\": \"Invoke debug_writeMemProfile with the single parameter \\\"mem.prof\\\" to instruct the node to write the allocation profile:\\n{\\n  \\\"method\\\": \\\"debug_writeMemProfile\\\",\\n  \\\"params\\\": [\\\"mem.prof\\\"],\\n  \\\"id\\\": 1,\\n  \\\"jsonrpc\\\": \\\"2.0\\\"\\n}\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Receive a JSON-RPC result field with value true or an empty string (implementation dependent).\",\n      \"Confirm that a new file named mem.prof appears in the node\u2019s working directory.\"\n    ]\n  },\n  {\n    \"intent\": \"Enable block-profiling with rate 1 on a Cosmos-EVM node\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"select_rpc_endpoint\",\n        \"description\": \"Locate the node\u2019s JSON-RPC URL.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"authenticate_debug_namespace\",\n        \"description\": \"Supply the private-API credentials for the debug namespace.\"\n      },\n      {\n        \"step\": 3,\n        \"tool\": \"json_rpc_call\",\n        \"description\": \"Send the call to debug_setBlockProfileRate with parameter 1:\\n{\\n  \\\"method\\\": \\\"debug_setBlockProfileRate\\\",\\n  \\\"params\\\": [1],\\n  \\\"id\\\": 1,\\n  \\\"jsonrpc\\\": \\\"2.0\\\"\\n}\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Expect the result field to echo the rate set or return null (stub implementation).\",\n      \"Optionally, write a few blocks and verify that cpu.block profile data is being collected in the node\u2019s pprof endpoint.\"\n    ]\n  },\n  {\n    \"intent\": \"Trace all transactions in block number 0xE using debug_traceBlockByNumber\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"select_rpc_endpoint\",\n        \"description\": \"Point to the Cosmos-EVM JSON-RPC endpoint.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"json_rpc_call\",\n        \"description\": \"Invoke debug_traceBlockByNumber with the hex string \\\"0xe\\\" and an empty tracer object:\\n{\\n  \\\"method\\\": \\\"debug_traceBlockByNumber\\\",\\n  \\\"params\\\": [\\\"0xe\\\", {}],\\n  \\\"id\\\": 1,\\n  \\\"jsonrpc\\\": \\\"2.0\\\"\\n}\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"According to current Cosmos-EVM docs the implementation is stubbed; the response is expected to be an empty array [].\",\n      \"If/when full tracing is enabled, verify the array contains one trace object per transaction in block 14 (decimal).\"\n    ]\n  },\n  {\n    \"intent\": \"Trace a block by hash with debug_traceBlockByHash\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"select_rpc_endpoint\",\n        \"description\": \"Use the node\u2019s JSON-RPC URL.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"json_rpc_call\",\n        \"description\": \"Call debug_traceBlockByHash with the desired block hash and an empty tracer:\\n{\\n  \\\"method\\\": \\\"debug_traceBlockByHash\\\",\\n  \\\"params\\\": [\\\"<blockHash>\\\", {}],\\n  \\\"id\\\": 1,\\n  \\\"jsonrpc\\\": \\\"2.0\\\"\\n}\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"Expect an empty array [] while tracing is stubbed.\",\n      \"Once implemented, ensure each transaction trace object is returned in the same order as the block\u2019s transactions.\"\n    ]\n  },\n  {\n    \"intent\": \"Retrieve intermediate state roots for a transaction\",\n    \"workflow\": [\n      {\n        \"step\": 1,\n        \"tool\": \"select_rpc_endpoint\",\n        \"description\": \"Determine the full node\u2019s JSON-RPC address.\"\n      },\n      {\n        \"step\": 2,\n        \"tool\": \"json_rpc_call\",\n        \"description\": \"Request debug_intermediateRoots with the target transaction hash:\\n{\\n  \\\"method\\\": \\\"debug_intermediateRoots\\\",\\n  \\\"params\\\": [\\\"<txHash>\\\"],\\n  \\\"id\\\": 1,\\n  \\\"jsonrpc\\\": \\\"2.0\\\"\\n}\"\n      }\n    ],\n    \"outcome_checks\": [\n      \"A successful call returns an array of hex-encoded state root values for each step of the transaction\u2019s execution.\",\n      \"Validate that the first element matches the pre-state root of the containing block and the last element matches the post-state root recorded in the receipt.\"\n    ]\n  }\n]",
            "additional_kwargs": {
                "refusal": null
            },
            "response_metadata": {
                "token_usage": {
                    "completion_tokens": 1739,
                    "prompt_tokens": 25998,
                    "total_tokens": 27737,
                    "completion_tokens_details": {
                        "accepted_prediction_tokens": 0,
                        "audio_tokens": 0,
                        "reasoning_tokens": 576,
                        "rejected_prediction_tokens": 0
                    },
                    "prompt_tokens_details": {
                        "audio_tokens": 0,
                        "cached_tokens": 0
                    }
                },
                "model_name": "o3-2025-04-16",
                "system_fingerprint": null,
                "id": "chatcmpl-CPw4k1VvqU2EbPWjdmUEPzRAKHnCI",
                "service_tier": "default",
                "finish_reason": "stop",
                "logprobs": null
            },
            "type": "ai",
            "name": null,
            "id": "run--6dc79ca7-5ac2-4081-9303-69388613f61d-0",
            "example": false,
            "tool_calls": [],
            "invalid_tool_calls": [],
            "usage_metadata": {
                "input_tokens": 25998,
                "output_tokens": 1739,
                "total_tokens": 27737,
                "input_token_details": {
                    "audio": 0,
                    "cache_read": 0
                },
                "output_token_details": {
                    "audio": 0,
                    "reasoning": 576
                }
            }
        }
    ]
}