{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a FastAPI/Python helper that validates that the supplied address both conforms to Bech32 formatting rules and exists on\u2013chain as a CW-721 contract.",
            "code": "from typing import Dict\nimport re\nimport requests\nfrom fastapi import FastAPI, HTTPException\n\n# Regular expression for basic Bech32 address validation (prefix + 38 data chars)\nBECH32_REGEX = re.compile(r'^[a-z0-9]{3,15}1[0-9a-z]{38}$')\n\n# Public LCD endpoint for the target chain (edit to match your network)\nLCD_ENDPOINT = 'https://lcd.osmosis.zone'\n\nclass ContractValidationError(Exception):\n    '''Raised when the given address fails validation checks.'''\n\n\ndef _validate_contract_address(address: str, lcd_endpoint: str = LCD_ENDPOINT) -> Dict:\n    '''Return contract_info if address is a CW-721 contract, else raise ContractValidationError.'''\n\n    # 1. Syntax check (Bech32)\n    if not BECH32_REGEX.match(address):\n        raise ContractValidationError('Address is not valid Bech32 format')\n\n    # 2. Query LCD to confirm the address is a contract account\n    url = f'{lcd_endpoint}/cosmwasm/wasm/v1/contract/{address}'\n    try:\n        resp = requests.get(url, timeout=8)\n        resp.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        raise ContractValidationError(f'Could not reach LCD: {err}') from err\n\n    payload = resp.json()\n    info = payload.get('contract_info')\n    if info is None:\n        raise ContractValidationError('No contract_info returned; address is not a contract')\n\n    # 3. Na\u00efve CW-721 detection based on the label field\n    if 'cw721' not in info.get('label', '').lower():\n        raise ContractValidationError('Contract does not appear to be a CW721 instance')\n\n    return {'is_valid': True, 'address': address, 'contract_info': info}\n\n\n# \u2500\u2500\u2500 FastAPI wrapper so the frontend can call this as REST \u2500\u2500\u2500\napp = FastAPI()\n\n\n@app.get('/api/validate_contract')\nasync def api_validate_contract(address: str):\n    '''HTTP GET endpoint \u2192 /api/validate_contract?address=<ADDR>'''\n    try:\n        return _validate_contract_address(address)\n    except ContractValidationError as e:\n        raise HTTPException(status_code=400, detail=str(e))",
            "usage": "Frontend performs `GET /api/validate_contract?address=<CONTRACT_ADDRESS>`; a successful response contains `{ \"is_valid\": true, ... }`."
        },
        {
            "step": 2,
            "label": "frontend",
            "introduction": "Step 2 provides a tiny utility that builds the canonical CW-721 `all_tokens` query message.",
            "code": "export const buildAllTokensQuery = () => {\n  // The CW721 'all_tokens' query optionally accepts pagination keys.\n  // Here we default to an empty object, meaning \"return every token.\"  \n  return { all_tokens: {} };\n};",
            "usage": "const queryMsg = buildAllTokensQuery();"
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "Step 3 executes the smart-contract query by hitting the chain\u2019s LCD endpoint. The query JSON is Base64-encoded as required by the CosmWasm REST specification.",
            "code": "export const wasmSmartQueryAllTokens = async ({ lcdEndpoint, contractAddress, pagination = {} }) => {\n  try {\n    // 1\u22c5 Build the query (reuse helper from Step 2)\n    const queryObj = { all_tokens: pagination };\n    const queryStr = JSON.stringify(queryObj);\n\n    // 2\u22c5 Base64-encode the query string (browser-safe)\n    const base64Query = btoa(queryStr);\n\n    // 3\u22c5 Construct REST URL per CosmWasm spec\n    const url = `${lcdEndpoint}/cosmwasm/wasm/v1/contract/${contractAddress}/smart/${base64Query}`;\n\n    // 4\u22c5 Fire the request\n    const resp = await fetch(url);\n    if (!resp.ok) {\n      throw new Error(`Smart query failed with status ${resp.status}: ${await resp.text()}`);\n    }\n    const json = await resp.json();\n    return json; // raw LCD response\n  } catch (err) {\n    console.error(err);\n    throw err;\n  }\n};",
            "usage": "const lcd = 'https://lcd.osmosis.zone';\nconst response = await wasmSmartQueryAllTokens({ lcdEndpoint: lcd, contractAddress });"
        },
        {
            "step": 4,
            "label": "frontend",
            "introduction": "Step 4 is a small parser that extracts the array of token IDs from the LCD smart-query response.",
            "code": "export const parseTokenIds = (smartQueryResponse) => {\n  // Different LCD implementations wrap the contract response under `data` or `result`.\n  const inner = smartQueryResponse?.data ?? smartQueryResponse?.result;\n  if (!inner) {\n    throw new Error('Unexpected response format: missing data/result field');\n  }\n\n  // The CW721 `all_tokens` query either returns `[\"id1\",\"id2\"]` or `{ tokens: [\"id1\",\"id2\"] }`.\n  const tokensArray = Array.isArray(inner) ? inner : inner.tokens;\n\n  if (!Array.isArray(tokensArray)) {\n    throw new Error('Smart-query response does not contain a tokens array');\n  }\n  return tokensArray;\n};",
            "usage": "const tokenIds = parseTokenIds(response);\nconsole.log('Token IDs:', tokenIds);"
        }
    ]
}