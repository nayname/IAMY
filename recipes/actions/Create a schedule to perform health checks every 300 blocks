{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "This Python helper fetches the Main DAO authority address by querying the DAO smart-contract. That address will be set as the `authority` field in subsequent governance messages.",
            "code": "from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.contract import CosmWasmContract\n\n\ndef get_dao_authority_address(dao_contract: str, lcd_url: str = \"https://lcd.neutron.org\") -> str:\n    \"\"\"Query the DAO contract for its authority address.\n\n    Parameters\n    ----------\n    dao_contract: str\n        On-chain address of the DAO contract.\n    lcd_url: str\n        LCD endpoint for a Neutron full node (defaults to main-net).\n\n    Returns\n    -------\n    str\n        The authority address able to create governance proposals.\n    \"\"\"\n    try:\n        cfg = NetworkConfig(\n            chain_id=\"neutron-1\",\n            url=lcd_url,\n            fee_minimum_gas_price=0.025,\n            fee_denomination=\"untrn\",\n        )\n        client = LedgerClient(cfg)\n        contract = CosmWasmContract(client, dao_contract)\n\n        # NB: replace the query payload with whatever your DAO exposes.\n        result = contract.query({\"authority\": {}})\n        authority = result.get(\"authority\")\n        if not authority:\n            raise ValueError(\"Authority address missing in query response\")\n        return authority\n    except Exception as err:\n        raise RuntimeError(f\"Failed to fetch DAO authority address: {err}\")",
            "usage": "authority_addr = get_dao_authority_address(\"neutron1dao...contract...\")"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "This function builds a protobuf `MsgAddSchedule` that will call the monitoring contract\u2019s `perform_checks` entry-point every 300 blocks (\u2248 30 min).",
            "code": "import json\nfrom google.protobuf.any_pb2 import Any as Any_pb\nfrom google.protobuf.json_format import MessageToDict\n\n# Protobuf imports generated from Neutron & Cosmos SDK proto definitions\nfrom neutron_proto.cron import MsgAddSchedule\nfrom cosmos_proto.cosmwasm.wasm.v1 import MsgExecuteContract\n\n\ndef build_msg_add_schedule(authority: str,\n                           monitoring_contract: str,\n                           gas_limit: int = 500_000) -> MsgAddSchedule:\n    \"\"\"Compose a MsgAddSchedule ready for inclusion in a Tx.\"\"\"\n    try:\n        # 1. Build the inner MsgExecuteContract that will be executed by Cron\n        exec_msg = MsgExecuteContract(\n            sender=authority,\n            contract=monitoring_contract,\n            msg=json.dumps({\"perform_checks\": {}}).encode(),\n            funds=[],\n        )\n\n        # 2. Wrap everything into MsgAddSchedule\n        add_schedule_msg = MsgAddSchedule(\n            authority=authority,\n            name=\"health_check\",\n            period=300,\n            msgs=[exec_msg.SerializeToString()],  # list[bytes]\n            gas_limit=gas_limit,\n        )\n        return add_schedule_msg\n    except Exception as err:\n        raise RuntimeError(f\"Unable to build MsgAddSchedule: {err}\")",
            "usage": "schedule_msg = build_msg_add_schedule(authority_addr, \"neutron1monitoring...\")"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Wrap the `MsgAddSchedule` in a DAO governance proposal (Cosmos-SDK `MsgSubmitProposal`). The description explains why a 300-block cadence is chosen.",
            "code": "from cosmos_proto.cosmos.gov.v1 import MsgSubmitProposal, TextProposal\n\n\ndef package_into_gov_proposal(authority: str,\n                              schedule_msg: MsgAddSchedule,\n                              deposit: int = 100_000_000) -> MsgSubmitProposal:\n    \"\"\"Create a MsgSubmitProposal that contains our schedule message.\"\"\"\n    try:\n        # Pack the schedule message in \"Any\"\n        any_schedule = Any_pb()\n        any_schedule.Pack(schedule_msg)\n\n        proposal_content = TextProposal(\n            title=\"Add periodic on-chain health check\",\n            description=(\n                \"This proposal adds a Cron schedule named `health_check` that \"\n                \"executes the monitoring contract\u2019s `perform_checks` message \"\n                \"every 300 blocks (~30 minutes). The cadence is selected to \"\n                \"provide timely detection of potential network issues while \"\n                \"minimising gas consumption.\"\n            ),\n        )\n        any_content = Any_pb()\n        any_content.Pack(proposal_content)\n\n        msg_submit = MsgSubmitProposal(\n            content=any_content,\n            messages=[any_schedule],\n            initial_deposit=[{\"denom\": \"untrn\", \"amount\": str(deposit)}],\n            proposer=authority,\n        )\n        return msg_submit\n    except Exception as err:\n        raise RuntimeError(f\"Could not package proposal: {err}\")",
            "usage": "gov_msg = package_into_gov_proposal(authority_addr, schedule_msg)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Finally we sign the governance proposal Tx with the DAO\u2019s key and broadcast it to the Neutron network.",
            "code": "from cosmpy.crypto.keypairs import PrivateKey\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\n\n\ndef sign_and_broadcast_tx(priv_key_hex: str,\n                          msgs: list,\n                          rpc_url: str = \"https://rpc.neutron.org\") -> str:\n    \"\"\"Sign an array of messages and broadcast the Tx, returning its hash.\"\"\"\n    try:\n        cfg = NetworkConfig(\n            chain_id=\"neutron-1\",\n            url=rpc_url,\n            fee_minimum_gas_price=0.025,\n            fee_denomination=\"untrn\",\n        )\n        client = LedgerClient(cfg)\n\n        private_key = PrivateKey(bytes.fromhex(priv_key_hex))\n        sender = private_key.public_key().address()\n\n        tx = Transaction()\n        for msg in msgs:\n            tx.add_message(msg)\n\n        tx.with_sender(sender)\n        tx.with_chain_id(cfg.chain_id)\n        tx = tx.with_gas(700_000)\n        tx = tx.with_fee(int(700_000 * 0.025), \"untrn\")\n\n        signed = tx.sign(private_key, client)\n        tx_hash = client.broadcast_tx(signed)\n        result = client.wait_for_tx(tx_hash)\n        if result.code != 0:\n            raise RuntimeError(f\"Tx failed: {result.raw_log}\")\n        return tx_hash\n    except Exception as err:\n        raise RuntimeError(f\"Broadcast error: {err}\")",
            "usage": "tx_hash = sign_and_broadcast_tx(PRIV_KEY_HEX, [gov_msg])"
        }
    ]
}