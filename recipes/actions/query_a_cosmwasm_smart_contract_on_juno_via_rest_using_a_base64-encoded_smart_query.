{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a Python backend helper that validates a Juno bech32 contract address before it is used in any LCD query.",
            "code": "import re\n\n\nclass ContractAddressValidationError(ValueError):\n    '''Raised when a provided contract address is not a valid Juno bech32 address.'''\n\n\ndef validate_contract_address_format(contract_address: str) -> str:\n    '''Validate that the contract address is a non-empty Juno bech32 address.\n\n    Args:\n        contract_address: The contract address string to validate.\n\n    Returns:\n        The original contract address if it is valid.\n\n    Raises:\n        ContractAddressValidationError: If the address is empty or invalid.\n    '''\n    if contract_address is None:\n        raise ContractAddressValidationError('Contract address is required.')\n\n    contract_address = contract_address.strip()\n    if not contract_address:\n        raise ContractAddressValidationError('Contract address cannot be empty or whitespace.')\n\n    # Basic bech32-style validation for Juno contract/account addresses.\n    # Juno addresses are lower-case and typically start with 'juno1'.\n    pattern = re.compile(r'^juno1[0-9a-z]{38}$')\n    if not pattern.fullmatch(contract_address):\n        raise ContractAddressValidationError(\n            'Invalid Juno contract address format. Expected a bech32 address starting with prefix juno1.'\n        )\n\n    return contract_address\n",
            "usage": "validated_address = validate_contract_address_format('juno1yourcontractaddresshere')"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 normalizes a high-level query (Python dict or JSON string) into a compact JSON string suitable for encoding.",
            "code": "import json\nfrom typing import Any, Union\n\n\nclass QueryBuildError(ValueError):\n    '''Raised when a contract query JSON cannot be built or parsed.'''\n\n\ndef build_query_json_string(query: Union[str, dict]) -> str:\n    '''Normalize the high-level query into a compact JSON string.\n\n    The input can be either a JSON string or a Python dict; this helper\n    validates and normalizes it.\n    '''\n    try:\n        if isinstance(query, str):\n            # Validate JSON string and normalize formatting.\n            parsed = json.loads(query)\n        elif isinstance(query, dict):\n            parsed = query\n        else:\n            raise QueryBuildError('Query must be a dict or JSON string.')\n    except (json.JSONDecodeError, TypeError) as exc:\n        raise QueryBuildError(f'Invalid query JSON: {exc}') from exc\n\n    # Serialize without extra whitespace and keep UTF-8 characters intact.\n    return json.dumps(parsed, separators=(',', ':'), ensure_ascii=False)\n",
            "usage": "compact_query = build_query_json_string({'get_config': {}})"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 takes the compact JSON query string, encodes it to base64, and then URL-encodes it so it can safely live in a URL path segment.",
            "code": "import base64\nimport urllib.parse\n\n\nclass QueryEncodingError(ValueError):\n    '''Raised when a query string cannot be encoded to base64 and URL format.'''\n\n\ndef encode_query_to_base64(json_query: str) -> str:\n    '''Encode a JSON query string to base64 and then URL-encode it.\n\n    The returned string is safe to embed directly into a URL path segment.\n    '''\n    if not isinstance(json_query, str) or not json_query:\n        raise QueryEncodingError('JSON query must be a non-empty string.')\n\n    try:\n        query_bytes = json_query.encode('utf-8')\n        b64_bytes = base64.b64encode(query_bytes)\n        b64_str = b64_bytes.decode('ascii')\n        # URL-encode to safely embed in a URL path segment (encodes characters such as +, /, =).\n        return urllib.parse.quote(b64_str, safe='')\n    except Exception as exc:\n        raise QueryEncodingError(f'Failed to encode query to base64: {exc}') from exc\n",
            "usage": "encoded_query = encode_query_to_base64(compact_query)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 performs the actual HTTP GET against the Juno LCD smart query endpoint using the validated contract address and encoded query.",
            "code": "import httpx\n\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nclass SmartQueryHttpError(RuntimeError):\n    '''Raised when the LCD smart query HTTP request fails.'''\n\n\nasync def http_get_lcd_smart_query(contract_address: str, encoded_query: str) -> dict:\n    '''Perform an HTTP GET to the Juno LCD smart query endpoint.\n\n    Args:\n        contract_address: Validated Juno contract address.\n        encoded_query: URL-safe base64 string produced from the JSON query.\n\n    Returns:\n        Parsed JSON body from the LCD response as a Python dict.\n\n    Raises:\n        SmartQueryHttpError: If the request fails or the response is invalid.\n    '''\n    if not contract_address or not encoded_query:\n        raise SmartQueryHttpError('Both contract_address and encoded_query are required.')\n\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{encoded_query}'\n    headers = {\n        'Accept': 'application/json',\n    }\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            response = await client.get(url, headers=headers)\n    except httpx.RequestError as exc:\n        raise SmartQueryHttpError(f'Network error while querying LCD: {exc}') from exc\n\n    if response.status_code != 200:\n        # Include body text when possible to make debugging easier.\n        body_text = response.text\n        raise SmartQueryHttpError(\n            f'LCD smart query failed with status {response.status_code}: {body_text}'\n        )\n\n    try:\n        return response.json()\n    except ValueError as exc:\n        raise SmartQueryHttpError(f'Failed to parse LCD JSON response: {exc}') from exc\n",
            "usage": "response_json = await http_get_lcd_smart_query(validated_address, encoded_query)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 parses the LCD JSON response and extracts the base64-encoded data field that represents the contract's raw response bytes.",
            "code": "import typing as t\n\n\nclass SmartQueryParseError(ValueError):\n    '''Raised when the LCD smart query response does not have the expected format.'''\n\n\ndef parse_lcd_smart_query_response(response_json: t.Mapping[str, t.Any]) -> str:\n    '''Extract the base64-encoded contract response data from the LCD JSON body.\n\n    Args:\n        response_json: Parsed JSON returned from the LCD smart query endpoint.\n\n    Returns:\n        The base64-encoded data field representing the contract response.\n\n    Raises:\n        SmartQueryParseError: If the response is missing the data field or is malformed.\n    '''\n    if response_json is None:\n        raise SmartQueryParseError('LCD response JSON is required.')\n\n    if not isinstance(response_json, dict):\n        raise SmartQueryParseError('LCD response JSON must be a dict.')\n\n    if 'data' not in response_json:\n        raise SmartQueryParseError('LCD smart query response missing required field data.')\n\n    data_field = response_json['data']\n    if not isinstance(data_field, str) or not data_field:\n        raise SmartQueryParseError('LCD smart query data field must be a non-empty base64 string.')\n\n    return data_field\n",
            "usage": "base64_data = parse_lcd_smart_query_response(response_json)"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 base64-decodes the contract's data field, interprets it as UTF-8 JSON, and returns the structured query result.",
            "code": "import base64\nimport json\nfrom typing import Any\n\n\nclass ContractResponseDecodeError(ValueError):\n    '''Raised when contract response data cannot be base64-decoded or parsed as JSON.'''\n\n\ndef decode_contract_response_data(data_b64: str) -> Any:\n    '''Decode base64 contract response bytes and parse them as UTF-8 JSON.\n\n    Args:\n        data_b64: Base64-encoded string taken from the LCD smart query response data field.\n\n    Returns:\n        Parsed Python object representing the contract query response.\n\n    Raises:\n        ContractResponseDecodeError: If decoding or JSON parsing fails.\n    '''\n    if not isinstance(data_b64, str) or not data_b64:\n        raise ContractResponseDecodeError('data_b64 must be a non-empty base64 string.')\n\n    try:\n        raw_bytes = base64.b64decode(data_b64)\n    except Exception as exc:\n        raise ContractResponseDecodeError(f'Failed to base64-decode contract data: {exc}') from exc\n\n    try:\n        text = raw_bytes.decode('utf-8')\n    except UnicodeDecodeError as exc:\n        raise ContractResponseDecodeError(f'Contract data is not valid UTF-8: {exc}') from exc\n\n    try:\n        return json.loads(text)\n    except json.JSONDecodeError as exc:\n        raise ContractResponseDecodeError(f'Contract data is not valid JSON: {exc}') from exc\n",
            "usage": "contract_result = decode_contract_response_data(base64_data)"
        }
    ]
}