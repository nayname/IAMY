{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a backend helper that maps the human-readable 'republic' label to a concrete chain configuration (chain ID, RPC/REST endpoints, indexer URL, Bech32 prefixes, and denom metadata).",
            "code": "from typing import Any, Dict\n\n# Static network registry for Republic-like Cosmos chains.\n# In a production service this could be loaded from configuration.\nREPUBLIC_NETWORKS: Dict[str, Dict[str, Any]] = {\n    'republic': {\n        'chain_id': 'republic-1',\n        'rpc_endpoint': 'https://rpc.republic.example.com',\n        'rest_endpoint': 'https://rest.republic.example.com',\n        'indexer_endpoint': 'https://indexer.republic.example.com',\n        # Bech32 prefixes follow standard Cosmos conventions\n        'bech32_prefix_acc': 'repub',\n        'bech32_prefix_valoper': 'repubvaloper',\n        # Token metadata\n        'native_denom': 'urep',          # on-chain micro-denom\n        'display_denom': 'REP',          # human-readable denom\n        'denom_exponent': 6,             # 1 REP = 10^6 urep\n    },\n}\n\n\ndef resolve_network_from_label(label: str) -> Dict[str, Any]:\n    '''\n    Resolve a human-friendly network label (e.g. 'republic')\n    into its full chain configuration.\n\n    Raises:\n        ValueError: if the label is unknown.\n    '''\n    if not label:\n        raise ValueError('Network label must be a non-empty string.')\n\n    normalized = label.strip().lower()\n    try:\n        return REPUBLIC_NETWORKS[normalized]\n    except KeyError as exc:\n        supported = ', '.join(sorted(REPUBLIC_NETWORKS.keys())) or '<none>'\n        raise ValueError(\n            f'Unknown network label {label!r}. Supported labels: {supported}'\n        ) from exc\n",
            "usage": "network_cfg = resolve_network_from_label('republic')  # {'chain_id': 'republic-1', 'rpc_endpoint': '...', ...}"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 provides a backend utility that validates a Republic validator operator (valoper) address using Bech32 prefix, checksum, and payload length checks, and returns it in canonical (lowercase) form.",
            "code": "from typing import Any, Dict\n\nfrom bech32 import bech32_decode, convertbits\n\n\ndef validate_validator_address_format(\n    address: str,\n    network: Dict[str, Any],\n) -> str:\n    '''\n    Validate that the given address is a well-formed Republic validator\n    operator (valoper) address and normalize it to a canonical form.\n\n    Args:\n        address: The validator operator address as provided by the client.\n        network: Network configuration returned by resolve_network_from_label.\n\n    Returns:\n        Canonical, lowercased validator operator address.\n\n    Raises:\n        ValueError: if the address is missing or malformed.\n    '''\n    if not address:\n        raise ValueError('Validator address must be a non-empty string.')\n\n    expected_prefix = network.get('bech32_prefix_valoper')\n    if not expected_prefix:\n        raise ValueError('Network configuration is missing bech32_prefix_valoper.')\n\n    # bech32_decode returns (hrp, data) where data is a list of 5-bit integers.\n    hrp, data = bech32_decode(address)\n    if hrp is None or data is None:\n        raise ValueError('Address is not valid bech32.')\n\n    if hrp != expected_prefix:\n        raise ValueError(\n            f'Address has wrong prefix {hrp!r}, expected {expected_prefix!r}.'\n        )\n\n    # Convert 5-bit groups back to 8-bit bytes to validate payload length.\n    try:\n        decoded_bytes = bytes(convertbits(data, 5, 8, False))\n    except ValueError as exc:\n        raise ValueError('Failed to convert bech32 data to bytes.') from exc\n\n    # Cosmos addresses are typically 20 or 32 bytes, depending on the chain.\n    if len(decoded_bytes) not in (20, 32):\n        raise ValueError(\n            f'Unexpected decoded address length {len(decoded_bytes)}, '\n            f'expected 20 or 32 bytes.'\n        )\n\n    # Canonical form: trimmed and lowercased (bech32 is case-insensitive).\n    canonical = address.strip().lower()\n\n    return canonical\n",
            "usage": "canonical_valoper = validate_validator_address_format(address=user_input_valoper, network=network_cfg)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 adds a backend function that queries the Republic (Cosmos-SDK) staking module for core validator details such as moniker, operator address, consensus public key, status, commission rate, minimum self-delegation, and total tokens.",
            "code": "from typing import Any, Dict\n\nimport httpx\n\n\nasync def query_republic_validator_details(\n    network: Dict[str, Any],\n    valoper_address: str,\n) -> Dict[str, Any]:\n    '''\n    Query the Republic staking module for core validator information.\n\n    This uses the Cosmos SDK REST (gRPC-gateway) endpoint:\n        /cosmos/staking/v1beta1/validators/{valoper_address}\n\n    Returns:\n        A dictionary with moniker, operator address, consensus public key,\n        status, commission, minimum self-delegation, and total tokens.\n\n    Raises:\n        RuntimeError: on network or protocol errors.\n    '''\n    rest_endpoint = network.get('rest_endpoint')\n    if not rest_endpoint:\n        raise RuntimeError('Network configuration is missing rest_endpoint.')\n\n    base_url = rest_endpoint.rstrip('/')\n    url = f'{base_url}/cosmos/staking/v1beta1/validators/{valoper_address}'\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            response = await client.get(url)\n        response.raise_for_status()\n    except httpx.HTTPError as exc:\n        raise RuntimeError(\n            f'Failed to query validator details from {url!r}: {exc}'\n        ) from exc\n\n    data = response.json()\n    validator = data.get('validator')\n    if not validator:\n        raise RuntimeError(\n            f'No validator data returned for address {valoper_address!r}.'\n        )\n\n    description = validator.get('description', {}) or {}\n    commission_obj = validator.get('commission', {}) or {}\n    commission_rates = commission_obj.get('commission_rates', {}) or {}\n\n    # Raw token amount in the chain's base denom (e.g. urep).\n    tokens_raw_str = validator.get('tokens', '0') or '0'\n    try:\n        tokens_raw = int(tokens_raw_str)\n    except (TypeError, ValueError):\n        raise RuntimeError(\n            f'Validator tokens field is not an integer: {tokens_raw_str!r}.'\n        )\n\n    exponent = int(network.get('denom_exponent', 6))\n    display_amount = tokens_raw / (10 ** exponent)\n\n    details: Dict[str, Any] = {\n        'moniker': description.get('moniker'),\n        'operator_address': validator.get('operator_address'),\n        'consensus_pubkey': validator.get('consensus_pubkey'),\n        'status': validator.get('status'),\n        'commission_rate': commission_rates.get('rate'),\n        'min_self_delegation': validator.get('min_self_delegation'),\n        'tokens': {\n            'amount': str(tokens_raw),\n            'denom': network.get('native_denom', 'urep'),\n            'display_amount': display_amount,\n            'display_denom': network.get('display_denom', 'REP'),\n        },\n    }\n\n    return details\n",
            "usage": "validator_details = await query_republic_validator_details(network=network_cfg, valoper_address=canonical_valoper)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 implements a backend routine that walks all delegations to the validator to compute total delegated stake, self-delegation amount (from the validator\u2019s own account), and the number of delegators.",
            "code": "from typing import Any, Dict, List\n\nimport httpx\nfrom bech32 import bech32_decode, bech32_encode\n\n\ndef _valoper_to_acc_address(\n    valoper_address: str,\n    network: Dict[str, Any],\n) -> str:\n    '''\n    Convert a validator operator address (valoper) into the corresponding\n    account address using the network's Bech32 prefixes.\n    '''\n    expected_prefix = network.get('bech32_prefix_valoper')\n    acc_prefix = network.get('bech32_prefix_acc')\n\n    if not expected_prefix or not acc_prefix:\n        raise ValueError('Network configuration is missing Bech32 prefixes.')\n\n    hrp, data = bech32_decode(valoper_address)\n    if hrp is None or data is None:\n        raise ValueError('valoper address is not valid bech32.')\n\n    if hrp != expected_prefix:\n        raise ValueError(\n            f'valoper address has wrong prefix {hrp!r}, expected {expected_prefix!r}.'\n        )\n\n    # Re-encode the same payload with the account prefix.\n    acc_address = bech32_encode(acc_prefix, data)\n    return acc_address\n\n\nasync def query_republic_validator_stake_totals(\n    network: Dict[str, Any],\n    valoper_address: str,\n) -> Dict[str, Any]:\n    '''\n    Compute detailed staking metrics for a Republic validator.\n\n    This function queries all delegations to the validator and derives:\n      - total delegated stake in the base denom\n      - self-delegation amount (from the validator's own account)\n      - number of delegators\n\n    Raises:\n        RuntimeError: on network or protocol errors.\n    '''\n    rest_endpoint = network.get('rest_endpoint')\n    if not rest_endpoint:\n        raise RuntimeError('Network configuration is missing rest_endpoint.')\n\n    denom = network.get('native_denom', 'urep')\n    exponent = int(network.get('denom_exponent', 6))\n\n    try:\n        self_delegator_address = _valoper_to_acc_address(valoper_address, network)\n    except ValueError as exc:\n        raise RuntimeError(f'Invalid valoper address: {exc}') from exc\n\n    base_url = rest_endpoint.rstrip('/')\n    delegations_path = f'{base_url}/cosmos/staking/v1beta1/validators/{valoper_address}/delegations'\n\n    total_amount = 0\n    self_amount = 0\n    num_delegators = 0\n    next_key: str | None = None\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            while True:\n                params: Dict[str, Any] = {'pagination.limit': 1000}\n                if next_key:\n                    params['pagination.key'] = next_key\n\n                response = await client.get(delegations_path, params=params)\n                response.raise_for_status()\n                page = response.json()\n\n                delegation_responses: List[Dict[str, Any]] = page.get(\n                    'delegation_responses', []\n                )\n\n                for entry in delegation_responses:\n                    delegation = entry.get('delegation', {}) or {}\n                    balance = entry.get('balance', {}) or {}\n\n                    if balance.get('denom') != denom:\n                        # Skip any non-native tokens.\n                        continue\n\n                    amount_str = balance.get('amount', '0') or '0'\n                    try:\n                        amount = int(amount_str)\n                    except (TypeError, ValueError):\n                        # Skip malformed balance entries rather than failing the whole query.\n                        continue\n\n                    total_amount += amount\n                    if delegation.get('delegator_address') == self_delegator_address:\n                        self_amount += amount\n\n                    num_delegators += 1\n\n                pagination = page.get('pagination', {}) or {}\n                next_key = pagination.get('next_key')\n                if not next_key:\n                    break\n\n    except httpx.HTTPError as exc:\n        raise RuntimeError(\n            f'Failed to query delegations for {valoper_address!r}: {exc}'\n        ) from exc\n\n    total_display = total_amount / (10 ** exponent)\n    self_display = self_amount / (10 ** exponent)\n\n    return {\n        'validator': valoper_address,\n        'total_stake': {\n            'amount': str(total_amount),\n            'denom': denom,\n            'display_amount': total_display,\n            'display_denom': network.get('display_denom', 'REP'),\n        },\n        'self_delegation': {\n            'amount': str(self_amount),\n            'denom': denom,\n            'display_amount': self_display,\n            'display_denom': network.get('display_denom', 'REP'),\n            'delegator_address': self_delegator_address,\n        },\n        'num_delegators': num_delegators,\n    }\n",
            "usage": "stake_totals = await query_republic_validator_stake_totals(network=network_cfg, valoper_address=canonical_valoper)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 adds a backend function that queries the Republic compute validation registry / indexer for the validator\u2019s latest throughput, inference, and achieved FLOPs benchmark results.",
            "code": "from typing import Any, Dict\n\nimport httpx\n\n\nasync def query_republic_compute_benchmarks(\n    network: Dict[str, Any],\n    valoper_address: str,\n) -> Dict[str, Any]:\n    '''\n    Fetch the most recent compute benchmark results for a validator\n    from the Republic compute validation registry / indexer.\n\n    Expected indexer endpoint (conceptual):\n        GET {indexer_endpoint}/v1/validators/{valoper_address}/benchmarks/latest\n\n    Returns:\n        A dictionary containing throughput, inference performance,\n        and achieved FLOPs benchmarks, or None values if not found.\n\n    Raises:\n        RuntimeError: on network or protocol errors other than 404.\n    '''\n    indexer_endpoint = network.get('indexer_endpoint')\n    if not indexer_endpoint:\n        raise RuntimeError('Network configuration is missing indexer_endpoint.')\n\n    base_url = indexer_endpoint.rstrip('/')\n    url = f'{base_url}/v1/validators/{valoper_address}/benchmarks/latest'\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            response = await client.get(url)\n    except httpx.HTTPError as exc:\n        raise RuntimeError(\n            f'Failed to query compute benchmarks from {url!r}: {exc}'\n        ) from exc\n\n    if response.status_code == 404:\n        # Validator has not yet published benchmark results.\n        return {\n            'throughput': None,\n            'inference': None,\n            'achieved_flops': None,\n        }\n\n    try:\n        response.raise_for_status()\n    except httpx.HTTPStatusError as exc:\n        raise RuntimeError(\n            f'Unexpected status when querying benchmarks: {exc.response.status_code}'\n        ) from exc\n\n    data = response.json() or {}\n\n    # The exact shape is indexer-defined; here we pass through canonical fields\n    # that match Republic's three benchmark categories.\n    return {\n        'throughput': data.get('throughput'),\n        'inference': data.get('inference'),\n        'achieved_flops': data.get('achieved_flops'),\n        # Preserve the raw payload for debugging or future fields.\n        'raw': data,\n    }\n",
            "usage": "benchmarks = await query_republic_compute_benchmarks(network=network_cfg, valoper_address=canonical_valoper)"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 introduces a backend helper that fetches the validator\u2019s current reputation score and its breakdown (benchmarks, job completion, slashing penalties) from the Republic reputation indexer.",
            "code": "from typing import Any, Dict\n\nimport httpx\n\n\nasync def query_republic_reputation_scores(\n    network: Dict[str, Any],\n    valoper_address: str,\n) -> Dict[str, Any]:\n    '''\n    Retrieve the current reputation score and its breakdown for a validator.\n\n    Expected indexer endpoint (conceptual):\n        GET {indexer_endpoint}/v1/validators/{valoper_address}/reputation\n\n    Returns:\n        A dictionary with an overall score and component breakdown, or a\n        zeroed-out structure if no reputation has been recorded yet.\n\n    Raises:\n        RuntimeError: on network or protocol errors other than 404.\n    '''\n    indexer_endpoint = network.get('indexer_endpoint')\n    if not indexer_endpoint:\n        raise RuntimeError('Network configuration is missing indexer_endpoint.')\n\n    base_url = indexer_endpoint.rstrip('/')\n    url = f'{base_url}/v1/validators/{valoper_address}/reputation'\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            response = await client.get(url)\n    except httpx.HTTPError as exc:\n        raise RuntimeError(\n            f'Failed to query reputation from {url!r}: {exc}'\n        ) from exc\n\n    if response.status_code == 404:\n        # No reputation data yet (e.g. new validator).\n        return {\n            'score': 0.0,\n            'components': {\n                'benchmarks': 0.0,\n                'job_completion': 0.0,\n                'slashing_penalty': 0.0,\n            },\n            'raw': None,\n        }\n\n    try:\n        response.raise_for_status()\n    except httpx.HTTPStatusError as exc:\n        raise RuntimeError(\n            f'Unexpected status when querying reputation: {exc.response.status_code}'\n        ) from exc\n\n    data = response.json() or {}\n    components = data.get('components') or {}\n\n    return {\n        'score': float(data.get('score', 0.0)),\n        'components': {\n            'benchmarks': float(components.get('benchmarks', 0.0)),\n            'job_completion': float(components.get('job_completion', 0.0)),\n            'slashing_penalty': float(components.get('slashing_penalty', 0.0)),\n        },\n        'raw': data,\n    }\n",
            "usage": "reputation = await query_republic_reputation_scores(network=network_cfg, valoper_address=canonical_valoper)"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Step 7 defines a backend function that queries the validator\u2019s slashing history from an indexer, normalizing each event with height, timestamp, reason, and slashed amount in REP\u2019s base denom.",
            "code": "from typing import Any, Dict, List\n\nimport httpx\n\n\nasync def query_republic_slashing_history(\n    network: Dict[str, Any],\n    valoper_address: str,\n) -> List[Dict[str, Any]]:\n    '''\n    Query the slashing history for a validator from an indexer or\n    event-log service.\n\n    Expected indexer endpoint (conceptual):\n        GET {indexer_endpoint}/v1/validators/{valoper_address}/slashing_events\n\n    Each returned event is normalized to include:\n        - height\n        - timestamp\n        - reason\n        - amount (in base denom)\n        - tx_hash (if available)\n\n    Raises:\n        RuntimeError: on network or protocol errors other than 404.\n    '''\n    indexer_endpoint = network.get('indexer_endpoint')\n    if not indexer_endpoint:\n        raise RuntimeError('Network configuration is missing indexer_endpoint.')\n\n    base_url = indexer_endpoint.rstrip('/')\n    url = f'{base_url}/v1/validators/{valoper_address}/slashing_events'\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            response = await client.get(url, params={'order': 'desc'})\n    except httpx.HTTPError as exc:\n        raise RuntimeError(\n            f'Failed to query slashing history from {url!r}: {exc}'\n        ) from exc\n\n    if response.status_code == 404:\n        # No slashing events recorded for this validator.\n        return []\n\n    try:\n        response.raise_for_status()\n    except httpx.HTTPStatusError as exc:\n        raise RuntimeError(\n            f'Unexpected status when querying slashing history: {exc.response.status_code}'\n        ) from exc\n\n    data = response.json() or {}\n    events = data.get('events') or []\n\n    normalized_events: List[Dict[str, Any]] = []\n    base_denom = network.get('native_denom', 'urep')\n\n    for ev in events:\n        amount_obj = ev.get('amount', {}) or {}\n        amount_str = amount_obj.get('amount', '0') or '0'\n        denom = amount_obj.get('denom', base_denom) or base_denom\n        try:\n            amount = int(amount_str)\n        except (TypeError, ValueError):\n            amount = 0\n\n        normalized_events.append(\n            {\n                'height': ev.get('height'),\n                'timestamp': ev.get('timestamp'),\n                'reason': ev.get('reason'),\n                'amount': {\n                    'amount': str(amount),\n                    'denom': denom,\n                },\n                'tx_hash': ev.get('tx_hash'),\n            }\n        )\n\n    return normalized_events\n",
            "usage": "slashing_events = await query_republic_slashing_history(network=network_cfg, valoper_address=canonical_valoper)"
        },
        {
            "step": 8,
            "label": "backend",
            "introduction": "Step 8 wires everything together into a Backend-for-Frontend FastAPI endpoint that resolves the network, validates the validator address, queries all underlying data (details, stake, benchmarks, reputation, slashing), and assembles a single validator profile object for UIs.",
            "code": "from typing import Any, Dict\n\nimport asyncio\nfrom fastapi import APIRouter, HTTPException, Query\n\n# This router can be mounted into your FastAPI application.\nrouter = APIRouter()\n\n\nasync def assemble_validator_profile(\n    network_label: str,\n    raw_valoper_address: str,\n) -> Dict[str, Any]:\n    '''\n    High-level orchestration function that combines:\n      - basic validator info\n      - stake metrics\n      - compute benchmarks\n      - reputation\n      - slashing history\n    into a single profile object suitable for API or UI consumption.\n    '''\n    # Resolve network configuration\n    try:\n        network = resolve_network_from_label(network_label)\n    except ValueError as exc:\n        raise HTTPException(status_code=400, detail=str(exc)) from exc\n\n    # Validate and canonicalize validator operator address\n    try:\n        valoper_address = validate_validator_address_format(\n            raw_valoper_address,\n            network,\n        )\n    except ValueError as exc:\n        raise HTTPException(status_code=400, detail=str(exc)) from exc\n\n    # Query core details first.\n    try:\n        validator_details = await query_republic_validator_details(\n            network,\n            valoper_address,\n        )\n    except RuntimeError as exc:\n        raise HTTPException(status_code=502, detail=str(exc)) from exc\n\n    # Fetch stake, benchmarks, reputation, and slashing history in parallel\n    # to minimize latency.\n    stake_task = asyncio.create_task(\n        query_republic_validator_stake_totals(network, valoper_address)\n    )\n    bench_task = asyncio.create_task(\n        query_republic_compute_benchmarks(network, valoper_address)\n    )\n    reputation_task = asyncio.create_task(\n        query_republic_reputation_scores(network, valoper_address)\n    )\n    slashing_task = asyncio.create_task(\n        query_republic_slashing_history(network, valoper_address)\n    )\n\n    try:\n        stake_totals, benchmarks, reputation, slashing_history = await asyncio.gather(\n            stake_task,\n            bench_task,\n            reputation_task,\n            slashing_task,\n        )\n    except RuntimeError as exc:\n        # Any of the underlying calls may raise RuntimeError; surface as 502.\n        raise HTTPException(status_code=502, detail=str(exc)) from exc\n\n    profile: Dict[str, Any] = {\n        'network': {\n            'label': network_label,\n            'chain_id': network.get('chain_id'),\n        },\n        'validator': {\n            **validator_details,\n            'stake': stake_totals,\n            'benchmarks': benchmarks,\n            'reputation': reputation,\n            'slashing_history': slashing_history,\n        },\n    }\n\n    return profile\n\n\n@router.get('/api/republic/validators/profile')\nasync def get_validator_profile(\n    address: str = Query(..., description='Validator operator (valoper) address.'),\n    network: str = Query('republic', description='Network label, e.g. republic.'),\n) -> Dict[str, Any]:\n    '''\n    FastAPI route that exposes the assembled validator profile over HTTP.\n\n    Frontends should call this single endpoint rather than invoking each\n    low-level query independently.\n    '''\n    return await assemble_validator_profile(network_label=network, raw_valoper_address=address)\n",
            "usage": "In your FastAPI app, include the router and call from the frontend:\n\n# backend/main.py\n# from .republic_profile import router as republic_profile_router\n# app.include_router(republic_profile_router)\n\n# frontend (e.g. React):\n# const res = await fetch(`/api/republic/validators/profile?address=${valoper}&network=republic`);\n# const profile = await res.json();"
        }
    ]
}