{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 implements a backend FastAPI handler that parses a Republic validator or delegator address, validates its Bech32 format, and resolves it to a canonical validator operator address using an indexer.",
            "code": "from typing import Literal\n\nimport os\n\nimport httpx\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom bech32 import bech32_decode\n\n# Configure expected Bech32 prefixes for Republic.\n# These can be overridden via environment variables if the chain uses different prefixes.\nVALIDATOR_HRP = os.getenv('REPUBLIC_VALIDATOR_HRP', 'repubvaloper')\nACCOUNT_HRP = os.getenv('REPUBLIC_ACCOUNT_HRP', 'repub')\n\n# Base URL for your Republic indexer or RPC-backed API that can resolve delegations.\nINDEXER_BASE_URL = os.getenv('REPUBLIC_INDEXER_URL', 'https://indexer.republic.org')\n\napp = FastAPI()\n\n\nclass ResolveValidatorResponse(BaseModel):\n    validator_operator_address: str\n    source_type: Literal['validator_address', 'delegator_address']\n\n\ndef _parse_bech32_prefix(address: str) -> str:\n    '''Return the human-readable prefix (HRP) of a Bech32 address or raise HTTP 400 if invalid.'''\n    hrp, data = bech32_decode(address)\n    if hrp is None or data is None:\n        raise HTTPException(status_code=400, detail='Invalid Bech32 address format.')\n    return hrp\n\n\nasync def _resolve_delegator_to_validator(delegator_address: str) -> str:\n    '''Map a delegator/account address to its primary validator operator address.\n\n    This assumes your indexer exposes an endpoint like:\n      GET /v1/delegations/{delegator_address}\n    that returns JSON:\n      {'delegations': [{'validator_address': '...', 'shares': '123.45'}, ...]}\n    '''\n    url = f'{INDEXER_BASE_URL}/v1/delegations/{delegator_address}'\n    timeout = httpx.Timeout(10.0, connect=5.0)\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        try:\n            resp = await client.get(url)\n        except httpx.RequestError as exc:\n            raise HTTPException(\n                status_code=502,\n                detail=f'Failed to reach delegation indexer: {exc}',\n            ) from exc\n\n    if resp.status_code == 404:\n        raise HTTPException(\n            status_code=404,\n            detail=f'No delegations found for delegator address {delegator_address}.',\n        )\n\n    if resp.status_code != 200:\n        raise HTTPException(\n            status_code=502,\n            detail=f'Delegation indexer returned HTTP {resp.status_code}: {resp.text}',\n        )\n\n    data = resp.json()\n    delegations = data.get('delegations') or []\n    if not delegations:\n        raise HTTPException(\n            status_code=404,\n            detail=f'Delegator {delegator_address} has no active delegations.',\n        )\n\n    # Choose the validator with the highest delegated stake/shares.\n    try:\n        best = max(\n            delegations,\n            key=lambda d: float(d.get('shares', '0')),\n        )\n        valoper = best['validator_address']\n    except (ValueError, KeyError, TypeError) as exc:\n        raise HTTPException(\n            status_code=500,\n            detail='Delegation response from indexer is malformed.',\n        ) from exc\n\n    # Sanity-check that it looks like a validator address.\n    hrp = _parse_bech32_prefix(valoper)\n    if hrp != VALIDATOR_HRP:\n        raise HTTPException(\n            status_code=500,\n            detail=(\n                f'Indexer returned a non-validator address ({valoper}) '\n                f'for delegator {delegator_address}.'\n            ),\n        )\n\n    return valoper\n\n\n@app.get('/api/validators/resolve', response_model=ResolveValidatorResponse)\nasync def parse_and_validate_validator_address(identifier: str) -> ResolveValidatorResponse:\n    '''Resolve a user-supplied identifier to a canonical validator operator address.\n\n    Query parameter:\n      - identifier: either a validator operator address (e.g., repubvaloper1...)\n                    or a regular account/delegator address (e.g., repub1...).\n    '''\n    if not identifier or not isinstance(identifier, str):\n        raise HTTPException(status_code=400, detail='Identifier must be a non-empty string.')\n\n    hrp = _parse_bech32_prefix(identifier)\n\n    # Case 1: already a validator operator address.\n    if hrp == VALIDATOR_HRP:\n        return ResolveValidatorResponse(\n            validator_operator_address=identifier,\n            source_type='validator_address',\n        )\n\n    # Case 2: a standard account/delegator address, try to map to a validator.\n    if hrp == ACCOUNT_HRP:\n        valoper = await _resolve_delegator_to_validator(identifier)\n        return ResolveValidatorResponse(\n            validator_operator_address=valoper,\n            source_type='delegator_address',\n        )\n\n    # Unknown HRP: reject.\n    raise HTTPException(\n        status_code=400,\n        detail=(\n            f'Address prefix {hrp} is not recognized as a Republic '\n            'validator or account address.'\n        ),\n    )\n",
            "usage": "From your frontend or other services, send an HTTP GET request to `/api/validators/resolve?identifier=<address>` to receive the resolved `validator_operator_address` and its `source_type`."
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 provides a backend function and HTTP endpoint that query the Republic indexer for a validator\u2019s core profile: operator address, total (delegated) stake, reputation score, and active/jailed status, failing gracefully if the validator is missing or inactive.",
            "code": "from typing import Literal\n\nimport os\n\nimport httpx\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\n\n# Base URL for the Republic indexer or chain-backed API.\nINDEXER_BASE_URL = os.getenv('REPUBLIC_INDEXER_URL', 'https://indexer.republic.org')\n\nrouter = APIRouter()\n\n\nclass ValidatorProfile(BaseModel):\n    operator_address: str\n    moniker: str\n    total_stake: int\n    reputation_score: float\n    status: Literal['active', 'jailed', 'inactive']\n    jailed: bool\n\n\nasync def backend_republic_get_validator_profile(valoper_address: str) -> ValidatorProfile:\n    '''Fetch validator core data from the Republic indexer or chain.\n\n    Raises:\n        HTTPException(404): if the validator does not exist.\n        HTTPException(409): if the validator exists but is not in the active set.\n        HTTPException(502): on upstream/indexer problems.\n    '''\n    if not valoper_address:\n        raise HTTPException(status_code=400, detail='Validator operator address is required.')\n\n    url = f'{INDEXER_BASE_URL}/v1/validators/{valoper_address}'\n    timeout = httpx.Timeout(10.0, connect=5.0)\n\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        try:\n            resp = await client.get(url)\n        except httpx.RequestError as exc:\n            raise HTTPException(\n                status_code=502,\n                detail=f'Failed to query validator profile from indexer: {exc}',\n            ) from exc\n\n    if resp.status_code == 404:\n        raise HTTPException(\n            status_code=404,\n            detail=f'Validator {valoper_address} was not found.',\n        )\n\n    if resp.status_code != 200:\n        raise HTTPException(\n            status_code=502,\n            detail=f'Validator profile indexer returned HTTP {resp.status_code}: {resp.text}',\n        )\n\n    raw = resp.json()\n\n    try:\n        # Cosmos-style fields, adapted for Republic.\n        operator_address = raw['operator_address']\n        moniker = raw.get('description', {}).get('moniker') or raw.get('moniker') or operator_address\n\n        # Many Cosmos indexers expose bonded tokens as strings; convert safely to int.\n        total_stake_str = raw.get('total_stake') or raw.get('tokens') or '0'\n        total_stake = int(total_stake_str)\n\n        # Reputation is a protocol-level metric specific to Republic.\n        reputation_score = float(raw.get('reputation_score', 0.0))\n\n        jailed = bool(raw.get('jailed', False))\n        raw_status = (raw.get('status') or '').upper()\n\n        if jailed or raw_status in {'JAILED', 'BOND_STATUS_UNBONDED', 'BOND_STATUS_UNBONDING'}:\n            status = 'jailed' if jailed or raw_status == 'JAILED' else 'inactive'\n        else:\n            status = 'active'\n\n    except (KeyError, ValueError, TypeError) as exc:\n        raise HTTPException(\n            status_code=500,\n            detail='Validator profile payload from indexer is malformed.',\n        ) from exc\n\n    # Fail gracefully if validator is not active in the current set.\n    if status != 'active':\n        raise HTTPException(\n            status_code=409,\n            detail=f'Validator {operator_address} is not in the active validator set (status={status}).',\n        )\n\n    return ValidatorProfile(\n        operator_address=operator_address,\n        moniker=moniker,\n        total_stake=total_stake,\n        reputation_score=reputation_score,\n        status=status,\n        jailed=jailed,\n    )\n\n\n@router.get('/api/validators/{valoper_address}/profile', response_model=ValidatorProfile)\nasync def get_validator_profile_endpoint(valoper_address: str) -> ValidatorProfile:\n    '''HTTP endpoint wrapper suitable for a BFF service.'''\n    return await backend_republic_get_validator_profile(valoper_address)\n",
            "usage": "In your BFF, import and call `await backend_republic_get_validator_profile(valoper_address)` directly, or expose it over HTTP via the provided GET `/api/validators/{valoper_address}/profile` route for your frontend to consume."
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 adds a backend function and endpoint that retrieve the validator\u2019s latest compute benchmark scores (throughput, inference, achieved FLOPs, and composite compute quality) from the Republic compute validation subsystem.",
            "code": "from typing import Optional\n\nimport os\n\nimport httpx\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\n\nINDEXER_BASE_URL = os.getenv('REPUBLIC_INDEXER_URL', 'https://indexer.republic.org')\n\nrouter = APIRouter()\n\n\nclass BenchmarkScores(BaseModel):\n    validator_operator_address: str\n    throughput_score: float\n    inference_score: float\n    flops_score: float\n    composite_compute_score: float\n    throughput_timestamp: Optional[str] = None\n    inference_timestamp: Optional[str] = None\n    flops_timestamp: Optional[str] = None\n\n\nasync def backend_republic_get_validator_benchmark_scores(valoper_address: str) -> BenchmarkScores:\n    '''Fetch the latest compute benchmark scores for a validator from the compute validation subsystem.'''\n    if not valoper_address:\n        raise HTTPException(status_code=400, detail='Validator operator address is required.')\n\n    url = f'{INDEXER_BASE_URL}/v1/validators/{valoper_address}/benchmarks/latest'\n    timeout = httpx.Timeout(10.0, connect=5.0)\n\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        try:\n            resp = await client.get(url)\n        except httpx.RequestError as exc:\n            raise HTTPException(\n                status_code=502,\n                detail=f'Failed to reach compute benchmark indexer: {exc}',\n            ) from exc\n\n    if resp.status_code == 404:\n        raise HTTPException(\n            status_code=404,\n            detail=f'No benchmark scores found for validator {valoper_address}.',\n        )\n\n    if resp.status_code != 200:\n        raise HTTPException(\n            status_code=502,\n            detail=f'Benchmark indexer returned HTTP {resp.status_code}: {resp.text}',\n        )\n\n    raw = resp.json()\n\n    try:\n        throughput_score = float(raw.get('throughput_score', 0.0))\n        inference_score = float(raw.get('inference_score', 0.0))\n        flops_score = float(raw.get('flops_score', raw.get('achieved_flops_score', 0.0)))\n        composite_compute_score = float(raw.get('composite_compute_score', 0.0))\n\n        throughput_timestamp = raw.get('throughput_timestamp') or raw.get('throughput_updated_at')\n        inference_timestamp = raw.get('inference_timestamp') or raw.get('inference_updated_at')\n        flops_timestamp = raw.get('flops_timestamp') or raw.get('flops_updated_at')\n\n    except (TypeError, ValueError) as exc:\n        raise HTTPException(\n            status_code=500,\n            detail='Benchmark payload from indexer is malformed.',\n        ) from exc\n\n    return BenchmarkScores(\n        validator_operator_address=valoper_address,\n        throughput_score=throughput_score,\n        inference_score=inference_score,\n        flops_score=flops_score,\n        composite_compute_score=composite_compute_score,\n        throughput_timestamp=throughput_timestamp,\n        inference_timestamp=inference_timestamp,\n        flops_timestamp=flops_timestamp,\n    )\n\n\n@router.get('/api/validators/{valoper_address}/benchmarks', response_model=BenchmarkScores)\nasync def get_validator_benchmarks_endpoint(valoper_address: str) -> BenchmarkScores:\n    '''HTTP endpoint wrapper suitable for a BFF service.'''\n    return await backend_republic_get_validator_benchmark_scores(valoper_address)\n",
            "usage": "Call `await backend_republic_get_validator_benchmark_scores(valoper_address)` from your backend orchestration code, or expose it to the frontend via the GET `/api/validators/{valoper_address}/benchmarks` route."
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 defines a backend function and endpoint that read the current protocol parameters controlling committee selection weights (stake, compute quality, and reputation) from an indexer or parameter service.",
            "code": "from typing import Optional\n\nimport os\n\nimport httpx\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\n\nINDEXER_BASE_URL = os.getenv('REPUBLIC_INDEXER_URL', 'https://indexer.republic.org')\n\nrouter = APIRouter()\n\n\nclass SelectionWeightParams(BaseModel):\n    stake_weight: float\n    compute_weight: float\n    reputation_weight: float\n    # Optional safety thresholds/caps.\n    min_reputation: Optional[float] = None\n    min_compute_score: Optional[float] = None\n    max_stake_fraction_cap: Optional[float] = None\n\n\nasync def backend_republic_get_selection_weight_params() -> SelectionWeightParams:\n    '''Query the current protocol parameters that govern committee selection weights.'''\n    url = f'{INDEXER_BASE_URL}/v1/protocol/committee_selection_params'\n    timeout = httpx.Timeout(10.0, connect=5.0)\n\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        try:\n            resp = await client.get(url)\n        except httpx.RequestError as exc:\n            raise HTTPException(\n                status_code=502,\n                detail=f'Failed to query committee selection parameters: {exc}',\n            ) from exc\n\n    if resp.status_code != 200:\n        raise HTTPException(\n            status_code=502,\n            detail=f'Parameter indexer returned HTTP {resp.status_code}: {resp.text}',\n        )\n\n    raw = resp.json()\n\n    try:\n        stake_weight = float(raw.get('stake_weight', 0.5))\n        compute_weight = float(raw.get('compute_weight', 0.3))\n        reputation_weight = float(raw.get('reputation_weight', 0.2))\n\n        min_reputation = raw.get('min_reputation')\n        min_compute_score = raw.get('min_compute_score')\n        max_stake_fraction_cap = raw.get('max_stake_fraction_cap')\n\n        min_reputation = float(min_reputation) if min_reputation is not None else None\n        min_compute_score = float(min_compute_score) if min_compute_score is not None else None\n        max_stake_fraction_cap = float(max_stake_fraction_cap) if max_stake_fraction_cap is not None else None\n\n    except (TypeError, ValueError) as exc:\n        raise HTTPException(\n            status_code=500,\n            detail='Committee selection parameter payload is malformed.',\n        ) from exc\n\n    # Basic sanity check: weights should sum to roughly 1.\n    total_weight = stake_weight + compute_weight + reputation_weight\n    if total_weight <= 0:\n        raise HTTPException(\n            status_code=500,\n            detail='Selection weights sum to zero or negative; protocol params appear invalid.',\n        )\n\n    return SelectionWeightParams(\n        stake_weight=stake_weight,\n        compute_weight=compute_weight,\n        reputation_weight=reputation_weight,\n        min_reputation=min_reputation,\n        min_compute_score=min_compute_score,\n        max_stake_fraction_cap=max_stake_fraction_cap,\n    )\n\n\n@router.get('/api/consensus/committee_selection_params', response_model=SelectionWeightParams)\nasync def get_selection_weight_params_endpoint() -> SelectionWeightParams:\n    '''HTTP endpoint wrapper suitable for a BFF service.'''\n    return await backend_republic_get_selection_weight_params()\n",
            "usage": "Use `await backend_republic_get_selection_weight_params()` from your backend logic, or let the frontend fetch parameters via the GET `/api/consensus/committee_selection_params` endpoint."
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 implements a backend orchestration function and endpoint that combine validator stake, compute quality, reputation, and protocol parameters with network-wide aggregates to compute the validator\u2019s raw committee selection weight and normalized selection probability.",
            "code": "from typing import Optional\n\nimport os\nimport asyncio\n\nimport httpx\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\n\nINDEXER_BASE_URL = os.getenv('REPUBLIC_INDEXER_URL', 'https://indexer.republic.org')\n\nrouter = APIRouter()\n\n\nclass ValidatorProfile(BaseModel):\n    operator_address: str\n    total_stake: int\n    reputation_score: float\n\n\nclass BenchmarkScores(BaseModel):\n    composite_compute_score: float\n\n\nclass SelectionWeightParams(BaseModel):\n    stake_weight: float\n    compute_weight: float\n    reputation_weight: float\n\n\nclass NetworkSelectionTotals(BaseModel):\n    total_bonded_stake: int\n    max_compute_score: float\n    max_reputation_score: float\n    total_weight_sum: Optional[float] = None\n\n\nclass SelectionWeightComponents(BaseModel):\n    stake_component: float\n    compute_component: float\n    reputation_component: float\n\n\nclass SelectionWeightResult(BaseModel):\n    validator_operator_address: str\n    raw_weight: float\n    normalized_probability: float\n    components: SelectionWeightComponents\n\n\nasync def _fetch_validator_profile(valoper_address: str) -> ValidatorProfile:\n    url = f'{INDEXER_BASE_URL}/v1/validators/{valoper_address}'\n    timeout = httpx.Timeout(10.0, connect=5.0)\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        try:\n            resp = await client.get(url)\n        except httpx.RequestError as exc:\n            raise HTTPException(\n                status_code=502,\n                detail=f'Failed to query validator profile: {exc}',\n            ) from exc\n\n    if resp.status_code != 200:\n        raise HTTPException(\n            status_code=resp.status_code,\n            detail=f'Validator profile query failed: {resp.text}',\n        )\n\n    raw = resp.json()\n    try:\n        total_stake_str = raw.get('total_stake') or raw.get('tokens') or '0'\n        total_stake = int(total_stake_str)\n        reputation_score = float(raw.get('reputation_score', 0.0))\n        return ValidatorProfile(\n            operator_address=raw['operator_address'],\n            total_stake=total_stake,\n            reputation_score=reputation_score,\n        )\n    except (KeyError, TypeError, ValueError) as exc:\n        raise HTTPException(\n            status_code=500,\n            detail='Malformed validator profile payload.',\n        ) from exc\n\n\nasync def _fetch_benchmark_scores(valoper_address: str) -> BenchmarkScores:\n    url = f'{INDEXER_BASE_URL}/v1/validators/{valoper_address}/benchmarks/latest'\n    timeout = httpx.Timeout(10.0, connect=5.0)\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        try:\n            resp = await client.get(url)\n        except httpx.RequestError as exc:\n            raise HTTPException(\n                status_code=502,\n                detail=f'Failed to query benchmark scores: {exc}',\n            ) from exc\n\n    if resp.status_code != 200:\n        raise HTTPException(\n            status_code=resp.status_code,\n            detail=f'Benchmark query failed: {resp.text}',\n        )\n\n    raw = resp.json()\n    try:\n        composite_compute_score = float(raw.get('composite_compute_score', 0.0))\n        return BenchmarkScores(composite_compute_score=composite_compute_score)\n    except (TypeError, ValueError) as exc:\n        raise HTTPException(\n            status_code=500,\n            detail='Malformed benchmark payload.',\n        ) from exc\n\n\nasync def _fetch_selection_params() -> SelectionWeightParams:\n    url = f'{INDEXER_BASE_URL}/v1/protocol/committee_selection_params'\n    timeout = httpx.Timeout(10.0, connect=5.0)\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        try:\n            resp = await client.get(url)\n        except httpx.RequestError as exc:\n            raise HTTPException(\n                status_code=502,\n                detail=f'Failed to query selection parameters: {exc}',\n            ) from exc\n\n    if resp.status_code != 200:\n        raise HTTPException(\n            status_code=resp.status_code,\n            detail=f'Selection parameter query failed: {resp.text}',\n        )\n\n    raw = resp.json()\n    try:\n        return SelectionWeightParams(\n            stake_weight=float(raw.get('stake_weight', 0.5)),\n            compute_weight=float(raw.get('compute_weight', 0.3)),\n            reputation_weight=float(raw.get('reputation_weight', 0.2)),\n        )\n    except (TypeError, ValueError) as exc:\n        raise HTTPException(\n            status_code=500,\n            detail='Malformed selection parameter payload.',\n        ) from exc\n\n\nasync def _fetch_network_totals() -> NetworkSelectionTotals:\n    '''Fetch network-wide aggregates needed for normalization.\n\n    Expected indexer endpoint:\n      GET /v1/network/committee_selection_totals\n    returning something like:\n      {\n        'total_bonded_stake': '1234567890',\n        'max_compute_score': 1.0,\n        'max_reputation_score': 1.0,\n        'total_weight_sum': 42.0   # optional precomputed sum over all validators\n      }\n    '''\n    url = f'{INDEXER_BASE_URL}/v1/network/committee_selection_totals'\n    timeout = httpx.Timeout(10.0, connect=5.0)\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        try:\n            resp = await client.get(url)\n        except httpx.RequestError as exc:\n            raise HTTPException(\n                status_code=502,\n                detail=f'Failed to query network selection totals: {exc}',\n            ) from exc\n\n    if resp.status_code != 200:\n        raise HTTPException(\n            status_code=resp.status_code,\n            detail=f'Network totals query failed: {resp.text}',\n        )\n\n    raw = resp.json()\n    try:\n        total_bonded_stake = int(raw.get('total_bonded_stake', '0'))\n        max_compute_score = float(raw.get('max_compute_score', 1.0))\n        max_reputation_score = float(raw.get('max_reputation_score', 1.0))\n        total_weight_sum = raw.get('total_weight_sum')\n        total_weight_sum = float(total_weight_sum) if total_weight_sum is not None else None\n    except (TypeError, ValueError) as exc:\n        raise HTTPException(\n            status_code=500,\n            detail='Malformed network selection totals payload.',\n        ) from exc\n\n    if total_bonded_stake <= 0:\n        raise HTTPException(\n            status_code=500,\n            detail='Network total bonded stake is zero; cannot normalize selection weights.',\n        )\n\n    return NetworkSelectionTotals(\n        total_bonded_stake=total_bonded_stake,\n        max_compute_score=max_compute_score or 1.0,\n        max_reputation_score=max_reputation_score or 1.0,\n        total_weight_sum=total_weight_sum,\n    )\n\n\ndef compute_validator_committee_selection_weight(\n    profile: ValidatorProfile,\n    benchmarks: BenchmarkScores,\n    params: SelectionWeightParams,\n    totals: NetworkSelectionTotals,\n) -> SelectionWeightResult:\n    '''Pure function to compute a validator's committee selection weight and normalized probability.'''\n    # Normalize components to [0, 1] using network aggregates.\n    stake_fraction = profile.total_stake / totals.total_bonded_stake\n\n    compute_fraction = benchmarks.composite_compute_score / totals.max_compute_score\n    # Guard against division by zero or bogus values.\n    compute_fraction = max(0.0, min(compute_fraction, 1.0))\n\n    reputation_fraction = profile.reputation_score / totals.max_reputation_score\n    reputation_fraction = max(0.0, min(reputation_fraction, 1.0))\n\n    stake_component = params.stake_weight * stake_fraction\n    compute_component = params.compute_weight * compute_fraction\n    reputation_component = params.reputation_weight * reputation_fraction\n\n    raw_weight = stake_component + compute_component + reputation_component\n\n    # If the indexer did not precompute the total_weight_sum, approximate probability\n    # as proportional to the validator's raw_weight relative to the sum of weights.\n    if totals.total_weight_sum and totals.total_weight_sum > 0:\n        probability = raw_weight / totals.total_weight_sum\n    else:\n        # In absence of global sum, treat the weighted average as the probability mass\n        # allocated to this validator relative to an idealized maximum of 1.0.\n        probability = max(0.0, min(raw_weight, 1.0))\n\n    return SelectionWeightResult(\n        validator_operator_address=profile.operator_address,\n        raw_weight=raw_weight,\n        normalized_probability=probability,\n        components=SelectionWeightComponents(\n            stake_component=stake_component,\n            compute_component=compute_component,\n            reputation_component=reputation_component,\n        ),\n    )\n\n\n@router.get('/api/validators/{valoper_address}/committee_weight', response_model=SelectionWeightResult)\nasync def compute_validator_committee_weight_endpoint(valoper_address: str) -> SelectionWeightResult:\n    '''High-level BFF endpoint to compute a validator's committee selection probability.'''\n    if not valoper_address:\n        raise HTTPException(status_code=400, detail='Validator operator address is required.')\n\n    profile_task = _fetch_validator_profile(valoper_address)\n    benchmarks_task = _fetch_benchmark_scores(valoper_address)\n    params_task = _fetch_selection_params()\n    totals_task = _fetch_network_totals()\n\n    profile, benchmarks, params, totals = await asyncio.gather(\n        profile_task,\n        benchmarks_task,\n        params_task,\n        totals_task,\n    )\n\n    return compute_validator_committee_selection_weight(profile, benchmarks, params, totals)\n",
            "usage": "Expose the GET `/api/validators/{valoper_address}/committee_weight` endpoint, or call `compute_validator_committee_selection_weight(profile, benchmarks, params, totals)` directly after fetching the required inputs to obtain `raw_weight` and `normalized_probability` for the validator."
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 implements a backend helper and endpoint that turn the computed selection probability and its components into a human-readable explanation, including simple sensitivity analysis for stake, compute quality, and reputation.",
            "code": "from typing import Dict\n\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\n\nrouter = APIRouter()\n\n\nclass SelectionWeightComponents(BaseModel):\n    stake_component: float\n    compute_component: float\n    reputation_component: float\n\n\nclass ProbabilityContext(BaseModel):\n    validator_operator_address: str\n    moniker: str\n    stake_tokens: int\n    reputation_score: float\n    composite_compute_score: float\n    selection_weights: Dict[str, float]\n    probability: float\n    components: SelectionWeightComponents\n\n\ndef generate_probability_explanation(ctx: ProbabilityContext) -> str:\n    '''Generate a human-readable explanation of the validator's committee selection probability.'''\n    total_weight = (\n        ctx.selection_weights.get('stake_weight', 0.0)\n        + ctx.selection_weights.get('compute_weight', 0.0)\n        + ctx.selection_weights.get('reputation_weight', 0.0)\n    )\n\n    lines: list[str] = []\n    lines.append(f'Validator: {ctx.moniker} ({ctx.validator_operator_address})')\n    lines.append('')\n    lines.append('Inputs:')\n    lines.append(f'  - Stake: {ctx.stake_tokens} REP (raw tokens staked, including delegations)')\n    lines.append(f'  - Composite compute score: {ctx.composite_compute_score:.4f}')\n    lines.append(f'  - Reputation score: {ctx.reputation_score:.4f}')\n    lines.append('')\n    lines.append('Selection weights (protocol parameters):')\n    for key in ('stake_weight', 'compute_weight', 'reputation_weight'):\n        lines.append(f'  - {key}: {ctx.selection_weights.get(key, 0.0):.4f}')\n    lines.append(f'  - Sum of weights: {total_weight:.4f}')\n    lines.append('')\n    lines.append('Normalized contribution to committee selection weight:')\n    lines.append(\n        f'  - Stake component: {ctx.components.stake_component:.6f} '\n        '(relative influence from economic stake)'\n    )\n    lines.append(\n        f'  - Compute component: {ctx.components.compute_component:.6f} '\n        '(relative influence from benchmarked compute quality)'\n    )\n    lines.append(\n        f'  - Reputation component: {ctx.components.reputation_component:.6f} '\n        '(relative influence from long-term reliability)'\n    )\n    base_raw = (\n        ctx.components.stake_component\n        + ctx.components.compute_component\n        + ctx.components.reputation_component\n    )\n    lines.append(\n        '  - Total raw selection weight: '\n        f'{base_raw:.6f}'\n    )\n    lines.append('')\n    lines.append(\n        'Estimated probability of being chosen for a committee slot in a typical epoch: '\n        f'{ctx.probability * 100:.4f}%'\n    )\n    lines.append('')\n    lines.append('Sensitivity analysis (holding network conditions constant):')\n\n    # Example: +20% stake\n    increased_stake = ctx.stake_tokens * 1.2\n\n    # We approximate by scaling the stake component linearly with stake.\n    if ctx.stake_tokens > 0:\n        stake_scale = increased_stake / ctx.stake_tokens\n        stake_component_up = ctx.components.stake_component * stake_scale\n    else:\n        stake_component_up = ctx.components.stake_component\n\n    raw_up_stake = stake_component_up + ctx.components.compute_component + ctx.components.reputation_component\n\n    # Example: +20% compute score\n    compute_component_up = ctx.components.compute_component * 1.2\n    raw_up_compute = ctx.components.stake_component + compute_component_up + ctx.components.reputation_component\n\n    # Example: +20% reputation\n    reputation_component_up = ctx.components.reputation_component * 1.2\n    raw_up_reputation = ctx.components.stake_component + ctx.components.compute_component + reputation_component_up\n\n    # We assume the probability is roughly proportional to raw weight.\n    if base_raw > 0:\n        prob_up_stake = ctx.probability * (raw_up_stake / base_raw)\n        prob_up_compute = ctx.probability * (raw_up_compute / base_raw)\n        prob_up_reputation = ctx.probability * (raw_up_reputation / base_raw)\n    else:\n        prob_up_stake = prob_up_compute = prob_up_reputation = ctx.probability\n\n    lines.append(\n        f'  - If stake increased by 20% (to {int(increased_stake)} REP), '\n        f'estimated probability would rise to ~{prob_up_stake * 100:.4f}%.'\n    )\n    lines.append(\n        '  - If composite compute score increased by 20%, '\n        f'estimated probability would rise to ~{prob_up_compute * 100:.4f}%.'\n    )\n    lines.append(\n        '  - If reputation score increased by 20%, '\n        f'estimated probability would rise to ~{prob_up_reputation * 100:.4f}%.'\n    )\n\n    return '\\n'.join(lines)\n\n\nclass ProbabilityExplanationResponse(BaseModel):\n    explanation: str\n\n\n@router.post('/api/validators/committee_probability_explanation', response_model=ProbabilityExplanationResponse)\nasync def generate_probability_explanation_endpoint(ctx: ProbabilityContext) -> ProbabilityExplanationResponse:\n    '''BFF endpoint that turns structured probability context into a human-readable explanation.'''\n    if ctx.probability < 0 or ctx.probability > 1:\n        raise HTTPException(status_code=400, detail='Probability must be in [0, 1].')\n\n    explanation = generate_probability_explanation(ctx)\n    return ProbabilityExplanationResponse(explanation=explanation)\n",
            "usage": "After computing a validator\u2019s selection weight and probability in step 5, construct a `ProbabilityContext` object (or JSON body) with the validator\u2019s moniker, stake, reputation, composite compute score, per-factor weights, probability, and components, then POST it to `/api/validators/committee_probability_explanation` to receive a human-readable explanation string."
        }
    ]
}