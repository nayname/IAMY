{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Connects to Keplr, ensures the Neutron chain is enabled, and returns the user\u2019s Bech32 address that owns the unclaimed rewards.",
            "code": "export const getWalletAddress = async () => {\n  const chainId = 'neutron-1';\n\n  // Make sure Keplr is injected\n  if (!window.keplr) {\n    throw new Error('Keplr wallet is not installed.');\n  }\n\n  // Request connection to Neutron\n  await window.keplr.enable(chainId);\n\n  // Get the offline signer & account list\n  const offlineSigner = window.getOfflineSigner(chainId);\n  const accounts = await offlineSigner.getAccounts();\n\n  if (!accounts || accounts.length === 0) {\n    throw new Error('No account found in the signer.');\n  }\n\n  // Return the first account\u2019s address\n  return accounts[0].address;\n};",
            "usage": "const address = await getWalletAddress();"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Queries the Vesting contract for `claimable_rewards(address)` and returns the raw integer amount (micro-denom).",
            "code": "import os\nimport json\nimport base64\nimport httpx\nfrom fastapi import APIRouter, HTTPException\n\nrouter = APIRouter()\n\nNEUTRON_LCD = os.getenv(\"NEUTRON_LCD\", \"https://lcd-kralum.neutron.org\")\nVESTING_CONTRACT = \"neutron1dz57hjkdytdshl2uyde0nqvkwdww0ckx7qfe05raz4df6m3khfyqfnj0nr\"\n\n@router.get(\"/claimable/{address}\")\nasync def query_vesting_contract(address: str):\n    \"\"\"Return the claimable rewards for a given address.\"\"\"\n    try:\n        query_msg = {\"claimable_rewards\": {\"address\": address}}\n        query_b64 = base64.b64encode(json.dumps(query_msg).encode()).decode()\n        url = f\"{NEUTRON_LCD}/cosmwasm/wasm/v1/contract/{VESTING_CONTRACT}/smart/{query_b64}\"\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            resp.raise_for_status()\n        data = resp.json()\n        # Expected format: {\"data\": {\"amount\": \"123456\"}}\n        amount = int(data.get(\"data\", {}).get(\"amount\", 0))\n        return {\"claimable\": amount}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "const {{ claimable }} = await fetch(`/api/claimable/${address}`).then(r => r.json());"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Validates that the claimable amount is non-zero; otherwise aborts with HTTP 400.",
            "code": "from fastapi import HTTPException\n\nasync def validate_claimable_amount(amount: int):\n    \"\"\"Raise an HTTP 400 if amount == 0.\"\"\"\n    if int(amount) == 0:\n        raise HTTPException(status_code=400, detail=\"No claimable rewards for this address.\")\n    return {\"ok\": True}",
            "usage": "await validate_claimable_amount(claimable);"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Constructs the ExecuteMsg `{ start_standard_vesting: {} }` to be sent to the Vesting contract and returns it as JSON.",
            "code": "def construct_execute_msg():\n    \"\"\"Return the execute message required to start vesting.\"\"\"\n    execute_msg = {\"start_standard_vesting\": {}}\n    return execute_msg",
            "usage": "const executeMsg = await fetch('/api/construct_msg').then(r => r.json());"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Signs and broadcasts the execute message using a server-managed key (MNEMONIC kept in an environment variable) with cosmpy. Returns the transaction hash.",
            "code": "import os\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.tx import MsgExecuteContract\nfrom cosmpy.aerial.wallet import PrivateKey\nfrom fastapi import HTTPException\n\nNETWORK = NetworkConfig(\n    chain_id=\"neutron-1\",\n    url=os.getenv(\"NEUTRON_RPC\", \"https://rpc-kralum.neutron.org\"),\n    fee_minimum_gas_price=0.025,\n    fee_denom=\"untrn\",\n)\n\nasync def sign_and_broadcast_tx(sender_addr: str, execute_msg: dict):\n    \"\"\"Sign the MsgExecuteContract and broadcast it to the Neutron network.\"\"\"\n    mnemonic = os.getenv(\"MNEMONIC\")\n    if not mnemonic:\n        raise HTTPException(status_code=500, detail=\"Backend signing key is not configured.\")\n\n    try:\n        # Create wallet & client\n        pk = PrivateKey.from_mnemonic(mnemonic)\n        if sender_addr != pk.address():\n            raise HTTPException(status_code=400, detail=\"Configured key does not match sender address.\")\n\n        client = LedgerClient(NETWORK, wallet=pk)\n\n        # Build the execute msg\n        msg = MsgExecuteContract(\n            sender=sender_addr,\n            contract_address=VESTING_CONTRACT,\n            msg=execute_msg,\n        )\n\n        # Estimate gas & broadcast\n        tx = client.tx.build_and_sign_tx(msgs=[msg])\n        tx_response = client.tx.broadcast_tx(tx)\n\n        if tx_response.is_err():\n            raise HTTPException(status_code=500, detail=f\"Broadcast failed: {tx_response.raw_log}\")\n\n        return {\"tx_hash\": tx_response.tx_hash}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "const { tx_hash } = await fetch('/api/sign_and_broadcast', {method: 'POST', body: JSON.stringify({sender: address, msg: executeMsg})}).then(r => r.json());"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "After a successful broadcast, this endpoint queries the Vesting contract for the new `vesting_schedule(address)` to confirm start & end times.",
            "code": "import base64\nimport json\nimport httpx\nfrom fastapi import HTTPException\n\nasync def query_vesting_schedule(address: str):\n    \"\"\"Return the latest vesting schedule for the provided address.\"\"\"\n    query = {\"vesting_schedule\": {\"address\": address}}\n    query_b64 = base64.b64encode(json.dumps(query).encode()).decode()\n    url = f\"{NEUTRON_LCD}/cosmwasm/wasm/v1/contract/{VESTING_CONTRACT}/smart/{query_b64}\"\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            resp.raise_for_status()\n        return resp.json().get(\"data\", {})\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "const schedule = await fetch(`/api/vesting_schedule/${address}`).then(r => r.json());"
        }
    ]
}