{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a backend helper that fetches a transaction by hash from the Juno LCD and returns the tx_response object, including logs and events.",
            "code": "import httpx\nfrom typing import Any, Dict\n\nLCD_BASE_URL = \"https://lcd-archive.junonetwork.io\"\n\n\nclass LcdRequestError(Exception):\n    # Raised when the LCD returns a non-success response or cannot be reached.\n    pass\n\n\nasync def lcd_get_tx_by_hash(tx_hash: str) -> Dict[str, Any]:\n    # Fetch transaction details for a given txhash from the Juno LCD.\n    # This calls: GET /cosmos/tx/v1beta1/txs/{hash} and returns the tx_response object.\n    if not tx_hash:\n        raise ValueError(\"tx_hash is required\")\n\n    url = f\"{LCD_BASE_URL}/cosmos/tx/v1beta1/txs/{tx_hash}\"\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            response = await client.get(url)\n        except httpx.RequestError as exc:\n            raise LcdRequestError(f\"Error while requesting {url}: {exc}\") from exc\n\n    if response.status_code != 200:\n        # Propagate a clear error that callers can handle.\n        raise LcdRequestError(\n            f\"LCD returned non-200 status {response.status_code}: {response.text}\"\n        )\n\n    data = response.json()\n    tx_response = data.get(\"tx_response\")\n    if tx_response is None:\n        raise LcdRequestError(\"LCD response missing 'tx_response' field\")\n\n    return tx_response\n",
            "usage": "tx_response = await lcd_get_tx_by_hash(\"<instantiate_txhash>\")"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 provides a parser that scans tx_response.logs[].events[].attributes[] to find the CosmWasm instantiate event and extract the instantiated contract address.",
            "code": "from typing import Any, Dict, List\n\n\nclass ContractAddressNotFoundError(Exception):\n    # Raised when a CosmWasm contract address cannot be found in tx logs.\n    pass\n\n\ndef parse_tx_logs_for_contract_address(tx_response: Dict[str, Any]) -> str:\n    # Inspect tx_response.logs[].events[].attributes[] and try to extract the\n    # instantiated contract address.\n    #\n    # It looks for an event corresponding to a CosmWasm instantiate operation and\n    # reads an attribute with key \"_contract_address\" or \"contract_address\".\n    logs: List[Dict[str, Any]] = tx_response.get(\"logs\", [])\n    if not logs:\n        raise ContractAddressNotFoundError(\"CONTRACT_ADDRESS_NOT_FOUND_IN_TX_LOGS\")\n\n    target_keys = {\"_contract_address\", \"contract_address\"}\n    instantiate_event_types = {\"instantiate\", \"wasm\", \"instantiate_contract\"}\n\n    # First pass: look only at likely instantiate-related events.\n    for log in logs:\n        for event in log.get(\"events\", []):\n            if event.get(\"type\") in instantiate_event_types:\n                for attr in event.get(\"attributes\", []):\n                    key = attr.get(\"key\")\n                    if key in target_keys:\n                        value = attr.get(\"value\")\n                        if value:\n                            return value\n\n    # Second pass: fall back to scanning all events.\n    for log in logs:\n        for event in log.get(\"events\", []):\n            for attr in event.get(\"attributes\", []):\n                key = attr.get(\"key\")\n                if key in target_keys:\n                    value = attr.get(\"value\")\n                    if value:\n                        return value\n\n    # If we reach this point, nothing was found.\n    raise ContractAddressNotFoundError(\"CONTRACT_ADDRESS_NOT_FOUND_IN_TX_LOGS\")\n",
            "usage": "contract_address = parse_tx_logs_for_contract_address(tx_response)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 validates that the extracted address is a real CosmWasm contract on-chain by calling the Juno LCD contract endpoint and checking contract_info fields.",
            "code": "import httpx\nfrom typing import Any, Dict\n\n\nclass ContractNotFoundOnChainError(Exception):\n    # Raised when the given address is not a valid CosmWasm contract on-chain.\n    pass\n\n\nasync def validate_contract_via_lcd(contract_address: str) -> Dict[str, Any]:\n    # Verify that the given address is a valid CosmWasm contract by calling:\n    #   GET /cosmwasm/wasm/v1/contract/{contract_address}\n    #\n    # Returns the full LCD response (including \"address\" and \"contract_info\")\n    # when the contract exists, otherwise raises ContractNotFoundOnChainError.\n    if not contract_address:\n        raise ValueError(\"contract_address is required\")\n\n    url = f\"{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}\"\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            response = await client.get(url)\n        except httpx.RequestError as exc:\n            # Reuse the LCD error type defined earlier.\n            raise LcdRequestError(f\"Error while requesting {url}: {exc}\") from exc\n\n    if response.status_code != 200:\n        # Treat any non-200 as \"not found / not valid\" for this use case.\n        raise ContractNotFoundOnChainError(\"CONTRACT_NOT_FOUND_ON_CHAIN\")\n\n    data = response.json()\n    contract_info = data.get(\"contract_info\")\n    if not isinstance(contract_info, dict):\n        raise ContractNotFoundOnChainError(\"CONTRACT_NOT_FOUND_ON_CHAIN\")\n\n    # Basic sanity check on expected fields.\n    if not contract_info.get(\"code_id\") or not contract_info.get(\"creator\"):\n        raise ContractNotFoundOnChainError(\"CONTRACT_NOT_FOUND_ON_CHAIN\")\n\n    return data\n",
            "usage": "contract_data = await validate_contract_via_lcd(contract_address)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 composes the previous helpers into a single resolver that either returns the validated contract address and info or a structured error code such as CONTRACT_ADDRESS_NOT_FOUND_IN_TX_LOGS or CONTRACT_NOT_FOUND_ON_CHAIN.",
            "code": "from typing import Any, Dict, Optional\n\n\nERROR_MESSAGES = {\n    \"CONTRACT_ADDRESS_NOT_FOUND_IN_TX_LOGS\": \"No CosmWasm contract address was found in the transaction logs.\",\n    \"CONTRACT_NOT_FOUND_ON_CHAIN\": \"The extracted address is not a valid CosmWasm contract on-chain.\",\n    \"LCD_REQUEST_FAILED\": \"Failed to query the Juno LCD.\",\n    \"UNEXPECTED_ERROR\": \"An unexpected error occurred while resolving the contract address.\",\n}\n\n\ndef _build_error_payload(code: str, details: Optional[str] = None) -> Dict[str, Any]:\n    # Helper to standardize backend error responses.\n    return {\n        \"ok\": False,\n        \"error\": {\n            \"code\": code,\n            \"message\": ERROR_MESSAGES.get(code, \"Unexpected error.\"),\n            \"details\": details,\n        },\n    }\n\n\nasync def resolve_contract_from_txhash(tx_hash: str) -> Dict[str, Any]:\n    # High-level helper that:\n    #   1. Fetches the tx_response by hash.\n    #   2. Parses logs to extract the instantiated contract address.\n    #   3. Validates that the address is a CosmWasm contract on-chain.\n    #\n    # On success, returns:\n    #   { \"ok\": True, \"contract_address\": \"...\", \"contract_info\": { ... } }\n    #\n    # On failure, returns a structured error object instead of raising.\n    try:\n        tx_response = await lcd_get_tx_by_hash(tx_hash)\n        contract_address = parse_tx_logs_for_contract_address(tx_response)\n        contract_data = await validate_contract_via_lcd(contract_address)\n\n        return {\n            \"ok\": True,\n            \"contract_address\": contract_address,\n            \"contract_info\": contract_data.get(\"contract_info\"),\n        }\n\n    except ContractAddressNotFoundError as exc:\n        return _build_error_payload(\n            \"CONTRACT_ADDRESS_NOT_FOUND_IN_TX_LOGS\",\n            details=str(exc),\n        )\n    except ContractNotFoundOnChainError as exc:\n        return _build_error_payload(\n            \"CONTRACT_NOT_FOUND_ON_CHAIN\",\n            details=str(exc),\n        )\n    except LcdRequestError as exc:\n        return _build_error_payload(\n            \"LCD_REQUEST_FAILED\",\n            details=str(exc),\n        )\n    except Exception as exc:\n        # Catch-all to prevent leaking internal errors to clients.\n        return _build_error_payload(\n            \"UNEXPECTED_ERROR\",\n            details=str(exc),\n        )\n",
            "usage": "result = await resolve_contract_from_txhash(\"<instantiate_txhash>\")\nif result[\"ok\"]:\n    print(\"Contract address:\", result[\"contract_address\"])\nelse:\n    print(\"Error:\", result[\"error\"])"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 exposes a FastAPI backend endpoint /api/contract-address-from-txhash that wraps the resolver so frontends or scripts can submit a txhash and receive the validated contract address as JSON.",
            "code": "from fastapi import FastAPI, Query\nfrom fastapi.responses import JSONResponse\nimport uvicorn\n\n# Import the high-level resolver from the module where steps 1-4 are defined.\nfrom contract_address_service import resolve_contract_from_txhash\n\napp = FastAPI()\n\n\n@app.get(\"/api/contract-address-from-txhash\")\nasync def contract_address_from_txhash_endpoint(\n    txhash: str = Query(\n        ...,\n        alias=\"hash\",\n        min_length=1,\n        description=\"Instantiate transaction hash (txhash) whose contract address should be resolved.\",\n    ),\n):\n    # Wrap the resolver and expose its result as a JSON HTTP response.\n    result = await resolve_contract_from_txhash(txhash)\n\n    if not result.get(\"ok\"):\n        error = (result.get(\"error\") or {})\n        code = error.get(\"code\")\n\n        # Map error codes to HTTP status codes.\n        status_code = 400\n        if code in (\"LCD_REQUEST_FAILED\", \"UNEXPECTED_ERROR\"):\n            status_code = 502\n\n        return JSONResponse(status_code=status_code, content=result)\n\n    return JSONResponse(status_code=200, content=result)\n\n\nif __name__ == \"__main__\":\n    # For local development only. In production, run with a proper ASGI server, e.g.:\n    #   uvicorn main:app --host 0.0.0.0 --port 8000\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n",
            "usage": "1) Put the helpers from steps 1-4 into contract_address_service.py.\n2) Save this code as main.py.\n3) Install dependencies: pip install fastapi uvicorn[standard] httpx.\n4) Run the API server: uvicorn main:app --reload.\n5) From a frontend or script, call: GET http://localhost:8000/api/contract-address-from-txhash?hash=<instantiate_txhash> to receive the validated contract address JSON."
        }
    ]
}