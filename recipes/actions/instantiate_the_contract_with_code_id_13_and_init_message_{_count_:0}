{
    "label": "instantiate",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Creates and validates the init message `{ \"count\": 0 }` that will be sent to the backend for contract instantiation.",
            "code": "/* counterInitMsg.js\n * Utility for building a valid init message for the counter contract.\n * No external libraries required\u2014plain JavaScript only.\n */\nexport const createCounterInitMsg = (count = 0) => {\n  // Basic validation ------------------------------------------------------\n  if (!Number.isInteger(count) || count < 0) {\n    throw new Error(\"`count` must be a non-negative integer.\");\n  }\n\n  // Build message ---------------------------------------------------------\n  const msg = { count };\n  return JSON.stringify(msg); // Always send backend a JSON string\n};",
            "usage": "const initMsg = createCounterInitMsg(0);\n// \u2192 '{\"count\":0}'"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "FastAPI endpoint that takes the prepared init message and broadcasts a `MsgInstantiateContract` transaction using cosmpy.",
            "code": "########################  instantiate.py  ########################\n\"\"\"Backend-for-Frontend (BFF) service that instantiates a CosmWasm contract.\n\nExposes POST /instantiate which expects:\n  {\n    \"code_id\": 13,\n    \"init_msg\": \"{\\\"count\\\":0}\",\n    \"label\": \"counter-v1\",\n    \"admin\": \"juno1...\"        // optional, may be null/empty\n  }\nReturns JSON { \"tx_hash\": \"...\" }\n\"\"\"\nimport os\nimport json\nfrom typing import Optional\n\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel, Field, validator\n\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.protos.cosmwasm.wasm.v1.tx_pb2 import MsgInstantiateContract\nfrom cosmpy.aerial.tx import Transaction\n\n###########################################################################\n# Network / key setup \u2014\u2014\u2014 use ENV so secrets never reach the frontend      #\n###########################################################################\n\nRPC_ENDPOINT = os.getenv(\"JUNO_RPC\", \"https://rpc.juno.omniflix.co:443\")\nCHAIN_ID = os.getenv(\"JUNO_CHAIN\", \"juno-1\")\nFEE_DENOM = os.getenv(\"FEE_DENOM\", \"ujuno\")\nGAS_PRICE = float(os.getenv(\"GAS_PRICE\", \"0.075\"))  # ujuno per gas unit\n\n# Load the mnemonic from an environment variable (\u26a0\ufe0f NEVER check secrets in)\nMNEMONIC = os.getenv(\"BACKEND_MNEMONIC\")\nif MNEMONIC is None:\n    raise RuntimeError(\"Missing BACKEND_MNEMONIC environment variable\")\n\nwallet = LocalWallet.create_from_mnemonic(MNEMONIC)\n\ncfg = NetworkConfig(\n    chain_id=CHAIN_ID,\n    url=RPC_ENDPOINT,\n    fee_minimum_gas_price=f\"{GAS_PRICE}{FEE_DENOM}\",\n    fee_denomination=FEE_DENOM,\n)\nclient = LedgerClient(cfg)\n\n###########################################################################\n# FastAPI Schemas                                                          #\n###########################################################################\n\nclass InstantiatePayload(BaseModel):\n    code_id: int = Field(..., example=13)\n    init_msg: str = Field(..., description=\"JSON string of the instantiate message\")\n    label: str = Field(..., example=\"counter-v1\")\n    admin: Optional[str] = Field(None, description=\"(optional) admin address\")\n\n    @validator(\"init_msg\")\n    def init_msg_must_be_valid_json(cls, v):\n        try:\n            json.loads(v)\n        except json.JSONDecodeError as e:\n            raise ValueError(f\"init_msg is not valid JSON: {e}\") from e\n        return v\n\napp = FastAPI()\n\n###########################################################################\n# Helper: Build & broadcast instantiate tx                                 #\n###########################################################################\n\ndef _broadcast_instantiate(payload: InstantiatePayload) -> str:\n    \"\"\"Builds, signs, and broadcasts a MsgInstantiateContract. Returns TX hash.\"\"\"\n\n    # Convert JSON string \u2192 bytes for protobuf msg field\n    init_bytes = json.dumps(json.loads(payload.init_msg)).encode()\n\n    # Build proto message --------------------------------------------------\n    msg = MsgInstantiateContract(\n        sender=wallet.address(),\n        admin=payload.admin or \"\",\n        code_id=payload.code_id,\n        label=payload.label,\n        msg=init_bytes,\n        funds=[],  # no native tokens sent along\n    )\n\n    # Create TX wrapper ----------------------------------------------------\n    tx = Transaction()\n    tx.add_message(msg)\n    tx.seal(wallet)  # add signer info & account sequence\n\n    # Estimate gas automatically (client-side simulation)\n    gas_estimate = client.estimate_gas(tx)\n    tx.set_gas(gas_estimate * 130 // 100)  # 30% safety margin\n\n    # Set fee based on gas x gas_price\n    fee_amount = int(tx.gas_limit * GAS_PRICE)\n    tx.set_fee([(fee_amount, FEE_DENOM)])\n\n    # Sign & broadcast -----------------------------------------------------\n    tx.sign(wallet)\n    resp = client.broadcast(tx)\n\n    if resp.tx_response.code != 0:\n        raise RuntimeError(f\"Tx failed: {resp.tx_response.raw_log}\")\n\n    return resp.tx_response.txhash\n\n###########################################################################\n# Route                                                                    #\n###########################################################################\n\n@app.post(\"/instantiate\")\nasync def instantiate_contract(payload: InstantiatePayload):\n    try:\n        tx_hash = _broadcast_instantiate(payload)\n        return {\"tx_hash\": tx_hash}\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))",
            "usage": "// Frontend \u2192\nconst res = await fetch('/api/instantiate', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    code_id: 13,\n    init_msg: initMsg,     // from Step-1\n    label: 'counter-v1',\n    admin: myAdminAddress  // or undefined\n  })\n});\nconst { tx_hash } = await res.json();"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Helper endpoint that waits for the previous transaction to be committed and extracts the newly deployed contract address from the event logs.",
            "code": "########################  tx_status.py  ########################\n\"\"\"Wait for a TX to commit and return the contract address (if any).\"\"\"\nimport asyncio\nimport json\nfrom typing import Optional\n\nfrom fastapi import APIRouter, HTTPException\n\nrouter = APIRouter()\n\n# Re-use `client` from instantiate.py via import (singleton pattern)\nfrom instantiate import client  # noqa: E402\n\n# Constants --------------------------------------------------------------\nPOLL_INTERVAL = 2.0   # seconds\nMAX_BLOCKS = 15       # safety limit (~1 min on Juno)\n\nasync def _extract_contract_address(tx_hash: str) -> Optional[str]:\n    \"\"\"Poll the node until TX found in a block, then parse logs for _contract_address.\"\"\"\n    for _ in range(MAX_BLOCKS):\n        tx = client.tx(tx_hash)\n        if tx is not None and tx.tx_response and tx.tx_response.height > 0:\n            # TX was found \u2014 parse logs\n            try:\n                logs = json.loads(tx.tx_response.raw_log)\n            except json.JSONDecodeError:\n                raise RuntimeError(\"Cannot decode tx logs\")\n\n            for event in logs[0].get(\"events\", []):\n                if event.get(\"type\") in (\"instantiate\", \"instantiate_contract\", \"wasm\"):  # chain-specific variants\n                    for attr in event.get(\"attributes\", []):\n                        if attr.get(\"key\") in (\"_contract_address\", \"contract_address\"):\n                            return attr.get(\"value\")\n            return None  # tx succeeded but no address (unexpected)\n        await asyncio.sleep(POLL_INTERVAL)\n    raise RuntimeError(\"Timed out waiting for transaction to be included in a block\")\n\n@router.get(\"/tx_status/{tx_hash}\")\nasync def tx_status(tx_hash: str):\n    try:\n        contract_addr = await _extract_contract_address(tx_hash)\n        return {\"contract_address\": contract_addr}\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))",
            "usage": "// Frontend \u2192 after receiving tx_hash\nconst poll = async (hash) => {\n  const res = await fetch(`/api/tx_status/${hash}`);\n  if (!res.ok) {\n    throw new Error(await res.text());\n  }\n  const { contract_address } = await res.json();\n  return contract_address; // \u21b3 e.g., 'juno1xyz...'\n};"
        }
    ]
}