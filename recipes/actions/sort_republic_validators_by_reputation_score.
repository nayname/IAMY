{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Resolve the human-friendly label 'republic' into a concrete chain configuration (REST/RPC/indexer URLs) for use by subsequent backend calls.",
            "code": "import os\nfrom typing import Dict\n\n\nclass NetworkNotFoundError(Exception):\n    # Raised when a requested network label cannot be resolved to a known chain configuration.\n    pass\n\n\ndef resolve_network_from_label(label: str) -> Dict[str, str]:\n    # Map a human-readable network label (for example, 'republic') to a concrete chain configuration.\n    if not label:\n        raise ValueError('Network label must be a non-empty string.')\n\n    normalized = label.strip().lower()\n\n    # Base configuration for known Republic networks. Replace the URLs with real endpoints.\n    base_configs = {\n        'republic': {\n            'chain_id': 'republic-1',\n            'rest_url': os.getenv('REPUBLIC_REST_URL', 'https://api.republic.network'),\n            'rpc_url': os.getenv('REPUBLIC_RPC_URL', 'https://rpc.republic.network'),\n            # Optional off-chain reputation/indexer service.\n            'reputation_api_url': os.getenv('REPUBLIC_REPUTATION_API_URL', 'https://indexer.republic.network'),\n        },\n        'republic-testnet': {\n            'chain_id': 'republic-testnet-1',\n            'rest_url': os.getenv('REPUBLIC_TESTNET_REST_URL', 'https://api.testnet.republic.network'),\n            'rpc_url': os.getenv('REPUBLIC_TESTNET_RPC_URL', 'https://rpc.testnet.republic.network'),\n            'reputation_api_url': os.getenv('REPUBLIC_TESTNET_REPUTATION_API_URL', 'https://indexer.testnet.republic.network'),\n        },\n    }\n\n    config = base_configs.get(normalized)\n    if not config:\n        raise NetworkNotFoundError(f'Unknown Republic network label: {label}')\n\n    # Normalize URLs to avoid double slashes when building request paths.\n    config = {**config}\n    for key in ('rest_url', 'rpc_url', 'reputation_api_url'):\n        if key in config and isinstance(config[key], str):\n            config[key] = config[key].rstrip('/')\n\n    return config\n",
            "usage": "config = resolve_network_from_label('republic')  # Returns dict with chain_id, rest_url, rpc_url, reputation_api_url"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Query the Republic staking/consensus module over REST to fetch the full set of active validators, handling pagination internally.",
            "code": "import httpx\nfrom typing import Any, Dict, List, Optional\n\n\nasync def query_republic_validators(network_label: str, status: str = 'BOND_STATUS_BONDED', timeout: float = 10.0) -> List[Dict[str, Any]]:\n    # Resolve chain configuration for the requested network label.\n    chain_cfg = resolve_network_from_label(network_label)\n    rest_url = chain_cfg['rest_url']\n    base_url = rest_url.rstrip('/')\n\n    validators: List[Dict[str, Any]] = []\n    next_key: Optional[str] = None\n\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        while True:\n            params = {\n                'status': status,\n                'pagination.limit': '100',\n            }\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                resp = await client.get(f'{base_url}/cosmos/staking/v1beta1/validators', params=params)\n                resp.raise_for_status()\n            except httpx.RequestError as exc:\n                # Network problem (DNS failure, refused connection, etc.).\n                raise RuntimeError(f'Failed to reach Republic staking endpoint: {exc}') from exc\n            except httpx.HTTPStatusError as exc:\n                # Remote server returned a 4xx/5xx error.\n                body = exc.response.text\n                raise RuntimeError(f'Republic staking endpoint returned HTTP {exc.response.status_code}: {body}') from exc\n\n            data = resp.json()\n            page_validators = data.get('validators', [])\n            if not isinstance(page_validators, list):\n                raise RuntimeError('Unexpected staking response shape: validators field is not a list.')\n\n            validators.extend(page_validators)\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return validators\n",
            "usage": "validators = await query_republic_validators('republic')  # Fetch all active (bonded) validators from Republic"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "For each validator, call the Republic reputation service (on-chain module or off-chain indexer) and merge the latest reputation score into the validator record.",
            "code": "import asyncio\nfrom typing import Any, Dict, List\n\nimport httpx\n\n\ndef _chunked(seq, size: int):\n    # Yield successive chunks from a sequence.\n    for i in range(0, len(seq), size):\n        yield seq[i:i + size]\n\n\nasync def attach_republic_reputation_scores(validators: List[Dict[str, Any]], network_label: str, timeout: float = 10.0) -> List[Dict[str, Any]]:\n    # Enrich each validator record with its current reputation score from the Republic reputation module or index.\n\n    if not validators:\n        return validators\n\n    chain_cfg = resolve_network_from_label(network_label)\n    base_url = chain_cfg.get('reputation_api_url')\n    if not base_url:\n        raise RuntimeError('No reputation_api_url configured for this network.')\n\n    # Collect all operator addresses we need scores for.\n    operator_addresses = []\n    for v in validators:\n        op_addr = v.get('operator_address') or v.get('operatorAddress')\n        if op_addr:\n            operator_addresses.append(op_addr)\n\n    if not operator_addresses:\n        # Nothing to enrich; return original list.\n        return validators\n\n    reputation_by_operator: Dict[str, Any] = {}\n\n    async with httpx.AsyncClient(timeout=timeout) as client:\n        # Query the reputation API in batches to avoid overly large query strings.\n        tasks = []\n        for chunk in _chunked(operator_addresses, 50):\n            params = {'operator_addresses': ','.join(chunk)}\n            tasks.append(client.get(f'{base_url}/v1/reputation/validators', params=params))\n\n        responses = await asyncio.gather(*tasks, return_exceptions=True)\n\n        for resp in responses:\n            if isinstance(resp, Exception):\n                # Any lower-level error (timeout, connection reset, etc.).\n                raise RuntimeError(f'Reputation API request failed: {resp}') from resp\n\n            try:\n                resp.raise_for_status()\n            except httpx.HTTPStatusError as exc:\n                body = exc.response.text\n                raise RuntimeError(f'Reputation API returned HTTP {exc.response.status_code}: {body}') from exc\n\n            data = resp.json()\n            rep_list = data.get('validators', [])\n            if not isinstance(rep_list, list):\n                raise RuntimeError('Unexpected reputation API response shape: validators field is not a list.')\n\n            for item in rep_list:\n                op = item.get('operator_address')\n                if not op:\n                    continue\n\n                score_raw = item.get('reputation_score')\n                try:\n                    score = float(score_raw) if score_raw is not None else None\n                except (TypeError, ValueError):\n                    # If the score cannot be parsed, treat it as None.\n                    score = None\n\n                reputation_by_operator[op] = score\n\n    # Merge the reputation scores back into the validator dicts.\n    for v in validators:\n        op_addr = v.get('operator_address') or v.get('operatorAddress')\n        if not op_addr:\n            v['reputation_score'] = None\n            continue\n\n        v['reputation_score'] = reputation_by_operator.get(op_addr)\n\n    return validators\n",
            "usage": "validators_with_scores = await attach_republic_reputation_scores(validators, 'republic')  # Adds a reputation_score field to each validator"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Sort the validator list by descending reputation score, using operator address as a deterministic tie-breaker.",
            "code": "from typing import Any, Dict, List\n\n\ndef sort_validators_by_reputation(validators: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    # Sort validators by descending reputation score, breaking ties deterministically\n    # by operator address in ascending lexicographic order.\n\n    def _score(v: Dict[str, Any]) -> float:\n        raw = v.get('reputation_score')\n        try:\n            return float(raw)\n        except (TypeError, ValueError):\n            return 0.0\n\n    def _operator_address(v: Dict[str, Any]) -> str:\n        return v.get('operator_address') or v.get('operatorAddress') or ''\n\n    # Python sorts ascending by default, so we negate the score to get descending order.\n    return sorted(validators, key=lambda v: (-_score(v), _operator_address(v)))\n",
            "usage": "sorted_validators = sort_validators_by_reputation(validators_with_scores)  # Highest reputation first, deterministic ordering"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Format the sorted validator set into an API-friendly structure exposing operator address, moniker, and reputation score plus optional metadata for UI consumption.",
            "code": "from datetime import datetime, timezone\nfrom typing import Any, Dict, List, Optional\n\n\ndef format_validator_list_response(validators: List[Dict[str, Any]], limit: Optional[int] = None) -> Dict[str, Any]:\n    # Format the sorted validator list for API/UI consumption.\n\n    if limit is not None and limit >= 0:\n        validators = validators[:limit]\n\n    items: List[Dict[str, Any]] = []\n    for index, v in enumerate(validators, start=1):\n        description = v.get('description') or {}\n        moniker = description.get('moniker') or v.get('moniker') or v.get('name')\n\n        op_addr = v.get('operator_address') or v.get('operatorAddress')\n        score_raw = v.get('reputation_score')\n        try:\n            reputation_score = float(score_raw) if score_raw is not None else None\n        except (TypeError, ValueError):\n            reputation_score = None\n\n        items.append({\n            'rank': index,\n            'operator_address': op_addr,\n            'moniker': moniker,\n            'reputation_score': reputation_score,\n            # Optional: include additional fields commonly used in UIs.\n            'tokens': v.get('tokens'),\n            'delegator_shares': v.get('delegator_shares'),\n            'jailed': v.get('jailed'),\n            'status': v.get('status'),\n        })\n\n    response: Dict[str, Any] = {\n        'validators': items,\n        'total': len(items),\n        'generated_at': datetime.now(timezone.utc).isoformat(),\n    }\n\n    return response\n",
            "usage": "response_payload = format_validator_list_response(sorted_validators)\n# In a FastAPI route, you might `return JSONResponse(content=response_payload)`."
        }
    ]
}