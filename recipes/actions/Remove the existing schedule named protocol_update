{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Queries the DAO contract to discover which address holds Main-DAO authority. This address is required to delete an existing on-chain schedule.",
            "code": "from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.exceptions import CosmPyException\n\n\ndef get_dao_authority_address(rpc_endpoint: str, chain_id: str, dao_contract: str) -> str:\n    \"\"\"Return the address that has Main-DAO authority.\n\n    Args:\n        rpc_endpoint (str): Full RPC URL, e.g. \"https://rpc-kralum.neutron.org:443\".\n        chain_id (str): The on-chain ID, e.g. \"neutron-1\".\n        dao_contract (str): Bech-32 address of the DAO WASM contract.\n\n    Returns:\n        str: Address with delete-schedule permissions.\n    \"\"\"\n    try:\n        cfg = NetworkConfig(chain_id=chain_id, url=rpc_endpoint, fee_minimum_gas_price=0)\n        client = LedgerClient(cfg)\n\n        # The DAO contract is expected to support `{ \"authority\": {} }` query.\n        query_msg = {\"authority\": {}}\n        res = client.wasm.contract_query(dao_contract, query_msg)\n        authority_addr = res.get(\"authority\")\n        if not authority_addr:\n            raise ValueError(\"DAO contract did not return an authority address.\")\n        return authority_addr\n    except (CosmPyException, ValueError) as err:\n        raise RuntimeError(f\"Unable to fetch DAO authority address: {err}\")\n",
            "usage": "authority = get_dao_authority_address(\n    rpc_endpoint=\"https://rpc-kralum.neutron.org:443\",\n    chain_id=\"neutron-1\",\n    dao_contract=\"neutron1xyz...dao\"\n)"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Creates the Neutron-specific MsgDeleteSchedule object that instructs the chain to remove the schedule named \u201cprotocol_update\u201d.",
            "code": "import json\n\n\ndef build_msg_delete_schedule(authority: str, schedule_name: str = \"protocol_update\") -> dict:\n    \"\"\"Return an amino/JSON-encoded MsgDeleteSchedule body ready for packing.\n\n    Args:\n        authority (str): Address returned from Step 1.\n        schedule_name (str): Name of the schedule to delete.\n\n    Returns:\n        dict: Properly-typed MsgDeleteSchedule for inclusion in gov proposal.\n    \"\"\"\n    if not authority:\n        raise ValueError(\"Authority address is required to build MsgDeleteSchedule.\")\n\n    msg = {\n        \"@type\": \"/neutron.admin.MsgDeleteSchedule\",\n        \"authority_address\": authority,\n        \"name\": schedule_name\n    }\n    # quick validation\n    json.dumps(msg)  # will raise if non-serialisable\n    return msg\n",
            "usage": "delete_msg = build_msg_delete_schedule(authority)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Wraps the MsgDeleteSchedule in a standard Cosmos-SDK governance proposal that the DAO will vote on.",
            "code": "from datetime import datetime\nimport json\n\n\ndef package_into_gov_proposal(authority: str, delete_msg: dict, deposit_amount: str = \"10000000\", denom: str = \"untrn\") -> dict:\n    \"\"\"Embed the delete-schedule message into a MsgSubmitProposal.\n\n    Args:\n        authority (str): DAO authority address (will be listed as proposer).\n        delete_msg (dict): Message from Step 2.\n        deposit_amount (str): Minimum deposit in micro-denom (10 NTRN default).\n        denom (str): Denomination for deposit.\n\n    Returns:\n        dict: MsgSubmitProposal ready for signing.\n    \"\"\"\n    title = \"Remove obsolete cron schedule: protocol_update\"\n    description = (\n        \"This proposal deletes the `protocol_update` cron schedule, which is no longer \"\n        \"needed after the successful upgrade executed on \" + datetime.utcnow().strftime(\"%Y-%m-%d\") + \".\"\n    )\n\n    proposal_msg = {\n        \"@type\": \"/cosmos.gov.v1beta1.MsgSubmitProposal\",\n        \"proposer\": authority,\n        \"initial_deposit\": [{\"denom\": denom, \"amount\": deposit_amount}],\n        \"content\": {\n            \"@type\": \"/cosmos.gov.v1beta1.TextProposal\",\n            \"title\": title,\n            \"description\": description\n        },\n        \"messages\": [delete_msg]  # custom message list supported by Neutron-gov\n    }\n\n    # Ensure JSON validity\n    json.dumps(proposal_msg)\n    return proposal_msg\n",
            "usage": "gov_proposal_msg = package_into_gov_proposal(authority, delete_msg)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Signs the governance proposal with the DAO authority key and broadcasts it to the Neutron network.",
            "code": "from cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.exceptions import CosmPyException\n\n\ndef sign_and_broadcast_tx(\n    rpc_endpoint: str,\n    chain_id: str,\n    authority_mnemonic: str,\n    gov_proposal_msg: dict,\n    gas: int = 400000,\n    fee_denom: str = \"untrn\",\n    gas_price: float = 0.025,\n) -> str:\n    \"\"\"Sign and submit the governance proposal to chain.\n\n    Args:\n        rpc_endpoint (str): Full RPC endpoint.\n        chain_id (str): Chain identifier.\n        authority_mnemonic (str): 24-word mnemonic for the authority address.\n        gov_proposal_msg (dict): Message prepared in Step 3.\n        gas (int): Gas limit.\n        fee_denom (str): Fee denomination.\n        gas_price (float): Gas price in fee_denom.\n\n    Returns:\n        str: Transaction hash if broadcast is successful.\n    \"\"\"\n    try:\n        cfg = NetworkConfig(chain_id=chain_id, url=rpc_endpoint, fee_minimum_gas_price=gas_price)\n        client = LedgerClient(cfg)\n\n        # Build wallet\n        wallet = LocalWallet.create_from_mnemonic(authority_mnemonic)\n        acc_num, acc_seq = client.query_account_number_and_sequence(wallet.address())\n\n        # Build tx\n        tx = Transaction()\n        tx.add_message(gov_proposal_msg)\n        tx.with_gas(gas)\n        tx.with_chain_id(chain_id)\n        tx.with_fee(int(gas * gas_price), fee_denom)\n        tx.with_memo(\"Delete schedule governance proposal\")\n        tx.with_sequence(acc_seq)\n        tx.with_account_number(acc_num)\n        tx.sign(wallet)\n\n        # Broadcast\n        tx_response = client.broadcast_tx_block(tx)\n        if tx_response.is_err():\n            raise RuntimeError(f\"Tx failed: {tx_response.raw_log}\")\n        return tx_response.tx_hash\n    except (CosmPyException, RuntimeError) as err:\n        raise RuntimeError(f\"Unable to broadcast governance proposal: {err}\")\n",
            "usage": "tx_hash = sign_and_broadcast_tx(\n    rpc_endpoint=\"https://rpc-kralum.neutron.org:443\",\n    chain_id=\"neutron-1\",\n    authority_mnemonic=\"pilot ... stereo\",  # DAO authority mnemonic\n    gov_proposal_msg=gov_proposal_msg\n)\nprint(\"Governance proposal submitted in tx:\", tx_hash)"
        }
    ]
}