{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a backend helper that runs 'junod version --long' to verify that the junod CLI is installed and accessible.",
            "code": "import subprocess\nfrom typing import Dict\n\n\ndef check_junod_installed() -> Dict[str, str]:\n    '''\n    Ensure the 'junod' binary is installed by running 'junod version --long'.\n    Returns a dict with installation status and raw output.\n    Raises RuntimeError with a helpful message if the binary is missing or the command fails.\n    '''\n    try:\n        result = subprocess.run(\n            ['junod', 'version', '--long'],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found on the host system. '\n            'Install junod and make sure it is on the PATH before continuing.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod version --long failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    return {\n        'installed': True,\n        'output': result.stdout.strip(),\n    }\n",
            "usage": "Call check_junod_installed() during backend initialization; if it raises RuntimeError, surface the message to the user and abort further junod-dependent actions."
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 provides a backend helper that runs 'junod config node NODE_URL' to set the default RPC or LCD node for subsequent junod commands.",
            "code": "import subprocess\nfrom typing import Dict\n\n\ndef set_junod_node(node_url: str) -> Dict[str, str]:\n    '''\n    Configure junod to use the given node_url by running 'junod config node NODE_URL'.\n    node_url must include scheme and port, for example 'http://localhost:26657'.\n    '''\n    if not node_url or not isinstance(node_url, str):\n        raise ValueError('node_url must be a non-empty string')\n\n    try:\n        result = subprocess.run(\n            ['junod', 'config', 'node', node_url],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found. Run check_junod_installed() first and ensure junod is on the PATH.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod config node {node_url} failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    return {\n        'node_url': node_url,\n        'stdout': result.stdout.strip(),\n    }\n",
            "usage": "After confirming junod is installed, call set_junod_node('http://localhost:26657') or another RPC URL before running any other junod commands."
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 defines a backend helper that runs 'junod config chain-id uni-6' (or another chain-id if provided) so subsequent junod commands target the correct network.",
            "code": "import subprocess\nfrom typing import Dict\n\n\ndef set_junod_chain_id(chain_id: str = 'uni-6') -> Dict[str, str]:\n    '''\n    Configure junod to use the provided chain_id (defaults to 'uni-6').\n    This wraps 'junod config chain-id <chain_id>'.\n    '''\n    if not chain_id or not isinstance(chain_id, str):\n        raise ValueError('chain_id must be a non-empty string')\n\n    try:\n        result = subprocess.run(\n            ['junod', 'config', 'chain-id', chain_id],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found. Run check_junod_installed() first and ensure junod is on the PATH.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod config chain-id {chain_id} failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    return {\n        'chain_id': chain_id,\n        'stdout': result.stdout.strip(),\n    }\n",
            "usage": "Call set_junod_chain_id() with the default or explicitly set_junod_chain_id('uni-6') before executing junod transactions or queries."
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 adds an optional backend helper to run 'junod config output json', ensuring future junod command output is machine readable.",
            "code": "import subprocess\nfrom typing import Dict\n\n\ndef set_junod_output_json() -> Dict[str, str]:\n    '''\n    Optionally configure junod to output json by default using 'junod config output json'.\n    This is useful if you plan to parse junod output programmatically.\n    '''\n    try:\n        result = subprocess.run(\n            ['junod', 'config', 'output', 'json'],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found. Run check_junod_installed() first and ensure junod is on the PATH.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod config output json failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    return {\n        'output_format': 'json',\n        'stdout': result.stdout.strip(),\n    }\n",
            "usage": "Call set_junod_output_json() once after node and chain-id configuration if you want all subsequent junod output in json format."
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 provides a backend helper that runs 'junod status --node NODE_URL', parses the JSON, and verifies that the reachable node reports the expected chain-id (network) uni-6.",
            "code": "import subprocess\nimport json\nfrom typing import Any, Dict\n\n\ndef _extract_network_field(data: Any) -> str:\n    '''\n    Internal helper to robustly extract the network or chain-id field from various\n    possible junod status JSON layouts.\n    '''\n    if not isinstance(data, dict):\n        return ''\n\n    # Common layouts to try, in order\n    candidate_paths = [\n        ('node_info', 'network'),\n        ('NodeInfo', 'network'),\n        ('result', 'node_info', 'network'),\n        ('Result', 'node_info', 'network'),\n    ]\n\n    for path in candidate_paths:\n        cursor: Any = data\n        for key in path:\n            if isinstance(cursor, dict) and key in cursor:\n                cursor = cursor[key]\n            else:\n                cursor = None\n                break\n        if isinstance(cursor, str) and cursor:\n            return cursor\n\n    return ''\n\n\ndef test_junod_connectivity(node_url: str, expected_chain_id: str = 'uni-6') -> Dict[str, Any]:\n    '''\n    Run 'junod status --node NODE_URL', parse the JSON output, and confirm that\n    the node is reachable and its reported network or chain-id matches expected_chain_id.\n    Raises RuntimeError on connectivity issues, non-json output, or chain-id mismatch.\n    '''\n    if not node_url or not isinstance(node_url, str):\n        raise ValueError('node_url must be a non-empty string')\n\n    try:\n        result = subprocess.run(\n            ['junod', 'status', '--node', node_url],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found. Run check_junod_installed() first and ensure junod is on the PATH.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod status --node {node_url} failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    raw = result.stdout.strip()\n    try:\n        status_json = json.loads(raw)\n    except json.JSONDecodeError as exc:\n        raise RuntimeError(\n            f'Failed to decode junod status output as json: {exc}. Raw output was: {raw}'\n        )\n\n    network = _extract_network_field(status_json)\n    if not network:\n        raise RuntimeError(\n            'Could not locate node_info.network or equivalent field in junod status output.'\n        )\n\n    if network != expected_chain_id:\n        raise RuntimeError(\n            f'Connected node reports chain-id {network}, but expected {expected_chain_id}.'\n        )\n\n    return {\n        'ok': True,\n        'node_url': node_url,\n        'reported_chain_id': network,\n        'raw_status': status_json,\n    }\n",
            "usage": "After configuring junod, call test_junod_connectivity('http://localhost:26657') to ensure the node is reachable and that its reported network matches uni-6; handle RuntimeError to report any mismatch or connectivity issue."
        }
    ]
}