{
    "label": "query_balance",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 provides a reusable Python helper that validates a Juno bech32 address (correct hrp and checksum) before any LCD calls.",
            "code": "from bech32 import bech32_decode\n\n\nclass InvalidJunoAddressError(ValueError):\n    '''Custom error for invalid Juno addresses.'''\n    pass\n\n\ndef validate_juno_address(address: str) -> str:\n    '''Validate that a string is a well-formed Juno bech32 address.\n\n    Returns the address if valid, otherwise raises InvalidJunoAddressError.\n    '''\n    if not isinstance(address, str):\n        raise InvalidJunoAddressError('Address must be a string.')\n\n    address = address.strip()\n    if not address:\n        raise InvalidJunoAddressError('Address must not be empty.')\n\n    # Basic prefix check first for clearer error messages\n    if not address.startswith('juno1'):\n        raise InvalidJunoAddressError('Address must start with prefix juno1.')\n\n    # Full bech32 decoding to verify checksum and HRP\n    hrp, data = bech32_decode(address)\n    if hrp != 'juno' or data is None:\n        raise InvalidJunoAddressError('Invalid Juno bech32 address: bad checksum or wrong prefix.')\n\n    return address\n",
            "usage": "Import and call validate_juno_address(ADDRESS) at the start of your backend handler. If the address is invalid it raises InvalidJunoAddressError; otherwise it returns the cleaned address string."
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 defines an async backend helper that calls the Juno LCD /cosmos/bank/v1beta1/balances/{address} endpoint and returns all balances (handling pagination).",
            "code": "import httpx\nfrom typing import Any, Dict, List\n\n\nBASE_LCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def fetch_all_balances(address: str) -> Dict[str, Any]:\n    '''Query /cosmos/bank/v1beta1/balances/{address} on the Juno LCD and\n    return the combined balances (across pagination pages).\n\n    This function assumes validate_juno_address has already been called.\n    '''\n    url = f'{BASE_LCD_URL}/cosmos/bank/v1beta1/balances/{address}'\n    balances: List[Dict[str, Any]] = []\n    next_key: str | None = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            params: Dict[str, Any] = {}\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                response = await client.get(url, params=params)\n                response.raise_for_status()\n            except httpx.HTTPError as exc:\n                # Wrap HTTP errors so callers can handle them uniformly\n                raise RuntimeError(f'Error querying Juno LCD balances: {exc}') from exc\n\n            data = response.json() or {}\n            balances.extend(data.get('balances', []))\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return {'balances': balances}\n",
            "usage": "After validating the address, call balances_result = await fetch_all_balances(ADDRESS) inside an async backend route or service. The returned dict has a 'balances' key containing the full list of coins."
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 adds an optional backend helper to query spendable (unlocked) balances via /cosmos/bank/v1beta1/spendable_balances/{address}.",
            "code": "import httpx\nfrom typing import Any, Dict, List\n\n\nBASE_LCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def fetch_spendable_balances(address: str) -> Dict[str, Any]:\n    '''Query /cosmos/bank/v1beta1/spendable_balances/{address} on the Juno LCD\n    and return the combined spendable balances (across pagination pages).\n\n    This function assumes validate_juno_address has already been called.\n    '''\n    url = f'{BASE_LCD_URL}/cosmos/bank/v1beta1/spendable_balances/{address}'\n    balances: List[Dict[str, Any]] = []\n    next_key: str | None = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            params: Dict[str, Any] = {}\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                response = await client.get(url, params=params)\n                response.raise_for_status()\n            except httpx.HTTPError as exc:\n                raise RuntimeError(f'Error querying Juno LCD spendable balances: {exc}') from exc\n\n            data = response.json() or {}\n            balances.extend(data.get('balances', []))\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return {'balances': balances}\n",
            "usage": "Optionally call spendable_result = await fetch_spendable_balances(ADDRESS) to retrieve only spendable coins. The returned dict has a 'balances' key with the list of spendable coins."
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 provides a backend helper that queries /cosmos/bank/v1beta1/denoms_metadata to fetch denom metadata (base, display, exponent) for later formatting.",
            "code": "import httpx\nfrom typing import Any, Dict, List\n\n\nBASE_LCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def fetch_denoms_metadata() -> Dict[str, Any]:\n    '''Query /cosmos/bank/v1beta1/denoms_metadata on the Juno LCD and return\n    all denom metadata records (handling pagination).\n    '''\n    url = f'{BASE_LCD_URL}/cosmos/bank/v1beta1/denoms_metadata'\n    metadatas: List[Dict[str, Any]] = []\n    next_key: str | None = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            params: Dict[str, Any] = {}\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                response = await client.get(url, params=params)\n                response.raise_for_status()\n            except httpx.HTTPError as exc:\n                raise RuntimeError(f'Error querying Juno LCD denoms metadata: {exc}') from exc\n\n            data = response.json() or {}\n            metadatas.extend(data.get('metadatas', []))\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return {'metadatas': metadatas}\n",
            "usage": "Call metadata_result = await fetch_denoms_metadata() from your backend to obtain a dict with a 'metadatas' key containing all registered denom metadata used for converting base units to display units."
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 wires everything into a FastAPI BFF endpoint that validates the Juno address, queries raw and spendable balances plus denom metadata, and returns a structured, human-readable list grouped by denom.",
            "code": "from decimal import Decimal, InvalidOperation\nfrom typing import Any, Dict, List, Optional\n\nimport httpx\nfrom bech32 import bech32_decode\nfrom fastapi import FastAPI, HTTPException\n\n\nBASE_LCD_URL = 'https://lcd-archive.junonetwork.io'\n\napp = FastAPI()\n\n\nclass InvalidJunoAddressError(ValueError):\n    '''Custom error for invalid Juno addresses.'''\n    pass\n\n\ndef validate_juno_address(address: str) -> str:\n    '''Validate that a string is a well-formed Juno bech32 address.\n\n    Returns the address if valid, otherwise raises InvalidJunoAddressError.\n    '''\n    if not isinstance(address, str):\n        raise InvalidJunoAddressError('Address must be a string.')\n\n    address = address.strip()\n    if not address:\n        raise InvalidJunoAddressError('Address must not be empty.')\n\n    if not address.startswith('juno1'):\n        raise InvalidJunoAddressError('Address must start with prefix juno1.')\n\n    # Full bech32 decoding to verify checksum and HRP\n    hrp, data = bech32_decode(address)\n    if hrp != 'juno' or data is None:\n        raise InvalidJunoAddressError('Invalid Juno bech32 address: bad checksum or wrong prefix.')\n\n    return address\n\n\nasync def fetch_all_balances(address: str) -> List[Dict[str, Any]]:\n    '''Fetch all bank balances for an address from the Juno LCD.'''\n    url = f'{BASE_LCD_URL}/cosmos/bank/v1beta1/balances/{address}'\n    balances: List[Dict[str, Any]] = []\n    next_key: Optional[str] = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            params: Dict[str, Any] = {}\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                response = await client.get(url, params=params)\n                response.raise_for_status()\n            except httpx.HTTPError as exc:\n                raise RuntimeError(f'Error querying Juno LCD balances: {exc}') from exc\n\n            data = response.json() or {}\n            balances.extend(data.get('balances', []))\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return balances\n\n\nasync def fetch_spendable_balances(address: str) -> List[Dict[str, Any]]:\n    '''Fetch all spendable bank balances for an address from the Juno LCD.'''\n    url = f'{BASE_LCD_URL}/cosmos/bank/v1beta1/spendable_balances/{address}'\n    balances: List[Dict[str, Any]] = []\n    next_key: Optional[str] = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            params: Dict[str, Any] = {}\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                response = await client.get(url, params=params)\n                response.raise_for_status()\n            except httpx.HTTPError as exc:\n                raise RuntimeError(f'Error querying Juno LCD spendable balances: {exc}') from exc\n\n            data = response.json() or {}\n            balances.extend(data.get('balances', []))\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return balances\n\n\nasync def fetch_denoms_metadata() -> List[Dict[str, Any]]:\n    '''Fetch metadata for all registered denoms from the Juno LCD.'''\n    url = f'{BASE_LCD_URL}/cosmos/bank/v1beta1/denoms_metadata'\n    metadatas: List[Dict[str, Any]] = []\n    next_key: Optional[str] = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            params: Dict[str, Any] = {}\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                response = await client.get(url, params=params)\n                response.raise_for_status()\n            except httpx.HTTPError as exc:\n                raise RuntimeError(f'Error querying Juno LCD denoms metadata: {exc}') from exc\n\n            data = response.json() or {}\n            metadatas.extend(data.get('metadatas', []))\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return metadatas\n\n\ndef build_metadata_index(metadatas: List[Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:\n    '''Index metadata records by their base denom for quick lookup.'''\n    index: Dict[str, Dict[str, Any]] = {}\n    for meta in metadatas:\n        base = meta.get('base')\n        if base:\n            index[base] = meta\n    return index\n\n\ndef decimal_to_str(value: Decimal) -> str:\n    '''Convert a Decimal to a non-scientific string without trailing zeros.'''\n    s = format(value, 'f')\n    if '.' in s:\n        s = s.rstrip('0').rstrip('.')\n    return s\n\n\ndef format_balances(\n    all_balances: List[Dict[str, Any]],\n    spendable_balances: Optional[List[Dict[str, Any]]],\n    metadata_index: Dict[str, Dict[str, Any]],\n) -> List[Dict[str, Any]]:\n    '''Combine raw balances, spendable balances and metadata into a\n    human-readable structure grouped by denom.\n    '''\n    spendable_map: Dict[str, str] = {}\n    if spendable_balances:\n        for coin in spendable_balances:\n            denom = coin.get('denom')\n            amount = coin.get('amount')\n            if denom is not None and amount is not None:\n                spendable_map[denom] = amount\n\n    result: List[Dict[str, Any]] = []\n\n    for coin in all_balances:\n        denom = coin.get('denom')\n        amount_str = coin.get('amount')\n        if denom is None or amount_str is None:\n            continue\n\n        meta = metadata_index.get(denom)\n        display_denom = denom\n        exponent = 0\n\n        if meta:\n            display_denom = meta.get('display') or denom\n            for unit in meta.get('denom_units', []):\n                if unit.get('denom') == display_denom:\n                    try:\n                        exponent = int(unit.get('exponent', 0))\n                    except (TypeError, ValueError):\n                        exponent = 0\n                    break\n\n        try:\n            base_amount = Decimal(amount_str)\n        except (InvalidOperation, TypeError):\n            base_amount = Decimal(0)\n\n        if exponent > 0:\n            factor = Decimal(10) ** exponent\n            display_amount = base_amount / factor\n        else:\n            display_amount = base_amount\n\n        spendable_amount_str = spendable_map.get(denom)\n        spendable_entry: Optional[Dict[str, Any]] = None\n        if spendable_amount_str is not None:\n            try:\n                spendable_base = Decimal(spendable_amount_str)\n            except (InvalidOperation, TypeError):\n                spendable_base = Decimal(0)\n\n            if exponent > 0:\n                factor = Decimal(10) ** exponent\n                spendable_display = spendable_base / factor\n            else:\n                spendable_display = spendable_base\n\n            spendable_entry = {\n                'amount': spendable_amount_str,\n                'display_amount': decimal_to_str(spendable_display),\n            }\n\n        result.append({\n            'base_denom': denom,\n            'display_denom': display_denom,\n            'exponent': exponent,\n            'total': {\n                'amount': amount_str,\n                'display_amount': decimal_to_str(display_amount),\n            },\n            'spendable': spendable_entry,\n        })\n\n    result.sort(key=lambda entry: entry['base_denom'])\n    return result\n\n\n@app.get('/api/juno/{address}/balances')\nasync def get_juno_balances(\n    address: str,\n    include_spendable: bool = True,\n    include_metadata: bool = True,\n) -> Dict[str, Any]:\n    '''Endpoint that validates a Juno address, fetches balances and optional\n    metadata, and returns a structured, human-readable response.\n    '''\n    try:\n        validated = validate_juno_address(address)\n    except InvalidJunoAddressError as exc:\n        raise HTTPException(status_code=400, detail=str(exc)) from exc\n\n    try:\n        all_balances = await fetch_all_balances(validated)\n        spendable_balances: Optional[List[Dict[str, Any]]] = []\n        if include_spendable:\n            spendable_balances = await fetch_spendable_balances(validated)\n\n        metadatas: Optional[List[Dict[str, Any]]] = []\n        if include_metadata:\n            metadatas = await fetch_denoms_metadata()\n    except RuntimeError as exc:\n        raise HTTPException(status_code=502, detail=str(exc)) from exc\n\n    metadata_index: Dict[str, Dict[str, Any]] = {}\n    if include_metadata and metadatas:\n        metadata_index = build_metadata_index(metadatas)\n\n    formatted = format_balances(\n        all_balances=all_balances,\n        spendable_balances=spendable_balances,\n        metadata_index=metadata_index,\n    )\n\n    return {\n        'address': validated,\n        'include_spendable': include_spendable,\n        'include_metadata': include_metadata,\n        'balances': formatted,\n    }\n",
            "usage": "Mount this FastAPI app with a server such as uvicorn (for example: uvicorn module_name:app --reload). From your frontend, call GET /api/juno/{ADDRESS}/balances?include_spendable=true&include_metadata=true. The JSON response contains the address and a balances array, where each entry includes base_denom, display_denom, exponent, total (base and display amounts), and optional spendable amounts."
        }
    ]
}