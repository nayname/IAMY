{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 provides a Python helper that queries the node config LCD endpoint to fetch and parse the minimum_gas_price field.",
            "code": "import requests\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nclass LCDQueryError(Exception):\n    '''Raised when an LCD query fails or returns unexpected data.'''\n    pass\n\n\ndef get_minimum_gas_price():\n    '''\n    Query the node configuration and parse the minimum_gas_price field.\n\n    Returns a dict with:\n      - raw: original minimum_gas_price string from the node\n      - amount: numeric amount part as a string (e.g. '0.025')\n      - denom: denom part (e.g. 'ujuno')\n    '''\n    url = f'{LCD_BASE_URL}/cosmos/base/node/v1beta1/config'\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException as exc:\n        raise LCDQueryError(f'Failed to query node config: {exc}') from exc\n\n    data = response.json()\n    minimum_gas_price = data.get('minimum_gas_price')\n    if not minimum_gas_price:\n        raise LCDQueryError('minimum_gas_price field missing in LCD response')\n\n    # The field can contain multiple comma-separated entries; use the first one\n    first_entry = minimum_gas_price.split(',')[0].strip()\n\n    # Split numeric amount from denom, e.g. '0.025ujuno' -> ('0.025', 'ujuno')\n    split_index = 0\n    while split_index < len(first_entry) and (\n        first_entry[split_index].isdigit() or first_entry[split_index] == '.'\n    ):\n        split_index += 1\n\n    if split_index == 0 or split_index == len(first_entry):\n        raise LCDQueryError(\n            f'Unexpected minimum_gas_price format: {first_entry!r}'\n        )\n\n    amount = first_entry[:split_index]\n    denom = first_entry[split_index:]\n\n    return {\n        'raw': minimum_gas_price,\n        'amount': amount,\n        'denom': denom,\n    }\n",
            "usage": "gas_price_info = get_minimum_gas_price()\nprint('Raw minimum_gas_price from node:', gas_price_info['raw'])"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 implements a Python helper that queries node_info (and falls back to blocks/latest) to determine the chain-id.",
            "code": "import requests\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nclass LCDQueryError(Exception):\n    '''Raised when an LCD query fails or returns unexpected data.'''\n    pass\n\n\ndef get_chain_id():\n    '''\n    Query node_info (and optionally blocks/latest) to determine the chain-id.\n\n    Returns:\n        Chain ID string, e.g. 'juno-1'.\n    '''\n    node_info_url = f'{LCD_BASE_URL}/cosmos/base/tendermint/v1beta1/node_info'\n    try:\n        response = requests.get(node_info_url, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException as exc:\n        raise LCDQueryError(f'Failed to query node_info: {exc}') from exc\n\n    data = response.json()\n    default_node_info = data.get('default_node_info') or {}\n    chain_id = default_node_info.get('network')\n\n    if chain_id:\n        return chain_id\n\n    # Fallback: derive chain-id from latest block header.chain_id\n    latest_block_url = f'{LCD_BASE_URL}/cosmos/base/tendermint/v1beta1/blocks/latest'\n    try:\n        response = requests.get(latest_block_url, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException as exc:\n        raise LCDQueryError(\n            f'Failed to query latest block for chain-id fallback: {exc}'\n        ) from exc\n\n    block_data = response.json()\n    header = (block_data.get('block') or {}).get('header') or {}\n    chain_id = header.get('chain_id')\n\n    if not chain_id:\n        raise LCDQueryError('Could not determine chain-id from LCD responses')\n\n    return chain_id\n",
            "usage": "chain_id = get_chain_id()\nprint('Detected chain-id:', chain_id)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 constructs a reusable TXFLAGS string in the backend using the minimum gas price and chain-id plus configured gas_adjustment and RPC endpoint.",
            "code": "def build_txflags_string(\n    minimum_gas_price: str,\n    chain_id: str,\n    gas_adjustment: float = 1.3,\n    rpc_endpoint: str = 'https://rpc.junonetwork.io',\n) -> str:\n    '''\n    Construct a TXFLAGS string suitable for reuse with junod CLI commands.\n\n    Args:\n        minimum_gas_price: Gas price string like '0.025ujuno'.\n        chain_id: Chain identifier, e.g. 'juno-1'.\n        gas_adjustment: Multiplier applied when using --gas=auto.\n        rpc_endpoint: RPC endpoint URL that junod should talk to.\n\n    Returns:\n        A flags string, for example:\n        '--gas=auto --gas-adjustment=1.3 --gas-prices=0.025ujuno --chain-id=juno-1 --node=https://rpc.junonetwork.io'\n    '''\n    if not minimum_gas_price or not chain_id:\n        raise ValueError('minimum_gas_price and chain_id must be non-empty')\n\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive')\n\n    flags = (\n        f'--gas=auto '\n        f'--gas-adjustment={gas_adjustment} '\n        f'--gas-prices={minimum_gas_price} '\n        f'--chain-id={chain_id} '\n        f'--node={rpc_endpoint}'\n    )\n\n    return flags\n",
            "usage": "from_step1 = get_minimum_gas_price()\nfrom_step2 = get_chain_id()\nminimum_gas_price = f\"{from_step1['amount']}{from_step1['denom']}\"\ntxflags = build_txflags_string(minimum_gas_price, from_step2, gas_adjustment=1.3, rpc_endpoint='https://rpc.junonetwork.io')\nprint('TXFLAGS string:', txflags)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 defines a backend helper that sets the TXFLAGS environment variable so subsequent junod commands inherit the gas and chain settings.",
            "code": "import os\n\n\ndef set_txflags_env(txflags: str) -> None:\n    '''\n    Set the TXFLAGS environment variable in the current process, so any\n    subsequent junod CLI calls from this process will automatically include\n    the configured gas and chain settings.\n    '''\n    if not txflags or not txflags.strip():\n        raise ValueError('txflags must be a non-empty string')\n\n    os.environ['TXFLAGS'] = txflags\n",
            "usage": "txflags = build_txflags_string('0.025ujuno', 'juno-1', gas_adjustment=1.3, rpc_endpoint='https://rpc.junonetwork.io')\nset_txflags_env(txflags)\n# Any junod subprocess started from this process will now see $TXFLAGS"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 runs a harmless junod self-send transaction (optionally as a dry-run) using the TXFLAGS environment variable to verify that gas settings are applied correctly.",
            "code": "import os\nimport shlex\nimport subprocess\nfrom typing import Optional, Dict, Any\n\n\nclass JunodTxTestError(Exception):\n    '''Raised when the test junod transaction fails.'''\n    pass\n\n\ndef test_junod_tx_with_txflags(\n    from_identifier: str,\n    amount: str = '1',\n    denom: str = 'ujuno',\n    simulate_only: bool = True,\n    home: Optional[str] = None,\n) -> Dict[str, Any]:\n    '''\n    Execute a harmless junod transaction using the TXFLAGS environment\n    variable to verify that gas settings are accepted by the node.\n\n    Args:\n        from_identifier: Local key name or bech32 address used as both sender\n            and recipient for a self-send.\n        amount: Token amount to send (as a string, default '1').\n        denom: Token denom to send (default 'ujuno').\n        simulate_only: If True, adds --dry-run so the tx is not broadcast.\n        home: Optional junod --home directory.\n\n    Returns:\n        A dict with the executed command, stdout, stderr, and returncode.\n    '''\n    txflags = os.environ.get('TXFLAGS')\n    if not txflags:\n        raise JunodTxTestError(\n            'TXFLAGS environment variable is not set. Call set_txflags_env(...) first.'\n        )\n\n    base_cmd = (\n        f'junod tx bank send {from_identifier} {from_identifier} '\n        f'{amount}{denom} --from {from_identifier} --yes'\n    )\n\n    if simulate_only:\n        base_cmd += ' --dry-run'\n\n    if home:\n        base_cmd += f' --home {home}'\n\n    full_cmd = f'{base_cmd} {txflags}'\n\n    try:\n        completed = subprocess.run(\n            shlex.split(full_cmd),\n            capture_output=True,\n            text=True,\n            check=False,\n        )\n    except OSError as exc:\n        raise JunodTxTestError(\n            f'Failed to execute junod command: {exc}'\n        ) from exc\n\n    result: Dict[str, Any] = {\n        'command': full_cmd,\n        'stdout': completed.stdout,\n        'stderr': completed.stderr,\n        'returncode': completed.returncode,\n    }\n\n    if completed.returncode != 0:\n        raise JunodTxTestError(\n            f'junod tx command failed with code {completed.returncode}: '\n            f\"{completed.stderr or completed.stdout}\"\n        )\n\n    return result\n",
            "usage": "set_txflags_env(build_txflags_string('0.025ujuno', 'juno-1'))\nresult = test_junod_tx_with_txflags(from_identifier='mykey', amount='1', denom='ujuno', simulate_only=True)\nprint('Executed command:', result['command'])\nprint('junod output:', result['stdout'])"
        }
    ]
}