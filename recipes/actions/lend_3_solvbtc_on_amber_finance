{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Expose a small FastAPI endpoint that returns the Bech32 address of the backend wallet that will perform the lending operations.",
            "code": "from fastapi import FastAPI, HTTPException\nimport os\n\napp = FastAPI()\n\n@app.get('/api/wallet/address')\nasync def get_sender_address(wallet_alias: str = 'lender'):\n    \"\"\"Return the Bech32 address for a configured backend wallet.\"\"\"\n    env_key = f\"{wallet_alias.upper()}_ADDRESS\"\n    address = os.getenv(env_key)\n    if not address:\n        raise HTTPException(status_code=404, detail=f'Wallet alias {wallet_alias} not configured')\n    return {\"wallet\": wallet_alias, \"address\": address}",
            "usage": "GET /api/wallet/address?wallet_alias=lender  \u279c  {\"wallet\":\"lender\",\"address\":\"neutron1...\"}"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Provide an endpoint that fetches the CW20 token balance (solvBTC) for a given address using Neutron\u2019s REST API.",
            "code": "import base64, json, os, requests\nfrom fastapi import FastAPI, HTTPException\n\nREST_ENDPOINT = os.getenv('NEUTRON_REST', 'https://rest-kralum.neutron-1.neutron.org')\napp = FastAPI()\n\n@app.get('/api/cw20/balance')\nasync def check_token_balance(address: str, cw20_contract: str):\n    \"\"\"Return the CW20 balance for a given address.\"\"\"\n    query = {\"balance\": {\"address\": address}}\n    encoded_query = base64.b64encode(json.dumps(query).encode()).decode()\n    url = f\"{REST_ENDPOINT}/cosmwasm/wasm/v1/contract/{cw20_contract}/smart/{encoded_query}\"\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        balance = int(resp.json().get('data', {}).get('balance', '0'))\n        return {\"address\": address, \"cw20_contract\": cw20_contract, \"balance\": balance}\n    except requests.RequestException as err:\n        raise HTTPException(status_code=500, detail=str(err))",
            "usage": "GET /api/cw20/balance?address=neutron1...&cw20_contract=neutron1cw20...  \u279c  {\"balance\": \"300000000\"}"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Create a helper function that returns the CW20 `increase_allowance` message needed to approve Amber Finance\u2019s market contract.",
            "code": "def construct_cw20_approve(spender: str, amount_micro: int) -> dict:\n    \"\"\"Build the CW20 increase_allowance message.\"\"\"\n    return {\n        'increase_allowance': {\n            'spender': spender,\n            'amount': str(amount_micro)\n        }\n    }",
            "usage": "msg = construct_cw20_approve(spender='neutron1amber...', amount_micro=300000000)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Sign and broadcast the approval transaction using cosmpy. This step relies on a private key stored in the `LENDER_PRIVKEY` environment variable.",
            "code": "import os, json\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import PrivateKey\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.protos.cosmwasm.wasm.v1.tx_pb2 import MsgExecuteContract\n\n\ndef sign_and_broadcast_approval() -> dict:\n    \"\"\"Signs and broadcasts the CW20 approve (increase_allowance) transaction.\"\"\"\n    network = NetworkConfig(\n        chain_id='neutron-1',\n        url=os.getenv('NEUTRON_GRPC', 'grpc://grpc-kralum.neutron-1.neutron.org:443'),\n        fee_minimum_gas_price=0.025,\n        fee_denom='untrn'\n    )\n    client = LedgerClient(network)\n\n    private_key_hex = os.getenv('LENDER_PRIVKEY')\n    if not private_key_hex:\n        raise RuntimeError('Missing LENDER_PRIVKEY environment variable')\n    wallet = PrivateKey(bytes.fromhex(private_key_hex))\n\n    cw20_contract = os.getenv('SOLVBTC_CONTRACT')\n    spender = os.getenv('AMBER_MARKET_CONTRACT')\n    amount_micro = int(os.getenv('APPROVE_AMOUNT', '300000000'))  # 3 solvBTC * 1e8 (assuming 8 decimals)\n\n    # Build execute message\n    msg = MsgExecuteContract(\n        sender=wallet.address(),\n        contract=cw20_contract,\n        msg=json.dumps({'increase_allowance': {'spender': spender, 'amount': str(amount_micro)}}).encode(),\n        funds=[]\n    )\n\n    tx = (\n        Transaction()\n        .with_messages(msg)\n        .with_chain_id(network.chain_id)\n        .with_gas_estimate(client)\n        .sign(wallet)\n        .broadcast(client, mode='block')\n    )\n    return {'tx_hash': tx.tx_hash}\n\n\nif __name__ == '__main__':\n    print(sign_and_broadcast_approval())",
            "usage": "python approve.py  \u279c  {'tx_hash': 'ABCD1234...'}"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Create the CosmWasm execute message that tells Amber Finance\u2019s market contract to lend (supply) the previously-approved solvBTC.",
            "code": "def construct_amber_lend_tx(amount_micro: int) -> dict:\n    \"\"\"Build the lend (supply) message for Amber Finance market contract.\"\"\"\n    return {\n        'lend': {\n            'amount': str(amount_micro)\n        }\n    }",
            "usage": "msg = construct_amber_lend_tx(300000000)"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Sign and broadcast the lend (supply) transaction that actually deposits the solvBTC into Amber Finance.",
            "code": "import os, json\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import PrivateKey\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.protos.cosmwasm.wasm.v1.tx_pb2 import MsgExecuteContract\n\n\ndef sign_and_broadcast_lend() -> dict:\n    \"\"\"Signs and broadcasts the lend (supply) transaction to Amber Finance.\"\"\"\n    network = NetworkConfig(\n        chain_id='neutron-1',\n        url=os.getenv('NEUTRON_GRPC', 'grpc://grpc-kralum.neutron-1.neutron.org:443'),\n        fee_minimum_gas_price=0.025,\n        fee_denom='untrn'\n    )\n    client = LedgerClient(network)\n\n    private_key_hex = os.getenv('LENDER_PRIVKEY')\n    if not private_key_hex:\n        raise RuntimeError('Missing LENDER_PRIVKEY environment variable')\n    wallet = PrivateKey(bytes.fromhex(private_key_hex))\n\n    amber_market_contract = os.getenv('AMBER_MARKET_CONTRACT')\n    amount_micro = int(os.getenv('LEND_AMOUNT', '300000000'))  # 3 solvBTC * 1e8\n\n    # Build execute message\n    msg = MsgExecuteContract(\n        sender=wallet.address(),\n        contract=amber_market_contract,\n        msg=json.dumps({'lend': {'amount': str(amount_micro)}}).encode(),\n        funds=[]\n    )\n\n    tx = (\n        Transaction()\n        .with_messages(msg)\n        .with_chain_id(network.chain_id)\n        .with_gas_estimate(client)\n        .sign(wallet)\n        .broadcast(client, mode='block')\n    )\n    return {'tx_hash': tx.tx_hash}\n\n\nif __name__ == '__main__':\n    print(sign_and_broadcast_lend())",
            "usage": "python lend.py  \u279c  {'tx_hash': 'EFGH5678...'}"
        }
    ]
}