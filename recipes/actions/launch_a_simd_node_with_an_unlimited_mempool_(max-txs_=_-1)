{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Verifies that the `simd` binary is installed, executable, and exposes an HTTP endpoint to surface that information to the frontend.",
            "code": "# backend/operations/simd_checks.py\n\nimport shutil\nimport subprocess\nfrom fastapi import APIRouter, HTTPException\n\nrouter = APIRouter()\n\ndef _check_simd_binary():\n    '''Verify that the `simd` binary exists in the user PATH and is executable.'''\n    simd_path = shutil.which(\"simd\")\n    if simd_path is None:\n        raise FileNotFoundError(\"`simd` binary not found in your PATH. Have you installed simd?\")\n    try:\n        result = subprocess.run(\n            [simd_path, \"version\"],\n            capture_output=True,\n            text=True,\n            check=True,\n            timeout=10\n        )\n    except (subprocess.CalledProcessError, subprocess.TimeoutExpired) as exc:\n        raise RuntimeError(f\"`simd` binary found but not executable: {exc}\")\n    return {\"simd_path\": simd_path, \"version\": result.stdout.strip()}\n\n@router.get(\"/api/check_simd\")\nasync def check_simd():\n    '''HTTP endpoint that returns the path and version of the `simd` binary.'''\n    try:\n        return _check_simd_binary()\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=str(exc))",
            "usage": "const info = await fetch('/api/check_simd').then(res => res.json());"
        },
        {
            "step": 2,
            "label": "frontend",
            "introduction": "Prompts (or recalls) the user\u2019s chosen home directory for the node and stores it in `localStorage` for re-use.",
            "code": "// frontend/utils/getNodeHome.js\n\nexport async function getNodeHome() {\n  // Try to read a cached home directory from browser storage\n  let homeDir = localStorage.getItem('simd_home');\n  if (!homeDir) {\n    // Prompt the user for the directory; default to ~/.simapp\n    homeDir = prompt('Enter the directory for your simd node (default ~/.simapp):', '~/.simapp') || '~/.simapp';\n    localStorage.setItem('simd_home', homeDir);\n  }\n\n  if (typeof homeDir !== 'string' || homeDir.trim() === '') {\n    throw new Error('Invalid home directory supplied.');\n  }\n\n  return homeDir.trim();\n}",
            "usage": "const homeDir = await getNodeHome();"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Builds a safe `simd start` command string with custom flags and returns it via an HTTP endpoint.",
            "code": "# backend/operations/simd_start.py\n\nimport os\nimport shlex\nfrom fastapi import APIRouter, HTTPException\n\nrouter = APIRouter()\n\ndef _construct_start_command(home_dir: str) -> str:\n    '''Return a safe string for starting simd with custom flags.'''\n    if not home_dir:\n        raise ValueError('home_dir parameter is required')\n    expanded_home = os.path.expanduser(home_dir)\n    # Ensure path exists\n    if not os.path.isdir(expanded_home):\n        raise FileNotFoundError(f'Provided home directory does not exist: {expanded_home}')\n    # Quote the directory to avoid shell injection\n    quoted_home = shlex.quote(expanded_home)\n    return f'simd start --mempool.max-txs=-1 --home={quoted_home}'\n\n@router.post('/api/build_start_cmd')\nasync def build_start_cmd(payload: dict):\n    '''Endpoint that returns the full `simd start` command string.'''\n    try:\n        home_dir = payload.get('home')\n        cmd = _construct_start_command(home_dir)\n        return {'command': cmd}\n    except Exception as exc:\n        raise HTTPException(status_code=400, detail=str(exc))",
            "usage": "const cmd = await fetch('/api/build_start_cmd', {method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ home: homeDir })}).then(r => r.json());"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Spawns the `simd` process with the previously built command and keeps a handle to the running process.",
            "code": "# backend/operations/simd_process.py\n\nimport shlex\nimport subprocess\nfrom fastapi import APIRouter, HTTPException\n\nrouter = APIRouter()\n_process_holder = {'proc': None}\n\ndef _start_simd_process(command: str):\n    if _process_holder['proc'] is not None:\n        raise RuntimeError('A simd process is already running.')\n    args = shlex.split(command)\n    proc = subprocess.Popen(\n        args,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.STDOUT,\n        text=True,\n        bufsize=1\n    )\n    _process_holder['proc'] = proc\n    return {'pid': proc.pid}\n\n@router.post('/api/start_simd')\nasync def start_simd(payload: dict):\n    try:\n        command = payload.get('command')\n        return _start_simd_process(command)\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=str(exc))",
            "usage": "await fetch('/api/start_simd', {method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ command: cmd.command })});"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Streams real-time logs from the running `simd` process using Server-Sent Events (SSE).",
            "code": "# backend/operations/simd_logs.py\n\nimport asyncio\nfrom fastapi import APIRouter\nfrom fastapi.responses import StreamingResponse\nfrom .simd_process import _process_holder\n\nrouter = APIRouter()\n\nasync def _log_streamer():\n    proc = _process_holder.get('proc')\n    if proc is None or proc.stdout is None:\n        yield 'data: simd process not running\\n\\n'\n        return\n    while True:\n        line = proc.stdout.readline()\n        if line:\n            yield f'data: {line.rstrip()}\\n\\n'\n        await asyncio.sleep(0.05)\n        if proc.poll() is not None:\n            break\n    yield 'data: **simd process ended**\\n\\n'\n\n@router.get('/api/simd_logs')\nasync def simd_logs():\n    return StreamingResponse(_log_streamer(), media_type='text/event-stream')",
            "usage": "const es = new EventSource('/api/simd_logs');\nes.onmessage = (evt) => console.log(evt.data);"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Checks the node\u2019s liveness by querying either the RPC endpoint or the CLI fallback.",
            "code": "# backend/operations/simd_status.py\n\nimport subprocess\nimport requests\nfrom fastapi import APIRouter, HTTPException\n\nrouter = APIRouter()\n\ndef _cli_status():\n    res = subprocess.run(['simd', 'status'], capture_output=True, text=True, check=True)\n    return res.stdout\n\ndef _rpc_status(rpc_url: str):\n    r = requests.get(f'{rpc_url.rstrip('/')}/status')\n    r.raise_for_status()\n    return r.json()\n\n@router.get('/api/simd_status')\nasync def simd_status(rpc: str = 'http://localhost:26657'):\n    try:\n        try:\n            return _rpc_status(rpc)\n        except Exception:\n            # Fallback to CLI if RPC fails\n            return {'raw': _cli_status()}\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=str(exc))",
            "usage": "const status = await fetch('/api/simd_status').then(r => r.json());"
        }
    ]
}