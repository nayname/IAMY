{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a backend utility that walks up the filesystem to locate the Cargo workspace root (a Cargo.toml with a [workspace] section).",
            "code": "import os\nfrom pathlib import Path\nfrom typing import Optional\n\ntry:\n    import tomllib  # Python 3.11+\nexcept ModuleNotFoundError:  # pragma: no cover - fallback\n    tomllib = None\n\n\nclass WorkspaceNotFoundError(Exception):\n    '''Raised when a Cargo workspace root cannot be found.'''\n\n\nclass InvalidWorkspaceError(Exception):\n    '''Raised when a Cargo.toml exists but does not define a [workspace] section.'''\n\n\ndef _load_toml(path: Path) -> dict:\n    '''Load a TOML file using tomllib if available.\n\n    Args:\n        path: Path to the TOML file.\n\n    Returns:\n        Parsed TOML as a dict.\n    '''\n    if not path.is_file():\n        raise FileNotFoundError(f'TOML file not found: {path}')\n\n    data = path.read_bytes()\n    if tomllib is None:\n        try:\n            import toml  # type: ignore\n        except ModuleNotFoundError as exc:\n            raise RuntimeError('No TOML parser available. Install toml or use Python 3.11+.') from exc\n        return toml.loads(data.decode('utf-8'))\n    return tomllib.loads(data.decode('utf-8'))\n\n\ndef detect_workspace_root(start_dir: Optional[str] = None) -> dict:\n    '''Locate the Cargo workspace root starting from start_dir and walking upwards.\n\n    A workspace root is defined as a directory containing Cargo.toml with a\n    top-level [workspace] section.\n\n    Args:\n        start_dir: Directory to start searching from. Defaults to current working directory.\n\n    Returns:\n        A JSON-serializable dict with the resolved workspace_root path.\n\n    Raises:\n        WorkspaceNotFoundError: If no workspace root can be located.\n        InvalidWorkspaceError: If a Cargo.toml is found but is not a workspace.\n    '''\n    if start_dir is None:\n        current = Path.cwd().resolve()\n    else:\n        current = Path(start_dir).expanduser().resolve()\n\n    for directory in [current] + list(current.parents):\n        cargo_toml = directory / 'Cargo.toml'\n        if not cargo_toml.is_file():\n            continue\n        try:\n            data = _load_toml(cargo_toml)\n        except Exception as exc:\n            raise RuntimeError(f'Failed to parse {cargo_toml}: {exc}') from exc\n\n        if 'workspace' in data:\n            # Found the workspace root\n            return {'workspace_root': str(directory)}\n        # If this Cargo.toml does not define a workspace, keep walking upward.\n\n    raise WorkspaceNotFoundError(f'No Cargo workspace root found starting from {current}')\n\n\nif __name__ == '__main__':\n    # Example CLI usage\n    try:\n        result = detect_workspace_root()\n        print(result['workspace_root'])\n    except Exception as e:\n        # Print to stderr to avoid interfering with JSON consumers\n        import sys\n        print(f'Error: {e}', file=sys.stderr)\n        sys.exit(1)\n",
            "usage": "from backend.workspace import detect_workspace_root\n\nresult = detect_workspace_root(start_dir='/path/to/project')\nworkspace_root = result['workspace_root']\n"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 adds a backend helper that parses the workspace Cargo.toml and returns the list of member contract packages, validating that each one looks like a CosmWasm contract.",
            "code": "from pathlib import Path\nfrom typing import List, Dict, Any, Optional\n\n\nclass WorkspaceMemberError(Exception):\n    '''Raised when a workspace member configuration is invalid.'''\n\n\ndef _resolve_workspace_root(workspace_root: Optional[str] = None) -> Path:\n    '''Resolve the workspace root directory, using detect_workspace_root if needed.\n\n    This helper builds on detect_workspace_root defined in step 1.\n    '''\n    if workspace_root:\n        root = Path(workspace_root).expanduser().resolve()\n    else:\n        info = detect_workspace_root()\n        root = Path(info['workspace_root']).resolve()\n\n    if not root.is_dir():\n        raise FileNotFoundError(f'Workspace root directory does not exist: {root}')\n    return root\n\n\ndef list_workspace_members(workspace_root: Optional[str] = None) -> dict:\n    '''Parse the workspace Cargo.toml and list member contract packages.\n\n    Each member is validated to ensure it has its own Cargo.toml and appears to\n    be a CosmWasm contract (lib.crate-type contains cdylib).\n\n    Args:\n        workspace_root: Optional explicit workspace root. If omitted, detect_workspace_root is used.\n\n    Returns:\n        Dict containing workspace_root, valid_members, and invalid_members.\n    '''\n    root = _resolve_workspace_root(workspace_root)\n    cargo_toml = root / 'Cargo.toml'\n\n    try:\n        data = _load_toml(cargo_toml)\n    except Exception as exc:\n        raise RuntimeError(f'Failed to parse root Cargo.toml at {cargo_toml}: {exc}') from exc\n\n    workspace = data.get('workspace')\n    if not isinstance(workspace, dict):\n        raise WorkspaceMemberError('Root Cargo.toml does not contain a valid [workspace] table.')\n\n    member_patterns = workspace.get('members', [])\n    if not isinstance(member_patterns, list) or not member_patterns:\n        raise WorkspaceMemberError('Workspace has no members defined under [workspace].')\n\n    valid_members: List[Dict[str, str]] = []\n    invalid_members: List[Dict[str, str]] = []\n\n    for pattern in member_patterns:\n        if not isinstance(pattern, str):\n            invalid_members.append(\n                {\n                    'pattern': repr(pattern),\n                    'reason': 'Workspace member pattern is not a string.',\n                }\n            )\n            continue\n\n        matches = list(root.glob(pattern))\n        if not matches:\n            invalid_members.append(\n                {\n                    'pattern': pattern,\n                    'reason': 'Workspace member pattern did not match any paths.',\n                }\n            )\n            continue\n\n        for member_dir in matches:\n            if not member_dir.is_dir():\n                invalid_members.append(\n                    {\n                        'path': str(member_dir),\n                        'reason': 'Matched workspace member is not a directory.',\n                    }\n                )\n                continue\n\n            member_cargo = member_dir / 'Cargo.toml'\n            if not member_cargo.is_file():\n                invalid_members.append(\n                    {\n                        'path': str(member_dir),\n                        'reason': 'Workspace member is missing Cargo.toml.',\n                    }\n                )\n                continue\n\n            try:\n                member_data = _load_toml(member_cargo)\n            except Exception as exc:\n                invalid_members.append(\n                    {\n                        'path': str(member_dir),\n                        'reason': f'Failed to parse Cargo.toml: {exc}',\n                    }\n                )\n                continue\n\n            pkg = member_data.get('package', {})\n            name = pkg.get('name', member_dir.name)\n\n            lib_cfg = member_data.get('lib')\n            is_valid_contract = False\n            failure_reason = ''\n\n            if isinstance(lib_cfg, dict):\n                crate_type = lib_cfg.get('crate-type') or lib_cfg.get('crate_type')\n                if isinstance(crate_type, list) and 'cdylib' in crate_type:\n                    is_valid_contract = True\n                else:\n                    failure_reason = 'lib.crate-type must contain cdylib for CosmWasm.'\n            else:\n                failure_reason = 'Missing [lib] section in contract Cargo.toml.'\n\n            if is_valid_contract:\n                valid_members.append(\n                    {\n                        'name': name,\n                        'path': str(member_dir),\n                    }\n                )\n            else:\n                invalid_members.append(\n                    {\n                        'name': name,\n                        'path': str(member_dir),\n                        'reason': failure_reason or 'Invalid CosmWasm contract configuration.',\n                    }\n                )\n\n    return {\n        'workspace_root': str(root),\n        'valid_members': valid_members,\n        'invalid_members': invalid_members,\n    }\n",
            "usage": "from backend.workspace import list_workspace_members\n\nmembers_info = list_workspace_members(workspace_root='/path/to/workspace')\nvalid_members = members_info['valid_members']\ninvalid_members = members_info['invalid_members']\n"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 runs the CosmWasm workspace-optimizer Docker image from the backend, building optimized wasm artifacts for all workspace members.",
            "code": "from pathlib import Path\nfrom typing import Optional\nimport subprocess\n\n\nclass OptimizerError(Exception):\n    '''Raised when the CosmWasm workspace optimizer fails.'''\n\n\ndef run_workspace_optimizer(\n    workspace_root: Optional[str] = None,\n    optimizer_image: str = 'cosmwasm/workspace-optimizer:0.13.0',\n    timeout: int = 1800,\n) -> dict:\n    '''Run the CosmWasm workspace-optimizer Docker image for the workspace.\n\n    Args:\n        workspace_root: Optional explicit workspace root. If omitted, detect_workspace_root is used.\n        optimizer_image: Docker image name for the workspace optimizer.\n        timeout: Maximum time in seconds to wait for the optimizer to finish.\n\n    Returns:\n        Dict with workspace_root, optimizer_image, stdout, stderr, and return_code.\n\n    Raises:\n        OptimizerError: If Docker is unavailable or the optimizer fails.\n    '''\n    # Reuse helper from step 2 to resolve the workspace root.\n    root = _resolve_workspace_root(workspace_root)\n\n    # Verify that Docker is available before trying to run the container.\n    try:\n        docker_check = subprocess.run(\n            ['docker', '--version'],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            check=False,\n        )\n    except FileNotFoundError as exc:\n        raise OptimizerError('Docker is not installed or not available in PATH.') from exc\n    except Exception as exc:\n        raise OptimizerError(f'Failed to run docker --version: {exc}') from exc\n\n    if docker_check.returncode != 0:\n        raise OptimizerError(f'Docker is not available: {docker_check.stderr.strip()}')\n\n    cmd = [\n        'docker',\n        'run',\n        '--rm',\n        '-v',\n        f'{str(root)}:/code',\n        '--mount',\n        f'type=volume,source={root.name}_cache,target=/code/target',\n        '--mount',\n        'type=volume,source=registry_cache,target=/usr/local/cargo/registry',\n        optimizer_image,\n    ]\n\n    try:\n        completed = subprocess.run(\n            cmd,\n            cwd=str(root),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            timeout=timeout,\n            check=False,\n        )\n    except subprocess.TimeoutExpired as exc:\n        raise OptimizerError(f'workspace-optimizer timed out after {timeout} seconds.') from exc\n    except Exception as exc:\n        raise OptimizerError(f'workspace-optimizer failed to start: {exc}') from exc\n\n    if completed.returncode != 0:\n        raise OptimizerError(\n            'workspace-optimizer failed with exit code '\n            f'{completed.returncode}: {completed.stderr.strip()}'\n        )\n\n    return {\n        'workspace_root': str(root),\n        'optimizer_image': optimizer_image,\n        'stdout': completed.stdout,\n        'stderr': completed.stderr,\n        'return_code': completed.returncode,\n    }\n",
            "usage": "from backend.workspace import run_workspace_optimizer\n\nresult = run_workspace_optimizer(workspace_root='/path/to/workspace')\nprint(result['stdout'])\n"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 inspects the artifacts/ directory, validates that each workspace member produced a non-empty, valid wasm file, and aggregates the success/failure lists.",
            "code": "from pathlib import Path\nfrom typing import Optional, List, Dict, Any\n\n\nclass ArtifactVerificationError(Exception):\n    '''Raised when expected wasm artifacts are missing or invalid.'''\n\n\ndef _is_valid_wasm(path: Path) -> bool:\n    '''Perform a basic sanity check on a wasm binary.\n\n    Checks that the file exists, is non-empty, and starts with the standard\n    WebAssembly magic header (0x00 0x61 0x73 0x6d).\n    '''\n    if not path.is_file():\n        return False\n    if path.stat().st_size == 0:\n        return False\n    try:\n        with path.open('rb') as f:\n            magic = f.read(4)\n        return magic == b'\\0asm'\n    except Exception:\n        return False\n\n\ndef collect_and_verify_wasm_outputs(\n    workspace_root: Optional[str] = None,\n    members: Optional[List[Dict[str, Any]]] = None,\n    artifacts_dir_name: str = 'artifacts',\n) -> dict:\n    '''Collect and validate wasm outputs for each workspace member.\n\n    Args:\n        workspace_root: Optional explicit workspace root. If omitted, detect_workspace_root is used.\n        members: Optional list of member metadata as returned by list_workspace_members.\n        artifacts_dir_name: Name of the directory under the workspace root where\n            optimized wasm artifacts are written.\n\n    Returns:\n        Dict with workspace_root, artifacts_dir, verified_contracts, failed_contracts.\n    '''\n    root = _resolve_workspace_root(workspace_root)\n    artifacts_dir = root / artifacts_dir_name\n\n    if not artifacts_dir.is_dir():\n        raise ArtifactVerificationError(f'Artifacts directory does not exist: {artifacts_dir}')\n\n    if members is None:\n        # Use helper from step 2 to discover members.\n        members_info = list_workspace_members(str(root))\n        members = members_info.get('valid_members', [])\n\n    verified: List[Dict[str, Any]] = []\n    failed: List[Dict[str, Any]] = []\n\n    for member in members:\n        name = member.get('name')\n        if not name:\n            failed.append({'member': member, 'reason': 'Missing contract name in member metadata.'})\n            continue\n\n        artifact_path = artifacts_dir / f'{name}.wasm'\n        if not artifact_path.is_file():\n            failed.append(\n                {\n                    'member': member,\n                    'artifact_path': str(artifact_path),\n                    'reason': 'Wasm artifact file is missing.',\n                }\n            )\n            continue\n\n        if not _is_valid_wasm(artifact_path):\n            failed.append(\n                {\n                    'member': member,\n                    'artifact_path': str(artifact_path),\n                    'reason': 'Wasm artifact failed basic validation (magic header or size).',\n                }\n            )\n            continue\n\n        verified.append(\n            {\n                'member': member,\n                'artifact_path': str(artifact_path),\n                'size_bytes': artifact_path.stat().st_size,\n            }\n        )\n\n    return {\n        'workspace_root': str(root),\n        'artifacts_dir': str(artifacts_dir),\n        'verified_contracts': verified,\n        'failed_contracts': failed,\n    }\n",
            "usage": "from backend.workspace import collect_and_verify_wasm_outputs, list_workspace_members\n\nmembers_info = list_workspace_members(workspace_root='/path/to/workspace')\nverification = collect_and_verify_wasm_outputs(\n    workspace_root='/path/to/workspace',\n    members=members_info['valid_members'],\n)\nprint('Verified:', verification['verified_contracts'])\nprint('Failed:', verification['failed_contracts'])\n"
        }
    ]
}