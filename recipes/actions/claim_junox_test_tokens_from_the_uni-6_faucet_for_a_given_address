{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Validate that the supplied value is a proper Bech32 Juno address before any on-chain or faucet interaction takes place.",
            "code": "/* utils/wallet.js */\nexport const validateJunoAddress = (address) => {\n  // Basic Bech32 pattern for Juno: \"juno1\" + 38 lowercase bech32 chars (total 42)\n  const regex = /^juno1[0-9a-z]{38}$/;\n\n  if (!regex.test(address)) {\n    throw new Error(\"Invalid Juno address format.\");\n  }\n  return true; // address is syntactically valid\n};",
            "usage": "try {\n  validateJunoAddress(userInputAddress);\n  // Continue to Step-2 if no error is thrown\n} catch (err) {\n  console.error(err.message);\n}"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Forward a credit request to the UNI (testnet) Juno faucet and return the raw faucet response.",
            "code": "'''api/faucet.py'''\nfrom fastapi import FastAPI, HTTPException\nimport httpx\n\napp = FastAPI()\nFAUCET_ENDPOINT = \"https://faucet.uni.junonetwork.io/credit\"\n\n@app.post(\"/api/faucet/credit\")\nasync def faucet_credit(payload: dict):\n    \"\"\"POST /api/faucet/credit { \"address\": \"juno1...\" } -> faucet JSON/text\"\"\"\n    address: str | None = payload.get(\"address\")\n\n    # Minimal server-side validation so we don\u2019t hammer the faucet with bad requests\n    if not address or not address.startswith(\"juno1\"):\n        raise HTTPException(status_code=400, detail=\"Invalid or missing Juno address.\")\n\n    url = f\"{FAUCET_ENDPOINT}?address={address}\"\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            faucet_resp = await client.post(url)\n    except httpx.RequestError as exc:\n        raise HTTPException(status_code=502, detail=f\"Faucet unreachable: {exc}\") from exc\n\n    if faucet_resp.status_code != 200:\n        raise HTTPException(status_code=faucet_resp.status_code, detail=faucet_resp.text)\n\n    # Return JSON when possible, fallback to raw text (some faucets return plain text)\n    try:\n        return faucet_resp.json()\n    except ValueError:\n        return {\"raw_response\": faucet_resp.text}\n",
            "usage": "// Frontend call example\nconst faucetRes = await fetch(\"/api/faucet/credit\", {\n  method: \"POST\",\n  headers: { \"Content-Type\": \"application/json\" },\n  body: JSON.stringify({ address })\n});\nconst faucetData = await faucetRes.json();"
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "Parse the faucet\u2019s response from Step-2 and try to extract a txHash or at least confirm success.",
            "code": "/* utils/faucet.js */\nexport const parseFaucetResponse = (data) => {\n  if (!data) throw new Error(\"Empty faucet response\");\n\n  // 1. Standard JSON key casing checks\n  const txHash = data.txhash || data.txHash;\n  if (txHash) return { success: true, txHash };\n\n  // 2. If faucet returned plain text, sniff for a 64-char hex hash\n  if (data.raw_response) {\n    const match = data.raw_response.match(/[0-9A-Fa-f]{64}/);\n    if (match) return { success: true, txHash: match[0] };\n  }\n\n  return { success: false };\n};",
            "usage": "const { success, txHash } = parseFaucetResponse(faucetData);\nconsole.log(success ? `Faucet txHash: ${txHash}` : \"Faucet request failed\");"
        },
        {
            "step": 4,
            "label": "frontend",
            "introduction": "After a short delay, query the Juno LCD to confirm the newly credited balance.",
            "code": "/* utils/bank.js */\nexport const queryJunoBalances = async (\n  address,\n  lcdUrl = \"https://lcd.uni.juno.deuslabs.fi\" // public LCD for UNI testnet\n) => {\n  // Optional delay to give the faucet tx time to be included in a block\n  await new Promise((res) => setTimeout(res, 5000));\n\n  const endpoint = `${lcdUrl}/cosmos/bank/v1beta1/balances/${address}`;\n  const resp = await fetch(endpoint);\n\n  if (!resp.ok) {\n    throw new Error(`LCD query failed: ${resp.status} ${resp.statusText}`);\n  }\n  const json = await resp.json();\n  return json.balances ?? [];\n};",
            "usage": "const balances = await queryJunoBalances(address);\nconsole.table(balances);"
        }
    ]
}