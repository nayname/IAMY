{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a backend helper that normalizes and validates the contract address, JSON query, and optional node configuration for a CosmWasm smart query.",
            "code": "import json\nimport os\nfrom dataclasses import dataclass\nfrom typing import Any, Dict, Optional\n\nDEFAULT_LCD_URL = 'https://lcd-archive.junonetwork.io'\n\n@dataclass\nclass NodeConfig:\n    lcd_url: str = DEFAULT_LCD_URL\n    rpc_url: Optional[str] = None\n    chain_id: Optional[str] = None\n    keyring_backend: Optional[str] = None\n\n@dataclass\nclass SmartQueryParameters:\n    contract_address: str\n    query: Dict[str, Any]\n    node: NodeConfig\n\ndef collect_query_parameters(payload: Dict[str, Any]) -> SmartQueryParameters:\n    '''\n    Normalize and validate inputs for a CosmWasm smart contract query.\n\n    Args:\n        payload: Dictionary typically obtained from an HTTP request body,\n                 e.g. {\n                     'contract_address': 'juno1...',\n                     'query': {'config': {}},\n                     'lcd_url': '...',        # optional\n                     'rpc_url': '...',        # optional\n                     'chain_id': 'juno-1',    # optional, mostly for CLI\n                     'keyring_backend': 'os'  # optional, mostly for CLI\n                 }\n\n    Returns:\n        SmartQueryParameters with sensible defaults applied.\n\n    Raises:\n        ValueError if required fields are missing or invalid.\n    '''\n    if not isinstance(payload, dict):\n        raise ValueError('payload must be a dict')\n\n    contract_address = payload.get('contract_address')\n    if not isinstance(contract_address, str) or not contract_address:\n        raise ValueError('contract_address (bech32) is required and must be a non-empty string')\n\n    raw_query = payload.get('query')\n    if raw_query is None:\n        raise ValueError('query is required (e.g. {config: {}})')\n\n    # Allow query to be provided as JSON string or already-parsed dict\n    if isinstance(raw_query, str):\n        try:\n            query_obj = json.loads(raw_query)\n        except json.JSONDecodeError as exc:\n            raise ValueError(f'query string must be valid JSON: {exc}') from exc\n    elif isinstance(raw_query, dict):\n        query_obj = raw_query\n    else:\n        raise ValueError('query must be either a dict or a JSON string')\n\n    lcd_url = (\n        payload.get('lcd_url')\n        or os.getenv('JUNO_LCD_URL')\n        or DEFAULT_LCD_URL\n    )\n\n    rpc_url = payload.get('rpc_url') or os.getenv('JUNO_RPC_URL')\n    chain_id = payload.get('chain_id') or os.getenv('JUNO_CHAIN_ID')\n    keyring_backend = payload.get('keyring_backend') or os.getenv('JUNO_KEYRING_BACKEND')\n\n    node_cfg = NodeConfig(\n        lcd_url=lcd_url,\n        rpc_url=rpc_url,\n        chain_id=chain_id,\n        keyring_backend=keyring_backend,\n    )\n\n    return SmartQueryParameters(\n        contract_address=contract_address,\n        query=query_obj,\n        node=node_cfg,\n    )",
            "usage": "params = collect_query_parameters({'contract_address': 'juno1contract...', 'query': {'config': {}}})"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 serializes the JSON query into minified bytes and base64-encodes it to produce query_data suitable for the LCD smart query path parameter.",
            "code": "import json\nimport base64\nfrom typing import Any, Dict\n\ndef encode_smart_query_for_lcd(query: Dict[str, Any]) -> str:\n    '''\n    Serialize and base64-encode the query for use in the LCD smart query path.\n\n    CosmWasm LCD expects the path parameter {query_data} to be a base64 encoding\n    of the raw JSON bytes of the query message.\n\n    Args:\n        query: Python dict representing the JSON query (e.g. {'config': {}}).\n\n    Returns:\n        Base64-encoded string suitable for insertion into the LCD path.\n    '''\n    if not isinstance(query, dict):\n        raise ValueError('query must be a dict representing the JSON payload')\n\n    try:\n        # Minified JSON string (no extra whitespace)\n        json_str = json.dumps(query, separators=(',', ':'), ensure_ascii=False)\n    except (TypeError, ValueError) as exc:\n        raise ValueError(f'query could not be serialized to JSON: {exc}') from exc\n\n    json_bytes = json_str.encode('utf-8')\n    b64 = base64.b64encode(json_bytes).decode('ascii')\n    return b64",
            "usage": "encoded_query = encode_smart_query_for_lcd(params.query)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 performs an HTTP GET to Juno's LCD at /cosmwasm/wasm/v1/contract/{address}/smart/{query_data} using the base64-encoded query and returns the raw LCD JSON body.",
            "code": "import requests\nfrom typing import Dict, Any\nfrom urllib.parse import quote\n\nDEFAULT_LCD_URL = 'https://lcd-archive.junonetwork.io'\n\ndef http_get_contract_smart_state(\n    contract_address: str,\n    query_data_b64: str,\n    lcd_url: str = DEFAULT_LCD_URL,\n    timeout: float = 10.0,\n) -> Dict[str, Any]:\n    '''\n    Perform an HTTP GET against Juno's LCD smart contract endpoint.\n\n    Args:\n        contract_address: Bech32 address of the CosmWasm contract.\n        query_data_b64: Base64-encoded query message (output of encode_smart_query_for_lcd).\n        lcd_url: Base URL of the LCD; defaults to Juno's archival LCD.\n        timeout: Request timeout in seconds.\n\n    Returns:\n        Parsed JSON response from the LCD (as a Python dict).\n\n    Raises:\n        ValueError for obvious input issues or unexpected response shape.\n        requests.RequestException for network-related errors.\n        requests.HTTPError for non-2xx HTTP responses.\n    '''\n    if not contract_address or not isinstance(contract_address, str):\n        raise ValueError('contract_address must be a non-empty string')\n\n    if not query_data_b64 or not isinstance(query_data_b64, str):\n        raise ValueError('query_data_b64 must be a non-empty base64 string')\n\n    base = lcd_url.rstrip('/')\n    encoded_addr = quote(contract_address, safe='')\n    encoded_query = quote(query_data_b64, safe='')\n\n    url = f'{base}/cosmwasm/wasm/v1/contract/{encoded_addr}/smart/{encoded_query}'\n\n    try:\n        resp = requests.get(url, timeout=timeout)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        # Wrap network errors with more context\n        raise requests.RequestException(f'Failed GET {url}: {exc}') from exc\n\n    try:\n        body = resp.json()\n    except ValueError as exc:\n        raise ValueError(f'LCD response was not valid JSON: {exc}; raw={resp.text!r}') from exc\n\n    # The documented response shape is {'data': '<base64_bytes>'}\n    if 'data' not in body:\n        raise ValueError(f'Unexpected LCD response; missing data field: {body}')\n\n    return body",
            "usage": "lcd_response = http_get_contract_smart_state(params.contract_address, encoded_query, params.node.lcd_url)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 decodes the LCD response's base64-encoded data field and interprets it as UTF-8 JSON when possible, yielding the actual smart query result.",
            "code": "import base64\nimport json\nfrom typing import Any, Dict, Union\n\ndef decode_lcd_smart_query_response(lcd_response: Dict[str, Any]) -> Union[Any, bytes]:\n    '''\n    Decode the `data` field from the LCD smart query response.\n\n    The LCD returns a base64-encoded byte array under the `data` field.\n    CosmWasm smart contract queries typically encode JSON as UTF-8 bytes.\n\n    Args:\n        lcd_response: Dict returned by http_get_contract_smart_state.\n\n    Returns:\n        Parsed JSON object if the decoded bytes are valid UTF-8 JSON;\n        otherwise the raw bytes.\n\n    Raises:\n        KeyError if `data` is missing.\n        ValueError if the base64 payload cannot be decoded.\n    '''\n    if not isinstance(lcd_response, dict):\n        raise ValueError('lcd_response must be a dict')\n\n    if 'data' not in lcd_response:\n        raise KeyError('lcd_response is missing required data field')\n\n    b64_data = lcd_response['data']\n    if not isinstance(b64_data, str):\n        raise ValueError('data field must be a base64 string')\n\n    try:\n        raw_bytes = base64.b64decode(b64_data)\n    except (ValueError, TypeError) as exc:\n        raise ValueError(f'Failed to base64-decode LCD data field: {exc}') from exc\n\n    # Attempt to interpret as UTF-8 JSON, fallback to raw bytes if that fails.\n    try:\n        text = raw_bytes.decode('utf-8')\n        return json.loads(text)\n    except (UnicodeDecodeError, json.JSONDecodeError):\n        return raw_bytes",
            "usage": "decoded_result = decode_lcd_smart_query_response(lcd_response)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 optionally executes the same smart query via the local junod CLI, which uses the RPC endpoint and chain-id, and parses the JSON output.",
            "code": "import json\nimport subprocess\nfrom typing import Any, Dict, Optional\n\ndef execute_junod_cli_smart_query(\n    contract_address: str,\n    query: Dict[str, Any],\n    rpc_endpoint: Optional[str],\n    chain_id: Optional[str],\n    junod_binary: str = 'junod',\n) -> Dict[str, Any]:\n    '''\n    Optionally execute the smart query via the local `junod` CLI.\n\n    This is useful in environments where the CLI is installed and configured,\n    either as the primary query mechanism or to cross-check LCD results.\n\n    Args:\n        contract_address: Bech32 address of the CosmWasm contract.\n        query: Dict representing the JSON query (e.g. {'config': {}}).\n        rpc_endpoint: RPC endpoint to reach the node (e.g. 'http://localhost:26657').\n        chain_id: Target chain-id (e.g. 'juno-1').\n        junod_binary: Name or path of the junod binary.\n\n    Returns:\n        Parsed JSON output from the CLI (as a Python dict).\n\n    Raises:\n        RuntimeError if the CLI is not available or returns a non-zero exit code\n        or if the output cannot be parsed as JSON.\n        ValueError for obvious input issues.\n    '''\n    if not contract_address or not isinstance(contract_address, str):\n        raise ValueError('contract_address must be a non-empty string')\n\n    if not isinstance(query, dict):\n        raise ValueError('query must be a dict representing the JSON payload')\n\n    if not rpc_endpoint or not chain_id:\n        raise ValueError('rpc_endpoint and chain_id are required to run junod CLI queries')\n\n    try:\n        query_str = json.dumps(query, separators=(',', ':'), ensure_ascii=False)\n    except (TypeError, ValueError) as exc:\n        raise ValueError(f'query could not be serialized to JSON: {exc}') from exc\n\n    cmd = [\n        junod_binary,\n        'query',\n        'wasm',\n        'contract-state',\n        'smart',\n        contract_address,\n        query_str,\n        '--node',\n        rpc_endpoint,\n        '--chain-id',\n        chain_id,\n        '--output',\n        'json',\n    ]\n\n    try:\n        completed = subprocess.run(\n            cmd,\n            check=False,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError as exc:\n        raise RuntimeError(f'junod binary not found: {junod_binary}') from exc\n    except Exception as exc:\n        raise RuntimeError(f'Failed to execute junod CLI: {exc}') from exc\n\n    if completed.returncode != 0:\n        stderr = completed.stderr.strip()\n        stdout = completed.stdout.strip()\n        stdout_display = stdout or '<empty>'\n        stderr_display = stderr or '<empty>'\n        raise RuntimeError(\n            'junod query failed with exit code '\n            f'{completed.returncode}. '\n            f'STDOUT: {stdout_display} STDERR: {stderr_display}'\n        )\n\n    try:\n        cli_output = json.loads(completed.stdout)\n    except json.JSONDecodeError as exc:\n        raise RuntimeError(\n            f'Failed to parse junod JSON output: {exc}; raw={completed.stdout!r}'\n        ) from exc\n\n    return cli_output",
            "usage": "cli_response = execute_junod_cli_smart_query(params.contract_address, params.query, params.node.rpc_url, params.node.chain_id)"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 compares the decoded LCD result with the junod CLI response (after decoding its data field) and raises a detailed error if they diverge.",
            "code": "import base64\nimport json\nfrom typing import Any, Dict\n\ndef compare_cli_and_lcd_results(\n    lcd_decoded_result: Any,\n    lcd_raw_response: Dict[str, Any],\n    cli_response: Dict[str, Any],\n) -> Dict[str, Any]:\n    '''\n    Compare decoded LCD smart query result with parsed junod CLI response.\n\n    Args:\n        lcd_decoded_result: Output of decode_lcd_smart_query_response (inner contract result).\n        lcd_raw_response: Raw dict returned by http_get_contract_smart_state.\n        cli_response: Parsed JSON dict returned by execute_junod_cli_smart_query.\n\n    Returns:\n        Dict with keys:\n            'match': bool\n            'lcd': decoded LCD result\n            'cli': decoded CLI result (inner contract result)\n\n    Raises:\n        ValueError if the decoded inner results differ or if the CLI response is malformed.\n    '''\n    if not isinstance(cli_response, dict):\n        raise ValueError('cli_response must be a dict')\n\n    if 'data' not in cli_response:\n        raise ValueError(f'CLI response is missing data field: {cli_response}')\n\n    data_field = cli_response['data']\n    if not isinstance(data_field, str):\n        raise ValueError('data field of CLI response must be a base64 string')\n\n    try:\n        cli_bytes = base64.b64decode(data_field)\n    except (ValueError, TypeError) as exc:\n        raise ValueError(f'Failed to base64-decode CLI data field: {exc}') from exc\n\n    try:\n        cli_text = cli_bytes.decode('utf-8')\n        cli_decoded = json.loads(cli_text)\n    except (UnicodeDecodeError, json.JSONDecodeError):\n        cli_decoded = cli_bytes\n\n    if lcd_decoded_result != cli_decoded:\n        # Include both for debugging\n        raise ValueError(\n            'LCD and junod CLI smart query results differ. '\n            f'Decoded LCD result: {lcd_decoded_result!r} '\n            f'Decoded CLI result: {cli_decoded!r} '\n            f'Raw LCD response: {lcd_raw_response!r} '\n            f'Raw CLI response: {cli_response!r}'\n        )\n\n    return {\n        'match': True,\n        'lcd': lcd_decoded_result,\n        'cli': cli_decoded,\n    }",
            "usage": "comparison = compare_cli_and_lcd_results(decoded_result, lcd_response, cli_response)"
        }
    ]
}