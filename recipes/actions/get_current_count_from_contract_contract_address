{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a backend helper that resolves the counter contract's bech32 address either from an explicit parameter or from the CONTRACT_ADDRESS environment variable, with basic validation.",
            "code": "import os\nfrom typing import Optional\n\n\ndef resolve_contract_address(explicit_address: Optional[str] = None, env_var_name: str = 'CONTRACT_ADDRESS') -> str:\n    '''Resolve the target counter contract's bech32 address.\n\n    Priority:\n    1. If explicit_address is provided, return it.\n    2. Otherwise, read from the given environment variable.\n    '''\n    if explicit_address:\n        contract_address = explicit_address\n    else:\n        contract_address = os.getenv(env_var_name)\n\n    if not contract_address:\n        raise ValueError(\n            f'No contract address provided and environment variable {env_var_name} is not set.'\n        )\n\n    # Basic sanity check for a Juno contract address (bech32 prefix)\n    if not contract_address.startswith('juno1'):\n        raise ValueError(\n            f'Resolved contract address {contract_address} does not look like a Juno bech32 address.'\n        )\n\n    return contract_address\n",
            "usage": "from my_module import resolve_contract_address\n\ncontract_address = resolve_contract_address()  # Or resolve_contract_address(explicit_address='juno1...')"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 builds the standard counter contract query payload {\"get_count\": {}} and base64-encodes it to produce the query_data path segment.",
            "code": "import base64\nimport json\n\n\ndef build_get_count_query_payload() -> str:\n    '''Construct the JSON query {\"get_count\": {}} and return it as a base64-encoded string.\n\n    The returned value is suitable for the {query_data} path parameter in the\n    /cosmwasm/wasm/v1/contract/{address}/smart/{query_data} endpoint.\n    '''\n    query_obj = {'get_count': {}}\n\n    try:\n        # Compact JSON encoding is fine; the contract only cares about semantic content.\n        json_bytes = json.dumps(query_obj, separators=(',', ':'), ensure_ascii=False).encode('utf-8')\n    except (TypeError, ValueError) as e:\n        # This should not happen for the static payload, but we fail clearly if it does.\n        raise ValueError(f'Failed to serialize get_count query JSON: {e}') from e\n\n    encoded = base64.b64encode(json_bytes).decode('ascii')\n    return encoded\n",
            "usage": "from my_module import build_get_count_query_payload\n\nquery_data_b64 = build_get_count_query_payload()"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 performs the LCD smart contract query by calling the Juno LCD endpoint /cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_data} and returns the parsed JSON response.",
            "code": "import requests\nfrom urllib.parse import quote\nfrom typing import Any, Dict\n\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\ndef lcd_query_wasm_smart(contract_address: str, query_data_b64: str, timeout: float = 10.0) -> Dict[str, Any]:\n    '''Call the Juno LCD smart query endpoint for a CosmWasm contract.\n\n    Args:\n        contract_address: Bech32 address of the target contract.\n        query_data_b64: Base64-encoded JSON query payload (as returned by build_get_count_query_payload).\n        timeout: Optional HTTP timeout in seconds.\n\n    Returns:\n        The decoded JSON body from the LCD, which should contain a 'data' field\n        that is itself a base64-encoded contract response, per Juno LCD schema.\n    '''\n    if not contract_address:\n        raise ValueError('contract_address is required')\n    if not query_data_b64:\n        raise ValueError('query_data_b64 is required')\n\n    # Ensure the base64 string is safe to embed in a URL path.\n    query_data_escaped = quote(query_data_b64, safe='')\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_data_escaped}'\n\n    try:\n        response = requests.get(url, timeout=timeout)\n    except requests.RequestException as e:\n        raise RuntimeError(f'Failed to reach LCD endpoint {url}: {e}') from e\n\n    if response.status_code != 200:\n        raise RuntimeError(\n            f'LCD query failed with status {response.status_code}: {response.text}'\n        )\n\n    try:\n        data = response.json()\n    except ValueError as e:\n        raise RuntimeError(\n            f'LCD response is not valid JSON: {e}. Raw body: {response.text}'\n        ) from e\n\n    # Per /cosmwasm/wasm/v1/contract/{address}/smart/{query_data} schema, we expect a top-level \"data\" field.\n    if 'data' not in data:\n        raise KeyError(f\"LCD JSON response is missing required 'data' field: {data}\")\n\n    return data\n",
            "usage": "from my_module import lcd_query_wasm_smart\n\nlcd_response = lcd_query_wasm_smart(contract_address=contract_address, query_data_b64=query_data_b64)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 decodes the base64-encoded 'data' field from the LCD response, parses the embedded JSON, and extracts the 'count' value as an integer.",
            "code": "import base64\nimport json\nfrom typing import Any, Dict\n\n\ndef decode_and_extract_count(lcd_response: Dict[str, Any]) -> int:\n    '''Decode the LCD smart-query response and extract the counter value.\n\n    Args:\n        lcd_response: JSON object returned by lcd_query_wasm_smart, expected to\n            contain a base64-encoded 'data' field.\n\n    Returns:\n        The 'count' field from the decoded contract response, coerced to int.\n    '''\n    if 'data' not in lcd_response:\n        raise KeyError(\"lcd_response does not contain required 'data' field\")\n\n    data_b64 = lcd_response['data']\n    if not isinstance(data_b64, str):\n        raise TypeError(\n            f\"lcd_response['data'] must be a base64-encoded string, got {type(data_b64)}\"\n        )\n\n    try:\n        raw_bytes = base64.b64decode(data_b64)\n    except (base64.binascii.Error, ValueError) as e:\n        raise ValueError(f\"Failed to base64-decode lcd_response['data']: {e}\") from e\n\n    try:\n        payload = json.loads(raw_bytes.decode('utf-8'))\n    except (UnicodeDecodeError, json.JSONDecodeError) as e:\n        raise ValueError(\n            f'Decoded contract response is not valid UTF-8 JSON: {e}. Raw bytes: {raw_bytes!r}'\n        ) from e\n\n    if 'count' not in payload:\n        raise KeyError(f\"Contract query result does not contain 'count' field: {payload}\")\n\n    count_value = payload['count']\n    try:\n        return int(count_value)\n    except (TypeError, ValueError) as e:\n        raise ValueError(f\"Contract 'count' field is not an integer: {count_value!r}\") from e\n",
            "usage": "from my_module import decode_and_extract_count\n\ncurrent_count = decode_and_extract_count(lcd_response)\n# current_count now holds the counter value as an int"
        }
    ]
}