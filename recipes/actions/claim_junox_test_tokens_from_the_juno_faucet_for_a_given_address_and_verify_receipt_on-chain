{
    "label": "query_balance",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Validate that a provided string is a well-formed Juno bech32 account address with the expected human-readable prefix (HRP), typically \"juno\" for both mainnet and uni-6.",
            "code": "from typing import Dict\n\ntry:\n    # Requires the 'bech32' package: pip install bech32\n    from bech32 import bech32_decode\nexcept ImportError as exc:\n    raise ImportError(\"The 'bech32' package is required for address validation. Install it with 'pip install bech32'.\") from exc\n\n\ndef validate_juno_address_format(address: str, expected_prefix: str = \"juno\") -> Dict[str, str]:\n    \"\"\"Validate that 'address' is a proper Juno bech32 account address.\n\n    Returns a dict with:\n      - is_valid: \"true\" or \"false\" (as strings for JSON friendliness)\n      - error: error message when invalid, empty string when valid\n\n    This function only checks format, prefix, and checksum; it does not\n    check on-chain existence of the account.\n    \"\"\"\n    result = {\"is_valid\": \"false\", \"error\": \"\"}\n\n    if not isinstance(address, str) or not address:\n        result[\"error\"] = \"Address must be a non-empty string.\"\n        return result\n\n    # Basic length sanity check (Cosmos addresses are usually ~45 chars)\n    if len(address) < 10 or len(address) > 90:\n        result[\"error\"] = \"Address length is not within the expected range.\"\n        return result\n\n    try:\n        hrp, data = bech32_decode(address)\n    except Exception as e:  # bech32_decode is usually safe, but we guard anyway\n        result[\"error\"] = f\"Invalid bech32 encoding: {e}\"\n        return result\n\n    # bech32_decode returns (None, None) on invalid input in most implementations\n    if hrp is None or data is None:\n        result[\"error\"] = \"Invalid bech32 address or checksum.\"\n        return result\n\n    if hrp != expected_prefix:\n        result[\"error\"] = f\"Invalid address prefix: expected '{expected_prefix}', got '{hrp}'.\"\n        return result\n\n    # Optionally, enforce a minimum data length to avoid obviously malformed addresses\n    if len(data) == 0:\n        result[\"error\"] = \"Bech32 data part is empty; address is malformed.\"\n        return result\n\n    # If we reach here, the address is considered valid\n    result[\"is_valid\"] = \"true\"\n    result[\"error\"] = \"\"\n    return result\n",
            "usage": "In your backend route handler (e.g., FastAPI/Flask), call:\n\nresult = validate_juno_address_format(address)\nif result[\"is_valid\"] == \"false\":\n    # Return HTTP 400 with result[\"error\"]\n    ..."
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Query the current JUNOX (ujunox) balance for a given Juno address from the Juno LCD and record the pre-faucet amount.",
            "code": "import httpx\nfrom typing import Dict\n\nLCD_BASE = \"https://lcd-archive.junonetwork.io\"\n\n\nasync def query_junox_balance_before_faucet(address: str, denom: str = \"ujunox\", lcd_base: str = LCD_BASE) -> Dict:\n    \"\"\"Query the JUNOX balance for 'address' before using the faucet.\n\n    Uses the endpoint:\n      GET {LCD_BASE}/cosmos/bank/v1beta1/balances/{address}/by_denom?denom=ujunox\n\n    Returns a dict:\n      {\n        \"address\": str,\n        \"denom\": str,\n        \"amount\": int,  # micro-denom units (e.g., ujunox)\n      }\n\n    Raises RuntimeError on network or protocol errors.\n    \"\"\"\n    if not address:\n        raise ValueError(\"Address is required to query balance.\")\n\n    url = f\"{lcd_base}/cosmos/bank/v1beta1/balances/{address}/by_denom\"\n    params = {\"denom\": denom}\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            resp = await client.get(url, params=params)\n    except httpx.RequestError as e:\n        raise RuntimeError(f\"Error querying Juno LCD: {e}\") from e\n\n    if resp.status_code != 200:\n        raise RuntimeError(\n            f\"LCD returned HTTP {resp.status_code} when querying balance: {resp.text}\"\n        )\n\n    data = resp.json()\n    balance = data.get(\"balance\")\n\n    # If no balance object is present, treat as zero\n    if balance is None:\n        amount_str = \"0\"\n        resp_denom = denom\n    else:\n        amount_str = balance.get(\"amount\", \"0\")\n        resp_denom = balance.get(\"denom\", denom)\n\n    if resp_denom != denom:\n        raise RuntimeError(f\"Unexpected denom in LCD response: {resp_denom} (expected {denom})\")\n\n    try:\n        amount_int = int(amount_str)\n    except ValueError as e:\n        raise RuntimeError(f\"Invalid amount format in LCD response: {amount_str}\") from e\n\n    return {\n        \"address\": address,\n        \"denom\": denom,\n        \"amount\": amount_int,\n    }\n",
            "usage": "From your frontend, call a backend endpoint that wraps this function, for example:\n\n// Frontend JavaScript\nconst res = await fetch(`/api/juno/pre_faucet_balance?address=${encodeURIComponent(address)}`);\nconst json = await res.json();\n// json.amount contains the pre-faucet ujunox balance as an integer."
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "Open the official Juno uni-6 faucet web UI in a new browser tab or window, using a faucet URL provided via configuration.",
            "code": "export const openJunoFaucetUI = (faucetUrl) => {\n  // 'faucetUrl' should be configured in your environment, e.g.\n  // process.env.NEXT_PUBLIC_JUNO_UNI6_FAUCET_URL\n  if (typeof window === 'undefined') {\n    throw new Error('Cannot open faucet UI: window is not available (are you on the server?).');\n  }\n\n  if (!faucetUrl || typeof faucetUrl !== 'string') {\n    throw new Error('Faucet URL is not configured or is invalid.');\n  }\n\n  try {\n    const newWindow = window.open(faucetUrl, '_blank', 'noopener,noreferrer');\n\n    if (!newWindow) {\n      // Pop-up may be blocked by the browser\n      throw new Error('Failed to open the faucet UI. Please allow pop-ups for this site.');\n    }\n  } catch (err) {\n    console.error('Error opening Juno faucet UI:', err);\n    throw err;\n  }\n};\n",
            "usage": "// Example in a React component event handler\n\nopenJunoFaucetUI(process.env.NEXT_PUBLIC_JUNO_UNI6_FAUCET_URL);",
            "introduction_additional": "This step assumes the actual faucet URL (for the correct environment such as uni-6) is provided externally via configuration."
        },
        {
            "step": 4,
            "label": "frontend",
            "introduction": "Guide the user to request faucet tokens in the opened faucet UI, ensuring a valid address is provided and surfacing any faucet-side errors to the user.",
            "code": "export const instructUserToRequestFaucetTokens = (address, denomLabel = 'JUNOX') => {\n  if (typeof window === 'undefined') {\n    throw new Error('Cannot show faucet instructions: window is not available (are you on the server?).');\n  }\n\n  if (!address || typeof address !== 'string') {\n    throw new Error('A valid Juno address is required before requesting faucet tokens.');\n  }\n\n  // This function does not attempt to automate the official faucet UI,\n  // because it is a separate web application and its implementation\n  // can change. Instead, we give clear instructions to the user.\n  const message = [\n    'A faucet window/tab should now be open.',\n    `1. Paste this address into the faucet address field: ${address}`,\n    `2. Select the token type (e.g., ${denomLabel}).`,\n    '3. Submit the request and wait for the faucet to confirm or show an error.',\n    '4. If you see errors such as rate limiting or daily limits, follow the faucet instructions or try again later.'\n  ].join('\\n');\n\n  // You can replace this alert with rendering a modal or in-app message.\n  window.alert(message);\n};\n",
            "usage": "// After calling openJunoFaucetUI, you might call:\n\ninstructUserToRequestFaucetTokens(userAddress, 'JUNOX');\n\n// In a real app, replace window.alert with a custom UI component\n// that shows these instructions next to your faucet button."
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Optionally poll the Juno LCD for a faucet transaction hash until it is successfully included in a block (tx_response.code == 0), fails, or a timeout is reached.",
            "code": "import asyncio\nimport httpx\nfrom typing import Dict, Any\n\nLCD_BASE = \"https://lcd-archive.junonetwork.io\"\n\n\nasync def poll_faucet_tx_until_final(\n    tx_hash: str,\n    lcd_base: str = LCD_BASE,\n    timeout_seconds: float = 60.0,\n    poll_interval_seconds: float = 2.0,\n) -> Dict[str, Any]:\n    \"\"\"Poll the LCD /cosmos/tx/v1beta1/txs/{hash} endpoint for a faucet tx.\n\n    Returns a dict of the form:\n      {\n        \"status\": \"success\" | \"failed\" | \"timeout\",\n        \"response\": <last LCD JSON or error info>,\n      }\n\n    - status == \"success\" when tx_response.code == 0\n    - status == \"failed\"  when tx_response.code != 0\n    - status == \"timeout\" when no final result was observed before timeout\n    \"\"\"\n    if not tx_hash:\n        raise ValueError(\"tx_hash is required to poll transaction status.\")\n\n    url = f\"{lcd_base}/cosmos/tx/v1beta1/txs/{tx_hash}\"\n    end_time = asyncio.get_event_loop().time() + timeout_seconds\n\n    last_response: Any = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            try:\n                resp = await client.get(url)\n            except httpx.RequestError as e:\n                # Network or connectivity error; record and continue polling until timeout\n                last_response = {\"error\": f\"Request error: {e}\"}\n            else:\n                if resp.status_code == 200:\n                    data = resp.json()\n                    last_response = data\n                    tx_resp = data.get(\"tx_response\")\n\n                    # If the tx is not yet indexed, tx_response may be missing\n                    if tx_resp is not None:\n                        try:\n                            code = int(tx_resp.get(\"code\", 0))\n                        except (TypeError, ValueError):\n                            code = 0\n\n                        if code == 0:\n                            return {\"status\": \"success\", \"response\": data}\n                        else:\n                            return {\"status\": \"failed\", \"response\": data}\n                else:\n                    # 404 or other non-200 status might mean the tx is not yet known\n                    last_response = {\n                        \"http_status\": resp.status_code,\n                        \"body\": resp.text,\n                    }\n\n            if asyncio.get_event_loop().time() >= end_time:\n                return {\"status\": \"timeout\", \"response\": last_response}\n\n            await asyncio.sleep(poll_interval_seconds)\n",
            "usage": "From your backend, once the faucet service returns a tx hash, call:\n\nresult = await poll_faucet_tx_until_final(tx_hash)\n\n# Then map result[\"status\"] to an appropriate HTTP response.\n# From the frontend you might call a backend endpoint like:\n// const res = await fetch(`/api/juno/poll_faucet_tx?hash=${encodeURIComponent(txHash)}`);\n// const json = await res.json();"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "After the faucet indicates success (or after a delay), query the JUNOX balance again and compare it with the pre-faucet amount to confirm that tokens were received.",
            "code": "from typing import Dict\n\n# Reuse LCD_BASE and the same query helper as in step 2.\nimport httpx\n\nLCD_BASE = \"https://lcd-archive.junonetwork.io\"\n\n\nasync def _query_junox_balance(address: str, denom: str = \"ujunox\", lcd_base: str = LCD_BASE) -> int:\n    \"\"\"Internal helper to query the JUNOX balance and return the amount as int.\"\"\"\n    url = f\"{lcd_base}/cosmos/bank/v1beta1/balances/{address}/by_denom\"\n    params = {\"denom\": denom}\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        resp = await client.get(url, params=params)\n\n    if resp.status_code != 200:\n        raise RuntimeError(\n            f\"LCD returned HTTP {resp.status_code} when querying balance: {resp.text}\"\n        )\n\n    data = resp.json()\n    balance = data.get(\"balance\")\n\n    if balance is None:\n        amount_str = \"0\"\n        resp_denom = denom\n    else:\n        amount_str = balance.get(\"amount\", \"0\")\n        resp_denom = balance.get(\"denom\", denom)\n\n    if resp_denom != denom:\n        raise RuntimeError(f\"Unexpected denom in LCD response: {resp_denom} (expected {denom})\")\n\n    try:\n        return int(amount_str)\n    except ValueError as e:\n        raise RuntimeError(f\"Invalid amount format in LCD response: {amount_str}\") from e\n\n\nasync def compare_junox_balance_after_faucet(\n    address: str,\n    pre_faucet_amount: int,\n    denom: str = \"ujunox\",\n    lcd_base: str = LCD_BASE,\n) -> Dict:\n    \"\"\"Query JUNOX balance after faucet and compare with pre-faucet amount.\n\n    Args:\n      address: Juno bech32 address.\n      pre_faucet_amount: The amount (int, micro-denom) recorded before faucet.\n\n    Returns:\n      {\n        \"address\": str,\n        \"denom\": str,\n        \"pre_amount\": int,\n        \"post_amount\": int,\n        \"delta\": int,  # tokens added (may be 0 if faucet failed)\n      }\n    \"\"\"\n    if pre_faucet_amount is None:\n        raise ValueError(\"pre_faucet_amount must be provided (from step 2).\")\n\n    post_amount = await _query_junox_balance(address, denom=denom, lcd_base=lcd_base)\n    delta = post_amount - int(pre_faucet_amount)\n\n    return {\n        \"address\": address,\n        \"denom\": denom,\n        \"pre_amount\": int(pre_faucet_amount),\n        \"post_amount\": post_amount,\n        \"delta\": delta,\n    }\n",
            "usage": "From your backend, after the faucet transaction is confirmed or after a delay, call:\n\ncomparison = await compare_junox_balance_after_faucet(address, pre_faucet_amount)\n\n# Then return 'comparison' as JSON to the frontend.\n// On the frontend you might do:\n// const res = await fetch(`/api/juno/post_faucet_balance?address=${encodeURIComponent(address)}&pre=${preFaucetAmount}`);\n// const json = await res.json();\n// json.delta > 0 indicates that faucet tokens were successfully received."
        }
    ]
}