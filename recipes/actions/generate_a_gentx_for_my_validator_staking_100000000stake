{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "This Python helper verifies that the `my_validator` key exists in the local keyring (test backend). If the key is missing it automatically creates it and, on success, returns the address and mnemonic.",
            "code": "import os\nimport subprocess\nimport json\n\n# Environment-driven configuration so the same code works for any chain binary\nCHAIN_BINARY = os.getenv(\"CHAIN_BINARY\", \"neutrond\")  # e.g. \"gaiad\", \"junod\", etc.\nKEY_HOME = os.getenv(\"KEY_HOME\", os.path.expanduser(\"~/.neutrond\"))\nKEYRING_BACKEND = os.getenv(\"KEYRING_BACKEND\", \"test\")\n\ndef ensure_key_exists(key_name: str) -> dict:\n    \"\"\"\n    Ensure a key with `key_name` is present in the local keyring. If the key is\n    absent, it is created. The function returns a status dictionary describing\n    what happened.\n    \"\"\"\n    try:\n        # Attempt to show the key; success means it already exists.\n        cmd_show = [\n            CHAIN_BINARY,\n            \"keys\",\n            \"show\",\n            key_name,\n            \"--output\",\n            \"json\",\n            \"--keyring-backend\",\n            KEYRING_BACKEND,\n            \"--home\",\n            KEY_HOME,\n        ]\n        show_result = subprocess.check_output(cmd_show, text=True)\n        info = json.loads(show_result)\n        return {\"status\": \"exists\", \"address\": info[\"address\"]}\n    except subprocess.CalledProcessError:\n        # Key does not exist \u2013 create it now.\n        cmd_add = [\n            CHAIN_BINARY,\n            \"keys\",\n            \"add\",\n            key_name,\n            \"--output\",\n            \"json\",\n            \"--keyring-backend\",\n            KEYRING_BACKEND,\n            \"--home\",\n            KEY_HOME,\n        ]\n        try:\n            add_result = subprocess.check_output(cmd_add, text=True)\n            info = json.loads(add_result)\n            return {\n                \"status\": \"created\",\n                \"address\": info.get(\"address\"),\n                \"mnemonic\": info.get(\"mnemonic\", \"\"),\n            }\n        except subprocess.CalledProcessError as exc:\n            raise RuntimeError(f\"Failed to create key {key_name}: {exc}\")",
            "usage": "result = ensure_key_exists(\"my_validator\")  # {'status': 'exists', 'address': ...} or {'status': 'created', ...}"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Generates a genesis transaction (gentx) that bonds exactly 100000000stake for `my_validator`. The function returns the absolute filesystem path to the freshly created gentx JSON file.",
            "code": "import os\nimport subprocess\n\nCHAIN_BINARY = os.getenv(\"CHAIN_BINARY\", \"neutrond\")\nCHAIN_ID = os.getenv(\"CHAIN_ID\", \"neutron-1\")\nKEY_HOME = os.getenv(\"KEY_HOME\", os.path.expanduser(\"~/.neutrond\"))\nKEYRING_BACKEND = os.getenv(\"KEYRING_BACKEND\", \"test\")\n\ndef generate_gentx(key_name: str, amount: str = \"100000000stake\") -> str:\n    \"\"\"\n    Produce a gentx for `key_name` staking `amount`.  Returns the full path to\n    the resulting gentx JSON file inside `<home>/config/gentx/`.\n    \"\"\"\n    # Run `<chain_binary> gentx ...` exactly as the user specified.\n    cmd = [\n        CHAIN_BINARY,\n        \"gentx\",\n        key_name,\n        amount,\n        \"--chain-id\",\n        CHAIN_ID,\n        \"--keyring-backend\",\n        KEYRING_BACKEND,\n        \"--home\",\n        KEY_HOME,\n    ]\n    try:\n        subprocess.check_call(cmd)\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(f\"gentx command failed: {exc}\") from exc\n\n    # After a successful run the gentx sits in `<home>/config/gentx/`.\n    gentx_dir = os.path.join(KEY_HOME, \"config\", \"gentx\")\n    all_gentxs = [\n        os.path.join(gentx_dir, f)\n        for f in os.listdir(gentx_dir)\n        if f.endswith(\".json\")\n    ]\n    if not all_gentxs:\n        raise FileNotFoundError(\"No gentx file found after running gentx command.\")\n\n    # Return the newest file (highest mtime) which is the one we just created.\n    latest_path = max(all_gentxs, key=os.path.getmtime)\n    return latest_path",
            "usage": "gentx_path = generate_gentx(\"my_validator\")  # e.g. '/home/user/.neutrond/config/gentx/gentx-<hash>.json'"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Reads the gentx produced in Step 2 and verifies that (1) the JSON is valid, (2) it stakes exactly 100000000stake, and (3) the validator address matches the `my_validator` key.",
            "code": "import os\nimport json\nimport subprocess\nimport re\n\nCHAIN_BINARY = os.getenv(\"CHAIN_BINARY\", \"neutrond\")\nKEY_HOME = os.getenv(\"KEY_HOME\", os.path.expanduser(\"~/.neutrond\"))\nKEYRING_BACKEND = os.getenv(\"KEYRING_BACKEND\", \"test\")\n\ndef validate_gentx(\n    gentx_path: str,\n    key_name: str,\n    expected_amount: str = \"100000000\",\n    expected_denom: str = \"stake\",\n) -> bool:\n    \"\"\"\n    Perform three sanity checks on a gentx:\n      1. Confirm it is valid JSON.\n      2. Confirm it stakes exactly `expected_amount``expected_denom`.\n      3. Confirm the validator address was derived from `key_name`.\n    Returns True if the transaction passes all checks, else raises an Exception.\n    \"\"\"\n    # 1\ufe0f\u20e3  Parse and validate JSON structure\n    try:\n        with open(gentx_path, \"r\") as fp:\n            tx = json.load(fp)\n    except json.JSONDecodeError as exc:\n        raise ValueError(f\"gentx is not valid JSON: {exc}\") from exc\n\n    # 2\ufe0f\u20e3  Extract the create-validator message and validate the stake amount\n    try:\n        # cosmos-sdk v0.47+ layout\n        msg = tx[\"body\"][\"messages\"][0]\n        stake_obj = msg[\"value\"][\"value\"] if \"value\" in msg[\"value\"] else msg[\"value\"]\n        amount = stake_obj[\"amount\"]\n        denom = stake_obj[\"denom\"]\n    except (KeyError, TypeError):\n        # Legacy layout fallback\n        try:\n            msg = tx[\"value\"][\"msg\"][0][\"value\"]\n            amount = msg[\"value\"][\"amount\"]\n            denom = msg[\"value\"][\"denom\"]\n        except (KeyError, TypeError) as exc:\n            raise ValueError(\"Unable to extract stake amount/denom from gentx.\") from exc\n\n    if str(amount) != str(expected_amount) or denom != expected_denom:\n        raise ValueError(\n            f\"Gentx stakes {amount}{denom}; expected {expected_amount}{expected_denom}.\"\n        )\n\n    # 3\ufe0f\u20e3  Confirm the validator address matches the operator address for key_name\n    try:\n        key_info_raw = subprocess.check_output(\n            [\n                CHAIN_BINARY,\n                \"keys\",\n                \"show\",\n                key_name,\n                \"--output\",\n                \"json\",\n                \"--keyring-backend\",\n                KEYRING_BACKEND,\n                \"--home\",\n                KEY_HOME,\n            ],\n            text=True,\n        )\n        key_info = json.loads(key_info_raw)\n        delegator_addr = key_info[\"address\"]\n        # Derive the valoper address; this assumes standard bech32 prefixes.\n        operator_addr = re.sub(r\"^([a-z]+)\", r\"\\1valoper\", delegator_addr)\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(f\"Unable to fetch key {key_name}: {exc}\") from exc\n\n    validator_addr_in_tx = msg.get(\"validator_address\") or msg.get(\"value\", {}).get(\"validator_address\")\n    if not validator_addr_in_tx:\n        raise ValueError(\"Validator address missing from gentx.\")\n\n    if validator_addr_in_tx != operator_addr:\n        raise ValueError(\n            f\"Gentx signed by {validator_addr_in_tx}; expected {operator_addr}.\"\n        )\n\n    # All checks passed \ud83c\udf89\n    return True",
            "usage": "is_valid = validate_gentx(gentx_path, \"my_validator\")  # Returns True or raises an error"
        }
    ]
}