{
    "label": "upload",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Creates a FastAPI endpoint that receives a compiled CosmWasm .wasm file and broadcasts a MsgStoreCode transaction via cosmpy. It returns the full on-chain transaction response as JSON.",
            "code": "###############################\n# backend/store_code.py       #\n###############################\n\nimport os\nfrom fastapi import FastAPI, File, UploadFile, HTTPException\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.crypto.keyring import PrivateKey\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmos_proto.cosmwasm.wasm.v1 import tx_pb2 as wasm_tx_pb2\n\napp = FastAPI()\n\n# -------- Configuration --------\nCHAIN_ID      = os.getenv(\"CHAIN_ID\", \"juno-1\")\nRPC_ENDPOINT  = os.getenv(\"RPC_ENDPOINT\", \"https://rpc.juno.strange.love:443\")\nFEE_DENOM     = os.getenv(\"FEE_DENOM\", \"ujuno\")\nGAS_PRICE     = float(os.getenv(\"GAS_PRICE\", \"0.025\"))\nSIGNER_MNEMONIC = os.getenv(\"SIGNER_MNEMONIC\")  # make sure to export this securely\n\nif not SIGNER_MNEMONIC:\n    raise RuntimeError(\"Environment variable SIGNER_MNEMONIC is required for contract upload.\")\n\nnet_cfg = NetworkConfig(\n    chain_id   = CHAIN_ID,\n    url        = RPC_ENDPOINT,\n    fee_denom  = FEE_DENOM,\n    gas_price  = GAS_PRICE,\n)\n\n# -------- Endpoint --------\n@app.post(\"/api/store_code\")\nasync def store_code(file: UploadFile = File(...)):\n    \"\"\"Upload compiled wasm, broadcast MsgStoreCode, and return full tx result.\"\"\"\n    try:\n        wasm_bytes = await file.read()\n        if not wasm_bytes:\n            raise ValueError(\"Uploaded file is empty or could not be read.\")\n\n        # Initialise signer & client\n        pk     = PrivateKey.from_mnemonic(SIGNER_MNEMONIC)\n        client = LedgerClient(net_cfg)\n\n        # Build MsgStoreCode\n        msg = wasm_tx_pb2.MsgStoreCode(\n            sender         = str(pk.address()),\n            wasm_byte_code = wasm_bytes,\n        )\n\n        # Assemble & sign the transaction\n        tx = (\n            Transaction()\n            .with_messages(msg)\n            .with_chain_id(CHAIN_ID)\n            .with_gas(3_000_000)        # adjust if needed\n            .with_fee_amount(1_000_000) # micro-denom\n            .with_fee_denom(FEE_DENOM)\n            .with_memo(\"Mintlify: upload contract code\")\n        )\n\n        signed_tx = tx.sign(pk)\n\n        # Broadcast & wait for inclusion (block mode)\n        tx_result = client.broadcast_block(signed_tx)\n        return tx_result  # will be consumed by Step 2\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "POST multipart/form-data with key `file` to /api/store_code. Example (frontend JS):\n\nconst formData = new FormData();\nformData.append('file', selectedWasmFile);\nconst txRes = await fetch('/api/store_code', { method: 'POST', body: formData });"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Parses the transaction JSON returned by Step 1 and extracts the resulting `code_id` emitted by the `store_code` event.",
            "code": "################################\n# backend/extract_code_id.py    #\n################################\n\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\n\napp = FastAPI()\n\nclass TxPayload(BaseModel):\n    \"\"\"Pydantic model matching the tx JSON from Step 1\"\"\"\n    tx_response: dict\n\n\ndef _extract_code_id(tx_json: dict) -> str:\n    \"\"\"Walk the tx response to locate the code_id inside the store_code event.\"\"\"\n    try:\n        events = tx_json[\"logs\"][0][\"events\"]\n        for evt in events:\n            if evt[\"type\"] == \"store_code\":\n                for attr in evt[\"attributes\"]:\n                    if attr[\"key\"] in (\"code_id\", \"codeID\"):\n                        return attr[\"value\"]\n        raise KeyError(\"code_id not found in logs\")\n    except Exception as err:\n        raise ValueError(f\"Unable to extract code_id: {err}\")\n\n\n@app.post(\"/api/extract_code_id\")\nasync def extract_code_id(payload: TxPayload):\n    \"\"\"HTTP endpoint: returns { \"code_id\": <str> }\"\"\"\n    try:\n        code_id = _extract_code_id(payload.tx_response)\n        return {\"code_id\": code_id}\n    except ValueError as e:\n        raise HTTPException(status_code=400, detail=str(e))",
            "usage": "After receiving the JSON tx result from Step 1, call:\n\nawait fetch('/api/extract_code_id', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ tx_response: txJson })\n});"
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "High-level helper that ties Steps 1 and 2 together. It uploads a .wasm file, asks the backend to store it, retrieves the generated `code_id`, and exposes it globally so subsequent docs snippets can reference it (mimicking `export CODE_ID`).",
            "code": "///////////////////////////////////////////\n// frontend/storeWasmAndGetCodeId.js      //\n///////////////////////////////////////////\n\nexport const storeWasmAndGetCodeId = async (wasmFile) => {\n  // 1. Upload the contract code to backend\n  const formData = new FormData();\n  formData.append('file', wasmFile, wasmFile.name);\n\n  const txResponse = await fetch('/api/store_code', {\n    method: 'POST',\n    body: formData,\n  }).then(async (res) => {\n    if (!res.ok) {\n      const err = await res.text();\n      throw new Error(`store_code failed: ${err}`);\n    }\n    return res.json();\n  });\n\n  // 2. Ask backend to extract code_id\n  const codeIdJson = await fetch('/api/extract_code_id', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ tx_response: txResponse }),\n  }).then(async (res) => {\n    if (!res.ok) {\n      const err = await res.text();\n      throw new Error(`extract_code_id failed: ${err}`);\n    }\n    return res.json();\n  });\n\n  // 3. Export CODE_ID (shell-style) by writing to the global window object\n  window.CODE_ID = codeIdJson.code_id;\n  console.info(`Contract uploaded. CODE_ID=${window.CODE_ID}`);\n\n  return window.CODE_ID;\n};",
            "usage": "const codeId = await storeWasmAndGetCodeId(selectedWasmFile);\n// window.CODE_ID is now available for other snippets, equivalent to `export CODE_ID`"
        }
    ]
}