{
    "label": "send",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 securely loads the sender's private key from a backend-only source, derives the secp256k1 public key and Juno bech32 address, and returns them without ever exposing the key to the frontend.",
            "code": "import os\nimport hashlib\nfrom ecdsa import SigningKey, SECP256k1\nfrom bech32 import bech32_encode, convertbits\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\nCHAIN_ID = 'juno-1'\nDENOM = 'ujuno'\n\n# In production, replace env var access with a secure key management system (HSM, KMS, keyring).\nasync def get_sender_wallet(env_var: str = 'JUNO_SENDER_PRIVATE_KEY') -> dict:\n    \"\"\"\n    Loads the sender's private key from a backend-only environment variable and derives\n    the compressed secp256k1 public key and Juno bech32 address.\n\n    NEVER expose the private key or the full return object to frontend clients.\n    \"\"\"\n    try:\n        hex_key = os.environ.get(env_var)\n        if not hex_key:\n            raise RuntimeError(f'Private key environment variable {env_var} is not set.')\n\n        hex_key = hex_key.strip().lower().replace('0x', '')\n        if len(hex_key) != 64:\n            raise ValueError('Private key must be 32 bytes (64 hex characters).')\n\n        priv_bytes = bytes.fromhex(hex_key)\n        sk = SigningKey.from_string(priv_bytes, curve=SECP256k1)\n        vk = sk.get_verifying_key()\n\n        # Compressed secp256k1 pubkey (33 bytes)\n        compressed_pub = vk.to_string('compressed')\n\n        # Cosmos/Juno address = bech32(hrp=\"juno\", ripemd160(sha256(compressed_pub)))\n        sha = hashlib.sha256(compressed_pub).digest()\n        ripemd = hashlib.new('ripemd160', sha).digest()\n        five_bit_r = convertbits(list(ripemd), 8, 5, True)\n        bech32_addr = bech32_encode('juno', five_bit_r)\n\n        return {\n            'address': bech32_addr,\n            'private_key_hex': priv_bytes.hex(),\n            'public_key_bytes': compressed_pub,\n        }\n    except Exception as e:\n        raise RuntimeError(f'Failed to load or derive sender wallet: {e}') from e\n",
            "usage": "wallet = await get_sender_wallet()\nsender_address = wallet['address']\n# Keep wallet['private_key_hex'] strictly on the backend; never include it in API responses."
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 validates that the CONTRACT_ADDRESS is a properly formatted Juno bech32 address and optionally confirms that it exists on-chain via the auth module.",
            "code": "import httpx\nfrom bech32 import bech32_decode\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\nasync def validate_contract_address(contract_address: str, check_on_chain: bool = True) -> bool:\n    \"\"\"\n    Validates that CONTRACT_ADDRESS is a well-formed Juno bech32 address (hrp == \"juno\").\n    If check_on_chain is True, also confirms that it is a valid on-chain account/contract\n    via /cosmos/auth/v1beta1/accounts/{address}.\n    \"\"\"\n    # Basic bech32 prefix and checksum validation\n    try:\n        hrp, data = bech32_decode(contract_address)\n        if data is None or hrp != 'juno':\n            raise ValueError('Invalid bech32 address or wrong prefix (expected \"juno\").')\n    except Exception as e:\n        raise ValueError(f'Invalid contract address format: {e}') from e\n\n    if not check_on_chain:\n        return True\n\n    url = f'{LCD_URL}/cosmos/auth/v1beta1/accounts/{contract_address}'\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            if resp.status_code == 404:\n                raise ValueError('Address not found on-chain (404 from auth module).')\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while validating contract address: {e}') from e\n\n    if 'account' not in data:\n        raise RuntimeError('LCD response does not contain an \"account\" field; cannot confirm account.')\n\n    return True\n",
            "usage": "await validate_contract_address(CONTRACT_ADDRESS)\n# If the function returns without raising, the address is syntactically valid (and exists on-chain if check_on_chain=True)."
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 queries the sender's ujuno balance via the bank module and ensures it is at least 1,000,000 ujuno plus a configurable fee buffer.",
            "code": "import httpx\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\nDENOM = 'ujuno'\n\nasync def check_sender_balance(\n    sender_address: str,\n    required_amount: int = 1_000_000,\n    fee_buffer: int = 200_000,\n) -> dict:\n    \"\"\"\n    Queries /cosmos/bank/v1beta1/balances/{address}/by_denom for ujuno and ensures the\n    balance is at least required_amount + fee_buffer. Raises ValueError if insufficient.\n    Returns a dict with the current balance and required_total.\n    \"\"\"\n    url = f'{LCD_URL}/cosmos/bank/v1beta1/balances/{sender_address}/by_denom'\n    params = {'denom': DENOM}\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url, params=params)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while querying sender balance: {e}') from e\n\n    balance_str = data.get('balance', {}).get('amount')\n    if balance_str is None:\n        raise RuntimeError('LCD response missing balance.amount for ujuno.')\n\n    try:\n        balance = int(balance_str)\n    except ValueError:\n        raise RuntimeError(f'Invalid balance amount returned: {balance_str}')\n\n    needed = required_amount + fee_buffer\n    if balance < needed:\n        raise ValueError(\n            f'Insufficient ujuno balance. Have {balance}, but need at least {needed} (1,000,000 for send + buffer).'\n        )\n\n    return {'balance': balance, 'required_total': needed}\n",
            "usage": "result = await check_sender_balance(SENDER_ADDRESS)\nprint(f\"Sender balance: {result['balance']} ujuno; required minimum: {result['required_total']} ujuno\")"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 constructs the Cosmos SDK bank MsgSend protobuf (wrapped in an Any) to send exactly 1,000,000 ujuno from SENDER_ADDRESS to CONTRACT_ADDRESS.",
            "code": "from google.protobuf.any_pb2 import Any\nimport cosmospy_protobuf.cosmos.bank.v1beta1.tx_pb2 as bank_tx_pb2\nimport cosmospy_protobuf.cosmos.base.v1beta1.coin_pb2 as coin_pb2\n\nDENOM = 'ujuno'\n\ndef construct_msg_send(from_address: str, to_address: str, amount: int = 1_000_000) -> Any:\n    \"\"\"\n    Constructs a /cosmos.bank.v1beta1.MsgSend message wrapped in a google.protobuf.Any\n    with type_url \"/cosmos.bank.v1beta1.MsgSend\".\n    \"\"\"\n    if amount <= 0:\n        raise ValueError('Amount must be a positive integer of ujuno.')\n\n    msg = bank_tx_pb2.MsgSend(\n        from_address=from_address,\n        to_address=to_address,\n        amount=[coin_pb2.Coin(denom=DENOM, amount=str(amount))],\n    )\n\n    any_msg = Any()\n    any_msg.Pack(msg)\n    # Ensure canonical type_url used by Cosmos SDK\n    any_msg.type_url = '/cosmos.bank.v1beta1.MsgSend'\n    return any_msg\n",
            "usage": "msg_any = construct_msg_send(from_address=SENDER_ADDRESS, to_address=CONTRACT_ADDRESS, amount=1_000_000)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 wraps the MsgSend in a Tx protobuf with an initial gas limit and empty signatures, creating an unsigned transaction ready for simulation and later signing.",
            "code": "import cosmospy_protobuf.cosmos.tx.v1beta1.tx_pb2 as tx_pb2\n\ndef build_unsigned_tx(msg_any, memo: str = '', initial_gas_limit: int = 200_000) -> tx_pb2.Tx:\n    \"\"\"\n    Creates an unsigned Tx containing the provided message. Sets an initial gas limit\n    on auth_info.fee.gas_limit and leaves signer_infos and signatures empty.\n    \"\"\"\n    if initial_gas_limit <= 0:\n        raise ValueError('initial_gas_limit must be positive.')\n\n    tx_body = tx_pb2.TxBody(\n        messages=[msg_any],\n        memo=memo,\n    )\n\n    fee = tx_pb2.Fee(\n        amount=[],   # to be filled after gas price calculation\n        gas_limit=initial_gas_limit,\n        payer='',\n        granter='',\n    )\n\n    auth_info = tx_pb2.AuthInfo(\n        signer_infos=[],  # to be filled during signing\n        fee=fee,\n    )\n\n    tx = tx_pb2.Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[],  # no signatures yet\n    )\n\n    return tx\n",
            "usage": "tx = build_unsigned_tx(msg_any, memo='Send 1 JUNO to contract for funding')"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 simulates the unsigned transaction via the LCD simulate endpoint to estimate gas usage, applies a safety multiplier, and updates the Tx's gas_limit.",
            "code": "import base64\nimport math\nimport httpx\nimport cosmospy_protobuf.cosmos.tx.v1beta1.tx_pb2 as tx_pb2\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\nasync def simulate_tx_for_gas(tx: tx_pb2.Tx, gas_adjustment: float = 1.2) -> int:\n    \"\"\"\n    Calls /cosmos/tx/v1beta1/simulate with tx_bytes for gas estimation.\n    Uses gas_info.gas_used from the response, multiplies by gas_adjustment, rounds up,\n    and updates tx.auth_info.fee.gas_limit. Returns the computed gas_limit.\n    \"\"\"\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive.')\n\n    tx_bytes = tx.SerializeToString()\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('utf-8'),\n    }\n\n    url = f'{LCD_URL}/cosmos/tx/v1beta1/simulate'\n    try:\n        async with httpx.AsyncClient(timeout=20) as client:\n            resp = await client.post(url, json=payload)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error during gas simulation: {e}') from e\n\n    gas_used_str = data.get('gas_info', {}).get('gas_used')\n    if gas_used_str is None:\n        raise RuntimeError('Simulation response missing gas_info.gas_used.')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError:\n        raise RuntimeError(f'Invalid gas_used value returned from simulate: {gas_used_str}')\n\n    gas_limit = math.ceil(gas_used * gas_adjustment)\n    tx.auth_info.fee.gas_limit = gas_limit\n    return gas_limit\n",
            "usage": "estimated_gas_limit = await simulate_tx_for_gas(tx)\nprint('Estimated gas_limit set to', estimated_gas_limit)"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Step 7 fetches the node's minimum_gas_price, parses the ujuno gas price, and computes the fee = gas_limit * gas_price, updating auth_info.fee.amount accordingly.",
            "code": "from decimal import Decimal, ROUND_UP\nimport httpx\nimport cosmospy_protobuf.cosmos.base.v1beta1.coin_pb2 as coin_pb2\nimport cosmospy_protobuf.cosmos.tx.v1beta1.tx_pb2 as tx_pb2\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\nDENOM = 'ujuno'\n\ndef _parse_gas_price_entry(entry: str):\n    \"\"\"Splits an entry like \"0.0025ujuno\" into (Decimal('0.0025'), 'ujuno').\"\"\"\n    entry = entry.strip()\n    if not entry:\n        raise ValueError('Empty gas price entry.')\n    i = 0\n    while i < len(entry) and (entry[i].isdigit() or entry[i] == '.'):\n        i += 1\n    if i == 0:\n        raise ValueError(f'Gas price entry has no numeric prefix: {entry}')\n    amount_str = entry[:i]\n    denom_str = entry[i:]\n    return Decimal(amount_str), denom_str\n\nasync def apply_min_gas_price_fee(tx: tx_pb2.Tx, denom: str = DENOM) -> str:\n    \"\"\"\n    Fetches /cosmos/base/node/v1beta1/config, parses minimum_gas_price, and finds the\n    entry for the requested denom. Computes fee = gas_limit * gas_price (rounded up),\n    updates tx.auth_info.fee.amount, and returns the fee amount as a string.\n    \"\"\"\n    url = f'{LCD_URL}/cosmos/base/node/v1beta1/config'\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while fetching minimum_gas_price: {e}') from e\n\n    min_gas_price_str = data.get('minimum_gas_price')\n    if not min_gas_price_str:\n        raise RuntimeError('minimum_gas_price is empty or missing in node config.')\n\n    selected_price = None\n    for part in min_gas_price_str.split(','):\n        amount_dec, denom_str = _parse_gas_price_entry(part)\n        if denom_str == denom:\n            selected_price = amount_dec\n            break\n\n    if selected_price is None:\n        raise RuntimeError(f'No gas price entry for denom {denom} found in \"{min_gas_price_str}\".')\n\n    gas_limit = tx.auth_info.fee.gas_limit\n    if gas_limit <= 0:\n        raise RuntimeError('tx.auth_info.fee.gas_limit must be set before computing fees.')\n\n    fee_amount = (selected_price * Decimal(gas_limit)).quantize(Decimal('1'), rounding=ROUND_UP)\n    tx.auth_info.fee.amount[:] = [coin_pb2.Coin(denom=denom, amount=str(fee_amount))]\n    return str(fee_amount)\n",
            "usage": "fee_amount_str = await apply_min_gas_price_fee(tx)\nprint('Computed fee amount:', fee_amount_str, 'ujuno')"
        },
        {
            "step": 8,
            "label": "backend",
            "introduction": "Step 8 queries the auth module for SENDER_ADDRESS, decodes the protobuf Any into a BaseAccount or vesting account, and extracts account_number and sequence required for signing.",
            "code": "import base64\nimport httpx\nfrom google.protobuf.any_pb2 import Any\nimport cosmospy_protobuf.cosmos.auth.v1beta1.auth_pb2 as auth_pb2\nimport cosmospy_protobuf.cosmos.vesting.v1beta1.vesting_pb2 as vesting_pb2\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\nasync def fetch_account_number_and_sequence(address: str) -> dict:\n    \"\"\"\n    Calls /cosmos/auth/v1beta1/accounts/{address}, decodes the returned Any protobuf\n    into a known account type, and returns account_number and sequence.\n    Supports BaseAccount and common vesting account wrappers.\n    \"\"\"\n    url = f'{LCD_URL}/cosmos/auth/v1beta1/accounts/{address}'\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while fetching account data: {e}') from e\n\n    account_any = data.get('account')\n    if not account_any or 'value' not in account_any:\n        raise RuntimeError('LCD response missing account.value; cannot decode account.')\n\n    raw = base64.b64decode(account_any['value'])\n    any_msg = Any()\n    any_msg.ParseFromString(raw)\n\n    base_account = None\n\n    # Handle standard BaseAccount\n    if any_msg.type_url.endswith('BaseAccount'):\n        base_account = auth_pb2.BaseAccount()\n        any_msg.Unpack(base_account)\n\n    # Handle ContinuousVestingAccount or DelayedVestingAccount\n    elif any_msg.type_url.endswith('ContinuousVestingAccount'):\n        vesting = vesting_pb2.ContinuousVestingAccount()\n        any_msg.Unpack(vesting)\n        base_account = vesting.base_account\n    elif any_msg.type_url.endswith('DelayedVestingAccount'):\n        vesting = vesting_pb2.DelayedVestingAccount()\n        any_msg.Unpack(vesting)\n        base_account = vesting.base_account\n    else:\n        raise RuntimeError(f'Unsupported account type_url: {any_msg.type_url}')\n\n    return {\n        'account_number': int(base_account.account_number),\n        'sequence': int(base_account.sequence),\n    }\n",
            "usage": "acct = await fetch_account_number_and_sequence(SENDER_ADDRESS)\naccount_number = acct['account_number']\nsequence = acct['sequence']"
        },
        {
            "step": 9,
            "label": "backend",
            "introduction": "Step 9 constructs a SignDoc using the chain_id, account_number, sequence, Tx body bytes, and auth_info bytes, then signs it with the sender's secp256k1 key and populates signer_infos and signatures.",
            "code": "import hashlib\nfrom ecdsa import SigningKey, SECP256k1, util as ecdsa_util\nfrom google.protobuf.any_pb2 import Any\nimport cosmospy_protobuf.cosmos.tx.v1beta1.tx_pb2 as tx_pb2\nimport cosmospy_protobuf.cosmos.tx.signing.v1beta1.signing_pb2 as signing_pb2\nimport cosmospy_protobuf.cosmos.crypto.secp256k1.keys_pb2 as secp_keys_pb2\n\nCHAIN_ID = 'juno-1'\n\ndef sign_tx_with_sender_key(\n    tx: tx_pb2.Tx,\n    private_key_hex: str,\n    account_number: int,\n    sequence: int,\n    chain_id: str = CHAIN_ID,\n) -> tx_pb2.Tx:\n    \"\"\"\n    Populates auth_info.signer_infos with the sender's public key and SIGN_MODE_DIRECT,\n    builds a SignDoc, signs it using the sender's secp256k1 private key, and sets\n    tx.signatures to contain the resulting signature bytes.\n    \"\"\"\n    if not private_key_hex:\n        raise ValueError('private_key_hex must be provided.')\n\n    priv_hex = private_key_hex.lower().replace('0x', '').strip()\n    if len(priv_hex) != 64:\n        raise ValueError('private_key_hex must be 32 bytes (64 hex characters).')\n\n    priv_bytes = bytes.fromhex(priv_hex)\n\n    # Derive compressed secp256k1 public key\n    sk = SigningKey.from_string(priv_bytes, curve=SECP256k1)\n    vk = sk.get_verifying_key()\n    compressed_pub = vk.to_string('compressed')\n\n    # Build PubKey Any: /cosmos.crypto.secp256k1.PubKey\n    pk = secp_keys_pb2.PubKey(key=compressed_pub)\n    pk_any = Any()\n    pk_any.Pack(pk)\n    pk_any.type_url = '/cosmos.crypto.secp256k1.PubKey'\n\n    mode_info = tx_pb2.ModeInfo(\n        single=tx_pb2.ModeInfo.Single(mode=signing_pb2.SignMode.SIGN_MODE_DIRECT)\n    )\n\n    signer_info = tx_pb2.SignerInfo(\n        public_key=pk_any,\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    tx.auth_info.signer_infos[:] = [signer_info]\n\n    # Build SignDoc\n    sign_doc = tx_pb2.SignDoc(\n        body_bytes=tx.body.SerializeToString(),\n        auth_info_bytes=tx.auth_info.SerializeToString(),\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n\n    sign_doc_bytes = sign_doc.SerializeToString()\n    sign_bytes = hashlib.sha256(sign_doc_bytes).digest()\n\n    # Deterministic 64-byte R||S signature\n    signature = sk.sign_deterministic(\n        sign_bytes,\n        hashfunc=hashlib.sha256,\n        sigencode=ecdsa_util.sigencode_string,\n    )\n\n    tx.signatures[:] = [signature]\n    return tx\n",
            "usage": "signed_tx = sign_tx_with_sender_key(\n    tx=tx,\n    private_key_hex=wallet['private_key_hex'],\n    account_number=account_number,\n    sequence=sequence,\n    chain_id='juno-1',\n)"
        },
        {
            "step": 10,
            "label": "backend",
            "introduction": "Step 10 serializes the fully signed Tx protobuf to raw bytes and base64-encodes it into tx_bytes suitable for LCD broadcasting.",
            "code": "import base64\nimport cosmospy_protobuf.cosmos.tx.v1beta1.tx_pb2 as tx_pb2\n\ndef encode_tx_to_bytes(tx: tx_pb2.Tx) -> str:\n    \"\"\"\n    Serializes the signed Tx to bytes and returns a base64-encoded string for\n    the \"tx_bytes\" field used in LCD broadcast endpoints.\n    \"\"\"\n    if not tx.signatures:\n        raise RuntimeError('Tx has no signatures; call sign_tx_with_sender_key() first.')\n\n    tx_bytes = tx.SerializeToString()\n    return base64.b64encode(tx_bytes).decode('utf-8')\n",
            "usage": "tx_bytes_b64 = encode_tx_to_bytes(signed_tx)\nprint('Base64-encoded signed tx_bytes:', tx_bytes_b64[:60] + '...')"
        },
        {
            "step": 11,
            "label": "backend",
            "introduction": "Step 11 broadcasts the base64-encoded signed transaction via the LCD /cosmos/tx/v1beta1/txs endpoint using the desired broadcast mode.",
            "code": "import httpx\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\nasync def broadcast_tx_via_lcd(tx_bytes_b64: str, mode: str = 'BROADCAST_MODE_SYNC') -> dict:\n    \"\"\"\n    POSTs the signed transaction to /cosmos/tx/v1beta1/txs with the given broadcast\n    mode (BROADCAST_MODE_SYNC or BROADCAST_MODE_BLOCK, etc.) and returns the\n    embedded tx_response JSON object.\n    \"\"\"\n    valid_modes = {\n        'BROADCAST_MODE_SYNC',\n        'BROADCAST_MODE_BLOCK',\n        'BROADCAST_MODE_ASYNC',\n        'BROADCAST_MODE_UNSPECIFIED',\n    }\n\n    if mode not in valid_modes:\n        raise ValueError(f'Invalid broadcast mode: {mode}')\n\n    url = f'{LCD_URL}/cosmos/tx/v1beta1/txs'\n    payload = {\n        'tx_bytes': tx_bytes_b64,\n        'mode': mode,\n    }\n\n    try:\n        async with httpx.AsyncClient(timeout=30) as client:\n            resp = await client.post(url, json=payload)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while broadcasting transaction: {e}') from e\n\n    tx_response = data.get('tx_response')\n    if tx_response is None:\n        raise RuntimeError('LCD broadcast response missing \"tx_response\" field.')\n\n    return tx_response\n",
            "usage": "tx_response = await broadcast_tx_via_lcd(tx_bytes_b64, mode='BROADCAST_MODE_SYNC')\nprint('Broadcast tx_response code:', tx_response.get('code'))"
        },
        {
            "step": 12,
            "label": "backend",
            "introduction": "Step 12 verifies that the broadcast result indicates success (code == 0) and, if not, raises an error including the raw_log for easier debugging. On success it returns a summary including txhash.",
            "code": "def verify_broadcast_result(tx_response: dict) -> dict:\n    \"\"\"\n    Validates that the broadcasted transaction was accepted by the chain.\n    Expects a tx_response object (as returned from broadcast_tx_via_lcd).\n    Raises RuntimeError with raw_log if code != 0. On success, returns a\n    summary dict containing txhash, height, and raw_log.\n    \"\"\"\n    if tx_response is None:\n        raise ValueError('tx_response is None; cannot verify broadcast result.')\n\n    if 'code' not in tx_response:\n        raise RuntimeError('tx_response missing \"code\" field.')\n\n    code = tx_response['code']\n    raw_log = tx_response.get('raw_log', '')\n\n    if code != 0:\n        raise RuntimeError(f'Transaction failed with code {code}: {raw_log}')\n\n    return {\n        'txhash': tx_response.get('txhash'),\n        'height': tx_response.get('height'),\n        'raw_log': raw_log,\n    }\n",
            "usage": "result = verify_broadcast_result(tx_response)\nprint('Transaction succeeded with hash', result['txhash'], 'at height', result['height'])"
        }
    ]
}