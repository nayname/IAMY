{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Connect to Keplr and return the sender\u2019s Neutron address that will supply uniBTC to Amber Finance.",
            "code": "export const getSenderAddress = async () => {\n  try {\n    const chainId = 'neutron-1';\n    if (!window?.keplr) {\n      throw new Error('Keplr wallet is not installed');\n    }\n\n    // Request Keplr to enable the Neutron chain\n    await window.keplr.enable(chainId);\n    const offlineSigner = window.getOfflineSigner(chainId);\n    const accounts = await offlineSigner.getAccounts();\n\n    if (!accounts || accounts.length === 0) {\n      throw new Error('No account found in Keplr');\n    }\n\n    return accounts[0].address;\n  } catch (err) {\n    console.error('Failed to get wallet address', err);\n    throw err;\n  }\n};",
            "usage": "const address = await getSenderAddress();"
        },
        {
            "step": 2,
            "label": "frontend",
            "introduction": "Query the uniBTC CW20 balance to ensure the chosen address holds at least 2 uniBTC on Neutron.",
            "code": "export const checkTokenBalance = async (address) => {\n  try {\n    // TODO: replace with the real uniBTC CW20 contract address\n    const cw20Contract = 'neutron1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';\n    const restEndpoint = 'https://rest-kralum.neutron.org';\n\n    // Build the CW20 balance query and base64-encode it for the REST endpoint\n    const query = { balance: { address } };\n    const encodedQuery = btoa(JSON.stringify(query));\n\n    const url = `${restEndpoint}/cosmwasm/wasm/v1/contract/${cw20Contract}/smart/${encodedQuery}`;\n    const res = await fetch(url);\n\n    if (!res.ok) {\n      throw new Error(`REST API returned ${res.status}`);\n    }\n\n    const json = await res.json();\n    const microAmount = BigInt(json?.data?.balance || 0n);\n\n    // Assume uniBTC uses 6 decimals on Neutron\n    const displayAmount = Number(microAmount) / 1_000_000;\n\n    return {\n      ok: displayAmount >= 2,\n      amount: displayAmount\n    };\n  } catch (err) {\n    console.error('Balance check failed', err);\n    throw err;\n  }\n};",
            "usage": "const { ok, amount } = await checkTokenBalance(address);\nif (!ok) throw new Error(`Need at least 2 uniBTC, found ${amount}`);"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Construct an unsigned MsgExecuteContract for CW20 `approve` that allows Amber Finance\u2019s lending pool to spend exactly 2 uniBTC on behalf of the user.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport base64, json\n\napp = FastAPI()\n\nclass ApproveBody(BaseModel):\n    sender: str            # User address\n    cw20_contract: str     # uniBTC CW20 contract address\n    spender: str           # Amber Finance lending contract address\n    amount: int            # Amount in micro-units (e.g. 2_000_000 for 6-decimals)\n\n@app.post('/api/amber/approve/construct')\nasync def construct_cw20_approve(body: ApproveBody):\n    '''Return a sign-ready MsgExecuteContract JSON payload for CW20 approve.'''\n    try:\n        # 1. Build the CW20 approve execute message\n        approve_msg = {\n            'approve': {\n                'spender': body.spender,\n                'amount': str(body.amount)\n            }\n        }\n\n        # 2. Encode the JSON message as base64 per CosmWasm requirements\n        encoded_msg = base64.b64encode(json.dumps(approve_msg).encode()).decode()\n\n        # 3. Wrap into a proto-compatible dict (cosmpy / cosmjs can turn this into a real proto).\n        cw20_execute_msg = {\n            'type_url': '/cosmwasm.wasm.v1.MsgExecuteContract',\n            'value': {\n                'sender': body.sender,\n                'contract': body.cw20_contract,\n                'msg': encoded_msg,\n                'funds': []\n            }\n        }\n\n        return { 'msg': cw20_execute_msg }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "POST /api/amber/approve/construct  with JSON  {\n  \"sender\": \"<walletAddress>\",\n  \"cw20_contract\": \"<uniBTCContract>\",\n  \"spender\": \"<amberPoolAddress>\",\n  \"amount\": 2000000\n}"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Sign and broadcast the CW20 approval transaction, then wait for confirmation.",
            "code": "from fastapi import HTTPException\nfrom pydantic import BaseModel\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import PrivateKey\nfrom cosmpy.aerial.tx import Transaction\n\n# Network configuration (adjust RPC endpoint if necessary)\nNETWORK = NetworkConfig(\n    chain_id='neutron-1',\n    url='https://rpc-kralum.neutron.org',\n    fee_minimum_gas_price='0.025untrn'\n)\n\nclass BroadcastBody(BaseModel):\n    mnemonic: str          # Supplied securely by the frontend (never log!)\n    msg: dict              # MsgExecuteContract produced in Step 3\n\n@app.post('/api/amber/approve/broadcast')\nasync def broadcast_approve(body: BroadcastBody):\n    try:\n        wallet = PrivateKey.from_mnemonic(body.mnemonic)\n        sender = wallet.public_key.address()\n\n        tx = Transaction()\n        tx.add_message(body.msg)            # Convert dict\u2192proto inside cosmpy in real code\n\n        client = LedgerClient(NETWORK)\n        tx.with_sequence(client.get_sequence(sender))\n        tx.with_account_number(client.get_number(sender))\n        tx.with_chain_id(NETWORK.chain_id)\n        tx.sign(wallet)\n\n        result = client.broadcast_tx(tx)\n        return result                      # JSON tx response\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "POST /api/amber/approve/broadcast with JSON { \"mnemonic\": \"<12-24 word seed>\", \"msg\": {\u2026} }"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Create an unsigned MsgExecuteContract that actually supplies the 2 uniBTC to Amber Finance\u2019s lending pool (CW20 `send`).",
            "code": "from fastapi import HTTPException\nfrom pydantic import BaseModel\nfrom base64 import b64encode\nimport json\n\nclass LendBody(BaseModel):\n    sender: str\n    cw20_contract: str   # uniBTC contract address\n    amber_pool: str      # Amber Finance pool contract address\n    amount: int          # micro-unit amount (2 BTC = 2_000_000 if 6 decimals)\n\n@app.post('/api/amber/lend/construct')\nasync def construct_lend(body: LendBody):\n    try:\n        # Optional inner payload for the lending pool (often empty)\n        inner_msg = {}\n\n        wrapped_send = {\n            'send': {\n                'contract': body.amber_pool,\n                'amount': str(body.amount),\n                'msg': b64encode(json.dumps(inner_msg).encode()).decode()\n            }\n        }\n\n        encoded = b64encode(json.dumps(wrapped_send).encode()).decode()\n        exec_msg = {\n            'type_url': '/cosmwasm.wasm.v1.MsgExecuteContract',\n            'value': {\n                'sender': body.sender,\n                'contract': body.cw20_contract,\n                'msg': encoded,\n                'funds': []\n            }\n        }\n\n        return { 'msg': exec_msg }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "POST /api/amber/lend/construct with JSON {\n  \"sender\": \"<walletAddress>\",\n  \"cw20_contract\": \"<uniBTCContract>\",\n  \"amber_pool\": \"<amberPoolAddress>\",\n  \"amount\": 2000000\n}"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Sign and broadcast the lending transaction created in Step 5.",
            "code": "from fastapi import HTTPException\nfrom pydantic import BaseModel\nfrom cosmpy.aerial.client import LedgerClient\nfrom cosmpy.aerial.wallet import PrivateKey\nfrom cosmpy.aerial.tx import Transaction\n\n# Re-use the NETWORK object from Step 4\n\nclass LendBroadcastBody(BaseModel):\n    mnemonic: str\n    msg: dict\n\n@app.post('/api/amber/lend/broadcast')\nasync def broadcast_lend(body: LendBroadcastBody):\n    try:\n        wallet = PrivateKey.from_mnemonic(body.mnemonic)\n        sender = wallet.public_key.address()\n        client = LedgerClient(NETWORK)\n\n        tx = Transaction()\n        tx.add_message(body.msg)\n        tx.with_sequence(client.get_sequence(sender))\n        tx.with_account_number(client.get_number(sender))\n        tx.with_chain_id(NETWORK.chain_id)\n        tx.sign(wallet)\n\n        return client.broadcast_tx(tx)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "POST /api/amber/lend/broadcast with JSON { \"mnemonic\": \"<12-24 word seed>\", \"msg\": {\u2026} }"
        }
    ]
}