{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 provides a Python helper that prepares an offline signer (LocalWallet from cosmpy) for a Juno account using a mnemonic stored in an environment variable.",
            "code": "import os\nfrom cosmpy.aerial.wallet import LocalWallet\n\n\ndef prepare_backend_signer() -> LocalWallet:\n    \"\"\"Load a LocalWallet for the Juno chain using a mnemonic stored\n    in the JUNO_MNEMONIC environment variable.\"\"\"\n    mnemonic = os.getenv(\"JUNO_MNEMONIC\")\n    if not mnemonic:\n        raise RuntimeError(\n            \"JUNO_MNEMONIC environment variable is not set. \"\n            \"Generate a mnemonic and export it before starting the backend.\"\n        )\n    try:\n        # Juno uses the \"juno\" Bech32 prefix\n        wallet = LocalWallet.from_mnemonic(mnemonic, prefix=\"juno\")\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to initialize LocalWallet: {exc}\") from exc\n\n    return wallet\n",
            "usage": "Export JUNO_MNEMONIC in your environment, then call in backend code:\n\n```python\nfrom signer_module import prepare_backend_signer\n\nwallet = prepare_backend_signer()\nprint(\"Backend signer address:\", wallet.address())\n```"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 initializes a cosmpy LedgerClient (an RPC signing client conceptually similar to SigningCosmWasmClient) configured for Juno mainnet and ready to use the prepared signer.",
            "code": "from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import LocalWallet\n\nRPC_ENDPOINT = \"https://rpc.juno.strange.love\"\nCHAIN_ID = \"juno-1\"\nFEE_DENOM = \"ujuno\"\n\n\ndef init_signing_cosmwasm_client(wallet: LocalWallet) -> LedgerClient:\n    \"\"\"Create a LedgerClient connected to the Juno RPC endpoint.\n\n    The client will be used later to execute CosmWasm contracts with the\n    provided LocalWallet as signer.\n    \"\"\"\n    try:\n        network_cfg = NetworkConfig(\n            chain_id=CHAIN_ID,\n            url=RPC_ENDPOINT,\n            fee_minimum_gas_price=0.025,\n            fee_denomination=FEE_DENOM,\n            staking_denomination=FEE_DENOM,\n        )\n        client = LedgerClient(network_cfg)\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to initialize Juno LedgerClient: {exc}\") from exc\n\n    return client\n",
            "usage": "After preparing the signer in Step 1, initialize the backend client:\n\n```python\nfrom signer_module import prepare_backend_signer\nfrom client_module import init_signing_cosmwasm_client\n\nwallet = prepare_backend_signer()\nclient = init_signing_cosmwasm_client(wallet)\n```"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 resolves the target counter contract address from configuration (e.g., the CONTRACT_ADDRESS environment variable).",
            "code": "import os\n\n\ndef resolve_contract_address() -> str:\n    \"\"\"Resolve the deployed counter contract address from configuration.\n\n    By default this reads the CONTRACT_ADDRESS environment variable.\n    \"\"\"\n    addr = os.getenv(\"CONTRACT_ADDRESS\")\n    if not addr:\n        raise RuntimeError(\n            \"CONTRACT_ADDRESS environment variable is not set. \"\n            \"Set it to the deployed counter contract address.\"\n        )\n\n    # Basic sanity check for Juno bech32 prefix\n    if not addr.startswith(\"juno1\"):\n        raise ValueError(f\"CONTRACT_ADDRESS does not look like a Juno address: {addr}\")\n\n    return addr\n",
            "usage": "Configure your contract address (e.g., `export CONTRACT_ADDRESS=juno1...`), then in backend code:\n\n```python\nfrom config_module import resolve_contract_address\n\ncontract_address = resolve_contract_address()\n```"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 executes the counter contract over RPC by sending the CosmWasm execute message `{ \"increment\": {} }`, returning the resulting transaction hash and raw result.",
            "code": "from typing import Any, Dict, Optional\n\nfrom cosmpy.aerial.client import LedgerClient\nfrom cosmpy.aerial.wallet import LocalWallet\n\n\ndef execute_increment_msg_over_rpc(\n    client: LedgerClient,\n    wallet: LocalWallet,\n    contract_address: str,\n    memo: Optional[str] = None,\n) -> Dict[str, Any]:\n    \"\"\"Execute the counter contract's `{\"increment\": {}}` message via RPC.\n\n    Uses the provided LedgerClient and LocalWallet to sign and broadcast\n    the transaction.\n\n    Returns a dictionary with the transaction hash and the raw result\n    object returned by cosmpy.\n    \"\"\"\n    msg = {\"increment\": {}}\n\n    try:\n        # The exact signature of `execute_contract` may vary slightly between\n        # cosmpy versions; this example assumes the high-level helper that\n        # takes a wallet, contract address, execute msg, and optional funds.\n        result = client.execute_contract(\n            wallet,\n            contract_address,\n            msg,\n            funds=[],\n            memo=memo or \"\",\n            gas_limit=200_000,\n        )\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to execute increment on contract: {exc}\") from exc\n\n    # Normalize txhash from the returned result (object or dict)\n    txhash = getattr(result, \"txhash\", None) or getattr(result, \"tx_hash\", None)\n    if txhash is None and isinstance(result, dict):\n        txhash = result.get(\"txhash\") or result.get(\"tx_hash\")\n\n    if not txhash:\n        raise RuntimeError(f\"Could not determine transaction hash from result: {result}\")\n\n    return {\"txhash\": txhash, \"raw_result\": result}\n",
            "usage": "Once you have `client`, `wallet`, and `contract_address`, execute the increment message:\n\n```python\nfrom exec_module import execute_increment_msg_over_rpc\n\nexec_result = execute_increment_msg_over_rpc(client, wallet, contract_address, memo=\"increment counter\")\nprint(\"Broadcasted txhash:\", exec_result[\"txhash\"])\n```"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 confirms the transaction by querying the Juno LCD endpoint `/cosmos/tx/v1beta1/txs/{hash}` and asserting that `tx_response.code == 0`.",
            "code": "import time\nfrom typing import Any, Dict\n\nimport httpx\n\nLCD_BASE_URL = \"https://lcd-archive.junonetwork.io\"\n\n\ndef confirm_tx_via_lcd(\n    txhash: str,\n    max_attempts: int = 12,\n    poll_interval: float = 2.0,\n) -> Dict[str, Any]:\n    \"\"\"Poll the Juno LCD until the given txhash is found and confirmed.\n\n    This uses the documented endpoint:\n      GET /cosmos/tx/v1beta1/txs/{hash}\n\n    It returns the `tx_response` JSON object on success, or raises\n    RuntimeError if the transaction fails, is not found in time, or\n    the LCD returns an error.\n    \"\"\"\n    url = f\"{LCD_BASE_URL}/cosmos/tx/v1beta1/txs/{txhash}\"\n\n    with httpx.Client(timeout=10.0) as client:\n        for attempt in range(max_attempts):\n            try:\n                resp = client.get(url)\n            except httpx.HTTPError as exc:\n                raise RuntimeError(f\"Error querying LCD for tx {txhash}: {exc}\") from exc\n\n            if resp.status_code == 404:\n                # Transaction not indexed yet; wait and retry.\n                time.sleep(poll_interval)\n                continue\n\n            if resp.status_code != 200:\n                raise RuntimeError(\n                    f\"Unexpected status while fetching tx {txhash}: \"\n                    f\"{resp.status_code} {resp.text}\"\n                )\n\n            body = resp.json()\n            tx_response = body.get(\"tx_response\")\n            if not tx_response:\n                raise RuntimeError(f\"Malformed LCD response for tx {txhash}: {body}\")\n\n            code = int(tx_response.get(\"code\", 0))\n            if code != 0:\n                raise RuntimeError(\n                    f\"Transaction {txhash} failed with code={code}, \"\n                    f\"raw_log={tx_response.get('raw_log')}\"\n                )\n\n            # Success\n            return tx_response\n\n    raise RuntimeError(\n        f\"Transaction {txhash} not found in LCD after {max_attempts} attempts.\"\n    )\n",
            "usage": "After Step 4, confirm the transaction using the LCD:\n\n```python\nfrom confirm_module import confirm_tx_via_lcd\n\ntxhash = exec_result[\"txhash\"]\ntx_response = confirm_tx_via_lcd(txhash)\nprint(\"Tx included at height\", tx_response[\"height\"])\n```"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 queries the counter contract via the LCD smart-query endpoint before and after the increment to verify that the stored count increased by 1.",
            "code": "import base64\nimport json\nfrom typing import Any, Dict, Optional\n\nimport httpx\n\nLCD_BASE_URL = \"https://lcd-archive.junonetwork.io\"\n\n\ndef _contract_smart_query(address: str, query_msg: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Helper to perform a CosmWasm smart query via the Juno LCD.\n\n    Uses the documented endpoint:\n      GET /cosmwasm/wasm/v1/contract/{address}/smart/{query_data}\n\n    where `query_data` is base64-encoded JSON.\n    \"\"\"\n    query_bytes = json.dumps(query_msg, separators=(\",\", \":\")).encode(\"utf-8\")\n    query_b64 = base64.b64encode(query_bytes).decode(\"utf-8\")\n    url = f\"{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{address}/smart/{query_b64}\"\n\n    with httpx.Client(timeout=10.0) as client:\n        resp = client.get(url)\n\n    if resp.status_code != 200:\n        raise RuntimeError(\n            f\"Smart query failed with status {resp.status_code}: {resp.text}\"\n        )\n\n    body = resp.json()\n    data_b64 = body.get(\"data\")\n    if not data_b64:\n        raise RuntimeError(f\"Malformed smart query response: {body}\")\n\n    try:\n        decoded = base64.b64decode(data_b64)\n        return json.loads(decoded.decode(\"utf-8\"))\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to decode smart query response: {exc}\") from exc\n\n\ndef get_current_count(contract_address: str) -> int:\n    \"\"\"Query the counter contract for its current count.\n\n    Assumes the contract exposes a `{ \\\"get_count\\\": {} }` query that\n    returns `{ \\\"count\\\": <int> }`.\n    \"\"\"\n    result = _contract_smart_query(contract_address, {\"get_count\": {}})\n    if \"count\" not in result:\n        raise RuntimeError(f\"'count' field missing in contract response: {result}\")\n    return int(result[\"count\"])\n\n\ndef verify_incremented_count(\n    contract_address: str,\n    before: Optional[int],\n) -> Dict[str, Any]:\n    \"\"\"Verify that the counter value increased by 1 after an increment.\n\n    The caller is expected to obtain `before` by calling\n    `get_current_count(contract_address)` prior to executing the\n    increment transaction.\n\n    Returns a dict: `{ \"before\": <int|None>, \"after\": <int>, \"verified\": <bool> }`.\n    \"\"\"\n    after = get_current_count(contract_address)\n    verified = before is not None and after == before + 1\n    return {\"before\": before, \"after\": after, \"verified\": verified}\n",
            "usage": "Call `get_current_count` before and after the execute step, then verify:\n\n```python\nfrom counter_verify import get_current_count, verify_incremented_count\n\ncontract_address = resolve_contract_address()\n\n# Before increment\nbefore = get_current_count(contract_address)\n\n# ...run Step 4 (execute increment) and Step 5 (confirm tx)...\n\n# After increment & verification\nresult = verify_incremented_count(contract_address, before)\nprint(result)  # e.g., {'before': 3, 'after': 4, 'verified': True}\n```"
        }
    ]
}