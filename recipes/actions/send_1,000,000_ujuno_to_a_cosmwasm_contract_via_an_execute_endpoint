{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Connects to Keplr, fetches the first account address and ensures it has at least 1,000,000 ujuno.",
            "code": "// frontend/keplr.js\nexport const getEligibleSenderAddress = async (minBalance = 1_000_000) => {\n  const chainId = \"juno-1\";\n  const denom = \"ujuno\";\n\n  // 1. Ensure Keplr exists\n  const { keplr } = window;\n  if (!keplr) throw new Error(\"Keplr wallet not installed\");\n\n  // 2. Enable chain & get signer\n  await keplr.enable(chainId);\n  const signer = keplr.getOfflineSigner\n    ? keplr.getOfflineSigner(chainId)\n    : await keplr.getOfflineSignerAuto(chainId);\n\n  // 3. Pull first account\n  const accounts = await signer.getAccounts();\n  if (!accounts.length) throw new Error(\"No account found in Keplr\");\n  const address = accounts[0].address;\n\n  // 4. Query balance via public LCD (no CosmJS needed)\n  const lcd = \"https://lcd-juno.cosmostation.io\";\n  const res = await fetch(\n    `${lcd}/cosmos/bank/v1beta1/balances/${address}/by_denom?denom=${denom}`\n  );\n  if (!res.ok) throw new Error(\"Unable to fetch balance from LCD\");\n  const data = await res.json();\n  const amount = Number(data.balance?.amount ?? \"0\");\n  if (amount < minBalance)\n    throw new Error(\n      `Insufficient funds: need \u2265 ${minBalance} ${denom}, found ${amount}`\n    );\n\n  // 5. Return address for later steps\n  return { address };\n};",
            "usage": "const { address } = await getEligibleSenderAddress();"
        },
        {
            "step": 2,
            "label": "frontend",
            "introduction": "Light-weight client-side check that the provided value is a valid Juno bech32 address (prefix `juno`).",
            "code": "// frontend/validators.js\nexport const validateContractAddress = (addr) => {\n  const re = /^juno1[0-9a-z]{38}$/;\n  if (!re.test(addr)) throw new Error(\"Invalid Juno bech32 address\");\n  return true;\n};",
            "usage": "validateContractAddress(CONTRACT_ADDRESS);"
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "Creates the JSON execute message the smart-contract expects. Keeps it serialisation-ready for the backend.",
            "code": "// frontend/executeMsg.js\nexport const constructExecuteMsg = (endpoint, payload = {}) => {\n  if (!endpoint) throw new Error(\"Endpoint string is required\");\n  return { [endpoint]: payload };\n};",
            "usage": "const execMsg = constructExecuteMsg(\"some_endpoint\", {});"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Python FastAPI route that receives sender + contract info, builds an *unsigned* MsgExecuteContract and returns the base64-encoded bytes along with a gas estimate.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import Dict, Any\nimport json, base64\n\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.wasm import MsgExecuteContract\nfrom cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin\n\napp = FastAPI()\n\nJUNO_MAINNET = NetworkConfig(\n    chain_id=\"juno-1\",\n    url=\"https://rpc-juno.itastakers.com:443\",\n    fee_minimum_gas_price=0.025,\n    fee_denomination=\"ujuno\",\n)\n\nclass ExecutePayload(BaseModel):\n    sender_address: str\n    contract_address: str\n    execute_msg: Dict[str, Any]\n    funds: int  # ujuno\n\n@app.post(\"/api/tx/execute/construct\")\nasync def construct_execute_tx(p: ExecutePayload):\n    try:\n        client = LedgerClient(JUNO_MAINNET)\n\n        coin = Coin(amount=str(p.funds), denom=\"ujuno\")\n        msg = MsgExecuteContract(\n            sender=p.sender_address,\n            contract=p.contract_address,\n            msg=json.dumps(p.execute_msg).encode(),\n            funds=[coin],\n        )\n\n        tx = Transaction()\n        tx.add_message(msg)\n        gas = client.estimate_gas(tx)\n\n        return {\n            \"unsigned_tx\": base64.b64encode(tx.serialize()).decode(),\n            \"gas_estimate\": gas,\n        }\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))",
            "usage": "POST /api/tx/execute/construct with JSON { sender_address, contract_address, execute_msg, funds: 1000000 }"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Signs the transaction with a user-supplied mnemonic (\u26a0\ufe0f never expose in production UIs) and broadcasts it to the Juno network.",
            "code": "from fastapi import Depends\nfrom cosmpy.aerial.wallet import LocalWallet\n\nclass SignBroadcastPayload(ExecutePayload):\n    mnemonic: str  # securely store / transmit in real apps!\n\n@app.post(\"/api/tx/execute/sign_and_broadcast\")\nasync def sign_and_broadcast(p: SignBroadcastPayload):\n    try:\n        wallet = LocalWallet.from_mnemonic(p.mnemonic)\n        if wallet.address() != p.sender_address:\n            raise HTTPException(status_code=400, detail=\"Mnemonic does not match sender\")\n\n        client = LedgerClient(JUNO_MAINNET)\n\n        coin = Coin(amount=str(p.funds), denom=\"ujuno\")\n        msg = MsgExecuteContract(\n            sender=p.sender_address,\n            contract=p.contract_address,\n            msg=json.dumps(p.execute_msg).encode(),\n            funds=[coin],\n        )\n\n        tx = Transaction()\n        tx.add_message(msg)\n        tx.with_chain_id(JUNO_MAINNET.chain_id)\n        tx.with_gas_limit(300_000)\n        tx_signed = tx.sign(wallet)\n\n        tx_hash = client.broadcast_tx(tx_signed)\n        return {\"tx_hash\": tx_hash}\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))",
            "usage": "POST /api/tx/execute/sign_and_broadcast with JSON { sender_address, contract_address, execute_msg, funds: 1000000, mnemonic } \u2192 returns { tx_hash }"
        }
    ]
}