{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Step 1 defines a small helper that builds the JSON execute message the CosmWasm contract expects. Because it is just object manipulation, no external libraries are required and the function can safely live in the browser code-base.",
            "code": "export const constructExecuteMsg = (action, payload = {}) => {\n  // Validate inputs\n  if (typeof action !== 'string' || action.length === 0) {\n    throw new Error('A valid contract action string must be provided');\n  }\n\n  /*\n   * CosmWasm execute messages follow the shape:\n   * {\n   *   \"<action>\": { ...payload }\n   * }\n   */\n  const msg = {\n    [action]: payload,\n  };\n\n  // The CLI / backend usually expects a JSON string\n  return JSON.stringify(msg);\n};",
            "usage": "const msg = constructExecuteMsg('increment', { });"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 spins up a FastAPI endpoint that takes the execute message, signs it with a hot-wallet key held on the server (loaded from an environment variable), and broadcasts the transaction via cosmpy. The endpoint returns the resulting tx_hash so the frontend can monitor progress.",
            "code": "import os\nimport json\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.contract import MsgExecuteContract\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.wallet import PrivateKey\nfrom cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin\n\napp = FastAPI()\n\nclass ExecuteContractRequest(BaseModel):\n    contract_address: str\n    msg: dict  # already parsed JSON from the frontend\n    amount: str = \"0\"\n    denom: str = \"ujuno\"\n\n@app.post(\"/api/execute_contract\")\nasync def execute_contract(req: ExecuteContractRequest):\n    \"\"\"\n    Signs and broadcasts a CosmWasm execute transaction using cosmpy.\n    A hex-encoded private key must be supplied in the JUNO_PRIVKEY_HEX environment variable.\n    \"\"\"\n    priv_key_hex = os.getenv(\"JUNO_PRIVKEY_HEX\")\n    if not priv_key_hex:\n        raise HTTPException(status_code=500, detail=\"Missing JUNO_PRIVKEY_HEX environment variable.\")\n\n    chain_id = os.getenv(\"CHAIN_ID\", \"juno-1\")\n    node_url = os.getenv(\"NODE_URL\", \"https://rpc-juno.itastakers.com:443\")\n    gas_price = float(os.getenv(\"GAS_PRICE\", \"0.025\"))\n\n    try:\n        pk = PrivateKey(bytes.fromhex(priv_key_hex))\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Invalid private key: {e}\")\n\n    cfg = NetworkConfig(\n        chain_id=chain_id,\n        url=node_url,\n        fee_minimum_gas_price=gas_price,\n        fee_denom=req.denom,\n    )\n    client = LedgerClient(cfg)\n    sender = pk.address()\n\n    funds = []\n    if int(req.amount) > 0:\n        funds.append(Coin(amount=req.amount, denom=req.denom))\n\n    tx = (\n        Transaction()\n        .with_messages(\n            MsgExecuteContract(\n                sender=sender,\n                contract=req.contract_address,\n                msg=json.dumps(req.msg).encode(),\n                funds=funds,\n            )\n        )\n        .with_gas(300000)\n        .with_chain_id(chain_id)\n        .with_sender(sender)\n    )\n\n    signed_tx = tx.build_and_sign(pk)\n\n    try:\n        res = client.broadcast_tx(signed_tx)\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=f\"Broadcast error: {e}\")\n\n    if res.tx_response.code != 0:\n        raise HTTPException(status_code=400, detail=f\"Execute failed: {res.tx_response.raw_log}\")\n\n    return {\"tx_hash\": res.tx_response.txhash, \"height\": res.tx_response.height}",
            "usage": "const { tx_hash } = await (await fetch('/api/execute_contract', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    contract_address: CONTRACT_ADDR,\n    msg: JSON.parse(msg), // msg from Step 1\n    amount: '0',\n    denom: 'ujuno'\n  })\n})).json();"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 offers a utility that polls the RPC endpoint until the provided tx_hash is included in a block (or times out). This can be exposed as another API route or called internally.",
            "code": "import os\nimport asyncio\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\n\nasync def poll_tx_hash(tx_hash: str, timeout: int = 60, interval: int = 3):\n    \"\"\"\n    Repeatedly queries the RPC endpoint for the provided tx_hash until it is included\n    in a block or the timeout (in seconds) is exceeded.\n    Returns a dict containing the tx result.\n    \"\"\"\n    chain_id = os.getenv(\"CHAIN_ID\", \"juno-1\")\n    node_url = os.getenv(\"NODE_URL\", \"https://rpc-juno.itastakers.com:443\")\n    denom = os.getenv(\"TX_DENOM\", \"ujuno\")\n\n    client = LedgerClient(NetworkConfig(chain_id=chain_id, url=node_url, fee_denom=denom))\n\n    elapsed = 0\n    while elapsed < timeout:\n        try:\n            res = client.query_tx(tx_hash)\n            if res and res.tx_response and res.tx_response.height > 0:\n                return {\n                    \"status\": \"confirmed\" if res.tx_response.code == 0 else \"failed\",\n                    \"height\": res.tx_response.height,\n                    \"gas_used\": res.tx_response.gas_used,\n                    \"raw_log\": res.tx_response.raw_log,\n                }\n        except Exception:\n            # Transaction not yet indexed\n            pass\n\n        await asyncio.sleep(interval)\n        elapsed += interval\n\n    raise TimeoutError(f\"Timed out after {timeout}s waiting for tx {tx_hash}.\")",
            "usage": "const txInfo = await (await fetch(`/api/poll_tx/${tx_hash}`)).json(); // or call poll_tx_hash(tx_hash) server-side"
        }
    ]
}