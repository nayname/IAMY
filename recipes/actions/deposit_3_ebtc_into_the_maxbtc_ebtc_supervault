{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Connect to the user\u2019s Keplr wallet, enable the Neutron chain and return the sender address that will perform the eBTC Supervault deposit.",
            "code": "/*\n * ensureWalletAndGetAddress.js\n * Utility to make sure Keplr is installed/enabled and to fetch the active Neutron address.\n */\nexport const ensureWalletAndGetAddress = async () => {\n  try {\n    const chainId = 'neutron-1';\n\n    // Basic Keplr presence check\n    if (!window.keplr) {\n      throw new Error('Keplr wallet is not installed. Please install it first.');\n    }\n\n    // Request connection to Neutron chain\n    await window.keplr.enable(chainId);\n\n    // Fetch the offline signer & accounts list\n    const offlineSigner = window.keplr.getOfflineSigner(chainId);\n    const accounts      = await offlineSigner.getAccounts();\n\n    if (!accounts || accounts.length === 0) {\n      throw new Error('No Neutron account found in Keplr.');\n    }\n\n    return accounts[0].address; // sender / depositor address\n  } catch (err) {\n    console.error('[ensureWalletAndGetAddress] \u2192', err);\n    throw err;\n  }\n};",
            "usage": "const senderAddress = await ensureWalletAndGetAddress();"
        },
        {
            "step": 2,
            "label": "frontend",
            "introduction": "Query the sender\u2019s on-chain eBTC balance via Neutron\u2019s public LCD endpoint and ensure at least 3 eBTC are available.",
            "code": "/*\n * checkEbtcBalance.js\n * Simple REST call to the Neutron LCD to verify the user has \u2265 minAmount (micro-denom) eBTC.\n */\nexport const checkEbtcBalance = async (address, minAmountMicro = '3000000') => {\n  try {\n    // Public Neutron LCD endpoint (you may replace with your own)\n    const lcd = 'https://lcd-kralum.neutron-1.nomusa.xyz';\n\n    // eBTC IBC denom on Neutron (see docs/btc-summer/technical/reference)\n    const EBTC_DENOM = 'ibc/E2A000FD3EDD91C9429B473995CE2C7C555BCC8CFC1D0A3D02F514392B7A80E8';\n\n    const resp   = await fetch(`${lcd}/cosmos/bank/v1beta1/balances/${address}`);\n    if (!resp.ok) throw new Error(`LCD error ${resp.status}`);\n\n    const { balances } = await resp.json();\n    const coin = balances.find((c) => c.denom === EBTC_DENOM);\n    const amount = coin ? coin.amount : '0';\n\n    if (BigInt(amount) < BigInt(minAmountMicro)) {\n      throw new Error(`Insufficient eBTC balance. Need \u2265 ${minAmountMicro}, have ${amount}`);\n    }\n\n    return {\n      ok: true,\n      amountMicro: amount\n    };\n  } catch (err) {\n    console.error('[checkEbtcBalance] \u2192', err);\n    throw err;\n  }\n};",
            "usage": "await checkEbtcBalance(senderAddress, '3000000'); // 3 eBTC (if 6-decimals micro-denom)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Provide a lightweight BFF (FastAPI) endpoint that returns the eBTC Supervault contract address plus a flag indicating whether single-sided deposits with eBTC are allowed.",
            "code": "### supervault_bff.py\n\"\"\"Minimal FastAPI BFF that exposes vault metadata.\nRun:  uvicorn supervault_bff:app --reload\n\"\"\"\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI(title=\"Supervault BFF\")\n\n# Static reference table \u2014 keep this up-to-date from docs/btc-summer/technical/reference\nSUPERVAULTS = {\n    \"ebtc\": {\n        \"contract\": \"neutron1s8k6gcrnsfrs9rj3j8757w4e0ttmzsdmjvwfwxruhu2t8xjgwxaqegzjgt\",\n        \"single_sided\": True\n    },\n    # Add other assets here \u2026\n}\n\n@app.get(\"/api/supervault/{asset}\")\nasync def get_vault(asset: str):\n    asset = asset.lower()\n    if asset not in SUPERVAULTS:\n        raise HTTPException(status_code=404, detail=\"Unsupported asset\")\n    return SUPERVAULTS[asset]",
            "usage": "GET /api/supervault/ebtc \u2192 { \"contract\": \"neutron1\u2026\", \"single_sided\": true }"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Compose the CosmWasm `deposit` execute message (3 eBTC) for the vault returned in step 3. This produces a signed-but-UNBROADCASTED tx in `tx_raw` form.",
            "code": "### tx_builder.py\n\"\"\"Utility that constructs a deposit tx for eBTC Supervault using cosmpy.\nThe mnemonic / private key should be provided via environment variable to keep secrets off the frontend.\n\"\"\"\nimport os, base64, json\nfrom datetime import timedelta\nfrom cosmpy.crypto.keypairs import PrivateKey\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.wallet import LocalWallet\n\n# Neutron main-net RPC + chain-id\nNETWORK = NetworkConfig(\n    chain_id=\"neutron-1\",\n    url=\"https://rpc-kralum.neutron-1.nomusa.xyz\",\n    fee_minimum_gas_price=0.025,\n    fee_denom=\"untrn\"\n)\n\nEBTC_DENOM = \"ibc/E2A000FD3EDD91C9429B473995CE2C7C555BCC8CFC1D0A3D02F514392B7A80E8\"\n\nclient = LedgerClient(NETWORK)\n\nMNEMONIC = os.getenv(\"BFF_MNEMONIC\")\nif not MNEMONIC:\n    raise RuntimeError(\"BFF_MNEMONIC env var not set \u2013 cannot sign tx\")\n\nwallet = LocalWallet.from_mnemonic(MNEMONIC)\n\n\ndef build_deposit_tx(vault_addr: str, sender_addr: str, amount_micro: int = 3_000_000):\n    \"\"\"Create an unsigned Transaction object with a single CosmWasm execute msg.\"\"\"\n\n    # CosmWasm messages require base64-encoded JSON inside the high-level msg\n    msg_inner = base64.b64encode(json.dumps({\"deposit\": {}}).encode()).decode()\n\n    exec_msg = {\n        \"type\": \"wasm/MsgExecuteContract\",\n        \"value\": {\n            \"sender\":   sender_addr,\n            \"contract\": vault_addr,\n            \"msg\":       msg_inner,\n            \"funds\":     [{\"denom\": EBTC_DENOM, \"amount\": str(amount_micro)}]\n        }\n    }\n\n    tx = (\n        Transaction()\n        .with_messages(exec_msg)\n        .with_sequence(client.query_sequence(sender_addr))\n        .with_account_num(client.query_account_number(sender_addr))\n        .with_chain_id(NETWORK.chain_id)\n        .with_gas(300000)  # rough estimate; adjust as needed\n        .with_fee_denom(NETWORK.fee_denom)\n        .with_fee(7500)\n        .with_memo(\"eBTC \u2192 Supervault deposit\")\n        .with_timeout_height(client.query_height() + 50)  # ~5 min sooner than current block\n    )\n    return tx\n",
            "usage": "tx = build_deposit_tx(vault_addr=\"neutron1s8\u2026\", sender_addr=wallet.address())"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Sign the transaction from step 4 with the BFF\u2019s service key and broadcast it to Neutron. Return the on-chain tx hash.",
            "code": "### broadcaster.py\n\"\"\"Sign + broadcast wrapper. Separating concerns keeps the builder reusable.\"\"\"\nimport json\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.client import NetworkConfig, LedgerClient\nfrom tx_builder import build_deposit_tx, wallet, client\n\n\ndef sign_and_broadcast(vault_addr: str, amount_micro: int = 3_000_000):\n    tx: Transaction = build_deposit_tx(vault_addr, wallet.address(), amount_micro)\n\n    # Sign with service wallet\n    tx_signed = tx.sign(wallet)\n\n    # Broadcast and await inclusion\n    resp = client.broadcast_tx(tx_signed)\n    if resp.is_err():\n        raise RuntimeError(f\"Broadcast failed: {resp.log}\")\n\n    print(\"\u2705 Broadcast successful \u2192 txhash:\", resp.tx_hash)\n    return {\"tx_hash\": resp.tx_hash}\n",
            "usage": "result = sign_and_broadcast(vault_addr=\"neutron1s8\u2026\")  # \u21d2 { tx_hash: \"ABC123\u2026\" }"
        }
    ]
}