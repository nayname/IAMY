{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Step 1 defines a small helper that discovers the user-specific vault contract address by calling a public indexer service. Adjust the `registryBaseUrl` to match your own API if it differs.",
            "code": "export const getVaultContractAddress = async (userAddress, registryBaseUrl = \"https://indexer.neutron.org\") => {\n  // Example endpoint:  GET {registryBaseUrl}/api/v1/vaults/{userAddress}\n  try {\n    const res = await fetch(`${registryBaseUrl}/api/v1/vaults/${userAddress}`);\n\n    if (!res.ok) {\n      throw new Error(`Failed to fetch vault address: ${res.status} ${res.statusText}`);\n    }\n\n    const { vault_address } = await res.json();\n\n    if (!vault_address) {\n      throw new Error(\"Vault address not found in response.\");\n    }\n\n    return vault_address;\n  } catch (err) {\n    console.error(\"[getVaultContractAddress]\", err);\n    throw err;\n  }\n};",
            "usage": "const vaultAddress = await getVaultContractAddress(userAddress);"
        },
        {
            "step": 2,
            "label": "frontend",
            "introduction": "Step 2 queries the vault\u2019s on-chain `config` by performing a direct REST LCD smart-query. No CosmJS dependency is required; the query payload is base64-encoded and sent over HTTPS.",
            "code": "export const queryVaultConfig = async (vaultAddress, lcdUrl = \"https://rest.neutron-1.neutron.org\") => {\n  /**\n   * Helper to base64-encode the JSON query in both browser and Node environments.\n   */\n  const base64Encode = (obj) => {\n    const jsonStr = JSON.stringify(obj);\n    if (typeof window !== \"undefined\" && window.btoa) {\n      return window.btoa(jsonStr);\n    }\n    return Buffer.from(jsonStr).toString(\"base64\");\n  };\n\n  try {\n    const queryMsg = { config: {} };        // \u2190 { \"config\": {} }\n    const encoded = base64Encode(queryMsg); // base64\n\n    const endpoint = `${lcdUrl}/cosmwasm/wasm/v1/contract/${vaultAddress}/smart/${encoded}`;\n    const res = await fetch(endpoint);\n\n    if (!res.ok) {\n      throw new Error(`Contract query failed: ${res.status} ${res.statusText}`);\n    }\n\n    // Depending on LCD version the JSON key can be `data` or `result`.\n    const json = await res.json();\n    const config = json.data ?? json.result ?? json;\n\n    return config; // returns the full config object\n  } catch (err) {\n    console.error(\"[queryVaultConfig]\", err);\n    throw err;\n  }\n};",
            "usage": "const config = await queryVaultConfig(vaultAddress);"
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "Step 3 parses the raw `config` object and isolates reward-related fields like `forfeitable_rewards` and `early_exit_penalty` for easy downstream consumption.",
            "code": "export const parseRewardPolicy = (config) => {\n  if (!config || typeof config !== \"object\") {\n    throw new Error(\"Invalid or empty config object supplied.\");\n  }\n\n  const forfeitableRewards = config.forfeitable_rewards ?? null;\n  const earlyExitPenalty = config.early_exit_penalty ?? null;\n\n  return {\n    forfeitableRewards,\n    earlyExitPenalty,\n    // Convenience flag\n    isForfeitable: Boolean(forfeitableRewards) || Boolean(earlyExitPenalty)\n  };\n};",
            "usage": "const policy = parseRewardPolicy(config);"
        },
        {
            "step": 4,
            "label": "frontend",
            "introduction": "Step 4 presents a minimal renderer that displays the parsed policy in the UI. It first tries to locate a DOM element by `targetElementId`; if none is found it falls back to `console.log`.",
            "code": "export const displayRewardPolicy = (policy, targetElementId = \"reward-policy\") => {\n  try {\n    const el = document.getElementById(targetElementId);\n\n    // Fallback if no DOM target is available\n    const output = (msg) => {\n      if (el) {\n        el.innerHTML = msg;\n      } else {\n        console.log(msg);\n      }\n    };\n\n    if (!policy || !policy.isForfeitable) {\n      output(\"No early withdrawal penalties. All rewards are fully claimable.\");\n      return;\n    }\n\n    let html = \"<h4>Early Withdrawal Policy</h4>\";\n\n    if (policy.earlyExitPenalty && typeof policy.earlyExitPenalty === \"object\") {\n      html += \"<ul>\";\n      for (const [period, penalty] of Object.entries(policy.earlyExitPenalty)) {\n        html += `<li>Within ${period}: ${penalty}% penalty</li>`;\n      }\n      html += \"</ul>\";\n    } else if (policy.forfeitableRewards !== null) {\n      html += `<p>${policy.forfeitableRewards}% of accumulated rewards are forfeited on early exit.</p>`;\n    }\n\n    output(html);\n  } catch (err) {\n    console.error(\"[displayRewardPolicy]\", err);\n  }\n};",
            "usage": "displayRewardPolicy(policy, \"policy-container\");"
        }
    ]
}