{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a backend helper that parses and validates the epoch_id from a path or query parameter and returns it as a positive integer.",
            "code": "import re\nfrom typing import Union\n\n\nclass EpochIdValidationError(ValueError):\n    'Raised when an epoch_id cannot be parsed or is invalid.'\n    pass\n\n\ndef parse_and_validate_epoch_id(epoch_param: Union[str, int]) -> int:\n    '''\n    Parse an epoch identifier from a path or query parameter and ensure it is\n    a positive integer. Supports inputs like:\n      - 123\n      - '123'\n      - 'epoch 123'\n      - 'epoch-123'\n    '''\n    if isinstance(epoch_param, int):\n        epoch_id = epoch_param\n    else:\n        if epoch_param is None:\n            raise EpochIdValidationError('epoch_id is required.')\n        text = str(epoch_param).strip()\n        match = re.search(r'\\d+', text)\n        if not match:\n            raise EpochIdValidationError(f'Could not find a numeric epoch_id in {text!r}.')\n        try:\n            epoch_id = int(match.group(0))\n        except ValueError:\n            raise EpochIdValidationError(f'Invalid epoch_id value {match.group(0)!r}.')\n    if epoch_id <= 0:\n        raise EpochIdValidationError('epoch_id must be a positive integer.')\n    return epoch_id\n",
            "usage": "from fastapi import FastAPI, Request, HTTPException\n\napp = FastAPI()\n\n@app.get('/epochs/{epoch_id}/committee')\nasync def get_committee_handler(request: Request, epoch_id: str):\n    try:\n        parsed_epoch_id = parse_and_validate_epoch_id(epoch_id)\n    except EpochIdValidationError as exc:\n        raise HTTPException(status_code=400, detail=str(exc))\n    # You would then pass parsed_epoch_id into the later backend steps\n    return {'epoch_id': parsed_epoch_id}"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 defines a backend function that queries a Republic node or indexer for the consensus committee in the given epoch_id, using REST first and optionally falling back to the republic CLI core utils.",
            "code": "import json\nimport os\nimport subprocess\nfrom typing import Any, Dict, List, Optional\n\nimport requests\n\n\nclass EpochCommitteeQueryError(RuntimeError):\n    'Raised when the committee for a given epoch cannot be fetched.'\n    pass\n\n\ndef get_epoch_committee(epoch_id: int,\n                        rest_url: Optional[str] = None,\n                        use_cli_fallback: bool = True) -> List[Dict[str, Any]]:\n    '''\n    Query the Republic node or indexer for the consensus committee in the\n    specified epoch_id. This function prefers a REST/indexer endpoint, with an\n    optional fallback to the `republic` CLI core utils.\n    '''\n    if epoch_id <= 0:\n        raise ValueError('epoch_id must be a positive integer.')\n\n    base_rest = rest_url or os.getenv('REPUBLIC_REST_URL', 'http://localhost:1317')\n    rest_endpoint = f'{base_rest}/republic/consensus/v1/epochs/{epoch_id}/committee'\n\n    raw_response: Optional[Dict[str, Any]] = None\n\n    # First attempt: REST / indexer API\n    try:\n        resp = requests.get(rest_endpoint, timeout=10)\n        if resp.status_code == 200:\n            raw_response = resp.json()\n        else:\n            # Non-200 response, keep option to fall back to CLI\n            if not use_cli_fallback:\n                raise EpochCommitteeQueryError(\n                    f'Committee REST query failed with status {resp.status_code}.'\n                )\n    except requests.RequestException as exc:\n        if not use_cli_fallback:\n            raise EpochCommitteeQueryError(\n                f'Error while calling committee REST endpoint: {exc}'\n            )\n\n    # Second attempt: CLI fallback if enabled and REST either failed or returned nothing\n    if raw_response is None and use_cli_fallback:\n        cli_cmd = [\n            'republic',\n            'committee',\n            'query',\n            '--epoch-id',\n            str(epoch_id),\n            '--output',\n            'json',\n        ]\n        try:\n            result = subprocess.run(\n                cli_cmd,\n                check=True,\n                capture_output=True,\n                text=True,\n            )\n            raw_response = json.loads(result.stdout)\n        except (subprocess.CalledProcessError, json.JSONDecodeError) as exc:\n            raise EpochCommitteeQueryError(\n                f'Error while querying committee via CLI: {exc}'\n            )\n\n    if raw_response is None:\n        raise EpochCommitteeQueryError('Committee query returned no data.')\n\n    committee = raw_response.get('committee') or raw_response.get('validators')\n    if committee is None:\n        raise EpochCommitteeQueryError(\n            'Committee query response did not contain a committee/validators field.'\n        )\n\n    normalized: List[Dict[str, Any]] = []\n    for entry in committee:\n        # Attempt to normalize field names from whatever the node/indexer returns.\n        operator_address = (\n            entry.get('operator_address')\n            or entry.get('valoper_address')\n            or entry.get('validator_address')\n        )\n        if not operator_address:\n            # Skip entries that do not contain an identifiable operator address.\n            continue\n\n        voting_power_raw = entry.get('voting_power') or entry.get('stake') or 0\n        try:\n            voting_power = int(voting_power_raw)\n        except (TypeError, ValueError):\n            voting_power = 0\n\n        stake_raw = entry.get('stake') or voting_power\n        try:\n            stake = int(stake_raw)\n        except (TypeError, ValueError):\n            stake = voting_power\n\n        compute_benchmarks = entry.get('compute_benchmarks') or {\n            'throughput': entry.get('throughput_score'),\n            'inference': entry.get('inference_score'),\n            'flops': entry.get('achieved_flops'),\n        }\n\n        normalized.append(\n            {\n                'operator_address': operator_address,\n                'voting_power': voting_power,\n                'stake': stake,\n                'reputation': entry.get('reputation'),\n                'compute_benchmarks': compute_benchmarks,\n            }\n        )\n\n    if not normalized:\n        raise EpochCommitteeQueryError('Committee query returned an empty set.')\n\n    return normalized\n",
            "usage": "try:\n    committee = get_epoch_committee(parsed_epoch_id)\nexcept EpochCommitteeQueryError as exc:\n    # In a FastAPI/Flask handler you would translate this into a 5xx or 4xx error\n    raise HTTPException(status_code=502, detail=str(exc))"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 enriches each validator in the committee with additional on-chain or indexer metadata such as moniker, identity, commission rate, and an updated reputation score.",
            "code": "import logging\nimport os\nfrom typing import Any, Dict, List, Optional\n\nimport requests\n\n\nlogger = logging.getLogger(__name__)\n\n\ndef enrich_validator_metadata(\n    committee: List[Dict[str, Any]],\n    rest_url: Optional[str] = None,\n    indexer_url: Optional[str] = None,\n) -> List[Dict[str, Any]]:\n    '''\n    For each validator in the committee, fetch additional metadata (moniker,\n    identity, commission rate, and optionally reputation) from the staking\n    registry or an indexer.\n    '''\n    if not committee:\n        return []\n\n    base_rest = rest_url or os.getenv('REPUBLIC_REST_URL', 'http://localhost:1317')\n    base_indexer = indexer_url or os.getenv('REPUBLIC_INDEXER_URL')\n\n    enriched: List[Dict[str, Any]] = []\n\n    for entry in committee:\n        operator_address = entry.get('operator_address')\n        if not operator_address:\n            logger.warning('Skipping committee entry without operator_address: %s', entry)\n            continue\n\n        moniker: Optional[str] = None\n        identity: Optional[str] = None\n        commission_rate: Optional[float] = None\n        reputation = entry.get('reputation')\n\n        # Query staking / validator registry (Cosmos-SDK style)\n        try:\n            staking_url = f'{base_rest}/cosmos/staking/v1beta1/validators/{operator_address}'\n            resp = requests.get(staking_url, timeout=10)\n            if resp.status_code == 200:\n                data = resp.json().get('validator') or {}\n                description = data.get('description') or {}\n                commission = (data.get('commission') or {}).get('commission_rates') or {}\n\n                moniker = description.get('moniker')\n                identity = description.get('identity')\n\n                commission_raw = commission.get('rate')\n                if commission_raw is not None:\n                    try:\n                        commission_rate = float(commission_raw)\n                    except (TypeError, ValueError):\n                        commission_rate = None\n        except requests.RequestException as exc:\n            logger.warning(\n                'Error fetching staking metadata for %s: %s',\n                operator_address,\n                exc,\n            )\n\n        # Optionally fetch a fresher reputation metric from an indexer.\n        if reputation is None and base_indexer:\n            try:\n                rep_url = f'{base_indexer}/republic/validators/{operator_address}/reputation'\n                rep_resp = requests.get(rep_url, timeout=10)\n                if rep_resp.status_code == 200:\n                    rep_data = rep_resp.json()\n                    reputation = rep_data.get('reputation_score') or rep_data.get('score')\n            except requests.RequestException as exc:\n                logger.warning(\n                    'Error fetching reputation for %s from indexer: %s',\n                    operator_address,\n                    exc,\n                )\n\n        enriched_entry = dict(entry)\n        if moniker is not None:\n            enriched_entry['moniker'] = moniker\n        if identity is not None:\n            enriched_entry['identity'] = identity\n        if commission_rate is not None:\n            enriched_entry['commission_rate'] = commission_rate\n        if reputation is not None:\n            enriched_entry['reputation'] = reputation\n\n        enriched.append(enriched_entry)\n\n    return enriched\n",
            "usage": "enriched_committee = enrich_validator_metadata(committee)\n# enriched_committee entries now include moniker, identity, commission_rate, and reputation where available"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 aggregates and formats the enriched committee into a JSON-serializable structure suitable for direct API responses, including epoch_id, committee size, total voting power, and a sorted validator list.",
            "code": "from typing import Any, Dict, List\n\n\ndef format_epoch_committee_response(\n    epoch_id: int,\n    validators: List[Dict[str, Any]],\n) -> Dict[str, Any]:\n    '''\n    Aggregate and format the committee composition for a given epoch into a\n    JSON-serializable structure suitable for returning from an API endpoint.\n    '''\n    if epoch_id <= 0:\n        raise ValueError('epoch_id must be a positive integer.')\n\n    committee_size = len(validators)\n    total_voting_power = sum(\n        int(v.get('voting_power') or 0) for v in validators\n    ) or 0\n\n    formatted_validators: List[Dict[str, Any]] = []\n\n    for v in validators:\n        voting_power = int(v.get('voting_power') or 0)\n        stake_share = float(voting_power) / float(total_voting_power) if total_voting_power > 0 else 0.0\n\n        formatted_validators.append(\n            {\n                'validator_address': v.get('operator_address'),\n                'moniker': v.get('moniker'),\n                'identity': v.get('identity'),\n                'voting_power': voting_power,\n                'stake_share': stake_share,\n                'reputation': v.get('reputation'),\n                'commission_rate': v.get('commission_rate'),\n                'compute_benchmarks': v.get('compute_benchmarks'),\n            }\n        )\n\n    # Sort primarily by voting power (descending), then by reputation if present.\n    def sort_key(item: Dict[str, Any]) -> Any:\n        rep = item.get('reputation')\n        rep_value = float(rep) if rep is not None else 0.0\n        return (-int(item.get('voting_power') or 0), -rep_value)\n\n    formatted_validators.sort(key=sort_key)\n\n    response: Dict[str, Any] = {\n        'epoch_id': epoch_id,\n        'committee_size': committee_size,\n        'total_voting_power': total_voting_power,\n        'validators': formatted_validators,\n    }\n\n    return response\n",
            "usage": "api_payload = format_epoch_committee_response(parsed_epoch_id, enriched_committee)\n# In a FastAPI handler, you could simply `return api_payload` to serialize as JSON"
        }
    ]
}