{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines chain-specific key parameters for Juno, including BIP-44 coin type 118, a standard derivation path, and the bech32 address prefix.",
            "code": "from typing import Any, Dict\n\n\ndef select_juno_chain_key_params() -> Dict[str, Any]:\n    \"\"\"Return standard key parameters for Juno (BIP-44 coin type 118 and bech32 'juno').\n\n    These values are used by later steps to derive keys and addresses consistently.\n    \"\"\"\n    return {\n        \"chain_id\": \"juno-1\",  # Juno mainnet chain-id; adjust if targeting a testnet\n        \"bip44_coin_type\": 118,  # Cosmos ecosystem coin type\n        \"derivation_path\": \"m/44'/118'/0'/0/0\",  # Account 0, external chain, index 0\n        \"bech32_prefix\": \"juno\",  # Bech32 human-readable prefix for Juno addresses\n    }\n",
            "usage": "params = select_juno_chain_key_params()\n# params['derivation_path'] -> \"m/44'/118'/0'/0/0\"\n# params['bech32_prefix']   -> \"juno\""
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 generates a new BIP-39 mnemonic (12 or 24 words) using a cryptographically secure RNG in a backend environment. The mnemonic is returned but must never be logged in plaintext.",
            "code": "from typing import Optional\n\ntry:\n    from bip_utils import Bip39MnemonicGenerator, Bip39WordsNum\nexcept ImportError as exc:\n    raise RuntimeError(\n        \"bip_utils is required for mnemonic generation. Install it with 'pip install bip-utils'.\"\n    ) from exc\n\n\ndef generate_bip39_mnemonic(words: int = 24) -> str:\n    \"\"\"Generate a new BIP-39 mnemonic using a cryptographically secure RNG.\n\n    :param words: Number of words in the mnemonic (12 or 24).\n    :return: The mnemonic sentence as a space-separated string.\n\n    SECURITY NOTE: Do *not* log this mnemonic. Only return it to the caller\n    over a secure channel (e.g. HTTPS) and instruct users to store it offline.\n    \"\"\"\n    if words not in (12, 24):\n        raise ValueError(\"words must be either 12 or 24.\")\n\n    try:\n        words_num = Bip39WordsNum.WORDS_NUM_12 if words == 12 else Bip39WordsNum.WORDS_NUM_24\n        mnemonic = Bip39MnemonicGenerator().FromWordsNumber(words_num)\n    except Exception as exc:  # pragma: no cover - defensive catch\n        raise RuntimeError(\"Failed to generate mnemonic using BIP-39 generator.\") from exc\n\n    # IMPORTANT: Do NOT log the mnemonic here.\n    return str(mnemonic)\n",
            "usage": "mnemonic = generate_bip39_mnemonic(words=24)\n# Show mnemonic once to the end user over HTTPS and never log it."
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 converts the mnemonic to a BIP-39 seed and derives the HD private key along the provided BIP-32/BIP-44 derivation path (e.g., m/44'/118'/0'/0/0).",
            "code": "from typing import Optional\n\ntry:\n    from bip_utils import Bip39SeedGenerator, Bip32Slip10Secp256k1\nexcept ImportError as exc:\n    raise RuntimeError(\n        \"bip_utils is required for HD key derivation. Install it with 'pip install bip-utils'.\"\n    ) from exc\n\n\ndef derive_hd_key_from_mnemonic(mnemonic: str, derivation_path: str = \"m/44'/118'/0'/0/0\") -> bytes:\n    \"\"\"Derive a hierarchical deterministic (HD) private key from a BIP-39 mnemonic.\n\n    This uses BIP-39 to turn the mnemonic into a seed, and BIP-32/BIP-44 logic\n    (SLIP-0010 secp256k1) to derive a private key at the provided path.\n\n    :param mnemonic: BIP-39 mnemonic sentence.\n    :param derivation_path: BIP-32/BIP-44 derivation path, e.g. \"m/44'/118'/0'/0/0\".\n    :return: 32-byte secp256k1 private key.\n    \"\"\"\n    if not isinstance(mnemonic, str) or not mnemonic.strip():\n        raise ValueError(\"mnemonic must be a non-empty string.\")\n    if not isinstance(derivation_path, str) or not derivation_path.startswith(\"m/\"):\n        raise ValueError(\"derivation_path must be a BIP-32 style string starting with 'm/'.\")\n\n    # 1. Convert mnemonic to seed (BIP-39).\n    try:\n        seed_bytes = Bip39SeedGenerator(mnemonic).Generate()\n    except Exception as exc:  # pragma: no cover - defensive\n        raise ValueError(\"Failed to convert mnemonic to seed; is the mnemonic valid BIP-39?\") from exc\n\n    # 2. Derive HD private key using BIP-32/SLIP-0010 secp256k1.\n    try:\n        root = Bip32Slip10Secp256k1.FromSeed(seed_bytes)\n        derived = root.DerivePath(derivation_path)\n        private_key_bytes = derived.PrivateKey().Raw().ToBytes()\n    except Exception as exc:  # pragma: no cover - defensive\n        raise RuntimeError(f\"Failed to derive private key for path {derivation_path}.\") from exc\n\n    if len(private_key_bytes) != 32:\n        raise RuntimeError(\"Derived private key is not 32 bytes; derivation may be incorrect.\")\n\n    # SECURITY NOTE: The caller must ensure this key is protected in memory and at rest.\n    return private_key_bytes\n",
            "usage": "params = select_juno_chain_key_params()\nmnemonic = generate_bip39_mnemonic(words=24)\nprivate_key = derive_hd_key_from_mnemonic(mnemonic, params[\"derivation_path\"])"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 derives the compressed secp256k1 public key from the private key and computes the Juno bech32 address using SHA-256 then RIPEMD-160 followed by bech32 encoding with prefix 'juno'.",
            "code": "from typing import Any, Dict\nimport hashlib\n\ntry:\n    from ecdsa import SECP256k1, SigningKey\nexcept ImportError as exc:\n    raise RuntimeError(\n        \"ecdsa is required for secp256k1 key handling. Install it with 'pip install ecdsa'.\"\n    ) from exc\n\ntry:\n    # Provided by the 'pycryptodome' package\n    from Crypto.Hash import RIPEMD160\nexcept ImportError as exc:\n    raise RuntimeError(\n        \"pycryptodome is required for RIPEMD-160 hashing. Install it with 'pip install pycryptodome'.\"\n    ) from exc\n\ntry:\n    from bech32 import bech32_encode, convertbits\nexcept ImportError as exc:\n    raise RuntimeError(\n        \"bech32 is required for address encoding. Install it with 'pip install bech32'.\"\n    ) from exc\n\n\ndef derive_public_key_and_address(\n    private_key: bytes,\n    bech32_prefix: str = \"juno\",\n) -> Dict[str, Any]:\n    \"\"\"Derive the compressed secp256k1 public key and Juno address from a private key.\n\n    :param private_key: 32-byte secp256k1 private key.\n    :param bech32_prefix: Bech32 human-readable prefix (\"juno\" for the Juno chain).\n    :return: Dict with 'public_key_bytes', 'public_key_hex', and 'address'.\n    \"\"\"\n    if not isinstance(private_key, (bytes, bytearray)):\n        raise TypeError(\"private_key must be bytes.\")\n    if len(private_key) != 32:\n        raise ValueError(\"private_key must be exactly 32 bytes for secp256k1.\")\n\n    # 1. Derive compressed public key from private key.\n    try:\n        sk = SigningKey.from_string(bytes(private_key), curve=SECP256k1)\n        try:\n            # ecdsa>=0.17 supports compressed format directly.\n            public_key_bytes = sk.get_verifying_key().to_string(\"compressed\")\n        except TypeError:\n            # Fallback: compress manually from uncompressed (x||y).\n            vk = sk.get_verifying_key()\n            uncompressed = vk.to_string()  # 64 bytes: x(32) || y(32)\n            x_bytes, y_bytes = uncompressed[:32], uncompressed[32:]\n            prefix = b\"\\x02\" if (y_bytes[-1] % 2 == 0) else b\"\\x03\"\n            public_key_bytes = prefix + x_bytes\n    except Exception as exc:  # pragma: no cover - defensive\n        raise RuntimeError(\"Failed to derive public key from private key.\") from exc\n\n    # 2. Cosmos-style address derivation: RIPEMD160(SHA256(pubkey_bytes)).\n    sha256_digest = hashlib.sha256(public_key_bytes).digest()\n    ripemd160 = RIPEMD160.new()\n    ripemd160.update(sha256_digest)\n    pubkey_hash = ripemd160.digest()  # 20 bytes\n\n    # 3. Encode as bech32 address with the given prefix.\n    data5 = convertbits(pubkey_hash, 8, 5, True)\n    if data5 is None:\n        raise RuntimeError(\"Failed to convert pubkey hash to 5-bit words for bech32 encoding.\")\n\n    address = bech32_encode(bech32_prefix, data5)\n    if address is None:\n        raise RuntimeError(\"bech32_encode returned None; invalid data or prefix.\")\n\n    # SECURITY NOTE: Do not log the private key or mnemonic anywhere.\n    return {\n        \"public_key_bytes\": public_key_bytes,\n        \"public_key_hex\": public_key_bytes.hex(),\n        \"address\": address,\n    }\n",
            "usage": "params = select_juno_chain_key_params()\nprivate_key = derive_hd_key_from_mnemonic(mnemonic, params[\"derivation_path\"])\nkey_info = derive_public_key_and_address(private_key, params[\"bech32_prefix\"])\naddress = key_info[\"address\"]\npublic_key_hex = key_info[\"public_key_hex\"]"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 persists wallet metadata (wallet name, Juno address, public key) in a backend keyring and stores the private key encrypted at rest. The mnemonic itself is not stored.",
            "code": "from typing import Any, Dict\nimport json\nimport os\n\ntry:\n    from cryptography.fernet import Fernet\nexcept ImportError as exc:\n    raise RuntimeError(\n        \"cryptography is required for key encryption. Install it with 'pip install cryptography'.\"\n    ) from exc\n\n\n# Path to a simple JSON-based keyring. In production, replace this with a\n# dedicated KMS, HSM, or secret manager.\nWALLET_STORE_PATH = os.environ.get(\"WALLET_STORE_PATH\", \"wallet_store.json\")\n\n\ndef _get_fernet() -> Fernet:\n    \"\"\"Construct a Fernet instance from the WALLET_ENCRYPTION_KEY env variable.\n\n    Generate a key once with:\n        >>> from cryptography.fernet import Fernet\n        >>> print(Fernet.generate_key().decode())\n\n    Then set WALLET_ENCRYPTION_KEY to that value in your backend environment.\n    \"\"\"\n    key = os.environ.get(\"WALLET_ENCRYPTION_KEY\")\n    if not key:\n        raise RuntimeError(\n            \"WALLET_ENCRYPTION_KEY environment variable must be set to a Fernet key.\"\n        )\n    try:\n        return Fernet(key.encode(\"utf-8\"))\n    except Exception as exc:  # pragma: no cover - defensive\n        raise RuntimeError(\n            \"Invalid WALLET_ENCRYPTION_KEY; expected a value from Fernet.generate_key().\"\n        ) from exc\n\n\ndef persist_wallet_metadata(\n    wallet_name: str,\n    address: str,\n    public_key_hex: str,\n    private_key: bytes,\n) -> Dict[str, Any]:\n    \"\"\"Persist wallet metadata and an encrypted private key in a backend keyring.\n\n    :param wallet_name: Human-readable name for the wallet (e.g. \"MyWalletName\").\n    :param address: Juno bech32 address.\n    :param public_key_hex: Hex-encoded compressed secp256k1 public key.\n    :param private_key: Raw 32-byte secp256k1 private key.\n    :return: Stored wallet metadata (without revealing the raw private key).\n\n    SECURITY NOTES:\n    - The mnemonic is *not* stored here.\n    - The private key is encrypted at rest using Fernet.\n    - For production, replace this file-based store with a stronger KMS/HSM solution.\n    \"\"\"\n    if not wallet_name:\n        raise ValueError(\"wallet_name is required.\")\n    if not address:\n        raise ValueError(\"address is required.\")\n    if not isinstance(private_key, (bytes, bytearray)) or len(private_key) != 32:\n        raise ValueError(\"private_key must be a 32-byte value.\")\n\n    fernet = _get_fernet()\n    encrypted_private_key = fernet.encrypt(bytes(private_key)).decode(\"utf-8\")\n\n    record: Dict[str, Any] = {\n        \"wallet_name\": wallet_name,\n        \"address\": address,\n        \"public_key_hex\": public_key_hex,\n        \"encrypted_private_key\": encrypted_private_key,\n    }\n\n    # Load existing keyring file (if any).\n    try:\n        if os.path.exists(WALLET_STORE_PATH):\n            with open(WALLET_STORE_PATH, \"r\", encoding=\"utf-8\") as f:\n                store = json.load(f)\n        else:\n            store = {}\n    except (OSError, json.JSONDecodeError) as exc:\n        raise RuntimeError(f\"Failed to load wallet store from {WALLET_STORE_PATH}.\") from exc\n\n    if address in store:\n        raise RuntimeError(f\"A wallet with address {address} already exists in the keyring.\")\n\n    store[address] = record\n\n    try:\n        with open(WALLET_STORE_PATH, \"w\", encoding=\"utf-8\") as f:\n            json.dump(store, f, indent=2)\n    except OSError as exc:\n        raise RuntimeError(f\"Failed to persist wallet metadata to {WALLET_STORE_PATH}.\") from exc\n\n    # Return metadata without any secret material.\n    return record\n",
            "usage": "wallet_record = persist_wallet_metadata(\n    wallet_name=\"MyWalletName\",\n    address=key_info[\"address\"],\n    public_key_hex=key_info[\"public_key_hex\"],\n    private_key=private_key,\n)\n# wallet_record now contains non-sensitive metadata; the private key is encrypted at rest."
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 optionally verifies that the backend is connected to a Juno LCD node by querying the /cosmos/base/tendermint/v1beta1/node_info endpoint on https://lcd-archive.junonetwork.io.",
            "code": "from typing import Any, Dict\n\nimport httpx\n\nLCD_BASE_URL = \"https://lcd-archive.junonetwork.io\"\n\n\ndef optional_verify_address_on_chain(expected_network: str = \"juno-1\") -> Dict[str, Any]:\n    \"\"\"Query Juno's node_info endpoint to confirm LCD connectivity and network name.\n\n    The newly created address will *not* appear in on-chain account queries\n    until it receives funds; this function only verifies network information.\n\n    :param expected_network: Expected chain-id (e.g. \"juno-1\").\n    :return: Dict containing the raw response, network name, and a boolean flag.\n    \"\"\"\n    url = f\"{LCD_BASE_URL}/cosmos/base/tendermint/v1beta1/node_info\"\n    try:\n        response = httpx.get(url, timeout=10.0)\n        response.raise_for_status()\n    except httpx.HTTPError as exc:\n        raise RuntimeError(f\"Failed to reach Juno LCD at {url}: {exc}\") from exc\n\n    try:\n        data = response.json()\n    except ValueError as exc:\n        raise RuntimeError(\"LCD node_info response was not valid JSON.\") from exc\n\n    default_info = data.get(\"default_node_info\", {}) or {}\n    network = default_info.get(\"network\")\n    matches_expected = expected_network is None or network == expected_network\n\n    return {\n        \"raw\": data,\n        \"network\": network,\n        \"matches_expected\": matches_expected,\n    }\n",
            "usage": "params = select_juno_chain_key_params()\nnode_info = optional_verify_address_on_chain(expected_network=params[\"chain_id\"])\n# node_info['network'] should be 'juno-1' on Juno mainnet."
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Step 7 provides a high-level backend function that orchestrates steps 1\u20136: it creates a new Juno wallet, persists its metadata, optionally verifies network info, and returns the wallet name, address, and mnemonic once to the caller.",
            "code": "from typing import Any, Dict\n\n\ndef create_juno_wallet(\n    wallet_name: str = \"MyWalletName\",\n    words: int = 24,\n    verify_network: bool = False,\n) -> Dict[str, Any]:\n    \"\"\"Create a new Juno wallet and return its details to the caller.\n\n    This function orchestrates:\n      1. Selecting Juno chain key parameters.\n      2. Generating a BIP-39 mnemonic.\n      3. Deriving the HD private key.\n      4. Deriving the public key and Juno address.\n      5. Persisting wallet metadata with an encrypted private key.\n      6. Optionally verifying LCD connectivity and network id.\n\n    The mnemonic is returned *once* and is not stored by this function. Callers\n    must ensure they only transmit it over secure channels (HTTPS) and never\n    log it in plaintext.\n\n    :param wallet_name: Label for the wallet in your backend keyring.\n    :param words: Number of mnemonic words (12 or 24).\n    :param verify_network: If True, also call the LCD node_info endpoint.\n    :return: Dict with wallet_name, address, mnemonic, and optional network_info.\n    \"\"\"\n    # Step 1: chain key parameters for Juno.\n    params = select_juno_chain_key_params()\n\n    # Step 2: generate a new mnemonic.\n    mnemonic = generate_bip39_mnemonic(words=words)\n\n    # Step 3: derive HD private key from mnemonic and derivation path.\n    private_key = derive_hd_key_from_mnemonic(mnemonic, params[\"derivation_path\"])\n\n    # Step 4: derive public key and Juno address from private key.\n    key_info = derive_public_key_and_address(private_key, params[\"bech32_prefix\"])\n    address = key_info[\"address\"]\n    public_key_hex = key_info[\"public_key_hex\"]\n\n    # Step 5: persist wallet metadata (but *not* the mnemonic).\n    persist_wallet_metadata(wallet_name, address, public_key_hex, private_key)\n\n    # Step 6: optionally verify LCD connectivity and chain-id.\n    network_info: Any = None\n    if verify_network:\n        try:\n            network_info = optional_verify_address_on_chain(expected_network=params[\"chain_id\"])\n        except Exception as exc:  # pragma: no cover - defensive\n            # Network verification issues should not prevent wallet creation.\n            network_info = {\"error\": str(exc)}\n\n    # Step 7: return wallet details to the caller (mnemonic shown once).\n    return {\n        \"wallet_name\": wallet_name,\n        \"address\": address,\n        \"mnemonic\": mnemonic,\n        \"network_info\": network_info,\n        \"warning\": (\n            \"Store this mnemonic offline and never share it. \"\n            \"Anyone with the mnemonic can control your funds.\"\n        ),\n    }\n",
            "usage": "# Example: call from a FastAPI/Django backend route handler.\nresult = create_juno_wallet(wallet_name=\"MyWalletName\", words=24, verify_network=True)\n# Return 'result' as JSON over HTTPS to the frontend, ensuring the mnemonic is\n# displayed only once and never logged server-side."
        }
    ]
}