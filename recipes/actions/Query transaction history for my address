{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 provides a Python helper that picks the most suitable data provider (Celatone GraphQL or Neutron LCD REST) by preference and latency checks.",
            "code": "import time\nimport requests\nfrom typing import Dict\n\n\ndef _ping(url: str, timeout: float = 1.5) -> float:\n    \"\"\"Return response-time in seconds (\u221e if unreachable).\"\"\"\n    start = time.time()\n    try:\n        requests.head(url, timeout=timeout)\n        return time.time() - start\n    except requests.RequestException:\n        return float(\"inf\")\n\n\ndef select_data_provider(prefer_graphql: bool = True) -> Dict[str, str]:\n    \"\"\"Choose the fastest available provider and return a descriptor dict.\"\"\"\n    providers = [\n        {\n            \"name\": \"celatone\",\n            \"base_url\": \"https://celatone-api.neutron.org/v1/graphql\",\n            \"api_type\": \"graphql\",\n        },\n        {\n            \"name\": \"lcd\",\n            \"base_url\": \"https://lcd.neutron.org\",\n            \"api_type\": \"rest\",\n        },\n    ]\n\n    # If GraphQL is preferred, try it first.\n    if prefer_graphql:\n        graphql_providers = [p for p in providers if p[\"api_type\"] == \"graphql\"]\n        if graphql_providers and _ping(graphql_providers[0][\"base_url\"]) != float(\"inf\"):\n            return graphql_providers[0]\n\n    # Fallback: choose the provider with the lowest latency.\n    best = min(providers, key=lambda p: _ping(p[\"base_url\"]))\n    if _ping(best[\"base_url\"]) == float(\"inf\"):\n        raise RuntimeError(\"No data provider is reachable at the moment.\")\n    return best",
            "usage": "provider = select_data_provider(prefer_graphql=True)"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 builds either a GraphQL or REST query that filters by `message.sender = {address}` and orders results by timestamp descending.",
            "code": "from typing import Tuple, Dict, Any, Optional, Union\n\n\ndef build_history_query(\n    provider: Dict[str, str],\n    address: str,\n    limit: int = 50,\n    cursor: Optional[str] = None,\n    offset: int = 0,\n) -> Tuple[str, Union[Dict[str, Any], None]]:\n    \"\"\"Return (query_or_endpoint, variables_or_params) ready for Step 3.\"\"\"\n    if provider[\"api_type\"] == \"graphql\":\n        # Celatone GraphQL query string with optional cursor for pagination.\n        gql_query = (\n            \"\"\"\n            query ($address: String!, $limit: Int!, $cursor: String) {\n              messages(\n                where: {sender: {_eq: $address}},\n                order_by: {block: {time: desc}},\n                limit: $limit,\n                %s\n              ) {\n                transaction_hash\n                block { height time }\n                type\n                success\n                fee { amount denom }\n              }\n              pageInfo: messages_aggregate(where: {sender: {_eq: $address}}) {\n                aggregate { count }\n              }\n            }\n            \"\"\"\n            % (\"offset: 0\" if cursor is None else \"cursor: $cursor\")\n        )\n        variables: Dict[str, Any] = {\"address\": address, \"limit\": limit}\n        if cursor:\n            variables[\"cursor\"] = cursor\n        return gql_query, variables\n\n    # ---------- REST / LCD ----------\n    endpoint = f\"{provider['base_url']}/cosmos/tx/v1beta1/txs\"\n    params: Dict[str, Any] = {\n        \"events\": f\"message.sender='{address}'\",\n        \"order_by\": \"ORDER_BY_DESC\",\n        \"pagination.limit\": str(limit),\n        \"pagination.offset\": str(offset),\n    }\n    return endpoint, params",
            "usage": "query_or_url, vars_or_params = build_history_query(provider, address=\"neutron1...\")"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 executes the HTTP request, returning raw results and a cursor/offset for pagination handling.",
            "code": "import requests\nfrom typing import List, Tuple, Dict, Any, Optional, Union\n\n\ndef execute_query_request(\n    provider: Dict[str, str],\n    query_or_url: str,\n    variables_or_params: Optional[Union[Dict[str, Any], None]] = None,\n    timeout: int = 10,\n) -> Tuple[List[Dict[str, Any]], Optional[str]]:\n    \"\"\"Return (raw_results, next_cursor_or_offset).\"\"\"\n    try:\n        if provider[\"api_type\"] == \"graphql\":\n            resp = requests.post(\n                provider[\"base_url\"],\n                json={\"query\": query_or_url, \"variables\": variables_or_params or {}},\n                timeout=timeout,\n            )\n            resp.raise_for_status()\n            data = resp.json()\n            if \"errors\" in data:\n                raise RuntimeError(f\"GraphQL error: {data['errors']}\")\n            results = data[\"data\"][\"messages\"]\n            # Cursor-based pagination (Celatone may not expose pageInfo directly \u2212 adjust if needed)\n            next_cursor = variables_or_params.get(\"cursor\") if variables_or_params else None\n            return results, next_cursor\n        # ---------------- REST / LCD ----------------\n        resp = requests.get(query_or_url, params=variables_or_params, timeout=timeout)\n        resp.raise_for_status()\n        data = resp.json()\n        results = data.get(\"txs\", []) or data.get(\"tx_responses\", [])\n        next_key = data.get(\"pagination\", {}).get(\"next_key\")\n        return results, next_key\n    except requests.RequestException as exc:\n        raise RuntimeError(f\"Failed to query {provider['name']}: {exc}\") from exc",
            "usage": "raw_results, next_cursor = execute_query_request(provider, query_or_url, vars_or_params)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 normalizes heterogeneous provider responses into a uniform schema suitable for rendering in a frontend table.",
            "code": "from typing import List, Dict, Any\n\n\ndef normalize_tx_results(provider: Dict[str, str], raw_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"Map each transaction to {hash, blockHeight, action, fee, success}.\"\"\"\n    normalized: List[Dict[str, Any]] = []\n\n    if provider[\"api_type\"] == \"graphql\":\n        for item in raw_results:\n            fee_obj = item.get(\"fee\", {}) or {}\n            fee_str = (\n                f\"{fee_obj.get('amount', '0')}{fee_obj.get('denom', '')}\"\n                if fee_obj else \"0\"\n            )\n            normalized.append(\n                {\n                    \"hash\": item.get(\"transaction_hash\"),\n                    \"blockHeight\": item.get(\"block\", {}).get(\"height\"),\n                    \"timestamp\": item.get(\"block\", {}).get(\"time\"),\n                    \"action\": item.get(\"type\"),\n                    \"fee\": fee_str,\n                    \"success\": bool(item.get(\"success\")),\n                }\n            )\n    else:  # REST / LCD\n        for tx in raw_results:\n            # Transaction hash and height\n            hash_ = tx.get(\"txhash\") or tx.get(\"hash\")\n            height = int(tx.get(\"height\", 0))\n            timestamp = tx.get(\"timestamp\")\n\n            # First message type as action indicator\n            first_msg = (\n                (tx.get(\"tx\", {}) or {}).get(\"body\", {}).get(\"messages\", [])\n            )\n            action = first_msg[0].get(\"@type\", \"\") if first_msg else \"\"\n\n            # Fee formatting\n            fee_info = (tx.get(\"tx\", {}) or {}).get(\"auth_info\", {}).get(\"fee\", {})\n            fee_amounts = fee_info.get(\"amount\", [])\n            fee_str = (\n                f\"{fee_amounts[0]['amount']}{fee_amounts[0]['denom']}\" if fee_amounts else \"0\"\n            )\n\n            success = tx.get(\"code\", 0) == 0  # code == 0 indicates success\n\n            normalized.append(\n                {\n                    \"hash\": hash_,\n                    \"blockHeight\": height,\n                    \"timestamp\": timestamp,\n                    \"action\": action,\n                    \"fee\": fee_str,\n                    \"success\": success,\n                }\n            )\n    return normalized",
            "usage": "table_rows = normalize_tx_results(provider, raw_results)"
        }
    ]
}