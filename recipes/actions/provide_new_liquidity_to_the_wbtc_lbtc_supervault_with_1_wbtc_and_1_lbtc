{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Connects the user\u2019s Keplr wallet and returns the Neutron address that will fund the Supervault deposit.",
            "code": "export const getUserWalletAddress = async () => {\n  const chainId = 'neutron-1';\n\n  // Make sure Keplr is available in the browser\n  if (!window?.keplr) {\n    throw new Error('Keplr wallet is not installed.');\n  }\n\n  try {\n    // Ask the extension to enable the Neutron chain\n    await window.keplr.enable(chainId);\n\n    // Obtain the OfflineSigner and fetch the first account\n    const signer = window.keplr.getOfflineSigner(chainId);\n    const accounts = await signer.getAccounts();\n\n    if (!accounts || accounts.length === 0) {\n      throw new Error('No account found in the signer.');\n    }\n\n    return accounts[0].address;\n  } catch (error) {\n    console.error('Failed to fetch wallet address', error);\n    throw error;\n  }\n};",
            "usage": "const address = await getUserWalletAddress();"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "FastAPI route that checks the CW20 balances of WBTC and LBTC for the provided address and verifies they each hold at least 1 token.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.contract import SmartContract\nimport os\n\napp = FastAPI()\n\nLCD_URL = os.getenv('LCD_URL', 'https://rest-kralum.neutron.org')\nCHAIN_ID = os.getenv('CHAIN_ID', 'neutron-1')\nWBTC_CONTRACT = os.getenv('WBTC_CONTRACT', 'neutron1wbtcxxxxxxxxxxxxxxxxxxxxxx')\nLBTC_CONTRACT = os.getenv('LBTC_CONTRACT', 'neutron1lbtcxxxxxxxxxxxxxxxxxxxxxx')\nMICRO_FACTOR = 1_000_000  # 1 token = 1_000_000 micro-units (example)\n\nnetwork_cfg = NetworkConfig(chain_id=CHAIN_ID, url=LCD_URL)\nclient = LedgerClient(network_cfg)\n\nclass BalanceStatus(BaseModel):\n    has_wbtc: bool\n    has_lbtc: bool\n\ndef cw20_balance(contract: str, addr: str) -> int:\n    \"\"\"Query CW20 balance via the contract's `balance` endpoint.\"\"\"\n    sc = SmartContract(contract, client)\n    try:\n        resp = sc.query({\"balance\": {\"address\": addr}})\n        return int(resp.get('balance', '0'))\n    except Exception:\n        # If the query fails treat balance as zero\n        return 0\n\n@app.get('/api/validate_balances', response_model=BalanceStatus)\nasync def validate_token_balances(address: str):\n    \"\"\"Checks that the user holds \u22651 WBTC and \u22651 LBTC.\"\"\"\n    try:\n        wbtc_bal = cw20_balance(WBTC_CONTRACT, address)\n        lbtc_bal = cw20_balance(LBTC_CONTRACT, address)\n        return BalanceStatus(\n            has_wbtc=wbtc_bal >= MICRO_FACTOR,\n            has_lbtc=lbtc_bal >= MICRO_FACTOR,\n        )\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=str(err))",
            "usage": "const ok = await fetch(`/api/validate_balances?address=${address}`).then(r => r.json());"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Returns the hard-coded (or environment-configured) contract address for the WBTC/LBTC Supervault.",
            "code": "from fastapi import FastAPI\nimport os\n\napp = FastAPI()\n\n@app.get('/api/supervault_address')\nasync def get_supervault_contract_address():\n    \"\"\"Simple helper so the frontend can discover the Supervault contract.\"\"\"\n    return {\n        'supervault_address': os.getenv('SUPERVAULT_CONTRACT', 'neutron1supervaultxxxxxxxxxxxxxxxxxxxxxx')\n    }",
            "usage": "const { supervault_address } = await fetch('/api/supervault_address').then(r => r.json());"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Builds an unsigned transaction containing two CW20 `send` messages\u2014one for 1 WBTC and one for 1 LBTC\u2014each forwarding tokens to the Supervault contract with a `deposit{}` payload.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport os, base64, json\n\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.tx import Transaction\n\napp = FastAPI()\n\nLCD_URL = os.getenv('LCD_URL', 'https://rest-kralum.neutron.org')\nCHAIN_ID = os.getenv('CHAIN_ID', 'neutron-1')\nWBTC_CONTRACT = os.getenv('WBTC_CONTRACT', 'neutron1wbtcxxxxxxxxxxxxxxxxxxxxxx')\nLBTC_CONTRACT = os.getenv('LBTC_CONTRACT', 'neutron1lbtcxxxxxxxxxxxxxxxxxxxxxx')\nSUPERVAULT_CONTRACT = os.getenv('SUPERVAULT_CONTRACT', 'neutron1supervaultxxxxxxxxxxxxxxxxxxxxxx')\nMICRO_FACTOR = 1_000_000\n\nnetwork_cfg = NetworkConfig(chain_id=CHAIN_ID, url=LCD_URL)\nclient = LedgerClient(network_cfg)\n\nclass TxBytes(BaseModel):\n    tx_bytes: str  # base64-encoded unsigned Tx body (returned to caller)\n\n@app.post('/api/construct_tx', response_model=TxBytes)\nasync def construct_tx_supervault_deposit(address: str):\n    \"\"\"Creates an unsigned deposit Tx and returns the raw bytes (base64).\"\"\"\n    try:\n        # Payload that the Supervault expects (often empty for simple deposits)\n        deposit_msg = {\"deposit\": {}}\n        deposit_payload_b64 = base64.b64encode(json.dumps(deposit_msg).encode()).decode()\n\n        def build_cw20_send(token_contract: str):\n            return {\n                \"typeUrl\": \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n                \"value\": {\n                    \"sender\": address,\n                    \"contract\": token_contract,\n                    \"msg\": base64.b64encode(json.dumps({\n                        \"send\": {\n                            \"contract\": SUPERVAULT_CONTRACT,\n                            \"amount\": str(MICRO_FACTOR),  # 1 token\n                            \"msg\": deposit_payload_b64\n                        }\n                    }).encode()).decode(),\n                    \"funds\": []\n                }\n            }\n\n        # Compose both messages\n        msgs = [build_cw20_send(WBTC_CONTRACT), build_cw20_send(LBTC_CONTRACT)]\n\n        tx = Transaction()\n        for m in msgs:\n            tx.add_message(m[\"value\"])\n\n        # Gas/fee estimates \u2014 tune to production needs\n        tx.set_fee(5000, \"untrn\")\n        tx.set_gas(400000)\n\n        unsigned_tx = tx.get_unsigned()\n        return {\"tx_bytes\": base64.b64encode(unsigned_tx.SerializeToString()).decode()}\n\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=str(err))",
            "usage": "const { tx_bytes } = await fetch('/api/construct_tx', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ address })\n}).then(r => r.json());"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Signs the unsigned Tx produced in Step 4 with a server-side mnemonic (kept secret on the backend) and broadcasts it to the Neutron network.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport os, base64\n\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import PrivateKeyWallet\nfrom cosmpy.aerial.tx import Transaction\n\napp = FastAPI()\n\nLCD_URL = os.getenv('LCD_URL', 'https://rest-kralum.neutron.org')\nCHAIN_ID = os.getenv('CHAIN_ID', 'neutron-1')\nnetwork_cfg = NetworkConfig(chain_id=CHAIN_ID, url=LCD_URL)\nclient = LedgerClient(network_cfg)\n\n# IMPORTANT: Store this mnemonic securely (e.g., Hashicorp Vault, AWS Secrets Manager)\nMNEMONIC = os.getenv('SIGNING_MNEMONIC')\nif not MNEMONIC:\n    raise RuntimeError('SIGNING_MNEMONIC environment variable is missing')\nwallet = PrivateKeyWallet.from_mnemonic(MNEMONIC)\n\nclass BroadcastReq(BaseModel):\n    tx_bytes: str  # base64-encoded unsigned Tx\n\n@app.post('/api/sign_and_broadcast')\nasync def sign_and_broadcast_tx(req: BroadcastReq):\n    \"\"\"Signs the provided Tx bytes and broadcasts them to Neutron.\"\"\"\n    try:\n        raw = base64.b64decode(req.tx_bytes)\n        tx = Transaction.load(raw)\n        signed_tx = tx.sign(wallet)\n        response = client.broadcast_tx(signed_tx)\n\n        # cosmpy returns an object that can be inspected for errors\n        if response.is_err():\n            raise HTTPException(status_code=500, detail=response.raw_log)\n\n        return {\"tx_hash\": response.tx_hash}\n\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=str(err))",
            "usage": "const { tx_hash } = await fetch('/api/sign_and_broadcast', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ tx_bytes })\n}).then(r => r.json());"
        }
    ]
}