{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Step 1 defines a small helper that constructs a valid JSON-RPC payload for either `txpool_inspect` (light-weight textual summary) or `txpool_content` (full transaction objects). It returns the payload so the caller can forward it to the backend.",
            "code": "/* utils/txpool.js */\nexport const createTxpoolPayload = (depth = 'inspect') => {\n  // Acceptable values are 'inspect' or 'content'. Default = 'inspect'.\n  const allowed = ['inspect', 'content'];\n  if (!allowed.includes(depth)) {\n    throw new Error(`Invalid depth: ${depth}. Expected 'inspect' or 'content'.`);\n  }\n\n  const method = depth === 'content' ? 'txpool_content' : 'txpool_inspect';\n\n  return {\n    jsonrpc: '2.0',\n    method,\n    params: [],\n    id: Date.now() // simple unique identifier\n  };\n};",
            "usage": "// Example (frontend)\nimport { createTxpoolPayload } from './utils/txpool.js';\n\nconst payload = createTxpoolPayload('inspect');\n// send `payload` to the backend route created in Step 2"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 exposes a FastAPI endpoint that receives the JSON-RPC payload from the frontend, forwards it to the EVM-compatible JSON-RPC node (endpoint stored in an environment variable), and streams the raw JSON-RPC response back. Separating this call on the backend prevents leaking the RPC URL or any potential auth headers to the browser.",
            "code": "######################## api/txpool.py ########################\nfrom fastapi import APIRouter, HTTPException, Depends, Request\nimport os, httpx, json\n\nrouter = APIRouter(prefix=\"/api\")\n\n# The RPC endpoint is read from an environment variable so it is **never** exposed to the browser.\nRPC_ENDPOINT = os.getenv(\"RPC_ENDPOINT\", \"http://localhost:8545\")  # fallback for local dev\n\n@router.post(\"/txpool\")\nasync def txpool_proxy(request: Request):\n    \"\"\"Proxy any txpool_* JSON-RPC request to the configured RPC_ENDPOINT.\"\"\"\n    try:\n        payload = await request.json()\n    except ValueError:\n        raise HTTPException(status_code=400, detail=\"Invalid JSON body\")\n\n    # Basic sanity-check that the user is only allowed to call txpool_* methods\n    if not payload.get(\"method\", \"\").startswith(\"txpool_\"):\n        raise HTTPException(status_code=400, detail=\"Only txpool_* methods are allowed\")\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            rpc_response = await client.post(RPC_ENDPOINT, json=payload)\n            rpc_response.raise_for_status()\n            return rpc_response.json()\n    except httpx.HTTPStatusError as he:\n        # Bubble up node-side HTTP errors\n        raise HTTPException(status_code=he.response.status_code, detail=str(he))\n    except Exception as e:\n        # Catch-all to ensure the client always receives a clean error structure\n        raise HTTPException(status_code=500, detail=f\"txpool_proxy internal error: {e}\")",
            "usage": "// Example (frontend)\nconst res = await fetch('/api/txpool', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(payload) // `payload` produced in Step 1\n});\nconst rawRpcResponse = await res.json();"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 adds a reusable Python helper that takes the raw JSON-RPC response returned by Step 2 and normalises it into a friendlier structure. If the caller used `txpool_inspect`, the helper returns a list of strings (`account:nonce => txData`). If the caller used `txpool_content`, it returns the full, deeply-nested dictionary of pending/queued transactions.",
            "code": "######################## utils/txpool_parser.py ########################\nfrom typing import Any, Dict, List, Union\n\nclass TxpoolParsingError(Exception):\n    \"\"\"Raised when the JSON-RPC response cannot be parsed as expected.\"\"\"\n\n\ndef parse_txpool_response(rpc_response: Dict[str, Any]) -> Union[List[str], Dict[str, Any]]:\n    \"\"\"Normalise the JSON-RPC `result` field.\n\n    Args:\n        rpc_response (dict): Raw response from an EVM JSON-RPC node.\n\n    Returns:\n        Union[List[str], Dict[str, Any]]: A simplified representation.\n\n    Raises:\n        TxpoolParsingError: If the response is malformed or contains an error.\n    \"\"\"\n    # Check for JSON-RPC errors first\n    if \"error\" in rpc_response:\n        raise TxpoolParsingError(rpc_response[\"error\"].get(\"message\", \"Unknown RPC error\"))\n\n    result = rpc_response.get(\"result\")\n    if result is None:\n        raise TxpoolParsingError(\"Missing 'result' field in RPC response\")\n\n    # Heuristically decide which method was used based on the payload format\n    if isinstance(result, str):\n        # This should be the `txpool_inspect` response (a big string). Split by lines.\n        # Each line looks like: \"0xAccount:nonce   tx_hash   {tx details...}\"\n        return [line.strip() for line in result.splitlines() if line.strip()]\n    elif isinstance(result, dict):\n        # Likely `txpool_content`: keep the full structure (pending / queued)\n        return result\n    else:\n        raise TxpoolParsingError(\"Unrecognised txpool response format\")",
            "usage": "from utils.txpool_parser import parse_txpool_response\n\n# Inside any backend handler (e.g., augmenting Step 2)\nparsed = parse_txpool_response(rawRpcResponse)\n# `parsed` is now a Python list (for 'inspect') or dict (for 'content') that can be sent back to the frontend."
        }
    ]
}