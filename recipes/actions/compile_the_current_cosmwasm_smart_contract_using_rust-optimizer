{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a backend helper that locates the CosmWasm single-contract project root by searching upward for Cargo.toml and rejecting workspace manifests.",
            "code": "from pathlib import Path\nfrom typing import Optional\n\nclass ProjectRootError(Exception):\n    # Raised when a CosmWasm contract project root cannot be determined.\n    pass\n\n\ndef detect_contract_project_root(start_dir: Optional[str] = None) -> Path:\n    # Determine the single-contract project root by searching upward for a\n    # Cargo.toml file that has a [package] section and does NOT declare [workspace].\n    start_path = Path(start_dir).resolve() if start_dir else Path.cwd().resolve()\n    current = start_path\n\n    # Walk up the directory tree until we find a suitable Cargo.toml.\n    for candidate in [current] + list(current.parents):\n        cargo_toml = candidate / 'Cargo.toml'\n        if cargo_toml.is_file():\n            try:\n                import tomllib  # Python 3.11+\n            except ModuleNotFoundError:\n                import tomli as tomllib  # type: ignore\n\n            with cargo_toml.open('rb') as f:\n                cargo_data = tomllib.load(f)\n\n            # Reject workspaces: these usually correspond to multi-contract repos.\n            if 'workspace' in cargo_data:\n                raise ProjectRootError(\n                    f'Found Cargo.toml at {cargo_toml}, but it defines a [workspace]. '\n                    'This helper expects to run inside a single-contract project. '\n                    'Please cd into the individual contract crate directory and retry.'\n                )\n\n            if 'package' not in cargo_data:\n                raise ProjectRootError(\n                    f'Cargo.toml at {cargo_toml} does not contain a [package] section. '\n                    'This does not look like a valid CosmWasm contract crate.'\n                )\n\n            return candidate\n\n    # No suitable Cargo.toml found.\n    raise ProjectRootError(\n        f'Could not locate a suitable Cargo.toml when walking up from {start_path}. '\n        'Ensure you are running this from within a CosmWasm single-contract project.'\n    )",
            "usage": "project_root = detect_contract_project_root()"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 provides a backend helper that reads the [package] name from Cargo.toml and computes the expected artifacts/CONTRACT_NAME.wasm path.",
            "code": "from pathlib import Path\nfrom typing import Tuple\n\nclass CargoReadError(Exception):\n    # Raised when Cargo.toml cannot be read or does not contain the expected fields.\n    pass\n\n\ndef read_contract_name_from_cargo(project_root: str) -> Tuple[str, Path]:\n    # Read the [package] name from Cargo.toml in the given project root and\n    # build the expected artifacts/<CONTRACT_NAME>.wasm path.\n    root = Path(project_root).resolve()\n    cargo_toml = root / 'Cargo.toml'\n\n    if not cargo_toml.is_file():\n        raise CargoReadError(f'Cargo.toml not found at {cargo_toml}')\n\n    try:\n        import tomllib  # Python 3.11+\n    except ModuleNotFoundError:\n        import tomli as tomllib  # type: ignore\n\n    try:\n        with cargo_toml.open('rb') as f:\n            cargo_data = tomllib.load(f)\n        package_table = cargo_data['package']\n        contract_name = package_table['name']\n    except KeyError as exc:\n        raise CargoReadError(\n            f'Cargo.toml at {cargo_toml} is missing the [package] name field.'\n        ) from exc\n\n    artifacts_dir = root / 'artifacts'\n    artifact_path = artifacts_dir / f'{contract_name}.wasm'\n\n    return contract_name, artifact_path",
            "usage": "contract_name, artifact_path = read_contract_name_from_cargo(str(project_root))"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 runs the CosmWasm rust-optimizer build from the backend using Docker by default, capturing stdout and stderr so failures can be surfaced to the frontend.",
            "code": "from pathlib import Path\nfrom typing import Dict, Any, Optional\nimport subprocess\n\nclass RustOptimizerError(Exception):\n    # Raised when running the CosmWasm rust-optimizer fails.\n    pass\n\n\ndef run_rust_optimizer(\n    project_root: str,\n    use_docker: bool = True,\n    docker_image: str = 'cosmwasm/rust-optimizer:0.14.0',\n    timeout_seconds: Optional[int] = None,\n) -> Dict[str, Any]:\n    # Run the CosmWasm rust-optimizer against the given project root.\n    # By default this uses the official Docker image; set use_docker=False\n    # to instead run a local 'cargo wasm --locked --release' build.\n    root = Path(project_root).resolve()\n\n    if not (root / 'Cargo.toml').is_file():\n        raise RustOptimizerError(\n            f'No Cargo.toml found under {root}. Is this a valid CosmWasm contract project?'\n        )\n\n    if use_docker:\n        # Recommended path: use the official rust-optimizer Docker image.\n        target_dir = root / 'target'\n        cmd = [\n            'docker',\n            'run',\n            '--rm',\n            '-v',\n            f'{root}:/code',\n            '-v',\n            f'{target_dir}:/target',\n            '-v',\n            'rust-optimizer-cache:/usr/local/cargo/registry',\n            docker_image,\n        ]\n        working_dir = root\n    else:\n        # Fallback: run a local cargo build (requires wasm32 target and wasm-opt).\n        cmd = ['cargo', 'wasm', '--locked', '--release']\n        working_dir = root\n\n    try:\n        completed = subprocess.run(\n            cmd,\n            cwd=working_dir,\n            check=False,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            timeout=timeout_seconds,\n        )\n    except FileNotFoundError as exc:\n        # Binary (docker or cargo) not found on PATH.\n        raise RustOptimizerError(\n            f'Failed to execute {cmd[0]!r}. Ensure it is installed and available on PATH.'\n        ) from exc\n    except subprocess.TimeoutExpired as exc:\n        raise RustOptimizerError(\n            f'rust-optimizer command timed out after {timeout_seconds} seconds.'\n        ) from exc\n\n    if completed.returncode != 0:\n        # Attach stdout/stderr to the error so callers can surface logs to the UI.\n        raise RustOptimizerError(\n            'rust-optimizer command failed with non-zero exit code '\n            f'{completed.returncode}.\\n\\nSTDOUT:\\n{completed.stdout}\\n\\nSTDERR:\\n{completed.stderr}'\n        )\n\n    return {\n        'stdout': completed.stdout,\n        'stderr': completed.stderr,\n        'returncode': completed.returncode,\n        'command': cmd,\n    }",
            "usage": "result = run_rust_optimizer(str(project_root))\noptimizer_stdout, optimizer_stderr = result['stdout'], result['stderr']"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 verifies that the optimized wasm artifact exists, is non-empty, and looks like a valid WebAssembly module, optionally running an external validator and including optimizer logs if verification fails.",
            "code": "from pathlib import Path\nfrom typing import Optional, Dict, Any\nimport subprocess\n\nclass WasmArtifactError(Exception):\n    # Raised when the optimized wasm artifact is missing or invalid.\n    pass\n\n\ndef verify_wasm_artifact(\n    artifact_path: str,\n    optimizer_stdout: Optional[str] = None,\n    optimizer_stderr: Optional[str] = None,\n    run_wasm_validator: bool = True,\n    wasm_validator_cmd: Optional[list] = None,\n) -> Dict[str, Any]:\n    # Verify that the artifact exists, is non-empty, and looks like a valid wasm module.\n    path = Path(artifact_path).resolve()\n\n    if not path.is_file():\n        msg = f'WASM artifact not found at {path}.'\n        if optimizer_stdout or optimizer_stderr:\n            msg += '\\n\\nOptimizer STDOUT:\\n' + (optimizer_stdout or '')\n            msg += '\\n\\nOptimizer STDERR:\\n' + (optimizer_stderr or '')\n        raise WasmArtifactError(msg)\n\n    size = path.stat().st_size\n    if size == 0:\n        msg = f'WASM artifact at {path} is empty (0 bytes).'\n        if optimizer_stdout or optimizer_stderr:\n            msg += '\\n\\nOptimizer STDOUT:\\n' + (optimizer_stdout or '')\n            msg += '\\n\\nOptimizer STDERR:\\n' + (optimizer_stderr or '')\n        raise WasmArtifactError(msg)\n\n    # Check the wasm magic bytes: 0x00 0x61 0x73 0x6d ('\\0asm').\n    with path.open('rb') as f:\n        magic = f.read(4)\n\n    if magic != b'\\x00asm':\n        msg = (\n            f'File at {path} does not appear to be a valid WebAssembly module. '\n            f'Expected magic bytes 0x00 0x61 0x73 0x6d, got {magic!r}. '\n        )\n        if optimizer_stdout or optimizer_stderr:\n            msg += '\\n\\nOptimizer STDOUT:\\n' + (optimizer_stdout or '')\n            msg += '\\n\\nOptimizer STDERR:\\n' + (optimizer_stderr or '')\n        raise WasmArtifactError(msg)\n\n    validator_output: Dict[str, Any] = {}\n\n    if run_wasm_validator:\n        # Use wasm-tools wasm-validate by default if available.\n        cmd = wasm_validator_cmd or ['wasm-tools', 'validate', str(path)]\n\n        try:\n            completed = subprocess.run(\n                cmd,\n                check=False,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n            )\n        except FileNotFoundError:\n            # External validator is optional; if missing, we just skip it.\n            validator_output = {\n                'validator_cmd': cmd,\n                'skipped': True,\n                'reason': f'Validator command {cmd[0]!r} not found on PATH; magic-byte validation passed.',\n            }\n        else:\n            if completed.returncode != 0:\n                msg = (\n                    f'External wasm validator failed for {path} with exit code {completed.returncode}. '\n                    f'Validator STDOUT:\\n{completed.stdout}\\nValidator STDERR:\\n{completed.stderr}'\n                )\n                if optimizer_stdout or optimizer_stderr:\n                    msg += '\\n\\nOptimizer STDOUT:\\n' + (optimizer_stdout or '')\n                    msg += '\\n\\nOptimizer STDERR:\\n' + (optimizer_stderr or '')\n                raise WasmArtifactError(msg)\n\n            validator_output = {\n                'validator_cmd': cmd,\n                'skipped': False,\n                'stdout': completed.stdout,\n                'stderr': completed.stderr,\n            }\n\n    return {\n        'artifact_path': str(path),\n        'size_bytes': size,\n        'magic_bytes': list(magic),\n        'validator': validator_output,\n    }",
            "usage": "verification = verify_wasm_artifact(str(artifact_path), optimizer_stdout=optimizer_stdout, optimizer_stderr=optimizer_stderr)"
        }
    ]
}