{
    "label": "upload",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Load critical chain configuration (RPC, chain-id, mnemonic, gas prices) from a .env file so subsequent steps can sign and submit Cosmos transactions.",
            "code": "from dotenv import load_dotenv\nimport os\n\n# config.py\n\ndef get_chain_config():\n    \"\"\"Read required environment variables and return them in a dict.\"\"\"\n    load_dotenv()\n    rpc_endpoint = os.getenv(\"RPC_ENDPOINT\")\n    chain_id = os.getenv(\"CHAIN_ID\")\n    mnemonic = os.getenv(\"DEPLOYER_MNEMONIC\")\n    gas_prices = os.getenv(\"GAS_PRICES\", \"0.025untrn\")  # sensible default\n\n    # Basic validation\n    if not rpc_endpoint or not chain_id or not mnemonic:\n        raise EnvironmentError(\n            \"RPC_ENDPOINT, CHAIN_ID and DEPLOYER_MNEMONIC must be set in .env\"\n        )\n\n    return {\n        \"rpc_endpoint\": rpc_endpoint,\n        \"chain_id\": chain_id,\n        \"mnemonic\": mnemonic,\n        \"gas_prices\": gas_prices,\n    }\n\nif __name__ == \"__main__\":\n    # Quick manual test\n    print(get_chain_config())",
            "usage": ">>> from config import get_chain_config\n>>> cfg = get_chain_config()"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Compile the CosmWasm contract to .wasm and then run the official docker optimizer to create a gas-efficient binary in ./artifacts.",
            "code": "import subprocess\nfrom pathlib import Path\n\n# build.py\n\ndef build_and_optimize(contract_root: str = \".\") -> dict:\n    \"\"\"Run `cargo wasm` followed by the rust-optimizer docker image.\"\"\"\n    root = Path(contract_root).resolve()\n\n    try:\n        # 1. Raw wasm build (debug, un-optimized)\n        subprocess.run([\"cargo\", \"wasm\"], check=True, cwd=root)\n\n        # 2. Run optimizer docker image \u2013 output goes to <root>/artifacts/*.wasm\n        subprocess.run(\n            [\n                \"docker\",\n                \"run\",\n                \"--rm\",\n                \"-v\",\n                f\"{root}:/code\",\n                \"cosmtrek/wasm:optimizer\",\n                \".\",\n            ],\n            check=True,\n        )\n\n        # Pick the most recent optimized wasm file\n        artifacts_dir = root / \"artifacts\"\n        wasm_files = sorted(artifacts_dir.glob(\"*.wasm\"), key=lambda p: p.stat().st_mtime, reverse=True)\n        if not wasm_files:\n            raise FileNotFoundError(\"No optimized .wasm found in artifacts/\")\n\n        return {\"wasm_path\": str(wasm_files[0])}\n\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(f\"Contract build failed: {err}\")\n\nif __name__ == \"__main__\":\n    print(build_and_optimize())",
            "usage": ">>> from build import build_and_optimize\n>>> result = build_and_optimize()\n>>> print(result[\"wasm_path\"])  # => ./artifacts/counter.wasm"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Upload (StoreCode) the optimized .wasm to the chain and obtain the resulting `code_id` using cosmpy.",
            "code": "from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.crypto.address import Address\nfrom config import get_chain_config\n\n# store_code.py\n\ndef store_code(wasm_path: str) -> dict:\n    cfg = get_chain_config()\n\n    # Prepare client & wallet\n    network_cfg = NetworkConfig(\n        chain_id=cfg[\"chain_id\"],\n        url=cfg[\"rpc_endpoint\"],\n        fee_minimum_gas_price=cfg[\"gas_prices\"],\n    )\n    client = LedgerClient(network_cfg)\n    wallet = LocalWallet.create_from_mnemonic(cfg[\"mnemonic\"])\n\n    # Build & send StoreCode tx\n    with open(wasm_path, \"rb\") as fp:\n        wasm_bytes = fp.read()\n\n    tx = Transaction(client=client, wallet=wallet)\n    tx.add_message(tx.MsgStoreCode(wallet.address(), wasm_bytes))\n\n    try:\n        result = tx.broadcast()\n    except Exception as e:\n        raise RuntimeError(f\"Failed to store code: {e}\")\n\n    # Extract code_id from tx logs\n    try:\n        code_id = int(result.logs[0].events_by_type[\"store_code\"][\"code_id\"][0])\n    except (KeyError, IndexError, ValueError):\n        raise RuntimeError(\"Could not parse code_id from broadcast result\")\n\n    return {\"code_id\": code_id, \"tx_hash\": result.tx_hash}\n\nif __name__ == \"__main__\":\n    print(store_code(\"artifacts/counter.wasm\"))",
            "usage": ">>> from store_code import store_code\n>>> rsp = store_code(\"artifacts/counter.wasm\")\n>>> print(rsp)  # {'code_id': 17, 'tx_hash': 'ABC123...'}"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Instantiate the uploaded counter contract (label = \"counter\") with `{ \"start\": 0 }` and capture the new on-chain address.",
            "code": "from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.aerial.tx import Transaction\nfrom config import get_chain_config\n\n# instantiate.py\n\ndef instantiate_contract(code_id: int, label: str = \"counter\", init_msg: dict | None = None) -> dict:\n    cfg = get_chain_config()\n    init_msg = init_msg or {\"start\": 0}\n\n    network_cfg = NetworkConfig(\n        chain_id=cfg[\"chain_id\"],\n        url=cfg[\"rpc_endpoint\"],\n        fee_minimum_gas_price=cfg[\"gas_prices\"],\n    )\n    client = LedgerClient(network_cfg)\n    wallet = LocalWallet.create_from_mnemonic(cfg[\"mnemonic\"])\n\n    tx = Transaction(client=client, wallet=wallet)\n    tx.add_message(\n        tx.MsgInstantiateContract(\n            sender=wallet.address(),\n            admin=None,  # no admin\n            code_id=code_id,\n            msg=init_msg,\n            funds=[],\n            label=label,\n        )\n    )\n\n    try:\n        result = tx.broadcast()\n    except Exception as e:\n        raise RuntimeError(f\"Instantiation failed: {e}\")\n\n    try:\n        contract_addr = result.logs[0].events_by_type[\"instantiate\"][\"_contract_address\"][0]\n    except (KeyError, IndexError):\n        raise RuntimeError(\"Contract address not found in tx logs\")\n\n    return {\"contract_addr\": contract_addr, \"tx_hash\": result.tx_hash}\n\nif __name__ == \"__main__\":\n    print(instantiate_contract(17))",
            "usage": ">>> from instantiate import instantiate_contract\n>>> rsp = instantiate_contract(code_id=17)\n>>> print(rsp[\"contract_addr\"])"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Execute the `increment` method on the deployed counter contract to increase the stored count by one.",
            "code": "from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.aerial.tx import Transaction\nfrom config import get_chain_config\n\n# execute.py\n\ndef increment(contract_addr: str) -> dict:\n    cfg = get_chain_config()\n\n    network_cfg = NetworkConfig(\n        chain_id=cfg[\"chain_id\"],\n        url=cfg[\"rpc_endpoint\"],\n        fee_minimum_gas_price=cfg[\"gas_prices\"],\n    )\n    client = LedgerClient(network_cfg)\n    wallet = LocalWallet.create_from_mnemonic(cfg[\"mnemonic\"])\n\n    tx = Transaction(client=client, wallet=wallet)\n    tx.add_message(\n        tx.MsgExecuteContract(\n            sender=wallet.address(),\n            contract=contract_addr,\n            msg={\"increment\": {}},\n            funds=[],\n        )\n    )\n\n    try:\n        result = tx.broadcast()\n    except Exception as e:\n        raise RuntimeError(f\"Execute failed: {e}\")\n\n    return {\"tx_hash\": result.tx_hash}\n\nif __name__ == \"__main__\":\n    print(increment(\"neutron1...\"))",
            "usage": ">>> from execute import increment\n>>> tx = increment(contract_addr)\n>>> print(tx[\"tx_hash\"])"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Smart-query the counter contract to verify the new `count` value.",
            "code": "from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom config import get_chain_config\n\n# query.py\n\ndef get_count(contract_addr: str) -> dict:\n    cfg = get_chain_config()\n\n    client = LedgerClient(\n        NetworkConfig(\n            chain_id=cfg[\"chain_id\"],\n            url=cfg[\"rpc_endpoint\"],\n            fee_minimum_gas_price=cfg[\"gas_prices\"],\n        )\n    )\n\n    try:\n        # CosmWasm smart query\n        response = client.wasm_query(contract_addr, {\"get_count\": {}})\n    except Exception as e:\n        raise RuntimeError(f\"Query failed: {e}\")\n\n    return {\"count\": response.get(\"count\")}\n\nif __name__ == \"__main__\":\n    print(get_count(\"neutron1...\"))",
            "usage": ">>> from query import get_count\n>>> print(get_count(contract_addr))  # {'count': 1}"
        }
    ]
}