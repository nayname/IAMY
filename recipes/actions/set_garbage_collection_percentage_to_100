{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 supplies a Python utility that programmatically ensures the systemd unit running your Cosmos SDK daemon contains `Environment=\"GOGC=100\"`. The script backs up the original file and safely updates or inserts the Environment line.",
            "code": "import argparse\nimport re\nimport shutil\nfrom pathlib import Path\nimport sys\n\n\ndef update_environment(service_file: str, env_key: str = \"GOGC\", env_value: str = \"100\") -> bool:\n    \"\"\"\n    Adds or updates Environment=\"GOGC=100\" inside the [Service] section of the\n    provided systemd unit file.\n\n    Returns True if the file was modified, False if no change was necessary.\n    \"\"\"\n    service_path = Path(service_file).expanduser()\n\n    if not service_path.exists():\n        raise FileNotFoundError(f\"The systemd file {service_path} does not exist.\")\n\n    original_text = service_path.read_text()\n    updated_text = original_text\n\n    pattern = re.compile(rf'^Environment=.*{env_key}=\\d+', re.MULTILINE)\n    replacement = f'Environment=\"{env_key}={env_value}\"'\n\n    if pattern.search(original_text):\n        # Replace current setting\n        updated_text = pattern.sub(replacement, original_text)\n    else:\n        # Insert new environment line directly under [Service] section\n        updated_text = original_text.replace(\"[Service]\", f\"[Service]\\n{replacement}\", 1)\n\n    if updated_text == original_text:\n        print(f\"{env_key} already set to {env_value}. No update performed.\")\n        return False\n\n    # Backup original file\n    backup_path = service_path.with_suffix(\".bak\")\n    shutil.copy(service_path, backup_path)\n\n    # Write new content\n    service_path.write_text(updated_text)\n    print(f\"Updated {service_path}. Backup stored at {backup_path}\")\n    return True\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Ensure GOGC=100 is present in a systemd service file.\")\n    parser.add_argument(\"--service-file\", required=True, help=\"Path to the systemd unit file (e.g., /etc/systemd/system/cosmosd.service)\")\n    parser.add_argument(\"--value\", default=\"100\", help=\"GC percentage to apply (default: 100)\")\n    args = parser.parse_args()\n\n    try:\n        modified = update_environment(args.service_file, \"GOGC\", args.value)\n        sys.exit(0 if modified else 1)\n    except Exception as err:\n        print(f\"Error: {err}\", file=sys.stderr)\n        sys.exit(2)\n",
            "usage": "sudo python3 update_gc_env.py --service-file /etc/systemd/system/cosmosd.service"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 reloads systemd and restarts the Cosmos SDK daemon so the new GOGC value is applied.",
            "code": "import argparse\nimport subprocess\nimport sys\n\n\ndef restart_node(service_name: str = \"cosmosd\"):\n    \"\"\"\n    Reloads systemd and restarts the provided service.\n    Requires sudo privileges.\n    \"\"\"\n    try:\n        subprocess.run([\"systemctl\", \"daemon-reload\"], check=True)\n        subprocess.run([\"systemctl\", \"restart\", service_name], check=True)\n        subprocess.run([\"systemctl\", \"is-active\", \"--quiet\", service_name], check=True)\n        print(f\"{service_name} restarted successfully.\")\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(f\"Failed to restart {service_name}: {err}\") from err\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Restart a Cosmos SDK daemon to apply new environment variables.\")\n    parser.add_argument(\"--service-name\", default=\"cosmosd\", help=\"systemd service name (default: cosmosd)\")\n    args = parser.parse_args()\n\n    try:\n        restart_node(args.service_name)\n    except Exception as err:\n        print(f\"Error: {err}\", file=sys.stderr)\n        sys.exit(1)\n",
            "usage": "sudo python3 restart_node.py --service-name cosmosd"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 queries the Go runtime\u2019s debug endpoint and confirms that `GCPercent` is now 100, proving that the garbage-collection tweak is active.",
            "code": "import argparse\nimport json\nimport urllib.request\n\n\ndef validate_gc_setting(host: str = \"http://localhost:6060\") -> int:\n    \"\"\"\n    Fetches Go runtime debug vars from the given host and returns the GCPercent value.\n    \"\"\"\n    url = f\"{host.rstrip('/')}/debug/vars\"\n    with urllib.request.urlopen(url, timeout=3) as response:\n        payload = json.loads(response.read().decode())\n        gc_percent = payload.get(\"GCPercent\")\n        print(f\"GCPercent reported: {gc_percent}\")\n        if gc_percent == 100:\n            print(\"\u2705 GOGC is correctly set to 100.\")\n        else:\n            print(\"\u274c GOGC is NOT 100. Check your configuration.\")\n        return gc_percent\n\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description=\"Validate that GOGC=100 has been applied.\")\n    parser.add_argument(\"--host\", default=\"http://localhost:6060\", help=\"Host where pprof/debug endpoint is exposed\")\n    args = parser.parse_args()\n    validate_gc_setting(args.host)\n",
            "usage": "python3 validate_gc.py --host http://localhost:6060"
        }
    ]
}