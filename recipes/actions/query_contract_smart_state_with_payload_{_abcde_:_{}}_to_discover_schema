{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a Python backend helper that resolves the target CosmWasm contract address from an explicit argument or environment variable.",
            "code": "import os\nfrom typing import Optional\n\n\nclass ContractAddressError(Exception):\n    '''Raised when the contract address cannot be resolved or is invalid.'''\n\n\ndef resolve_contract_address(explicit_address: Optional[str] = None, env_var: str = 'CONTRACT_ADDRESS') -> str:\n    '''Resolve the CosmWasm contract address from an explicit argument or environment.\n\n    :param explicit_address: Optional address provided by the caller.\n    :param env_var: Name of the environment variable to fall back to.\n    :returns: A validated contract address string.\n    :raises ContractAddressError: If no address is found or the value looks invalid.\n    '''\n    address = explicit_address or os.getenv(env_var)\n\n    if not address:\n        raise ContractAddressError(\n            f'Contract address not provided. Pass explicit_address or set {env_var}.'\n        )\n\n    # Basic sanity check; adjust this to your chain address format if needed.\n    if not isinstance(address, str) or len(address) < 10:\n        raise ContractAddressError('Resolved contract address appears malformed.')\n\n    return address",
            "usage": "from contract_utils import resolve_contract_address\n\ncontract_address = resolve_contract_address()\n# Or, with an explicit address:\n# contract_address = resolve_contract_address('juno1contractaddress...')"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 builds the JSON query payload with root field abcde and base64-encodes it for the CosmWasm smart query endpoint.",
            "code": "import base64\nimport json\nfrom typing import Any, Dict\n\n\ndef build_smart_query_payload() -> str:\n    '''Construct the JSON payload with root field abcde and return it base64 encoded.\n\n    This base64 string is what the CosmWasm LCD smart query endpoint expects\n    in the query_data path parameter.\n    '''\n    query_msg: Dict[str, Any] = {'abcde': {}}\n\n    try:\n        json_bytes = json.dumps(query_msg, separators=(',', ':')).encode('utf-8')\n    except (TypeError, ValueError) as exc:\n        raise ValueError(f'Unable to serialize query message: {exc}') from exc\n\n    encoded = base64.b64encode(json_bytes).decode('ascii')\n    return encoded",
            "usage": "from contract_utils import build_smart_query_payload\n\nquery_data_b64 = build_smart_query_payload()\n# Pass query_data_b64 into query_wasm_smart together with the contract address."
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 performs the HTTP GET request to Juno's LCD smart query endpoint using the contract address and encoded payload.",
            "code": "import urllib.parse\nfrom typing import Any, Dict\n\nimport requests\n\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nclass LCDQueryError(Exception):\n    '''Raised when the LCD smart query fails or returns an unexpected response.'''\n\n\ndef query_wasm_smart(contract_address: str, query_data_b64: str, timeout: float = 10.0) -> Dict[str, Any]:\n    '''Query a CosmWasm contract using the LCD smart query endpoint.\n\n    :param contract_address: Bech32 contract address on Juno.\n    :param query_data_b64: Base64-encoded query payload (output of build_smart_query_payload).\n    :param timeout: Optional request timeout in seconds.\n    :returns: Parsed JSON response from the LCD.\n    :raises LCDQueryError: If the HTTP request fails or the response is invalid.\n    '''\n    if not contract_address:\n        raise LCDQueryError('contract_address must be provided')\n\n    if not query_data_b64:\n        raise LCDQueryError('query_data_b64 must be provided')\n\n    # Encode the base64 string so it is safe inside the URL path segment.\n    encoded_query_data = urllib.parse.quote(query_data_b64, safe='')\n\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{encoded_query_data}'\n\n    try:\n        response = requests.get(url, timeout=timeout)\n    except requests.RequestException as exc:\n        raise LCDQueryError(f'Error while calling LCD endpoint: {exc}') from exc\n\n    if response.status_code != 200:\n        raise LCDQueryError(\n            f'LCD returned status {response.status_code}: {response.text}'\n        )\n\n    try:\n        payload: Dict[str, Any] = response.json()\n    except ValueError as exc:\n        raise LCDQueryError(f'LCD response is not valid JSON: {exc}') from exc\n\n    if 'data' not in payload:\n        raise LCDQueryError('LCD response JSON does not contain required key data')\n\n    return payload",
            "usage": "from contract_utils import query_wasm_smart\n\nlcd_response = query_wasm_smart(contract_address, query_data_b64)\n# lcd_response is a dict with a base64-encoded data field ready for decoding."
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 decodes the base64-encoded contract response, parses it as JSON, and analyzes the structure to infer a simple query schema.",
            "code": "import base64\nimport binascii\nimport json\nfrom typing import Any, Dict\n\n\nclass ContractResponseDecodeError(Exception):\n    '''Raised when the contract response cannot be decoded or parsed.'''\n\n\ndef _analyze_structure(obj: Any) -> Any:\n    '''Recursively analyze a JSON-compatible Python object to infer a simple schema.'''\n    if isinstance(obj, dict):\n        return {\n            'type': 'object',\n            'fields': {key: _analyze_structure(value) for key, value in obj.items()},\n        }\n    if isinstance(obj, list):\n        if not obj:\n            return {'type': 'array', 'items': 'unknown (empty array)'}\n        return {'type': 'array', 'items': _analyze_structure(obj[0])}\n    return {'type': type(obj).__name__}\n\n\ndef decode_and_analyze_contract_response(lcd_response: Dict[str, Any]) -> Dict[str, Any]:\n    '''Decode the base64-encoded data field from the LCD response and analyze its structure.\n\n    :param lcd_response: Parsed JSON object returned by query_wasm_smart.\n    :returns: Dictionary containing raw bytes, JSON text, parsed object, and inferred schema.\n    :raises ContractResponseDecodeError: On missing fields or decode or parse errors.\n    '''\n    if 'data' not in lcd_response:\n        raise ContractResponseDecodeError('LCD response does not contain key data')\n\n    data_field = lcd_response['data']\n\n    if not isinstance(data_field, str):\n        raise ContractResponseDecodeError('LCD data field must be a base64 string')\n\n    try:\n        raw_bytes = base64.b64decode(data_field)\n    except (binascii.Error, ValueError) as exc:\n        raise ContractResponseDecodeError(f'Failed to base64-decode data field: {exc}') from exc\n\n    try:\n        json_text = raw_bytes.decode('utf-8')\n    except UnicodeDecodeError as exc:\n        raise ContractResponseDecodeError(f'Decoded data is not valid UTF-8: {exc}') from exc\n\n    try:\n        parsed = json.loads(json_text)\n    except ValueError as exc:\n        raise ContractResponseDecodeError(f'Decoded data is not valid JSON: {exc}') from exc\n\n    schema = _analyze_structure(parsed)\n\n    return {\n        'raw_bytes': raw_bytes,\n        'json_text': json_text,\n        'parsed': parsed,\n        'inferred_schema': schema,\n    }",
            "usage": "from contract_utils import decode_and_analyze_contract_response\n\nanalysis = decode_and_analyze_contract_response(lcd_response)\n# Inspect analysis['parsed'] for the full response and analysis['inferred_schema'] for a schema-like view."
        }
    ]
}