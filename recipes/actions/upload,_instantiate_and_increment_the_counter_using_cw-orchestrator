{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 creates a backend Rust helper that initializes a cw-orch `Daemon` chain handle for Juno using a Tokio runtime and environment variables for RPC, chain-id, and mnemonic.",
            "code": "use anyhow::{Context, Result};\nuse cw_orch::{daemon::DaemonBuilder, prelude::*};\n\n/// Build a cw-orch `Daemon` chain handle for Juno using environment variables.\n///\n/// Required env vars:\n/// - `JUNO_RPC`       : RPC (or gRPC-gateway) endpoint, e.g. `https://rpc.juno.strange.love:443`\n/// - `JUNO_CHAIN_ID`  : Chain id, e.g. `juno-1`\n/// - `JUNO_MNEMONIC`  : Mnemonic for a funded key on that chain.\npub fn setup_juno_daemon(rt: &tokio::runtime::Runtime) -> Result<Daemon> {\n    // Load configuration from the environment.\n    let rpc = std::env::var(\"JUNO_RPC\").context(\"JUNO_RPC env var is required\")?;\n    let chain_id = std::env::var(\"JUNO_CHAIN_ID\").context(\"JUNO_CHAIN_ID env var is required\")?;\n    let mnemonic = std::env::var(\"JUNO_MNEMONIC\").context(\"JUNO_MNEMONIC env var is required\")?;\n\n    // Build a NetworkInfo struct describing the Juno chain.\n    // Adjust gas_denom / bech32_prefix if you target a different chain.\n    let network = NetworkInfo {\n        chain_id,\n        rpc_endpoint: rpc.clone(),\n        grpc_endpoint: rpc,\n        gas_denom: \"ujuno\".to_string(),\n        bech32_prefix: \"juno\".to_string(),\n        ..NetworkInfo::default()\n    };\n\n    // Create the cw-orch daemon using the provided Tokio runtime handle.\n    // `build()` will fail if RPC is unreachable or the mnemonic is invalid.\n    let daemon = DaemonBuilder::default()\n        .handle(rt.handle().clone())\n        .chain(network)\n        .mnemonic(mnemonic)\n        .build()?;\n\n    Ok(daemon)\n}\n",
            "usage": "use anyhow::Result;\n\nfn main() -> Result<()> {\n    // Create a Tokio runtime for cw-orch to run async I/O under the hood.\n    let rt = tokio::runtime::Runtime::new()?;\n\n    // Build the Juno chain handle (fails fast if env vars or RPC are misconfigured).\n    let daemon = setup_juno_daemon(&rt)?;\n\n    // Pass `daemon` into later steps (contract interface, upload, instantiate, etc.).\n    Ok(())\n}"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 imports the generated cw-orch interface type for your Counter contract and constructs it from the daemon so it knows which chain and artifacts to use.",
            "code": "use cw_orch::prelude::*;\n// This module path depends on how you structured your contract crate.\n// Typically it is generated by cw-orch macros (`#[contract]`, etc.).\nuse counter::interface::Counter; // e.g. crate providing `Counter<Daemon>`\n\n/// Initialize the cw-orch Counter interface bound to the given `Daemon`.\npub fn init_counter_interface(chain: &Daemon) -> Counter<Daemon> {\n    // `Daemon` is `Clone`, so we clone it for the interface.\n    Counter::new(chain.clone())\n}\n",
            "usage": "// Assuming you already have a `daemon: Daemon` from step 1:\nlet counter = init_counter_interface(&daemon);\n\n// `counter` now knows how to find the compiled `.wasm` artifact and\n// how to encode/decode messages for this contract on the Juno chain."
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 uploads the Counter contract wasm to the Juno chain using the cw-orch interface, broadcasting a store-code transaction and recording the returned `code_id`.",
            "code": "use anyhow::{anyhow, Result};\nuse cw_orch::prelude::*;\nuse counter::interface::Counter;\n\n/// Upload the Counter wasm code to chain and return the new `code_id`.\npub fn upload_counter(counter: &Counter<Daemon>) -> Result<u64> {\n    // This will broadcast a `store-code` transaction and wait for it to be included\n    // in a block. Any non-zero tx code will be turned into an error.\n    counter.upload()?;\n\n    // After a successful upload, cw-orch tracks the `code_id` for this interface.\n    let code_id = counter\n        .code_id()\n        .ok_or_else(|| anyhow!(\"Upload succeeded but no code_id recorded in cw-orch\"))?;\n\n    println!(\"Uploaded Counter contract. code_id = {}\", code_id);\n    Ok(code_id)\n}\n",
            "usage": "// After step 2:\nlet code_id = upload_counter(&counter)?;\nprintln!(\"Stored Counter wasm on-chain with code_id = {}\", code_id);\n\n// You generally do not need to pass `code_id` around manually; cw-orch stores\n// it on the interface, but returning it can help with logging or cross-checking."
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 instantiates the uploaded Counter code with an `InstantiateMsg`, waits for the instantiate tx to commit, and returns the new contract address tracked by cw-orch.",
            "code": "use anyhow::Result;\nuse cw_orch::prelude::*;\nuse counter::interface::Counter;\nuse counter::msg::InstantiateMsg; // adjust to your contract's msg module\n\n/// Instantiate the Counter contract on-chain and return its address as a String.\npub fn instantiate_counter(counter: &Counter<Daemon>, initial_count: u64) -> Result<String> {\n    let instantiate_msg = InstantiateMsg { count: initial_count };\n\n    // Arguments:\n    // - &instantiate_msg : the instantiate payload\n    // - None             : no explicit admin (set one here if your contract needs it)\n    // - \"cw-orch-counter\": human-readable label\n    // - &[]              : no initial funds sent\n    // - None             : default tx options (gas price/limit, etc.)\n    let addr: Addr = counter.instantiate(\n        &instantiate_msg,\n        None,\n        \"cw-orch-counter\",\n        &[],\n        None,\n    )?;\n\n    println!(\"Instantiated Counter contract at {}\", addr);\n\n    // cw-orch will internally remember this address for future execute/query calls.\n    Ok(addr.to_string())\n}\n",
            "usage": "// After uploading in step 3:\nlet initial_count: u64 = 0;\nlet contract_addr = instantiate_counter(&counter, initial_count)?;\nprintln!(\"Counter is live at {}\", contract_addr);\n\n// From this point on, `counter` is bound to `contract_addr` inside cw-orch\n// and can be used to execute messages without passing the address explicitly."
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 uses the cw-orch interface to execute the `increment` entry point on the instantiated counter contract, relying on cw-orch to wait for inclusion in a block and surface any non-zero tx code as an error.",
            "code": "use anyhow::Result;\nuse cw_orch::prelude::*;\nuse counter::interface::Counter;\n\n/// Execute the `increment` entrypoint on the Counter contract.\n///\n/// The exact method name/signature depends on how your cw-orch interface was\n/// generated. If you do not have a dedicated `increment()` helper, you can\n/// instead call a generic `execute` with `ExecuteMsg::Increment {}`.\npub fn execute_increment(counter: &Counter<Daemon>) -> Result<()> {\n    // In many cw-orch bindings, this is generated for you:\n    //   counter.increment()?;\n    // Adjust if your interface differs.\n\n    // Example 1: direct helper (preferred when available)\n    counter.increment()?;\n\n    // If your interface instead exposes a generic execute method, you might use:\n    // use counter::msg::ExecuteMsg;\n    // counter.execute(&ExecuteMsg::Increment {}, &[], None)?;\n\n    // cw-orch waits for the tx to be committed and returns an error if the chain\n    // reports a non-zero code, so propagating `?` is enough to assert success.\n    println!(\"Executed increment on Counter contract\");\n    Ok(())\n}\n",
            "usage": "// After instantiation in step 4:\nexecute_increment(&counter)?;\n\n// If this call returns `Ok(())`, the increment transaction was included in a\n// block and the chain returned a successful (code = 0) result."
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 verifies on-chain state by issuing a backend LCD request directly to the Juno LCD endpoint `/cosmwasm/wasm/v1/contract/{address}/smart/{query_data}` with a base64-encoded `{\"get_count\":{}}` query and decoding the response.",
            "code": "use anyhow::{Context, Result};\nuse base64::{engine::general_purpose, Engine};\nuse serde::Deserialize;\n\n/// Envelope returned by the LCD smart query endpoint.\n/// Schema: { \"data\": \"base64-encoded-bytes\" }\n#[derive(Deserialize)]\nstruct SmartQueryEnvelope {\n    data: String,\n}\n\n/// Response structure returned by the Counter contract's `get_count` query.\n#[derive(Deserialize)]\nstruct CounterState {\n    count: u64,\n}\n\n/// Query the Counter contract's current count via the Juno LCD endpoint.\n///\n/// This uses the documented endpoint:\n///   GET https://lcd-archive.junonetwork.io/cosmwasm/wasm/v1/contract/{address}/smart/{query_data}\n/// where `query_data` is base64(JSON({\"get_count\":{}})).\npub async fn query_counter_via_lcd(contract_address: &str) -> Result<u64> {\n    // Build the JSON query: {\"get_count\":{}}\n    let query_json = serde_json::json!({ \"get_count\": {} });\n    let query_bytes = serde_json::to_vec(&query_json)?;\n\n    // Base64-encode the query payload as required by the LCD smart query endpoint.\n    let query_data = general_purpose::STANDARD.encode(query_bytes);\n\n    // Construct the full URL against the trusted Juno LCD endpoint.\n    let url = format!(\n        \"https://lcd-archive.junonetwork.io/cosmwasm/wasm/v1/contract/{}/smart/{}\",\n        contract_address, query_data\n    );\n\n    let client = reqwest::Client::new();\n    let resp = client\n        .get(&url)\n        .send()\n        .await\n        .context(\"Failed to send LCD smart query request\")?;\n\n    if !resp.status().is_success() {\n        let status = resp.status();\n        let body = resp.text().await.unwrap_or_default();\n        anyhow::bail!(\"LCD returned error {}: {}\", status, body);\n    }\n\n    // Parse the outer JSON envelope: { \"data\": \"...base64...\" }\n    let envelope: SmartQueryEnvelope = resp\n        .json()\n        .await\n        .context(\"Failed to parse LCD JSON body\")?;\n\n    // Decode the inner base64-encoded contract response bytes.\n    let decoded = general_purpose::STANDARD\n        .decode(&envelope.data)\n        .context(\"Failed to base64-decode contract response\")?;\n\n    // The decoded bytes should be JSON representing the CounterState.\n    let state: CounterState = serde_json::from_slice(&decoded)\n        .context(\"Failed to deserialize CounterState from contract response\")?;\n\n    Ok(state.count)\n}\n",
            "usage": "// Inside your binary, re-using the Tokio runtime from step 1 and\n// the `contract_addr` and `initial_count` from step 4:\n\nuse anyhow::Result;\n\nfn main() -> Result<()> {\n    let rt = tokio::runtime::Runtime::new()?;\n    let daemon = setup_juno_daemon(&rt)?;\n    let counter = init_counter_interface(&daemon);\n\n    // Full flow for context (upload, instantiate, execute):\n    let _code_id = upload_counter(&counter)?;\n    let initial_count: u64 = 0;\n    let contract_addr = instantiate_counter(&counter, initial_count)?;\n    execute_increment(&counter)?;\n\n    // Verify via LCD that the count increased.\n    let new_count = rt.block_on(query_counter_via_lcd(&contract_addr))?;\n    println!(\"Counter value from LCD: {}\", new_count);\n\n    if new_count <= initial_count {\n        anyhow::bail!(\n            \"Expected counter to increase above {}, but LCD returned {}\",\n            initial_count,\n            new_count\n        );\n    }\n\n    println!(\"State verification succeeded: counter incremented as expected.\");\n    Ok(())\n}"
        }
    ]
}