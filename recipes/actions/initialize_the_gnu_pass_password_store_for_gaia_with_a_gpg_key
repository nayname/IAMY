{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 exposes a FastAPI GET endpoint that lists all GPG public-key IDs present on the host machine. The frontend can call this endpoint to let the user pick which key will encrypt the password store.",
            "code": "from fastapi import FastAPI, HTTPException\nimport subprocess\nfrom typing import List\n\n# FastAPI application instance for this micro-service\napp = FastAPI()\n\ndef list_gpg_keys() -> List[str]:\n    \"\"\"Return a list of available GPG key IDs that exist on the host.\n\n    This helper runs `gpg --list-keys --with-colons` and parses the\n    machine-readable output (colon-separated fields).  The 5th column holds\n    the long key ID.\n    \"\"\"\n    try:\n        completed = subprocess.run(\n            [\"gpg\", \"--list-keys\", \"--with-colons\"],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n    except FileNotFoundError:\n        # The `gpg` binary is not present on the system.\n        raise RuntimeError(\"`gpg` command is missing. Please install GnuPG and try again.\")\n    except subprocess.CalledProcessError as exc:\n        # The command executed but returned a non-zero exit status.\n        raise RuntimeError(f\"Failed to list GPG keys: {exc.stderr.strip()}\")\n\n    # Parse keys from command output.\n    key_ids = [\n        row.split(\":\")[4]\n        for row in completed.stdout.splitlines()\n        if row.startswith(\"pub\") and len(row.split(\":\")) > 4\n    ]\n    return key_ids\n\n@app.get(\"/api/gpg/keys\")\nasync def get_gpg_keys():\n    \"\"\"HTTP endpoint: GET /api/gpg/keys\n    Returns a JSON object with the available GPG key IDs so the frontend can\n    let the user choose which one to use for `pass init`.\n    \"\"\"\n    try:\n        keys = list_gpg_keys()\n    except RuntimeError as e:\n        # Convert Python errors to proper HTTP errors for the client.\n        raise HTTPException(status_code=500, detail=str(e))\n    return {\"keys\": keys}",
            "usage": "// Frontend example\nconst response = await fetch('/api/gpg/keys');\nconst { keys } = await response.json();\nconsole.log(keys); // ['A1B2C3D4E5F6ABCD', ...]"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 provides a POST endpoint that runs `pass init <GPG_KEY_ID>` on the server, creating `~/.password-store` encrypted with the key selected in Step 1.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport subprocess\n\napp = FastAPI()\n\nclass InitRequest(BaseModel):\n    key_id: str  # The GPG key to be used for encrypting the password store\n\ndef init_pass_store(key_id: str) -> None:\n    \"\"\"Initialise the `pass` password store with the supplied `key_id`.\"\"\"\n    try:\n        subprocess.run(\n            [\"pass\", \"init\", key_id],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\"`pass` CLI not found. Install 'pass' and ensure it is on $PATH.\")\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(f\"`pass init` failed: {exc.stderr.strip()}\")\n\n@app.post(\"/api/pass/init\")\nasync def api_init_pass_store(req: InitRequest):\n    \"\"\"HTTP endpoint: POST /api/pass/init {\"key_id\": \"<GPG_KEY_ID>\"}.\n    It runs `pass init` on the server and returns status back to the caller.\n    \"\"\"\n    try:\n        init_pass_store(req.key_id)\n    except RuntimeError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n    return {\"status\": \"initialised\", \"key_id\": req.key_id}",
            "usage": "// Frontend example\nawait fetch('/api/pass/init', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ key_id: '<GPG_KEY_ID>' })\n});"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 implements a verification endpoint that calls `pass ls` to ensure the password store is operational and returns its current list of entries (should be empty right after initialisation).",
            "code": "from fastapi import FastAPI, HTTPException\nimport subprocess\nfrom typing import List\n\napp = FastAPI()\n\ndef verify_pass_store() -> List[str]:\n    \"\"\"Return list of entries in the password store (empty list if none).\n\n    Returns an empty list when the store is freshly initialised.\n    \"\"\"\n    try:\n        completed = subprocess.run(\n            [\"pass\", \"ls\"],\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\"`pass` CLI not found. Install 'pass' and ensure it is on $PATH.\")\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(f\"`pass ls` failed: {exc.stderr.strip()}\")\n\n    # Clean up and flatten the textual tree output.\n    entries = [line.strip() for line in completed.stdout.splitlines() if line.strip()]\n    return entries\n\n@app.get(\"/api/pass/verify\")\nasync def api_verify_pass_store():\n    \"\"\"HTTP endpoint: GET /api/pass/verify.\n    Returns the current list of passwords in the store. If the list is empty\n    the store is valid but has no secrets yet.\n    \"\"\"\n    try:\n        entries = verify_pass_store()\n    except RuntimeError as e:\n        raise HTTPException(status_code=500, detail=str(e))\n    return {\"entries\": entries}",
            "usage": "// Frontend example\nconst resp = await fetch('/api/pass/verify');\nconst { entries } = await resp.json();\nconsole.log(entries); // []"
        }
    ]
}