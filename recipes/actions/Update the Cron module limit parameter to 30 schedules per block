{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 constructs a Cron MsgUpdateParams message that will later be wrapped into a DAO proposal.",
            "code": "import json\n\ndef construct_msg_update_params(authority: str, schedules_per_block: int = 30) -> dict:\n    \"\"\"Return a dict that represents `/neutron.cron.MsgUpdateParams`.\n\n    Args:\n        authority (str): The DAO (gov) address that is allowed to change chain params.\n        schedules_per_block (int): Desired value for the `schedules_per_block` param.\n\n    Returns:\n        dict: JSON-serialisable message ready to be embedded in a proposal.\n    \"\"\"\n    # Basic validation -------------------------------------------------------\n    if not authority.startswith(\"neutron\"):\n        raise ValueError(\"`authority` must be a valid Neutron bech32 address\")\n    if schedules_per_block <= 0:\n        raise ValueError(\"`schedules_per_block` must be > 0\")\n\n    # Build the message ------------------------------------------------------\n    msg = {\n        \"@type\": \"/neutron.cron.MsgUpdateParams\",\n        \"authority\": authority,\n        \"params\": {\n            \"schedules_per_block\": schedules_per_block\n        }\n    }\n    return msg\n\n# OPTIONAL: pretty-print for audit / persistence\nif __name__ == \"__main__\":\n    DAO_ADDR = \"neutron1...\"  # <- replace with real address\n    print(json.dumps(construct_msg_update_params(DAO_ADDR), indent=2))",
            "usage": "msg_update = construct_msg_update_params(authority=DAO_ADDR, schedules_per_block=30)"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 wraps the MsgUpdateParams in a DAO (cw-core) proposal object that can be executed via a smart-contract call.",
            "code": "import base64\nimport json\nfrom typing import Dict\n\n# The cw-dao \"propose\" message expects Cosmos encoded messages (base64)\n# We therefore wrap the Cron MsgUpdateParams in a Cosmos \"Any\" and then\n# base64-encode the final bytes.\n\ndef _encode_cosmos_msg(msg: Dict) -> Dict:\n    \"\"\"Helper: builds a `CosmosMsg::Gov`-compatible JSON envelope.\n\n    Because cosmpy (and most clients) accept raw JSON in place of protobuf\n    for Custom messages, we simply return the dict itself. If your DAO core\n    requires base64-encoded `wasm/MsgExecuteContract`, encode as shown below.\n    \"\"\"\n    return msg  # no additional wrapping needed for most cw-dao versions\n\n\ndef build_dao_proposal(msg_update_params: Dict,\n                       title: str = \"Update Cron schedules_per_block to 30\",\n                       description: str = \"Set cron.schedules_per_block param to 30 via governance.\",\n                       deposit: str = \"1000000untrn\",\n                       proposer: str | None = None) -> Dict:\n    \"\"\"Return the message to execute against the DAO core contract.\"\"\"\n\n    if proposer is not None and not proposer.startswith(\"neutron\"):\n        raise ValueError(\"Invalid proposer address\")\n\n    proposal = {\n        \"propose\": {\n            \"title\": title,\n            \"description\": description,\n            \"msgs\": [\n                {\"custom\": _encode_cosmos_msg(msg_update_params)}\n            ],\n            \"deposit\": deposit\n        }\n    }\n    # Some DAO cores support an explicit `proposer` field\n    if proposer:\n        proposal[\"propose\"][\"proposer\"] = proposer\n\n    return proposal\n\nif __name__ == \"__main__\":\n    dao_contract_addr = \"neutron1dao...\"  # <- your DAO core address\n    cron_msg = construct_msg_update_params(authority=dao_contract_addr, schedules_per_block=30)\n    proposal_msg = build_dao_proposal(cron_msg)\n    print(json.dumps(proposal_msg, indent=2))",
            "usage": "proposal_msg = build_dao_proposal(msg_update)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 signs and broadcasts the proposal transaction to the chain using cosmpy\u2019s high-level helpers.",
            "code": "import asyncio, json, base64\nfrom pathlib import Path\nfrom cosmpy.aerial.client import NetworkConfig, LedgerClient\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.aerial.tx import Transaction\n\nRPC = \"https://rpc.ntrn.tech:443\"  # <- public or private RPC endpoint\nCHAIN_ID = \"neutron-1\"\nGAS_LIMIT = 400_000\nGAS_PRICE = 0.05  # in uNTRN\n\nasync def sign_and_broadcast_tx(dao_contract: str,\n                                proposal_msg: dict,\n                                mnemonic: str) -> str:\n    \"\"\"Signs the DAO `propose` execute-contract message and broadcasts it.\n\n    Args:\n        dao_contract (str): cw-dao core contract address.\n        proposal_msg (dict): Message produced in Step 2.\n        mnemonic (str): Mnemonic for the proposer\u2019s wallet key.\n\n    Returns:\n        str: On-chain tx hash.\n    \"\"\"\n    # ---------------------------------------------------------------------\n    wallet = LocalWallet.from_mnemonic(mnemonic)\n    network_cfg = NetworkConfig(chain_id=CHAIN_ID, url=RPC, fee_minimum_gas_price=GAS_PRICE)\n    client = LedgerClient(network_cfg)\n\n    # Build MsgExecuteContract ------------------------------------------------\n    exec_msg = {\n        \"sender\": wallet.address(),\n        \"contract\": dao_contract,\n        \"msg\": base64.b64encode(json.dumps(proposal_msg).encode()).decode(),\n        \"funds\": []\n    }\n\n    tx = (Transaction()\n          .with_messages((\"/cosmwasm.wasm.v1.MsgExecuteContract\", exec_msg))\n          .with_signer(wallet)\n          .with_chain_id(CHAIN_ID)\n          .with_gas(GAS_LIMIT))\n\n    try:\n        tx_response = client.broadcast_tx_block(tx)\n        if tx_response.is_error:\n            raise RuntimeError(f\"Tx failed: {tx_response.raw_log}\")\n        print(f\"Broadcasted \u2713  txhash={tx_response.tx_hash}\")\n        return tx_response.tx_hash\n    finally:\n        client.close()\n\n# Example direct run ---------------------------------------------------------\nif __name__ == \"__main__\":\n    dao_addr = \"neutron1dao...\"\n    mnemonic_path = Path.home() / \".dao_keyseed\"\n    tx_hash = asyncio.run(sign_and_broadcast_tx(dao_addr, proposal_msg, mnemonic_path.read_text().strip()))",
            "usage": "tx_hash = await sign_and_broadcast_tx(dao_contract=DAO_CORE_ADDR, proposal_msg=proposal_msg, mnemonic=MNEMONIC)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 periodically queries the DAO contract until the proposal reaches the \u201cexecuted\u201d state.",
            "code": "import asyncio, json\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\n\nasync def monitor_proposal_status(dao_contract: str, proposal_id: int,\n                                  rpc: str = RPC,\n                                  chain_id: str = CHAIN_ID,\n                                  interval: int = 15):\n    \"\"\"Continuously poll DAO contract for proposal status until finalised.\"\"\"\n    client = LedgerClient(NetworkConfig(chain_id=chain_id, url=rpc))\n    try:\n        while True:\n            try:\n                result = client.query_contract_state(dao_contract, {\"proposal\": {\"proposal_id\": proposal_id}})\n                status = result[\"proposal\"].get(\"status\", \"unknown\")\n                print(f\"Proposal {proposal_id} \u279c {status}\")\n                if status.lower() in {\"executed\", \"rejected\", \"failed\"}:\n                    return status\n            except Exception as err:\n                print(f\"query error: {err}\")\n            await asyncio.sleep(interval)\n    finally:\n        client.close()\n\n# Usage example --------------------------------------------------------------\n# final_status = await monitor_proposal_status(DAO_CORE_ADDR, PROPOSAL_ID)",
            "usage": "final_status = await monitor_proposal_status(dao_contract=DAO_CORE_ADDR, proposal_id=MY_PROPOSAL_ID)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 queries the Cron module parameters to confirm the new value was applied.",
            "code": "import json, subprocess\n\ndef query_cron_params() -> int:\n    \"\"\"Calls `neutrond query cron params` and returns schedules_per_block value.\n\n    Raises:\n        RuntimeError: if CLI call fails.\n    \"\"\"\n    cmd = [\n        \"neutrond\", \"query\", \"cron\", \"params\",\n        \"--output\", \"json\"\n    ]\n    completed = subprocess.run(cmd, capture_output=True, text=True)\n    if completed.returncode != 0:\n        raise RuntimeError(completed.stderr.strip())\n\n    data = json.loads(completed.stdout)\n    return int(data[\"params\"][\"schedules_per_block\"])\n\nif __name__ == \"__main__\":\n    current_value = query_cron_params()\n    print(f\"schedules_per_block = {current_value}\")",
            "usage": "assert query_cron_params() == 30, \"Parameter update failed!\""
        }
    ]
}