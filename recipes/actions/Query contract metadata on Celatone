{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 spins up a head-less Chrome instance (via Selenium) and opens the Celatone explorer on the requested Neutron network (mainnet = \"neutron-1\", testnet = \"pion-1\").  It returns a ready-to-use WebDriver object.",
            "code": "from selenium import webdriver\nfrom selenium.webdriver.chrome.options import Options\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import WebDriverException\n\n\ndef open_celatone_explorer(chain_id: str, download_dir: str = \"/tmp\") -> webdriver.Chrome:\n    \"\"\"Launch Celatone (https://celatone.osmosis.zone) for the given chain and\n    return an initialized Selenium WebDriver.\n\n    Args:\n        chain_id (str): Either \"neutron-1\" (mainnet) or \"pion-1\" (testnet).\n        download_dir (str): Directory where Celatone will drop the metadata JSON.\n\n    Returns:\n        webdriver.Chrome: A configured Chrome WebDriver pointing at Celatone.\n    \"\"\"\n\n    if chain_id not in (\"neutron-1\", \"pion-1\"):\n        raise ValueError(\"Unsupported chain id. Use 'neutron-1' or 'pion-1'.\")\n\n    url = f\"https://celatone.osmosis.zone/{chain_id}\"\n\n    # Configure Chrome for head-less use and automatic downloads\n    chrome_opts = Options()\n    chrome_opts.add_argument(\"--headless=new\")\n    chrome_opts.add_argument(\"--window-size=1920,1080\")\n    chrome_opts.add_experimental_option(\n        \"prefs\",\n        {\n            \"download.default_directory\": download_dir,\n            \"download.prompt_for_download\": False,\n            \"download.directory_upgrade\": True,\n            \"safebrowsing.enabled\": True,\n        },\n    )\n\n    try:\n        driver = webdriver.Chrome(options=chrome_opts)\n        driver.get(url)\n\n        # Wait until the search bar is rendered so we know the page finished loading\n        WebDriverWait(driver, 15).until(\n            EC.presence_of_element_located((\"css selector\", \"input[type='search']\"))\n        )\n        return driver\n    except WebDriverException as exc:\n        raise RuntimeError(f\"Failed to open Celatone explorer: {exc}\") from exc",
            "usage": "driver = open_celatone_explorer(chain_id=\"neutron-1\", download_dir=\"/tmp/celatone_downloads\")"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 takes the active WebDriver and performs a search for a given contract address inside Celatone\u2019s search box.",
            "code": "from selenium.webdriver.common.by import By\nfrom selenium.webdriver.common.keys import Keys\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import TimeoutException\n\n\ndef search_contract_address(driver: webdriver.Chrome, contract_address: str, timeout: int = 15) -> None:\n    \"\"\"Paste the contract address into Celatone's search bar and navigate to the\n    contract page.\n\n    Args:\n        driver (webdriver.Chrome): Active Celatone WebDriver.\n        contract_address (str): Bech32 address of the target contract.\n        timeout (int): Max seconds to wait for the contract page to load.\n    \"\"\"\n\n    try:\n        # Locate the search bar element and submit the address\n        search_box = driver.find_element(By.CSS_SELECTOR, \"input[type='search']\")\n        search_box.clear()\n        search_box.send_keys(contract_address + Keys.ENTER)\n\n        # Wait until URL contains the contract address, indicating navigation\n        WebDriverWait(driver, timeout).until(\n            EC.url_contains(contract_address.lower())\n        )\n    except TimeoutException:\n        raise RuntimeError(\"Celatone did not navigate to the contract page in time.\")",
            "usage": "search_contract_address(driver, contract_address=\"neutron1...xyz\")"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "After landing on the contract page, Step 3 clicks the \u201cMetadata\u201d tab (if present) so that Celatone loads the contract\u2019s stored metadata.",
            "code": "from selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import TimeoutException, NoSuchElementException\n\n\ndef navigate_to_metadata_tab(driver: webdriver.Chrome, timeout: int = 10) -> None:\n    \"\"\"Click Celatone's \"Metadata\" tab for the currently opened contract page.\"\"\"\n    try:\n        # The tab usually appears as a button or anchor containing the visible text \"Metadata\"\n        metadata_tab = WebDriverWait(driver, timeout).until(\n            EC.element_to_be_clickable((By.XPATH, \"//button[contains(., 'Metadata')] | //a[contains(., 'Metadata')]\"))\n        )\n        metadata_tab.click()\n\n        # Wait until the JSON download (</>) icon is visible in the Metadata view\n        WebDriverWait(driver, timeout).until(\n            EC.presence_of_element_located((By.XPATH, \"//button[contains(@title, 'Download') or contains(@aria-label, 'Download')]\"))\n        )\n    except (TimeoutException, NoSuchElementException):\n        raise RuntimeError(\"Could not open the Metadata tab on Celatone.\")",
            "usage": "navigate_to_metadata_tab(driver)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Finally, Step 4 presses Celatone\u2019s \u201cDownload JSON\u201d (</>) button, waits for the file to appear in the chosen download folder, and returns its path so downstream code can inspect the metadata.",
            "code": "import os\nimport time\nfrom pathlib import Path\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.common.exceptions import TimeoutException\n\n\ndef download_metadata_json(driver: webdriver.Chrome, download_dir: str, timeout: int = 30) -> Path:\n    \"\"\"Click the download button and wait until the metadata JSON is fully\n    written to disk.\n\n    Args:\n        driver (webdriver.Chrome): Active WebDriver on the Metadata tab.\n        download_dir (str): Directory configured in open_celatone_explorer().\n        timeout (int): Max seconds to wait for the file to finish downloading.\n\n    Returns:\n        Path: Absolute path to the downloaded metadata JSON file.\n    \"\"\"\n\n    # Grab a snapshot of existing files so we can detect the new one later\n    pre_existing = set(Path(download_dir).iterdir()) if os.path.isdir(download_dir) else set()\n\n    # Click the download (code / </>) button\n    try:\n        download_btn = driver.find_element(By.XPATH, \"//button[contains(@title, 'Download') or contains(@aria-label, 'Download')]\")\n        download_btn.click()\n    except Exception as exc:\n        raise RuntimeError(\"Failed to click Celatone's download button\") from exc\n\n    # Poll for a new .json file that was not present earlier\n    end_time = time.time() + timeout\n    while time.time() < end_time:\n        current_files = set(Path(download_dir).iterdir())\n        new_files = [f for f in current_files - pre_existing if f.suffix.lower() == \".json\"]\n        if new_files:\n            # Celatone sometimes writes a *.crdownload first; wait until file stabilises.\n            candidate = new_files[0]\n            if not candidate.name.endswith(\".crdownload\"):\n                return candidate.resolve()\n        time.sleep(0.5)\n\n    raise TimeoutException(\"Timed out waiting for metadata JSON download to complete.\")",
            "usage": "json_path = download_metadata_json(driver, download_dir=\"/tmp/celatone_downloads\")"
        }
    ]
}