{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a Python helper to parse a CLI-style coin string into a validated list of {denom, amount} objects for Juno.",
            "code": "from typing import List, Dict, Optional\nimport re\n\n# Simple pattern: one or more digits followed by a denom (letters/numbers or '/' for IBC denoms)\nCOIN_RE = re.compile(r'^([0-9]+)([a-zA-Z0-9/]+)$')\n\n\nclass AmountParseError(ValueError):\n    '''Raised when a coin string cannot be parsed or validated.'''\n\n\ndef parse_and_validate_amounts(coin_str: str, allowed_denoms: Optional[List[str]] = None) -> List[Dict[str, str]]:\n    '''Parse a human coin string like 100000ujunox,25000ujuno into a list of\n    {denom: <str>, amount: <str>} objects and validate them.\n\n    :param coin_str: Comma-separated coin string.\n    :param allowed_denoms: Optional whitelist of allowed denoms.\n    :return: List of dicts with keys denom and amount.\n    :raises AmountParseError: If the string is invalid.\n    '''\n    if not coin_str:\n        raise AmountParseError('Coin string must not be empty.')\n\n    # Default to common Juno denoms; extend this list in your app as needed.\n    if allowed_denoms is None:\n        allowed_denoms = ['ujuno', 'ujunox']\n\n    coins: List[Dict[str, str]] = []\n\n    for part in coin_str.split(','):\n        token = part.strip()\n        if not token:\n            continue\n\n        m = COIN_RE.match(token)\n        if not m:\n            raise AmountParseError(f'Invalid coin segment {token}. Expected format like 100000ujuno.')\n\n        amount_str, denom = m.groups()\n\n        # Amount must be positive integer and not have leading zeros unless it is exactly 0.\n        if not amount_str.isdigit():\n            raise AmountParseError(f'Amount {amount_str} in segment {token} is not a valid integer.')\n        if amount_str == '0':\n            raise AmountParseError('Amounts must be strictly positive.')\n        # Leading zeros check (e.g., 001 is not allowed)\n        if len(amount_str) > 1 and amount_str.startswith('0'):\n            raise AmountParseError(f'Amount {amount_str} must not contain leading zeros.')\n\n        if denom not in allowed_denoms:\n            raise AmountParseError(\n                f'Denom {denom} is not in the list of allowed Juno denoms: {allowed_denoms}.'\n            )\n\n        coins.append({'denom': denom, 'amount': amount_str})\n\n    if not coins:\n        raise AmountParseError('No valid coin segments were found in input.')\n\n    # Optionally, you can aggregate amounts by denom here if duplicates are possible.\n\n    return coins\n",
            "usage": "coins = parse_and_validate_amounts('50000ujunox,25000ujuno')"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 adds an async backend check that queries Juno spendable balances via the LCD and verifies the user can cover funds plus fees.",
            "code": "from typing import List, Dict, Optional\nimport httpx\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\nclass InsufficientBalanceError(ValueError):\n    '''Raised when the sender does not have enough spendable balance.'''\n\n\nasync def check_spendable_balances_for_sender(\n    sender_address: str,\n    required_funds: List[Dict[str, str]],\n    expected_fee_per_denom: Optional[Dict[str, int]] = None,\n    lcd_url: str = LCD_URL,\n) -> Dict[str, Dict[str, int]]:\n    '''Ensure that sender_address has at least required_funds plus expected_fee_per_denom\n    available as spendable balance.\n\n    :param sender_address: Bech32 Juno address of the sender.\n    :param required_funds: List of dicts with keys denom and amount from step 1.\n    :param expected_fee_per_denom: Optional dict mapping denom to extra units reserved for fees.\n    :param lcd_url: Base LCD URL.\n    :return: Dict containing a mapping of spendable balances.\n    :raises InsufficientBalanceError: If any denom is insufficient.\n    '''\n    if expected_fee_per_denom is None:\n        expected_fee_per_denom = {}\n\n    url = f'{lcd_url}/cosmos/bank/v1beta1/spendable_balances/{sender_address}'\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            resp = await client.get(url)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise RuntimeError(f'Error querying spendable balances from LCD: {exc}') from exc\n\n    data = resp.json()\n    # Build a simple denom -> int amount map\n    spendable_map: Dict[str, int] = {}\n    for coin in data.get('balances', []):\n        denom = coin.get('denom')\n        amount_str = coin.get('amount', '0')\n        if denom is None:\n            continue\n        try:\n            spendable_map[denom] = int(amount_str)\n        except ValueError:\n            raise RuntimeError(f'LCD returned a non-integer amount {amount_str} for denom {denom}.')\n\n    # Check each required fund\n    for coin in required_funds:\n        denom = coin['denom']\n        raw_amount = coin['amount']\n        try:\n            required_amount = int(raw_amount)\n        except ValueError:\n            raise ValueError(f'Required amount {raw_amount} for denom {denom} is not a valid integer.')\n\n        fee_buffer = int(expected_fee_per_denom.get(denom, 0))\n        total_required = required_amount + fee_buffer\n        available = spendable_map.get(denom, 0)\n\n        if available < total_required:\n            raise InsufficientBalanceError(\n                f'Insufficient spendable balance for denom {denom}. '\n                f'Required including fees: {total_required}, available: {available}.'\n            )\n\n    return {'spendable_balances': spendable_map}\n",
            "usage": "balances_info = await check_spendable_balances_for_sender(sender_address, coins, expected_fee_per_denom={'ujuno': 5000})"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 builds a CosmWasm MsgExecuteContract protobuf message including the JSON execute payload and attached funds.",
            "code": "from typing import List, Dict\nimport json\n\nfrom cosmpy.protos.cosmwasm.wasm.v1 import tx_pb2 as wasm_tx_pb2\nfrom cosmpy.protos.cosmos.base.v1beta1 import coin_pb2\n\n\nclass ExecuteMsgBuildError(ValueError):\n    '''Raised when an execute message cannot be constructed.'''\n\n\ndef build_execute_contract_msg_with_funds(\n    sender: str,\n    contract: str,\n    execute_msg: Dict,\n    funds: List[Dict[str, str]],\n) -> wasm_tx_pb2.MsgExecuteContract:\n    '''Build a MsgExecuteContract protobuf message including attached funds.\n\n    :param sender: Bech32 Juno address of the sender.\n    :param contract: Bech32 address of the target contract.\n    :param execute_msg: Python dict representing the contract execute message.\n    :param funds: List of dicts with keys denom and amount from step 1.\n    :return: MsgExecuteContract protobuf object.\n    '''\n    if not isinstance(execute_msg, dict):\n        raise ExecuteMsgBuildError('execute_msg must be a JSON-serializable dict.')\n\n    if not funds:\n        # It is technically valid to send no funds, but this helper is meant for cases with funds.\n        raise ExecuteMsgBuildError('funds must be a non-empty list when attaching tokens.')\n\n    try:\n        msg_bytes = json.dumps(execute_msg, separators=(',', ':'), ensure_ascii=False).encode('utf-8')\n    except (TypeError, ValueError) as exc:\n        raise ExecuteMsgBuildError(f'Failed to JSON-encode execute_msg: {exc}') from exc\n\n    proto_funds = []\n    for coin in funds:\n        denom = coin['denom']\n        amount = coin['amount']\n        # Basic validation; detailed checks were already done in step 1.\n        if not denom or not amount:\n            raise ExecuteMsgBuildError(f'Invalid fund entry: {coin}.')\n        proto_funds.append(coin_pb2.Coin(denom=denom, amount=str(amount)))\n\n    msg = wasm_tx_pb2.MsgExecuteContract(\n        sender=sender,\n        contract=contract,\n        msg=msg_bytes,\n        funds=proto_funds,\n    )\n\n    return msg\n",
            "usage": "execute_msg = {'some_endpoint': {}}  # replace with your execute message\nmsg = build_execute_contract_msg_with_funds(sender_address, contract_address, execute_msg, coins)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 wraps the execute message in an unsigned Cosmos SDK Tx with initial gas and fee based on the node minimum_gas_price.",
            "code": "from typing import Tuple\nfrom decimal import Decimal, ROUND_UP\nimport httpx\n\nfrom google.protobuf.any_pb2 import Any as AnyProto\n\nfrom cosmpy.protos.cosmos.tx.v1beta1 import tx_pb2\nfrom cosmpy.protos.cosmos.tx.signing.v1beta1 import signing_pb2\nfrom cosmpy.protos.cosmos.crypto.secp256k1 import keys_pb2\nfrom cosmpy.protos.cosmos.base.v1beta1 import coin_pb2\nfrom cosmpy.protos.cosmwasm.wasm.v1 import tx_pb2 as wasm_tx_pb2\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\nclass TxConstructionError(RuntimeError):\n    '''Raised when an unsigned transaction cannot be constructed.'''\n\n\nasync def _get_minimum_gas_price(lcd_url: str = LCD_URL) -> Tuple[Decimal, str]:\n    '''Fetch and parse minimum_gas_price from the node config endpoint.'''\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        resp = await client.get(f'{lcd_url}/cosmos/base/node/v1beta1/config')\n        resp.raise_for_status()\n\n    cfg = resp.json()\n    mgp = cfg.get('minimum_gas_price')\n    if not mgp:\n        raise TxConstructionError('LCD /config did not return minimum_gas_price.')\n\n    # Example format: 0.0025ujuno\n    i = 0\n    while i < len(mgp) and (mgp[i].isdigit() or mgp[i] == '.'):\n        i += 1\n    amount_str = mgp[:i]\n    denom = mgp[i:]\n    if not amount_str or not denom:\n        raise TxConstructionError(f'Could not parse minimum_gas_price value {mgp}.')\n\n    return Decimal(amount_str), denom\n\n\nasync def construct_execute_tx(\n    msg: wasm_tx_pb2.MsgExecuteContract,\n    public_key_bytes: bytes,\n    sequence: int,\n    gas_limit: int = 200_000,\n    gas_adjustment: float = 1.0,\n    lcd_url: str = LCD_URL,\n) -> Tuple[tx_pb2.Tx, int, coin_pb2.Coin]:\n    '''Wrap the MsgExecuteContract in a Tx with an initial gas limit and fee.\n\n    This creates an unsigned Tx (no signatures yet) that can be simulated in step 5.\n\n    :param msg: MsgExecuteContract protobuf message.\n    :param public_key_bytes: 33-byte compressed secp256k1 public key for the sender.\n    :param sequence: Account sequence for the sender.\n    :param gas_limit: Initial gas limit used before simulation.\n    :param gas_adjustment: Optional multiplier applied to gas_limit.\n    :param lcd_url: Base LCD URL used to fetch minimum_gas_price.\n    :return: Tuple of (unsigned_tx, effective_gas_limit, fee_coin).\n    '''\n    if gas_limit <= 0:\n        raise TxConstructionError('gas_limit must be positive.')\n    effective_gas_limit = int(gas_limit * gas_adjustment)\n\n    # Fetch minimum gas price (for example 0.0025ujuno) and compute fee = ceil(price * gas_limit)\n    try:\n        gas_price_amount, gas_price_denom = await _get_minimum_gas_price(lcd_url)\n    except httpx.HTTPError as exc:\n        raise TxConstructionError(f'Failed to fetch minimum_gas_price from LCD: {exc}') from exc\n\n    fee_decimal = (gas_price_amount * Decimal(effective_gas_limit)).to_integral_value(rounding=ROUND_UP)\n    fee_amount = int(fee_decimal)\n    fee_coin = coin_pb2.Coin(denom=gas_price_denom, amount=str(fee_amount))\n\n    # Pack MsgExecuteContract into an Any proto\n    msg_any = AnyProto(\n        type_url='/cosmwasm.wasm.v1.MsgExecuteContract',\n        value=msg.SerializeToString(),\n    )\n\n    tx_body = tx_pb2.TxBody(\n        messages=[msg_any],\n        memo='',\n        timeout_height=0,\n    )\n\n    # Signer info with direct sign mode\n    pubkey = keys_pb2.PubKey(key=public_key_bytes)\n    pubkey_any = AnyProto(\n        type_url='/cosmos.crypto.secp256k1.PubKey',\n        value=pubkey.SerializeToString(),\n    )\n\n    mode_info = tx_pb2.ModeInfo(\n        single=tx_pb2.ModeInfo.Single(mode=signing_pb2.SIGN_MODE_DIRECT)\n    )\n\n    signer_info = tx_pb2.SignerInfo(\n        public_key=pubkey_any,\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    auth_info = tx_pb2.AuthInfo(\n        signer_infos=[signer_info],\n        fee=tx_pb2.Fee(\n            amount=[fee_coin],\n            gas_limit=effective_gas_limit,\n            payer='',\n            granter='',\n        ),\n    )\n\n    unsigned_tx = tx_pb2.Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[],  # populated in step 6\n    )\n\n    return unsigned_tx, effective_gas_limit, fee_coin\n",
            "usage": "unsigned_tx, gas_limit, fee_coin = await construct_execute_tx(msg, public_key_bytes, sequence)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 simulates the unsigned transaction via the LCD simulate endpoint to obtain gas_used and a recommended adjusted gas limit.",
            "code": "from typing import Tuple\nimport base64\n\nimport httpx\nfrom cosmpy.protos.cosmos.tx.v1beta1 import tx_pb2\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\nclass TxSimulationError(RuntimeError):\n    '''Raised when transaction simulation fails.'''\n\n\nasync def simulate_execute_tx(\n    unsigned_tx: tx_pb2.Tx,\n    gas_adjustment: float = 1.2,\n    lcd_url: str = LCD_URL,\n) -> Tuple[int, int]:\n    '''Simulate an unsigned transaction to estimate gas usage.\n\n    :param unsigned_tx: Tx object from step 4 (no signatures required for simulation).\n    :param gas_adjustment: Multiplier applied to gas_used to compute new gas_limit.\n    :param lcd_url: Base LCD URL.\n    :return: Tuple of (gas_used, adjusted_gas_limit).\n    '''\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive.')\n\n    tx_bytes = unsigned_tx.SerializeToString()\n    payload = {'tx_bytes': base64.b64encode(tx_bytes).decode('utf-8')}\n\n    async with httpx.AsyncClient(timeout=20.0) as client:\n        try:\n            resp = await client.post(f'{lcd_url}/cosmos/tx/v1beta1/simulate', json=payload)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise TxSimulationError(f'Error calling /cosmos/tx/v1beta1/simulate: {exc}') from exc\n\n    data = resp.json()\n    gas_info = data.get('gas_info') or {}\n    gas_used_str = gas_info.get('gas_used')\n    if gas_used_str is None:\n        raise TxSimulationError(f'Simulation response missing field gas_used: {data}')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError:\n        raise TxSimulationError(f'Simulation returned non-integer gas_used {gas_used_str}.')\n\n    adjusted_gas_limit = int(gas_used * gas_adjustment)\n\n    return gas_used, adjusted_gas_limit\n",
            "usage": "gas_used, adjusted_gas_limit = await simulate_execute_tx(unsigned_tx)\n# After this, you can rebuild the unsigned_tx with construct_execute_tx using gas_limit=adjusted_gas_limit before signing."
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 signs the prepared Tx with the sender private key using CosmPy and broadcasts it to the Juno LCD in BLOCK mode.",
            "code": "from typing import Tuple\nimport base64\n\nimport httpx\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.crypto.keypairs import PrivateKey\nfrom cosmpy.protos.cosmos.tx.v1beta1 import tx_pb2\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\nclass TxBroadcastError(RuntimeError):\n    '''Raised when broadcasting a transaction fails.'''\n\n\nasync def sign_and_broadcast_execute_tx(\n    unsigned_tx: tx_pb2.Tx,\n    privkey_hex: str,\n    account_number: int,\n    sequence: int,\n    chain_id: str,\n    lcd_url: str = LCD_URL,\n) -> Tuple[str, dict]:\n    '''Sign an execute transaction with the sender key and broadcast it via the LCD.\n\n    :param unsigned_tx: Tx object from step 4 (fee and gas_limit should already be set,\n                       optionally updated after step 5).\n    :param privkey_hex: Hex-encoded secp256k1 private key for the sender.\n    :param account_number: Sender account number on chain.\n    :param sequence: Sender sequence (nonce) on chain.\n    :param chain_id: Chain ID, for example juno-1 or uni-6.\n    :param lcd_url: Base LCD URL.\n    :return: Tuple of (txhash, full tx_response dict).\n    '''\n    key_hex = privkey_hex.lower().replace('0x', '')\n    if len(key_hex) != 64:\n        raise ValueError('Private key must be 32 bytes (64 hex characters).')\n\n    try:\n        privkey = PrivateKey(bytes.fromhex(key_hex))\n    except ValueError as exc:\n        raise ValueError(f'Invalid private key hex: {exc}') from exc\n\n    wallet = LocalWallet(privkey)\n\n    # cosmpy will create the SignDoc, sign it, and attach the signature to the Tx.\n    signed_tx: tx_pb2.Tx = wallet.sign_tx(\n        unsigned_tx,\n        account_number=account_number,\n        sequence=sequence,\n        chain_id=chain_id,\n    )\n\n    tx_bytes = signed_tx.SerializeToString()\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('utf-8'),\n        'mode': 'BROADCAST_MODE_BLOCK',\n    }\n\n    async with httpx.AsyncClient(timeout=30.0) as client:\n        try:\n            resp = await client.post(f'{lcd_url}/cosmos/tx/v1beta1/txs', json=payload)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise TxBroadcastError(f'Error broadcasting transaction: {exc}') from exc\n\n    data = resp.json()\n    tx_response = data.get('tx_response') or {}\n    txhash = tx_response.get('txhash')\n\n    if not txhash:\n        raise TxBroadcastError(f'LCD did not return txhash. Full response: {data}')\n\n    code = tx_response.get('code', 0)\n    if code != 0:\n        raw_log = tx_response.get('raw_log', '')\n        raise TxBroadcastError(\n            f'Transaction failed with code {code}. txhash={txhash}, raw_log={raw_log}'\n        )\n\n    return txhash, tx_response\n",
            "usage": "txhash, tx_response = await sign_and_broadcast_execute_tx(unsigned_tx, privkey_hex, account_number, sequence, 'uni-6')"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Step 7 re-queries bank balances for the contract and optionally the sender to confirm that the attached funds were transferred.",
            "code": "from typing import List, Dict, Optional\n\nimport httpx\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\nclass FundsVerificationError(RuntimeError):\n    '''Raised when post-transaction balance checks fail.'''\n\n\nasync def _get_balance_by_denom(\n    address: str,\n    denom: str,\n    lcd_url: str = LCD_URL,\n) -> int:\n    '''Helper to query /balances/{address}/by_denom for a single denom.'''\n    url = f'{lcd_url}/cosmos/bank/v1beta1/balances/{address}/by_denom'\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        resp = await client.get(url, params={'denom': denom})\n        resp.raise_for_status()\n\n    data = resp.json()\n    balance = data.get('balance') or {}\n    amount_str = balance.get('amount', '0')\n    try:\n        return int(amount_str)\n    except ValueError:\n        raise RuntimeError(f'LCD returned non-integer balance {amount_str} for {address} denom {denom}.')\n\n\nasync def verify_funds_transferred_to_contract(\n    contract_address: str,\n    sender_address: str,\n    attached_funds: List[Dict[str, str]],\n    before_contract_balances: Optional[Dict[str, int]] = None,\n    before_sender_balances: Optional[Dict[str, int]] = None,\n    lcd_url: str = LCD_URL,\n) -> Dict[str, Dict[str, int]]:\n    '''Verify that funds attached to the execute transaction have arrived in the contract account.\n\n    If before_contract_balances and before_sender_balances snapshots are provided, this will also\n    validate that the observed balance deltas match or exceed the attached_funds amounts.\n\n    :param contract_address: Bech32 contract address that received funds.\n    :param sender_address: Bech32 address of the sender.\n    :param attached_funds: List of dicts with keys denom and amount that were sent to the contract.\n    :param before_contract_balances: Optional mapping denom to amount (int) before the transaction.\n    :param before_sender_balances: Optional mapping denom to amount (int) before the transaction.\n    :param lcd_url: Base LCD URL.\n    :return: Dict summarizing pre and post balances and deltas.\n    :raises FundsVerificationError: If observed deltas do not match expectations.\n    '''\n    after_contract: Dict[str, int] = {}\n    after_sender: Dict[str, int] = {}\n\n    # Fetch fresh balances after the transaction\n    for coin in attached_funds:\n        denom = coin['denom']\n        after_contract[denom] = await _get_balance_by_denom(contract_address, denom, lcd_url)\n        after_sender[denom] = await _get_balance_by_denom(sender_address, denom, lcd_url)\n\n    # If before_* snapshots are provided, compute and validate deltas.\n    contract_deltas: Dict[str, int] = {}\n    sender_deltas: Dict[str, int] = {}\n\n    for coin in attached_funds:\n        denom = coin['denom']\n        sent_amount = int(coin['amount'])\n\n        if before_contract_balances is not None:\n            before_c = int(before_contract_balances.get(denom, 0))\n            delta_c = after_contract[denom] - before_c\n            contract_deltas[denom] = delta_c\n            if delta_c < sent_amount:\n                raise FundsVerificationError(\n                    f'Contract balance for {denom} increased by {delta_c}, '\n                    f'expected at least {sent_amount}.'\n                )\n\n        if before_sender_balances is not None:\n            before_s = int(before_sender_balances.get(denom, 0))\n            delta_s = after_sender[denom] - before_s\n            sender_deltas[denom] = delta_s\n            if delta_s > -sent_amount:\n                raise FundsVerificationError(\n                    f'Sender balance for {denom} decreased by {-delta_s}, '\n                    f'expected at least {sent_amount}.'\n                )\n\n    return {\n        'after_contract_balances': after_contract,\n        'after_sender_balances': after_sender,\n        'contract_deltas': contract_deltas,\n        'sender_deltas': sender_deltas,\n    }\n",
            "usage": "result = await verify_funds_transferred_to_contract(contract_address, sender_address, coins, before_contract_balances, before_sender_balances)"
        }
    ]
}