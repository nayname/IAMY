{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 provides a backend helper that returns the configured Juno sender address used for signing and fee payment.",
            "code": "import os\n\n# Base Juno LCD URL used for subsequent steps\nLCD_URL = 'https://lcd-archive.junonetwork.io'\nCHAIN_ID = 'juno-1'\n\n\ndef get_sender_address() -> str:\n    '''\n    Return the bech32 Juno address used to sign and pay for transactions.\n\n    The address is read from the JUNO_SENDER_ADDRESS environment variable, which\n    should be configured on the backend (custodial key management).\n    '''\n    address = os.getenv('JUNO_SENDER_ADDRESS')\n    if not address:\n        raise RuntimeError('Environment variable JUNO_SENDER_ADDRESS is not set.')\n    if not address.startswith('juno1'):\n        raise ValueError(f'JUNO_SENDER_ADDRESS must start with prefix juno1. Got: {address}')\n    return address\n",
            "usage": "sender_address = get_sender_address()"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 queries the Juno LCD for auth account data and decodes a BaseAccount to obtain account_number, sequence, and the on-chain public key.",
            "code": "import base64\nimport requests\nfrom cosmpy.protos.cosmos.auth.v1beta1 import auth_pb2\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\ndef get_account_info(sender_address: str):\n    '''\n    Query the chain via LCD to obtain account_number, sequence, and pub_key Any\n    for a given address.\n    '''\n    url = f'{LCD_URL}/cosmos/auth/v1beta1/accounts/{sender_address}'\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error querying account info: {e}') from e\n\n    data = resp.json()\n    account_any = data.get('account')\n    if not account_any:\n        raise RuntimeError(f'No account field in LCD response for {sender_address}')\n\n    value_b64 = account_any.get('value')\n    if not value_b64:\n        raise RuntimeError('LCD account response missing protobuf-encoded BaseAccount value.')\n\n    try:\n        raw = base64.b64decode(value_b64)\n    except (base64.binascii.Error, TypeError) as e:\n        raise RuntimeError(f'Failed to base64-decode account value: {e}') from e\n\n    base_account = auth_pb2.BaseAccount()\n    base_account.ParseFromString(raw)\n\n    if not base_account.address:\n        raise RuntimeError('Decoded BaseAccount has empty address.')\n    if base_account.address != sender_address:\n        # Not fatal, but worth surfacing.\n        raise RuntimeError(\n            f'Address mismatch: requested {sender_address}, got {base_account.address} from LCD.'\n        )\n\n    # pub_key may be unset if the account has never signed a tx.\n    if not base_account.pub_key.type_url:\n        raise RuntimeError(\n            'Account has no public key set on-chain (likely never used). '\n            'Cannot construct SignerInfo without a pub_key.'\n        )\n\n    return {\n        'account_number': int(base_account.account_number),\n        'sequence': int(base_account.sequence),\n        'pub_key': base_account.pub_key,  # google.protobuf.Any\n    }\n",
            "usage": "info = get_account_info(sender_address)\naccount_number = info['account_number']\nsequence = info['sequence']\npub_key_any = info['pub_key']"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 checks the sender\u2019s spendable balance via LCD to ensure there are enough funds to cover gas and fees.",
            "code": "import requests\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\ndef check_spendable_balance(sender_address: str, required_amount: int, denom: str = 'ujuno') -> int:\n    '''\n    Query the spendable balance for sender_address and ensure it is >= required_amount.\n    required_amount is expressed in the base denom (e.g. ujuno).\n    Returns the actual balance for the denom on success.\n    '''\n    url = f'{LCD_URL}/cosmos/bank/v1beta1/spendable_balances/{sender_address}'\n    params = {'pagination.limit': '1000'}\n    try:\n        resp = requests.get(url, params=params, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error querying spendable balances: {e}') from e\n\n    data = resp.json()\n    balances = data.get('balances', [])\n    balance_amount = 0\n    for coin in balances:\n        if coin.get('denom') == denom:\n            try:\n                balance_amount = int(coin.get('amount', '0'))\n            except ValueError:\n                bad = coin.get('amount')\n                raise RuntimeError(f'Invalid amount for {denom} in LCD response: {bad}')\n            break\n\n    if balance_amount == 0:\n        raise RuntimeError(f'No spendable balance found for denom {denom} on address {sender_address}.')\n\n    if balance_amount < required_amount:\n        raise RuntimeError(\n            f'Insufficient {denom} balance. Required: {required_amount}, available: {balance_amount}.'\n        )\n\n    return balance_amount\n",
            "usage": "balance = check_spendable_balance(sender_address, required_amount=2000000, denom='ujuno')"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 builds a CosmWasm MsgExecuteContract for the reset(count = 0) execution and wraps it in a protobuf Any message.",
            "code": "import json\nfrom google.protobuf.any_pb2 import Any\nfrom cosmpy.protos.cosmwasm.wasm.v1 import tx_pb2 as wasm_tx_pb2\n\n\ndef construct_msg_execute_reset(sender_address: str, contract_address: str) -> Any:\n    '''\n    Build a MsgExecuteContract to call `reset { count: 0 }` on a CosmWasm counter contract.\n    Returns the message wrapped in a google.protobuf.Any ready to be added to a TxBody.\n    '''\n    # CosmWasm execute message payload\n    execute_payload = {'reset': {'count': 0}}\n\n    msg = wasm_tx_pb2.MsgExecuteContract(\n        sender=sender_address,\n        contract=contract_address,\n        msg=json.dumps(execute_payload).encode('utf-8'),\n        funds=[],  # no funds attached\n    )\n\n    # Wrap in Any with the proper type_url: /cosmwasm.wasm.v1.MsgExecuteContract\n    any_msg = Any()\n    any_msg.Pack(msg, type_url_prefix='/')\n\n    # Sanity-check the type_url to avoid subtle bugs.\n    if any_msg.type_url != '/cosmwasm.wasm.v1.MsgExecuteContract':\n        raise RuntimeError(f'Unexpected type_url for MsgExecuteContract: {any_msg.type_url}')\n\n    return any_msg\n",
            "usage": "CONTRACT_ADDRESS = 'juno1...'  # replace with your contract address\nexecute_any = construct_msg_execute_reset(sender_address, CONTRACT_ADDRESS)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 wraps the execute message in a Tx body, sets an initial gas limit and fee, and constructs an unsigned Tx with signer_infos using the on-chain public key and sequence.",
            "code": "from google.protobuf.any_pb2 import Any\nfrom cosmpy.protos.cosmos.base.v1beta1 import coin_pb2 as cosmos_coin_pb2\nfrom cosmpy.protos.cosmos.tx.v1beta1 import tx_pb2 as cosmos_tx_pb2\nfrom cosmpy.protos.cosmos.tx.signing.v1beta1 import signing_pb2\n\n\ndef build_unsigned_tx(\n    execute_msg_any: Any,\n    sequence: int,\n    pub_key_any: Any,\n    gas_limit: int = 200000,\n    fee_amount: int = 50000,\n    fee_denom: str = 'ujuno',\n    memo: str = '',\n) -> cosmos_tx_pb2.Tx:\n    '''\n    Construct an unsigned Tx containing a single MsgExecuteContract.\n    - execute_msg_any: Any-wrapped MsgExecuteContract (from step 4)\n    - sequence: current account sequence from LCD\n    - pub_key_any: Any-wrapped public key from the on-chain account\n    - gas_limit: initial gas limit used prior to simulation\n    - fee_amount: fee in base denom (e.g. ujuno)\n    '''\n    if gas_limit <= 0:\n        raise ValueError('gas_limit must be positive.')\n    if fee_amount < 0:\n        raise ValueError('fee_amount cannot be negative.')\n\n    tx_body = cosmos_tx_pb2.TxBody(\n        messages=[execute_msg_any],\n        memo=memo,\n    )\n\n    fee = cosmos_tx_pb2.Fee(\n        amount=[cosmos_coin_pb2.Coin(denom=fee_denom, amount=str(fee_amount))],\n        gas_limit=gas_limit,\n    )\n\n    mode_info = cosmos_tx_pb2.ModeInfo(\n        single=cosmos_tx_pb2.ModeInfo.Single(\n            mode=signing_pb2.SignMode.SIGN_MODE_DIRECT\n        )\n    )\n\n    signer_info = cosmos_tx_pb2.SignerInfo(\n        public_key=pub_key_any,\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    auth_info = cosmos_tx_pb2.AuthInfo(\n        signer_infos=[signer_info],\n        fee=fee,\n    )\n\n    tx = cosmos_tx_pb2.Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[],  # signatures added at step 7\n    )\n    return tx\n",
            "usage": "unsigned_tx = build_unsigned_tx(execute_any, sequence=sequence, pub_key_any=pub_key_any, gas_limit=200000, fee_amount=50000)"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 simulates the unsigned Tx via the Juno LCD simulate endpoint and updates its gas_limit and fee based on gas_used.",
            "code": "import base64\nfrom decimal import Decimal, ROUND_UP\nimport requests\nfrom cosmpy.protos.cosmos.base.v1beta1 import coin_pb2 as cosmos_coin_pb2\nfrom cosmpy.protos.cosmos.tx.v1beta1 import tx_pb2 as cosmos_tx_pb2\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\ndef simulate_tx_and_update_fee(\n    tx: cosmos_tx_pb2.Tx,\n    gas_price: Decimal = Decimal('0.025'),  # example: 0.025 ujuno per gas\n    gas_adjustment: float = 1.2,\n    fee_denom: str = 'ujuno',\n) -> dict:\n    '''\n    Simulate the unsigned transaction via the LCD endpoint and update its\n    gas_limit and fee amount based on the returned gas_used.\n    Returns a dict with simulation details; the tx object is mutated in-place.\n    '''\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive.')\n\n    # Serialize Tx (signatures may be empty for simulation)\n    tx_bytes = tx.SerializeToString()\n    tx_bytes_b64 = base64.b64encode(tx_bytes).decode('utf-8')\n\n    url = f'{LCD_URL}/cosmos/tx/v1beta1/simulate'\n    payload = {'tx_bytes': tx_bytes_b64}\n\n    try:\n        resp = requests.post(url, json=payload, timeout=15)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error simulating transaction: {e}') from e\n\n    sim = resp.json()\n    gas_info = sim.get('gas_info') or {}\n    gas_used_str = gas_info.get('gas_used')\n    if gas_used_str is None:\n        raise RuntimeError(f'Simulation response missing gas_used: {sim}')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError:\n        raise RuntimeError(f'Invalid gas_used in simulation response: {gas_used_str}')\n\n    # Apply gas adjustment and compute fee = gas_limit * gas_price\n    gas_limit_decimal = Decimal(gas_used) * Decimal(str(gas_adjustment))\n    gas_limit = int(gas_limit_decimal.quantize(Decimal('1'), rounding=ROUND_UP))\n    fee_amount_decimal = Decimal(gas_limit) * gas_price\n    fee_amount = int(fee_amount_decimal.quantize(Decimal('1'), rounding=ROUND_UP))\n\n    # Update tx.auth_info.fee\n    tx.auth_info.fee.gas_limit = gas_limit\n    tx.auth_info.fee.amount[:] = [cosmos_coin_pb2.Coin(denom=fee_denom, amount=str(fee_amount))]\n\n    return {\n        'gas_used': gas_used,\n        'gas_limit': gas_limit,\n        'fee_amount': fee_amount,\n        'fee_denom': fee_denom,\n    }\n",
            "usage": "from decimal import Decimal\n\nsim_result = simulate_tx_and_update_fee(unsigned_tx, gas_price=Decimal('0.025'), gas_adjustment=1.2)\nupdated_tx = unsigned_tx  # mutated in-place with new gas_limit and fee"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Step 7 signs the adjusted Tx on the backend using the sender\u2019s secp256k1 private key and produces raw tx_bytes suitable for broadcast.",
            "code": "import os\nimport base64\nfrom cosmpy.crypto.keypairs import PrivateKey\nfrom cosmpy.protos.cosmos.tx.v1beta1 import tx_pb2 as cosmos_tx_pb2\n\nCHAIN_ID = 'juno-1'\n\n\ndef sign_tx(tx: cosmos_tx_pb2.Tx, account_number: int, chain_id: str = CHAIN_ID, private_key_hex: str = None) -> dict:\n    '''\n    Sign the provided Tx using the secp256k1 private key.\n    Returns a dict with the signed Tx object and raw/base64-encoded bytes.\n    '''\n    if private_key_hex is None:\n        private_key_hex = os.getenv('JUNO_PRIVATE_KEY_HEX')\n    if not private_key_hex:\n        raise RuntimeError(\n            'Missing private key. Set JUNO_PRIVATE_KEY_HEX or pass private_key_hex explicitly.'\n        )\n\n    try:\n        privkey_bytes = bytes.fromhex(private_key_hex)\n    except ValueError as e:\n        raise RuntimeError('JUNO_PRIVATE_KEY_HEX must be a valid hex string.') from e\n\n    privkey = PrivateKey(privkey_bytes)\n\n    # Build SignDoc\n    body_bytes = tx.body.SerializeToString()\n    auth_info_bytes = tx.auth_info.SerializeToString()\n    sign_doc = cosmos_tx_pb2.SignDoc(\n        body_bytes=body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n\n    sign_bytes = sign_doc.SerializeToString()\n    signature = privkey.sign(sign_bytes)\n\n    # Attach signature to Tx\n    tx.signatures[:] = [signature]\n\n    raw_tx_bytes = tx.SerializeToString()\n    tx_bytes_b64 = base64.b64encode(raw_tx_bytes).decode('utf-8')\n\n    return {\n        'tx': tx,\n        'raw_tx_bytes': raw_tx_bytes,\n        'tx_bytes_b64': tx_bytes_b64,\n    }\n",
            "usage": "signed = sign_tx(updated_tx, account_number=account_number)\nraw_tx_bytes = signed['raw_tx_bytes']\ntx_bytes_b64 = signed['tx_bytes_b64']"
        },
        {
            "step": 8,
            "label": "backend",
            "introduction": "Step 8 broadcasts the signed tx_bytes to the Juno LCD /cosmos/tx/v1beta1/txs endpoint and returns the tx_response, raising on non-zero error codes.",
            "code": "import requests\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\ndef broadcast_tx(tx_bytes_b64: str, mode: str = 'BROADCAST_MODE_SYNC') -> dict:\n    '''\n    Broadcast the signed transaction to the Juno LCD endpoint and return the tx_response.\n    Raises an exception if the endpoint returns an HTTP error or a non-zero ABCI code.\n    '''\n    url = f'{LCD_URL}/cosmos/tx/v1beta1/txs'\n    payload = {'tx_bytes': tx_bytes_b64, 'mode': mode}\n\n    try:\n        resp = requests.post(url, json=payload, timeout=30)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error broadcasting transaction: {e}') from e\n\n    data = resp.json()\n    tx_response = data.get('tx_response')\n    if not tx_response:\n        raise RuntimeError(f'LCD broadcast response missing tx_response: {data}')\n\n    code = int(tx_response.get('code', 0))\n    if code != 0:\n        raw_log = tx_response.get('raw_log')\n        raise RuntimeError(\n            f'Transaction failed with code {code}: {raw_log}'\n        )\n\n    return tx_response\n",
            "usage": "tx_response = broadcast_tx(tx_bytes_b64, mode='BROADCAST_MODE_SYNC')\ntxhash = tx_response['txhash']"
        },
        {
            "step": 9,
            "label": "backend",
            "introduction": "Step 9 smart-queries the contract via LCD to confirm that the on-chain counter state has been reset to 0.",
            "code": "import base64\nimport json\nimport requests\n\nLCD_URL = 'https://lcd-archive.junonetwork.io'\n\n\ndef verify_reset_effect(contract_address: str, expected_count: int = 0) -> int:\n    '''\n    Query the contract via its smart query endpoint to ensure that the current\n    count equals expected_count (default 0). Raises RuntimeError if not.\n    '''\n    query_msg = {'get_count': {}}\n    query_b64 = base64.b64encode(json.dumps(query_msg).encode('utf-8')).decode('utf-8')\n\n    url = f'{LCD_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_b64}'\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error querying contract state: {e}') from e\n\n    data = resp.json()\n    data_b64 = data.get('data')\n    if data_b64 is None:\n        raise RuntimeError(f'Unexpected smart query response (missing data field): {data}')\n\n    try:\n        raw = base64.b64decode(data_b64)\n        decoded = json.loads(raw.decode('utf-8'))\n    except Exception as e:\n        raise RuntimeError(f'Failed to decode smart query response payload: {e}') from e\n\n    count = decoded.get('count')\n    if count != expected_count:\n        raise RuntimeError(f'Contract count mismatch. Expected {expected_count}, got {count}.')\n\n    return count\n",
            "usage": "current_count = verify_reset_effect(CONTRACT_ADDRESS, expected_count=0)"
        }
    ]
}