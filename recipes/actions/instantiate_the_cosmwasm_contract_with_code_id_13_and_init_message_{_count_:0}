{
    "label": "instantiate",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 normalizes and validates the init JSON (e.g. {'count': 0}) and returns canonical UTF-8 bytes for use as the CosmWasm instantiate msg.",
            "code": "import json\nfrom typing import Union\n\n\ndef normalize_and_serialize_init_msg(raw_init: Union[str, dict]) -> bytes:\n    '''Normalize and validate a CosmWasm init message and return UTF-8 bytes.'''\n    if isinstance(raw_init, str):\n        try:\n            obj = json.loads(raw_init)\n        except json.JSONDecodeError as e:\n            raise ValueError(f'Invalid JSON for init msg: {e}')\n    elif isinstance(raw_init, dict):\n        obj = raw_init\n    else:\n        raise TypeError('raw_init must be a JSON string or dict')\n\n    # Basic validation for the counter example: ensure count is an integer\n    if 'count' not in obj:\n        raise ValueError('init msg must contain a count field')\n    if not isinstance(obj['count'], int):\n        raise ValueError('count must be an integer')\n\n    # Canonical JSON: no extra spaces, sorted keys\n    normalized_str = json.dumps(obj, sort_keys=True, separators=(',', ':'))\n    return normalized_str.encode('utf-8')\n",
            "usage": "init_bytes = normalize_and_serialize_init_msg({'count': 0})"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 verifies that the specified CosmWasm code id (13) exists on Juno using the LCD /cosmwasm/wasm/v1/code/{code_id} endpoint.",
            "code": "import httpx\nfrom typing import Any, Dict\n\n\nBASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def lcd_check_code_id_exists(code_id: int) -> Dict[str, Any]:\n    '''Verify that a given CosmWasm code id exists on Juno.'''\n    try:\n        async with httpx.AsyncClient(base_url=BASE_URL, timeout=10.0) as client:\n            resp = await client.get(f'/cosmwasm/wasm/v1/code/{code_id}')\n    except httpx.RequestError as e:\n        raise RuntimeError(f'Network error while checking code id {code_id}: {e}') from e\n\n    if resp.status_code != 200:\n        raise ValueError(f'LCD returned status {resp.status_code} for code id {code_id}: {resp.text}')\n\n    data = resp.json()\n    code_info = data.get('code_info')\n    if not code_info or not code_info.get('code_id'):\n        raise ValueError(f'Code id {code_id} does not exist on Juno or LCD response is malformed')\n\n    return code_info\n",
            "usage": "code_info = await lcd_check_code_id_exists(13)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 fetches the chain-id from /cosmos/base/tendermint/v1beta1/node_info and decodes the account number and sequence from /cosmos/auth/v1beta1/accounts/{address}.",
            "code": "import base64\nfrom typing import Any, Dict\n\nimport httpx\nfrom cosmos.auth.v1beta1 import auth_pb2 as cosmos_auth\n\n\nBASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def bff_get_chain_and_account_info(address: str) -> Dict[str, Any]:\n    '''Fetch chain id and the account number/sequence for a Juno address.'''\n    try:\n        async with httpx.AsyncClient(base_url=BASE_URL, timeout=10.0) as client:\n            node_resp = await client.get('/cosmos/base/tendermint/v1beta1/node_info')\n            acct_resp = await client.get(f'/cosmos/auth/v1beta1/accounts/{address}')\n    except httpx.RequestError as e:\n        raise RuntimeError(f'Network error while fetching chain or account info: {e}') from e\n\n    if node_resp.status_code != 200:\n        raise ValueError(f'Failed to fetch node info: HTTP {node_resp.status_code} {node_resp.text}')\n    if acct_resp.status_code != 200:\n        raise ValueError(f'Failed to fetch account info: HTTP {acct_resp.status_code} {acct_resp.text}')\n\n    node_data = node_resp.json()\n    chain_id = node_data.get('default_node_info', {}).get('network')\n    if not chain_id:\n        raise ValueError('LCD node_info response did not contain a network/chain id')\n\n    acct_data = acct_resp.json().get('account')\n    if not acct_data:\n        raise ValueError('LCD auth/accounts response did not contain an account field')\n\n    value_b64 = acct_data.get('value')\n    if not value_b64:\n        raise ValueError('Account Any does not contain a value field')\n\n    try:\n        acct_bytes = base64.b64decode(value_b64)\n    except Exception as e:\n        raise ValueError(f'Failed to base64-decode account value: {e}') from e\n\n    base_account = cosmos_auth.BaseAccount()\n    try:\n        base_account.ParseFromString(acct_bytes)\n    except Exception as e:\n        raise ValueError(f'Failed to decode BaseAccount protobuf: {e}') from e\n\n    account_number = int(base_account.account_number)\n    sequence = int(base_account.sequence)\n\n    return {\n        'chain_id': chain_id,\n        'account_number': account_number,\n        'sequence': sequence,\n    }\n",
            "usage": "info = await bff_get_chain_and_account_info(sender_address)\nchain_id = info['chain_id']\naccount_number = info['account_number']\nsequence = info['sequence']"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 checks that the sender has sufficient spendable balance in the chosen fee denom via /cosmos/bank/v1beta1/spendable_balances/{address}.",
            "code": "import httpx\nfrom typing import Dict, Any\n\n\nBASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def lcd_check_spendable_balances(address: str, denom: str, required_amount: int) -> int:\n    '''Ensure the sender has enough spendable balance in the given denom.'''\n    try:\n        async with httpx.AsyncClient(base_url=BASE_URL, timeout=10.0) as client:\n            resp = await client.get(f'/cosmos/bank/v1beta1/spendable_balances/{address}')\n    except httpx.RequestError as e:\n        raise RuntimeError(f'Network error while querying spendable balances: {e}') from e\n\n    if resp.status_code != 200:\n        raise ValueError(f'Failed to fetch spendable balances: HTTP {resp.status_code} {resp.text}')\n\n    data = resp.json()\n    balances = data.get('balances', []) or []\n\n    available = 0\n    for coin in balances:\n        if coin.get('denom') == denom:\n            try:\n                available = int(coin.get('amount', '0'))\n            except ValueError:\n                raise ValueError(f'Invalid amount value in balance for denom {denom}')\n            break\n\n    if available < required_amount:\n        raise ValueError(f'Insufficient funds in {denom}: required {required_amount}, available {available}')\n\n    return available\n",
            "usage": "available = await lcd_check_spendable_balances(sender_address, 'ujuno', required_amount=500000)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 builds an unsigned Tx with a single MsgInstantiateContract message, provisional gas_limit and fee, ready for simulation.",
            "code": "import base64\nfrom typing import Any, Dict, Optional\n\nfrom google.protobuf.any_pb2 import Any as ProtoAny\nfrom cosmos.tx.v1beta1 import tx_pb2 as cosmos_tx\nfrom cosmos.tx.signing.v1beta1 import signing_pb2\nfrom cosmos.base.v1beta1 import coin_pb2 as cosmos_coin\nfrom cosmwasm.wasm.v1 import tx_pb2 as cosmwasm_tx\n\n\ndef bff_construct_instantiate_contract_tx(\n    sender: str,\n    admin: Optional[str],\n    code_id: int,\n    label: str,\n    init_msg_bytes: bytes,\n    sequence: int,\n    gas_limit: int,\n    gas_price: float,\n    fee_denom: str,\n) -> Dict[str, Any]:\n    '''Construct an unsigned Tx for MsgInstantiateContract with provisional gas and fee.'''\n    if gas_limit <= 0:\n        raise ValueError('gas_limit must be positive')\n    if gas_price <= 0:\n        raise ValueError('gas_price must be positive')\n\n    # Build the CosmWasm instantiate message\n    msg = cosmwasm_tx.MsgInstantiateContract(\n        sender=sender,\n        admin=admin or '',\n        code_id=code_id,\n        label=label,\n        msg=init_msg_bytes,\n        funds=[],\n    )\n\n    msg_any = ProtoAny(type_url='/cosmwasm.wasm.v1.MsgInstantiateContract', value=msg.SerializeToString())\n\n    body = cosmos_tx.TxBody(messages=[msg_any], memo='')\n\n    fee_amount = int(gas_limit * gas_price)\n    if fee_amount <= 0:\n        raise ValueError('Computed fee_amount must be positive')\n\n    fee_coin = cosmos_coin.Coin(denom=fee_denom, amount=str(fee_amount))\n\n    mode_info = cosmos_tx.ModeInfo(single=cosmos_tx.ModeInfo.Single(mode=signing_pb2.SIGN_MODE_UNSPECIFIED))\n\n    signer_info = cosmos_tx.SignerInfo(\n        public_key=None,  # populated later before signing\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    auth_info = cosmos_tx.AuthInfo(\n        signer_infos=[signer_info],\n        fee=cosmos_tx.Fee(amount=[fee_coin], gas_limit=gas_limit, payer='', granter=''),\n    )\n\n    unsigned_tx = cosmos_tx.Tx(body=body, auth_info=auth_info, signatures=[])\n\n    body_bytes = body.SerializeToString()\n    auth_info_bytes = auth_info.SerializeToString()\n    unsigned_tx_bytes = unsigned_tx.SerializeToString()\n    unsigned_tx_b64 = base64.b64encode(unsigned_tx_bytes).decode()\n\n    return {\n        'body_bytes': body_bytes,\n        'auth_info_bytes': auth_info_bytes,\n        'unsigned_tx_bytes': unsigned_tx_bytes,\n        'unsigned_tx_b64': unsigned_tx_b64,\n        'gas_limit': gas_limit,\n        'gas_price': gas_price,\n        'fee_amount': fee_amount,\n        'fee_denom': fee_denom,\n        'sequence': sequence,\n    }\n",
            "usage": "tx_data = bff_construct_instantiate_contract_tx(sender_address, sender_address, 13, 'counter-13', init_bytes, sequence, gas_limit=300000, gas_price=0.025, fee_denom='ujuno')"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 simulates the unsigned instantiate Tx via /cosmos/tx/v1beta1/simulate to estimate gas, then updates the Tx fee and gas_limit using a safety margin.",
            "code": "import base64\nfrom typing import Any, Dict\n\nimport httpx\nfrom cosmos.tx.v1beta1 import tx_pb2 as cosmos_tx\nfrom cosmos.base.v1beta1 import coin_pb2 as cosmos_coin\n\n\nBASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def lcd_simulate_tx(\n    unsigned_tx_bytes: bytes,\n    gas_price: float,\n    fee_denom: str,\n    gas_adjustment: float = 1.2,\n    extra_gas: int = 5000,\n) -> Dict[str, Any]:\n    '''Simulate an unsigned Tx to estimate gas, then update fee and gas_limit.'''\n    if gas_price <= 0:\n        raise ValueError('gas_price must be positive')\n\n    tx_b64 = base64.b64encode(unsigned_tx_bytes).decode()\n    payload = {'tx_bytes': tx_b64}\n\n    try:\n        async with httpx.AsyncClient(base_url=BASE_URL, timeout=20.0) as client:\n            resp = await client.post('/cosmos/tx/v1beta1/simulate', json=payload)\n    except httpx.RequestError as e:\n        raise RuntimeError(f'Network error while simulating transaction: {e}') from e\n\n    if resp.status_code != 200:\n        raise ValueError(f'Simulation failed: HTTP {resp.status_code} {resp.text}')\n\n    data = resp.json()\n    gas_info = data.get('gas_info') or {}\n    gas_used_str = gas_info.get('gas_used') or '0'\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError:\n        raise ValueError(f'Invalid gas_used value in simulation response: {gas_used_str}')\n\n    # Apply safety margin\n    gas_limit = int(gas_used * gas_adjustment) + int(extra_gas)\n    if gas_limit <= 0:\n        raise ValueError('Computed gas_limit must be positive')\n\n    fee_amount = int(gas_limit * gas_price)\n    if fee_amount <= 0:\n        raise ValueError('Computed fee_amount must be positive')\n\n    # Decode, update AuthInfo.fee, and re-encode the Tx\n    tx = cosmos_tx.Tx()\n    tx.ParseFromString(unsigned_tx_bytes)\n\n    tx.auth_info.fee.gas_limit = gas_limit\n\n    if tx.auth_info.fee.amount:\n        tx.auth_info.fee.amount[0].denom = fee_denom\n        tx.auth_info.fee.amount[0].amount = str(fee_amount)\n    else:\n        coin = cosmos_coin.Coin(denom=fee_denom, amount=str(fee_amount))\n        tx.auth_info.fee.amount.extend([coin])\n\n    updated_unsigned_tx_bytes = tx.SerializeToString()\n    updated_tx_b64 = base64.b64encode(updated_unsigned_tx_bytes).decode()\n    body_bytes = tx.body.SerializeToString()\n    auth_info_bytes = tx.auth_info.SerializeToString()\n\n    return {\n        'gas_used': gas_used,\n        'gas_limit': gas_limit,\n        'fee_amount': fee_amount,\n        'unsigned_tx_bytes': updated_unsigned_tx_bytes,\n        'unsigned_tx_b64': updated_tx_b64,\n        'body_bytes': body_bytes,\n        'auth_info_bytes': auth_info_bytes,\n    }\n",
            "usage": "sim_result = await lcd_simulate_tx(tx_data['unsigned_tx_bytes'], gas_price=tx_data['gas_price'], fee_denom=tx_data['fee_denom'])"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Step 7 signs the updated instantiate Tx using a backend-held secp256k1 key, producing final tx_bytes ready to broadcast.",
            "code": "import base64\nfrom hashlib import sha256\nfrom typing import Any, Dict\n\nfrom ecdsa import SECP256k1, SigningKey, util as ecdsa_util\nfrom google.protobuf.any_pb2 import Any as ProtoAny\nfrom cosmos.tx.v1beta1 import tx_pb2 as cosmos_tx\nfrom cosmos.crypto.secp256k1 import keys_pb2 as secp256k1_keys\n\n\ndef bff_sign_instantiate_tx(\n    body_bytes: bytes,\n    auth_info_bytes: bytes,\n    account_number: int,\n    chain_id: str,\n    privkey_hex: str,\n    public_key_bytes: bytes,\n) -> Dict[str, Any]:\n    '''Sign the instantiate Tx using a local secp256k1 private key.'''\n    if not privkey_hex:\n        raise ValueError('privkey_hex must be provided')\n\n    # Decode TxBody and AuthInfo\n    body = cosmos_tx.TxBody()\n    auth_info = cosmos_tx.AuthInfo()\n    try:\n        body.ParseFromString(body_bytes)\n        auth_info.ParseFromString(auth_info_bytes)\n    except Exception as e:\n        raise ValueError(f'Failed to parse TxBody/AuthInfo: {e}') from e\n\n    if not auth_info.signer_infos:\n        raise ValueError('AuthInfo.signer_infos is empty; cannot attach signer')\n\n    # Attach the public key to the first signer\n    pubkey = secp256k1_keys.PubKey(key=public_key_bytes)\n    pubkey_any = ProtoAny(type_url='/cosmos.crypto.secp256k1.PubKey', value=pubkey.SerializeToString())\n    auth_info.signer_infos[0].public_key.CopyFrom(pubkey_any)\n\n    # Re-serialize AuthInfo now that it includes the public key\n    auth_info_bytes = auth_info.SerializeToString()\n\n    # Build SignDoc\n    sign_doc = cosmos_tx.SignDoc(\n        body_bytes=body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n\n    sign_bytes = sign_doc.SerializeToString()\n    digest = sha256(sign_bytes).digest()\n\n    try:\n        sk = SigningKey.from_string(bytes.fromhex(privkey_hex), curve=SECP256k1)\n    except Exception as e:\n        raise ValueError(f'Invalid privkey_hex: {e}') from e\n\n    signature = sk.sign_digest(digest, sigencode=ecdsa_util.sigencode_string_canonize)\n\n    tx = cosmos_tx.Tx(body=body, auth_info=auth_info, signatures=[signature])\n    tx_bytes = tx.SerializeToString()\n    tx_b64 = base64.b64encode(tx_bytes).decode()\n\n    return {\n        'tx_bytes': tx_bytes,\n        'tx_b64': tx_b64,\n    }\n",
            "usage": "signed = bff_sign_instantiate_tx(sim_result['body_bytes'], sim_result['auth_info_bytes'], account_number, chain_id, privkey_hex, public_key_bytes)\nfinal_tx_b64 = signed['tx_b64']"
        },
        {
            "step": 8,
            "label": "backend",
            "introduction": "Step 8 broadcasts the signed instantiate Tx to Juno via /cosmos/tx/v1beta1/txs in BROADCAST_MODE_BLOCK and returns the tx_response.",
            "code": "import httpx\nfrom typing import Any, Dict\n\n\nBASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def lcd_broadcast_tx(tx_b64: str, mode: str = 'BROADCAST_MODE_BLOCK') -> Dict[str, Any]:\n    '''Broadcast a signed transaction to Juno and return the tx_response.'''\n    payload = {'tx_bytes': tx_b64, 'mode': mode}\n\n    try:\n        async with httpx.AsyncClient(base_url=BASE_URL, timeout=30.0) as client:\n            resp = await client.post('/cosmos/tx/v1beta1/txs', json=payload)\n    except httpx.RequestError as e:\n        raise RuntimeError(f'Network error while broadcasting transaction: {e}') from e\n\n    if resp.status_code != 200:\n        raise ValueError(f'Broadcast failed: HTTP {resp.status_code} {resp.text}')\n\n    data = resp.json()\n    tx_response = data.get('tx_response') or {}\n\n    if not tx_response:\n        raise ValueError('LCD broadcast response did not contain a tx_response field')\n\n    return tx_response\n",
            "usage": "tx_response = await lcd_broadcast_tx(signed['tx_b64'])\ntxhash = tx_response.get('txhash')\ncode = tx_response.get('code')"
        },
        {
            "step": 9,
            "label": "backend",
            "introduction": "Step 9, after confirming tx_response.code == 0, parses logs/events (or refetches via /cosmos/tx/v1beta1/txs/{txhash}) to extract and return the newly instantiated contract address.",
            "code": "from typing import Any, Dict, Optional\n\nimport httpx\n\n\nBASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def lcd_parse_instantiate_events(txhash: str, tx_response: Optional[Dict[str, Any]] = None) -> str:\n    '''Extract the instantiated contract address from tx logs/events.'''\n    # If a tx_response is provided, ensure the transaction succeeded\n    if tx_response is not None:\n        code_val = tx_response.get('code')\n        try:\n            code_int = int(code_val)\n        except (TypeError, ValueError):\n            code_int = None\n        if code_int not in (None, 0):\n            raise ValueError(f'Transaction {txhash} failed with non-zero code {code_int}')\n\n    if not tx_response or not tx_response.get('logs'):\n        # Fetch full tx by hash if we do not have logs yet\n        try:\n            async with httpx.AsyncClient(base_url=BASE_URL, timeout=20.0) as client:\n                resp = await client.get(f'/cosmos/tx/v1beta1/txs/{txhash}')\n        except httpx.RequestError as e:\n            raise RuntimeError(f'Network error while fetching tx by hash {txhash}: {e}') from e\n\n        if resp.status_code != 200:\n            raise ValueError(f'Failed to fetch tx {txhash}: HTTP {resp.status_code} {resp.text}')\n\n        data = resp.json()\n        tx_response = data.get('tx_response') or {}\n        if not tx_response:\n            raise ValueError(f'LCD response for tx {txhash} did not contain tx_response')\n\n    logs = tx_response.get('logs') or []\n\n    for log in logs:\n        events = log.get('events') or []\n        for event in events:\n            ev_type = event.get('type')\n            if ev_type not in ('instantiate', 'wasm'):\n                continue\n            for attr in event.get('attributes') or []:\n                key = attr.get('key')\n                value = attr.get('value')\n                if key in ('_contract_address', 'contract_address') and value:\n                    return value\n\n    raise ValueError('Could not find instantiated contract address in tx events')\n",
            "usage": "contract_address = await lcd_parse_instantiate_events(txhash, tx_response)\n# persist contract_address for later use"
        },
        {
            "step": 10,
            "label": "backend",
            "introduction": "Step 10 verifies on-chain that the new contract exists and that its code_id and creator match the expected values using /cosmwasm/wasm/v1/contract/{contract_address}.",
            "code": "from typing import Any, Dict\n\nimport httpx\n\n\nBASE_URL = 'https://lcd-archive.junonetwork.io'\n\n\nasync def lcd_verify_contract_info(contract_address: str, expected_code_id: int, expected_creator: str) -> Dict[str, Any]:\n    '''Verify that a contract exists on-chain and matches the expected code id and creator.'''\n    try:\n        async with httpx.AsyncClient(base_url=BASE_URL, timeout=20.0) as client:\n            resp = await client.get(f'/cosmwasm/wasm/v1/contract/{contract_address}')\n    except httpx.RequestError as e:\n        raise RuntimeError(f'Network error while fetching contract info: {e}') from e\n\n    if resp.status_code != 200:\n        raise ValueError(f'Failed to fetch contract info: HTTP {resp.status_code} {resp.text}')\n\n    data = resp.json()\n    contract_info = data.get('contract_info') or {}\n\n    if not contract_info:\n        raise ValueError('LCD response did not contain contract_info')\n\n    code_id_on_chain = str(contract_info.get('code_id', '')).strip()\n    expected_code_id_str = str(expected_code_id)\n    if code_id_on_chain != expected_code_id_str:\n        raise ValueError(f'Contract code_id mismatch: on-chain {code_id_on_chain}, expected {expected_code_id_str}')\n\n    creator_on_chain = contract_info.get('creator')\n    if creator_on_chain != expected_creator:\n        raise ValueError(f'Contract creator mismatch: on-chain {creator_on_chain}, expected {expected_creator}')\n\n    return contract_info\n",
            "usage": "contract_info = await lcd_verify_contract_info(contract_address, expected_code_id=13, expected_creator=sender_address)"
        }
    ]
}