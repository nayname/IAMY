{
    "label": "upload",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Read and validate the local CosmWasm artifact (artifacts/CONTRACT_NAME.wasm). Ensure the file exists, is non-empty, and starts with the correct wasm magic bytes.",
            "code": "import os\nfrom pathlib import Path\n\nWASM_MAGIC = b\"\\x00asm\"  # 0x00 0x61 0x73 0x6d\n\nclass WasmArtifactError(Exception):\n    \"\"\"Raised when the wasm artifact is missing or invalid.\"\"\"\n\n\ndef read_and_validate_wasm_artifact(contract_name: str, artifacts_dir: str = \"artifacts\") -> bytes:\n    \"\"\"Read artifacts/CONTRACT_NAME.wasm and validate it is a proper wasm binary.\n\n    :param contract_name: Logical contract name (without .wasm extension).\n    :param artifacts_dir: Directory where wasm artifacts are stored.\n    :return: Raw wasm file bytes.\n    :raises WasmArtifactError: If file is missing, empty, or invalid.\n    \"\"\"\n    # Build path like artifacts/CONTRACT_NAME.wasm\n    wasm_path = Path(artifacts_dir) / f\"{contract_name}.wasm\"\n\n    if not wasm_path.exists() or not wasm_path.is_file():\n        raise WasmArtifactError(f\"Wasm artifact not found at {wasm_path!s}\")\n\n    try:\n        wasm_bytes = wasm_path.read_bytes()\n    except OSError as exc:\n        raise WasmArtifactError(f\"Failed to read wasm artifact: {exc}\") from exc\n\n    if not wasm_bytes:\n        raise WasmArtifactError(f\"Wasm artifact {wasm_path!s} is empty\")\n\n    # Validate magic bytes (first 4 bytes of a wasm module)\n    if wasm_bytes[:4] != WASM_MAGIC:\n        raise WasmArtifactError(\n            f\"Invalid wasm artifact {wasm_path!s}: missing magic bytes 0x00 0x61 0x73 0x6d\"\n        )\n\n    return wasm_bytes\n",
            "usage": "from backend.wasm_uploader import read_and_validate_wasm_artifact\n\nwasm_bytes = read_and_validate_wasm_artifact(contract_name=\"CONTRACT_NAME\")"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Compute and cache a SHA-256 checksum for the wasm artifact so it can be compared with on-chain code_info.data_hash later.",
            "code": "import hashlib\nfrom dataclasses import dataclass\n\n@dataclass\nclass WasmChecksum:\n    \"\"\"Holds both raw bytes and hex representation of the wasm checksum.\"\"\"\n    digest: bytes\n    hex: str\n\n\ndef compute_wasm_checksum(wasm_bytes: bytes) -> WasmChecksum:\n    \"\"\"Compute SHA-256 checksum for the wasm artifact.\n\n    :param wasm_bytes: Raw wasm bytes from the artifact.\n    :return: WasmChecksum containing digest bytes and hex string.\n    \"\"\"\n    if not isinstance(wasm_bytes, (bytes, bytearray)) or not wasm_bytes:\n        raise ValueError(\"wasm_bytes must be non-empty bytes\")\n\n    sha = hashlib.sha256()\n    sha.update(wasm_bytes)\n    digest = sha.digest()\n    hex_digest = sha.hexdigest()\n    return WasmChecksum(digest=digest, hex=hex_digest)\n",
            "usage": "from backend.wasm_uploader import compute_wasm_checksum\n\nchecksum = compute_wasm_checksum(wasm_bytes)\nprint(\"Local wasm SHA-256:\", checksum.hex)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Query the Juno LCD to discover the chain-id and to fetch the account_number and sequence for the given bech32 address.",
            "code": "import base64\nfrom dataclasses import dataclass\n\nimport httpx\n\nfrom cosmpy.protos.cosmos.auth.v1beta1 import auth_pb2\n\nLCD_URL = \"https://lcd-archive.junonetwork.io\"\n\n\n@dataclass\nclass ChainAccountInfo:\n    chain_id: str\n    account_number: int\n    sequence: int\n\n\nclass ChainQueryError(Exception):\n    \"\"\"Raised when querying chain/account info fails.\"\"\"\n\n\nasync def get_chain_and_account_info(address: str, lcd_url: str = LCD_URL) -> ChainAccountInfo:\n    \"\"\"Fetch chain-id and account metadata for the given Juno address.\n\n    This function performs two LCD calls:\n      1. /cosmos/base/tendermint/v1beta1/node_info -> chain-id (network)\n      2. /cosmos/auth/v1beta1/accounts/{address} -> account_number & sequence\n\n    :param address: Bech32 Juno address.\n    :param lcd_url: Base LCD endpoint.\n    :return: ChainAccountInfo with chain_id, account_number, sequence.\n    :raises ChainQueryError: On HTTP or decoding errors.\n    \"\"\"\n    async with httpx.AsyncClient(timeout=10) as client:\n        # (a) Fetch node_info to get chain-id\n        try:\n            node_resp = await client.get(f\"{lcd_url}/cosmos/base/tendermint/v1beta1/node_info\")\n            node_resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise ChainQueryError(f\"Failed to fetch node_info: {exc}\") from exc\n\n        node_data = node_resp.json()\n        try:\n            chain_id = node_data[\"default_node_info\"][\"network\"]\n        except (KeyError, TypeError) as exc:\n            raise ChainQueryError(f\"Unexpected node_info format: {node_data}\") from exc\n\n        # (b) Fetch account data to get account_number & sequence\n        try:\n            acct_resp = await client.get(f\"{lcd_url}/cosmos/auth/v1beta1/accounts/{address}\")\n            acct_resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise ChainQueryError(f\"Failed to fetch account info: {exc}\") from exc\n\n        acct_data = acct_resp.json()\n        try:\n            any_account = acct_data[\"account\"]\n            type_url = any_account[\"type_url\"]\n            value_b64 = any_account[\"value\"]\n        except (KeyError, TypeError) as exc:\n            raise ChainQueryError(f\"Unexpected account response format: {acct_data}\") from exc\n\n        # Decode the embedded BaseAccount proto from the Any.value field\n        try:\n            raw_bytes = base64.b64decode(value_b64)\n            base_account = auth_pb2.BaseAccount()\n            base_account.ParseFromString(raw_bytes)\n        except Exception as exc:  # protobuf or base64 errors\n            raise ChainQueryError(f\"Failed to decode BaseAccount from Any.value: {exc}\") from exc\n\n        return ChainAccountInfo(\n            chain_id=chain_id,\n            account_number=int(base_account.account_number),\n            sequence=int(base_account.sequence),\n        )\n",
            "usage": "from backend.wasm_uploader import get_chain_and_account_info\n\n# Inside an async context (e.g. FastAPI endpoint)\nchain_acct = await get_chain_and_account_info(\"juno1...useraddress...\")\nprint(chain_acct.chain_id, chain_acct.account_number, chain_acct.sequence)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Construct an unsigned protobuf Tx containing a single CosmWasm MsgStoreCode message with the wasm bytecode.",
            "code": "import base64\nfrom typing import Tuple\n\nfrom google.protobuf.any_pb2 import Any\n\nfrom cosmpy.protos.cosmwasm.wasm.v1.tx_pb2 import MsgStoreCode\nfrom cosmpy.protos.cosmos.tx.v1beta1 import tx_pb2 as cosmos_tx_pb2\nfrom cosmpy.protos.cosmos.base.v1beta1 import coin_pb2\n\n\ndef construct_store_code_tx(\n    sender_address: str,\n    wasm_bytes: bytes,\n    gas_limit: int = 2_000_000,\n    fee_amount: str = \"500000\",\n    fee_denom: str = \"ujuno\",\n    memo: str = \"store wasm code\",\n) -> Tuple[cosmos_tx_pb2.Tx, str]:\n    \"\"\"Construct an unsigned Tx with a CosmWasm MsgStoreCode message.\n\n    :param sender_address: Bech32 address paying for the upload.\n    :param wasm_bytes: Raw wasm bytes of the contract.\n    :param gas_limit: Placeholder gas limit to be refined via simulation.\n    :param fee_amount: Placeholder fee amount in the given denom.\n    :param fee_denom: Fee denomination (Juno mainnet uses 'ujuno').\n    :param memo: Optional memo for the tx.\n    :return: (Tx protobuf object, base64-encoded tx bytes).\n    \"\"\"\n    if not wasm_bytes:\n        raise ValueError(\"wasm_bytes must be non-empty\")\n\n    # Build MsgStoreCode\n    msg = MsgStoreCode(\n        sender=sender_address,\n        wasm_byte_code=wasm_bytes,\n    )\n\n    msg_any = Any(\n        type_url=\"/cosmwasm.wasm.v1.MsgStoreCode\",\n        value=msg.SerializeToString(),\n    )\n\n    # Tx body with a single message\n    tx_body = cosmos_tx_pb2.TxBody(\n        messages=[msg_any],\n        memo=memo,\n    )\n\n    # Placeholder fee; gas_limit will be updated after simulation\n    fee_coin = coin_pb2.Coin(denom=fee_denom, amount=fee_amount)\n    fee = cosmos_tx_pb2.Fee(\n        amount=[fee_coin],\n        gas_limit=gas_limit,\n    )\n\n    # Leave signer_infos empty for now; this is an unsigned tx\n    auth_info = cosmos_tx_pb2.AuthInfo(fee=fee)\n\n    tx = cosmos_tx_pb2.Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[],  # will be filled after signing\n    )\n\n    tx_bytes = tx.SerializeToString()\n    tx_bytes_b64 = base64.b64encode(tx_bytes).decode()\n\n    return tx, tx_bytes_b64\n",
            "usage": "from backend.wasm_uploader import construct_store_code_tx\n\nunsigned_tx, unsigned_b64 = construct_store_code_tx(\n    sender_address=\"juno1...useraddress...\",\n    wasm_bytes=wasm_bytes,\n)\nprint(\"Unsigned tx (base64):\", unsigned_b64)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Simulate the unsigned store-code transaction via the LCD to estimate gas, then update the tx's gas_limit and fee based on the result.",
            "code": "import base64\nimport math\nfrom decimal import Decimal, ROUND_UP\nfrom typing import Tuple\n\nimport httpx\n\nfrom cosmpy.protos.cosmos.tx.v1beta1 import tx_pb2 as cosmos_tx_pb2\nfrom cosmpy.protos.cosmos.base.v1beta1 import coin_pb2\n\nLCD_URL = \"https://lcd-archive.junonetwork.io\"\n\n\nclass SimulationError(Exception):\n    \"\"\"Raised when transaction simulation fails.\"\"\"\n\n\nasync def simulate_and_update_fee(\n    tx: cosmos_tx_pb2.Tx,\n    lcd_url: str = LCD_URL,\n    gas_adjustment: float = 1.3,\n    gas_price_ujuno: Decimal = Decimal(\"0.075\"),  # 0.075 ujuno per gas (example)\n    fee_denom: str = \"ujuno\",\n) -> Tuple[cosmos_tx_pb2.Tx, int, int]:\n    \"\"\"Simulate the Tx to estimate gas and update fee/gas_limit accordingly.\n\n    :param tx: Unsigned Tx protobuf to simulate.\n    :param lcd_url: Base LCD URL.\n    :param gas_adjustment: Safety margin multiplier over gas_used.\n    :param gas_price_ujuno: Gas price (ujuno per unit gas) used to compute fee.\n    :param fee_denom: Denom used for paying fees.\n    :return: (updated_tx, gas_used, gas_limit).\n    :raises SimulationError: On HTTP or response errors.\n    \"\"\"\n    tx_bytes = tx.SerializeToString()\n    tx_b64 = base64.b64encode(tx_bytes).decode()\n\n    payload = {\"tx_bytes\": tx_b64}\n\n    async with httpx.AsyncClient(timeout=15) as client:\n        try:\n            resp = await client.post(f\"{lcd_url}/cosmos/tx/v1beta1/simulate\", json=payload)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise SimulationError(f\"Simulation HTTP error: {exc}\") from exc\n\n    data = resp.json()\n    try:\n        gas_used_str = data[\"gas_info\"][\"gas_used\"]\n        gas_used = int(gas_used_str)\n    except (KeyError, TypeError, ValueError) as exc:\n        raise SimulationError(f\"Unexpected simulate response: {data}\") from exc\n\n    # Apply safety margin\n    gas_limit = math.ceil(gas_used * gas_adjustment)\n\n    # Compute fee = gas_limit * gas_price_ujuno (rounded up to integer ujuno)\n    fee_amount_int = int((Decimal(gas_limit) * gas_price_ujuno).to_integral_value(rounding=ROUND_UP))\n    fee_coin = coin_pb2.Coin(denom=fee_denom, amount=str(fee_amount_int))\n\n    # Update tx.auth_info.fee\n    if not tx.auth_info.fee:\n        tx.auth_info.fee.CopyFrom(cosmos_tx_pb2.Fee())\n\n    tx.auth_info.fee.gas_limit = gas_limit\n    # Clear any previous amount entries and set the new one\n    tx.auth_info.fee.amount.clear()\n    tx.auth_info.fee.amount.append(fee_coin)\n\n    return tx, gas_used, gas_limit\n",
            "usage": "from backend.wasm_uploader import simulate_and_update_fee\n\n# Inside an async context\nupdated_tx, gas_used, gas_limit = await simulate_and_update_fee(unsigned_tx)\nprint(\"Simulated gas_used=\", gas_used, \"gas_limit=\", gas_limit)"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Sign the store-code transaction using backend-managed keys, populating signer_infos and signatures based on the account_number, sequence, and chain-id.",
            "code": "import base64\n\nfrom google.protobuf.any_pb2 import Any\n\nfrom cosmpy.crypto.keypairs import PrivateKey\nfrom cosmpy.protos.cosmos.tx.v1beta1 import tx_pb2 as cosmos_tx_pb2\nfrom cosmpy.protos.cosmos.tx.signing.v1beta1 import signing_pb2\nfrom cosmpy.protos.cosmos.crypto.secp256k1 import keys_pb2 as secp256k1_keys_pb2\n\n\nclass SigningError(Exception):\n    \"\"\"Raised when signing the transaction fails.\"\"\"\n\n\ndef sign_store_code_tx(\n    tx: cosmos_tx_pb2.Tx,\n    chain_id: str,\n    account_number: int,\n    sequence: int,\n    private_key_hex: str,\n) -> str:\n    \"\"\"Sign the MsgStoreCode Tx using a secp256k1 private key.\n\n    :param tx: Tx with body and fee populated (auth_info.signer_infos may be empty).\n    :param chain_id: Chain-id from node_info (e.g. 'juno-1').\n    :param account_number: Account number of the sender.\n    :param sequence: Current sequence of the sender.\n    :param private_key_hex: Hex-encoded secp256k1 private key.\n    :return: Base64-encoded signed tx bytes ready for broadcast.\n    :raises SigningError: If signing fails.\n    \"\"\"\n    try:\n        priv_key_bytes = bytes.fromhex(private_key_hex)\n        priv_key = PrivateKey(priv_key_bytes)\n        pubkey_bytes = priv_key.public_key.bytes\n    except Exception as exc:\n        raise SigningError(f\"Invalid private key: {exc}\") from exc\n\n    # Build protobuf PubKey and wrap in Any\n    proto_pubkey = secp256k1_keys_pb2.PubKey(key=pubkey_bytes)\n    pubkey_any = Any(\n        type_url=\"/cosmos.crypto.secp256k1.PubKey\",\n        value=proto_pubkey.SerializeToString(),\n    )\n\n    # Prepare signer info with SIGN_MODE_DIRECT\n    mode_info = cosmos_tx_pb2.ModeInfo(\n        single=cosmos_tx_pb2.ModeInfo.Single(mode=signing_pb2.SIGN_MODE_DIRECT)\n    )\n\n    signer_info = cosmos_tx_pb2.SignerInfo(\n        public_key=pubkey_any,\n        mode_info=mode_info,\n        sequence=int(sequence),\n    )\n\n    # Attach signer info to auth_info\n    if not tx.auth_info:\n        tx.auth_info.CopyFrom(cosmos_tx_pb2.AuthInfo())\n\n    tx.auth_info.signer_infos.clear()\n    tx.auth_info.signer_infos.append(signer_info)\n\n    # Build SignDoc\n    sign_doc = cosmos_tx_pb2.SignDoc(\n        body_bytes=tx.body.SerializeToString(),\n        auth_info_bytes=tx.auth_info.SerializeToString(),\n        chain_id=chain_id,\n        account_number=int(account_number),\n    )\n\n    sign_doc_bytes = sign_doc.SerializeToString()\n\n    try:\n        signature = priv_key.sign(sign_doc_bytes)\n    except Exception as exc:\n        raise SigningError(f\"Failed to sign SignDoc: {exc}\") from exc\n\n    # Attach signature\n    tx.signatures.clear()\n    tx.signatures.append(signature)\n\n    # Serialize final signed tx\n    tx_bytes = tx.SerializeToString()\n    return base64.b64encode(tx_bytes).decode()\n",
            "usage": "from backend.wasm_uploader import sign_store_code_tx\n\nsigned_b64 = sign_store_code_tx(\n    tx=updated_tx,\n    chain_id=chain_acct.chain_id,\n    account_number=chain_acct.account_number,\n    sequence=chain_acct.sequence,\n    private_key_hex=\"<YOUR_PRIVATE_KEY_HEX>\",\n)\nprint(\"Signed tx (base64):\", signed_b64)"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Broadcast the signed transaction to Juno via the LCD using BROADCAST_MODE_BLOCK and capture the returned txhash and code.",
            "code": "import httpx\n\nLCD_URL = \"https://lcd-archive.junonetwork.io\"\n\n\nclass BroadcastError(Exception):\n    \"\"\"Raised when broadcasting the transaction fails.\"\"\"\n\n\nasync def broadcast_signed_tx(\n    signed_tx_base64: str,\n    lcd_url: str = LCD_URL,\n    mode: str = \"BROADCAST_MODE_BLOCK\",\n) -> dict:\n    \"\"\"Broadcast the signed tx using the /cosmos/tx/v1beta1/txs LCD endpoint.\n\n    :param signed_tx_base64: Base64-encoded signed tx bytes.\n    :param lcd_url: Base LCD base URL.\n    :param mode: Broadcast mode (BLOCK, SYNC, or ASYNC).\n    :return: tx_response JSON dict containing txhash, code, raw_log, etc.\n    :raises BroadcastError: If the HTTP call fails or response is malformed.\n    \"\"\"\n    payload = {\n        \"tx_bytes\": signed_tx_base64,\n        \"mode\": mode,\n    }\n\n    async with httpx.AsyncClient(timeout=30) as client:\n        try:\n            resp = await client.post(f\"{lcd_url}/cosmos/tx/v1beta1/txs\", json=payload)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise BroadcastError(f\"Broadcast HTTP error: {exc}\") from exc\n\n    data = resp.json()\n    try:\n        tx_response = data[\"tx_response\"]\n        # Accessing these is safe if present; otherwise KeyError will be raised\n        _ = tx_response[\"txhash\"]\n        _ = tx_response[\"code\"]\n    except (KeyError, TypeError) as exc:\n        raise BroadcastError(f\"Unexpected broadcast response format: {data}\") from exc\n\n    return tx_response\n",
            "usage": "from backend.wasm_uploader import broadcast_signed_tx\n\n# Inside an async context\ntx_response = await broadcast_signed_tx(signed_b64)\nprint(\"txhash=\", tx_response[\"txhash\"], \"code=\", tx_response[\"code\"])"
        },
        {
            "step": 8,
            "label": "backend",
            "introduction": "Fetch the transaction by hash (if needed) and parse its events to extract the CosmWasm store-code code_id.",
            "code": "from typing import Optional\n\nimport httpx\n\nLCD_URL = \"https://lcd-archive.junonetwork.io\"\n\n\nclass CodeIdNotFoundError(Exception):\n    \"\"\"Raised when a code_id cannot be located in tx events.\"\"\"\n\n\nasync def fetch_tx_and_extract_code_id(txhash: str, lcd_url: str = LCD_URL) -> str:\n    \"\"\"Fetch the tx by hash and scan events for the stored code_id.\n\n    This scans tx_response.logs[].events[] for an event of type 'store_code' or\n    'wasm' and looks for an attribute with key 'code_id'.\n\n    :param txhash: Hex-encoded transaction hash.\n    :param lcd_url: Base LCD URL.\n    :return: Extracted code_id as a string.\n    :raises CodeIdNotFoundError: If no code_id attribute is found.\n    :raises httpx.HTTPError: On network/HTTP failures.\n    \"\"\"\n    async with httpx.AsyncClient(timeout=15) as client:\n        resp = await client.get(f\"{lcd_url}/cosmos/tx/v1beta1/txs/{txhash}\")\n        resp.raise_for_status()\n\n    data = resp.json()\n    tx_response = data.get(\"tx_response\", {})\n    logs = tx_response.get(\"logs\", [])\n\n    # Iterate all events looking for a code_id attribute\n    for log in logs:\n        for event in log.get(\"events\", []):\n            ev_type = event.get(\"type\", \"\")\n            if ev_type not in (\"store_code\", \"wasm\"):\n                continue\n            for attr in event.get(\"attributes\", []):\n                # Depending on the node, key/value may be plain text or base64. Juno LCD\n                # returns them as plain text according to the provided schema.\n                if attr.get(\"key\") == \"code_id\":\n                    code_id = attr.get(\"value\")\n                    if code_id:\n                        return code_id\n\n    raise CodeIdNotFoundError(\n        f\"No code_id attribute found in tx events for txhash={txhash}. Response: {tx_response}\"\n    )\n",
            "usage": "from backend.wasm_uploader import fetch_tx_and_extract_code_id\n\n# Inside an async context, after broadcast\nif tx_response[\"code\"] == 0:\n    code_id = await fetch_tx_and_extract_code_id(tx_response[\"txhash\"])\n    print(\"Stored code_id=\", code_id)\nelse:\n    print(\"Tx failed with code\", tx_response[\"code\"], \"log:\", tx_response.get(\"raw_log\"))"
        },
        {
            "step": 9,
            "label": "backend",
            "introduction": "Query the uploaded code by code_id and verify that the on-chain data_hash matches the locally computed wasm checksum.",
            "code": "import base64\n\nimport httpx\n\nLCD_URL = \"https://lcd-archive.junonetwork.io\"\n\n\nclass CodeHashMismatchError(Exception):\n    \"\"\"Raised when the on-chain code hash does not match the local checksum.\"\"\"\n\n\nasync def verify_uploaded_code_hash(\n    code_id: str,\n    local_checksum_bytes: bytes,\n    lcd_url: str = LCD_URL,\n) -> bool:\n    \"\"\"Verify that on-chain code_info.data_hash matches the local wasm checksum.\n\n    :param code_id: Code ID returned by the store-code tx events.\n    :param local_checksum_bytes: SHA-256 digest bytes computed from the local wasm.\n    :param lcd_url: Base LCD URL.\n    :return: True if hashes match.\n    :raises CodeHashMismatchError: If the hashes differ.\n    :raises httpx.HTTPError: On network/HTTP failures.\n    \"\"\"\n    if not local_checksum_bytes:\n        raise ValueError(\"local_checksum_bytes must be non-empty\")\n\n    async with httpx.AsyncClient(timeout=15) as client:\n        resp = await client.get(f\"{lcd_url}/cosmwasm/wasm/v1/code/{code_id}\")\n        resp.raise_for_status()\n\n    data = resp.json()\n    try:\n        code_info = data[\"code_info\"]\n        data_hash_b64 = code_info[\"data_hash\"]\n    except (KeyError, TypeError) as exc:\n        raise CodeHashMismatchError(f\"Unexpected code info response: {data}\") from exc\n\n    try:\n        onchain_hash = base64.b64decode(data_hash_b64)\n    except Exception as exc:\n        raise CodeHashMismatchError(f\"Failed to decode on-chain data_hash: {exc}\") from exc\n\n    if onchain_hash != local_checksum_bytes:\n        raise CodeHashMismatchError(\n            f\"On-chain data_hash ({onchain_hash.hex()}) does not match local checksum ({local_checksum_bytes.hex()})\"\n        )\n\n    return True\n",
            "usage": "from backend.wasm_uploader import verify_uploaded_code_hash\n\n# Inside an async context\nok = await verify_uploaded_code_hash(code_id, checksum.digest)\nprint(\"Code hash verification passed:\", ok)"
        }
    ]
}