{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a Python helper to validate that a provided CONTRACT_ADDRESS is a valid Juno bech32 address before any LCD queries are made.",
            "code": "from bech32 import bech32_decode\n\nJUNO_HRP = \"juno\"\n\n\nclass InvalidContractAddress(Exception):\n    \"\"\"Raised when a provided contract address is not a valid Juno bech32 address.\"\"\"\n    pass\n\n\ndef validate_contract_address(contract_address: str) -> str:\n    \"\"\"Validate that the given address is a non-empty Juno bech32 address.\n\n    Returns the address if valid; raises InvalidContractAddress otherwise.\n    \"\"\"\n    if not isinstance(contract_address, str) or not contract_address:\n        raise InvalidContractAddress(\"Contract address must be a non-empty string.\")\n\n    # bech32_decode returns (hrp, data). For a valid Juno address, hrp should be 'juno'.\n    hrp, data = bech32_decode(contract_address)\n    if hrp != JUNO_HRP or data is None:\n        raise InvalidContractAddress(\n            f\"Invalid Juno bech32 address: {contract_address}\"\n        )\n\n    return contract_address\n",
            "usage": "validated = validate_contract_address(\"juno1yourcontractaddresshere...\")"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 declares a small PaginationState dataclass and an initializer to manage PAGE_LIMIT, aggregated token IDs, and the start_after cursor.",
            "code": "from dataclasses import dataclass, field\nfrom typing import List, Optional\n\nPAGE_LIMIT_DEFAULT = 100\n\n\n@dataclass\nclass PaginationState:\n    \"\"\"Holds CW721 all_tokens pagination state.\"\"\"\n\n    page_limit: int = PAGE_LIMIT_DEFAULT\n    start_after: Optional[str] = None\n    token_ids: List[str] = field(default_factory=list)\n\n\ndef initialize_pagination_state(page_limit: int = PAGE_LIMIT_DEFAULT) -> PaginationState:\n    \"\"\"Initialize pagination with a configurable page size.\n\n    :param page_limit: Number of token IDs to request per page.\n    :raises ValueError: If page_limit is not a positive integer.\n    \"\"\"\n    if not isinstance(page_limit, int) or page_limit <= 0:\n        raise ValueError(\"page_limit must be a positive integer.\")\n\n    return PaginationState(page_limit=page_limit)\n",
            "usage": "state = initialize_pagination_state(page_limit=100)\n# state.page_limit == 100, state.start_after is None, state.token_ids is []"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 provides a function to construct the CW721 all_tokens query JSON, adding start_after only for subsequent pages.",
            "code": "import json\nfrom typing import Any, Dict, Optional\n\n\ndef build_all_tokens_query_json(page_limit: int, start_after: Optional[str] = None) -> Dict[str, Any]:\n    \"\"\"Build the CW721 all_tokens query JSON structure.\n\n    Example first page: {'all_tokens': {'limit': 100}}\n    Example next page:  {'all_tokens': {'limit': 100, 'start_after': 'last_token_id'}}\n    \"\"\"\n    if not isinstance(page_limit, int) or page_limit <= 0:\n        raise ValueError(\"page_limit must be a positive integer.\")\n\n    all_tokens: Dict[str, Any] = {\"limit\": page_limit}\n    if start_after:\n        all_tokens[\"start_after\"] = start_after\n\n    return {\"all_tokens\": all_tokens}\n",
            "usage": "query_json = build_all_tokens_query_json(page_limit=state.page_limit, start_after=state.start_after)\n# For the first page, start_after is None, so the JSON is {\"all_tokens\": {\"limit\": 100}}"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 serializes the all_tokens query JSON to UTF-8 and base64-encodes it, yielding QUERY_DATA_B64 for the LCD smart query endpoint.",
            "code": "import base64\nimport json\nfrom typing import Any, Dict\n\n\ndef encode_query_to_base64(query: Dict[str, Any]) -> str:\n    \"\"\"Serialize the query JSON to UTF-8 and base64-encode it.\n\n    The returned string can be used as the {query_data} path segment in the\n    /cosmwasm/wasm/v1/contract/{address}/smart/{query_data} LCD endpoint.\n    \"\"\"\n    try:\n        # Compact JSON, keep it deterministic.\n        json_bytes = json.dumps(query, separators=(\",\", \":\"), ensure_ascii=False).encode(\"utf-8\")\n    except (TypeError, ValueError) as e:\n        raise ValueError(f\"Failed to serialize query to JSON: {e}\") from e\n\n    # urlsafe_b64encode avoids '/' and '+' which simplifies embedding in URLs.\n    encoded = base64.urlsafe_b64encode(json_bytes).decode(\"ascii\")\n    return encoded\n",
            "usage": "query_b64 = encode_query_to_base64(query_json)\n# query_b64 is your QUERY_DATA_B64 for the LCD smart query URL."
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 implements an async helper that calls the Juno LCD smart query endpoint for the all_tokens query using the prepared CONTRACT_ADDRESS and QUERY_DATA_B64.",
            "code": "import httpx\nfrom typing import Dict, Any\n\nLCD_BASE_URL = \"https://lcd-archive.junonetwork.io\"\n\n\nasync def lcd_smart_query_all_tokens(contract_address: str, query_data_b64: str, timeout: float = 10.0) -> Dict[str, Any]:\n    \"\"\"Perform an HTTP GET to the Juno LCD CosmWasm smart query endpoint.\n\n    This calls:\n      GET /cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_data_b64}\n\n    :param contract_address: Validated Juno contract address.\n    :param query_data_b64: Base64-encoded JSON query string for all_tokens.\n    :param timeout: HTTP timeout in seconds.\n    :returns: Parsed JSON response from the LCD.\n    :raises RuntimeError: On HTTP or JSON errors, or if the LCD returns a non-2xx code.\n    \"\"\"\n    url = f\"{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_data_b64}\"\n\n    try:\n        async with httpx.AsyncClient(timeout=timeout) as client:\n            response = await client.get(url)\n        response.raise_for_status()\n    except httpx.HTTPStatusError as e:\n        # The LCD returned a non-success status code.\n        raise RuntimeError(\n            f\"LCD smart query failed with status {e.response.status_code}: {e.response.text}\"\n        ) from e\n    except httpx.RequestError as e:\n        # Network or connection-level error.\n        raise RuntimeError(f\"Network error while calling LCD: {e}\") from e\n\n    try:\n        data = response.json()\n    except ValueError as e:\n        raise RuntimeError(f\"Failed to parse LCD response as JSON: {e}\") from e\n\n    if \"data\" not in data:\n        # According to the schema, the smart query result is returned under 'data' (base64-encoded).\n        raise RuntimeError(f\"LCD response missing 'data' field: {data}\")\n\n    return data\n",
            "usage": "lcd_response = await lcd_smart_query_all_tokens(contract_address=validated, query_data_b64=query_b64)\n# lcd_response is a dict containing at least a base64-encoded 'data' field."
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 decodes the base64-encoded data field from the LCD smart query response, parses it as JSON, and extracts the list of token IDs (typically under 'tokens').",
            "code": "import base64\nimport json\nfrom typing import Any, Dict, List\n\n\ndef decode_all_tokens_response(lcd_response: Dict[str, Any]) -> List[str]:\n    \"\"\"Decode the 'data' field from the LCD smart query response and extract token IDs.\n\n    The LCD response has the form: {'data': '<base64-encoded-bytes>'}.\n    Those bytes should decode to JSON like: {'tokens': ['id1', 'id2', ...]}.\n    \"\"\"\n    if \"data\" not in lcd_response:\n        raise KeyError(\"LCD response dict does not contain 'data' field.\")\n\n    b64_data = lcd_response[\"data\"]\n    if not isinstance(b64_data, str):\n        raise TypeError(\"'data' field must be a base64-encoded string.\")\n\n    try:\n        # Support both standard and URL-safe base64\n        # First try standard, then urlsafe as a fallback.\n        try:\n            raw_bytes = base64.b64decode(b64_data)\n        except Exception:\n            raw_bytes = base64.urlsafe_b64decode(b64_data)\n    except Exception as e:\n        raise ValueError(f\"Failed to base64-decode response 'data': {e}\") from e\n\n    try:\n        decoded_json = json.loads(raw_bytes.decode(\"utf-8\"))\n    except (UnicodeDecodeError, json.JSONDecodeError) as e:\n        raise ValueError(f\"Failed to decode response JSON: {e}\") from e\n\n    # For CW721 all_tokens, we expect a structure like {\"tokens\": [\"token1\", \"token2\", ...]}\n    if not isinstance(decoded_json, dict):\n        raise TypeError(f\"Decoded response JSON is not an object: {decoded_json}\")\n\n    tokens = decoded_json.get(\"tokens\")\n    if tokens is None:\n        raise KeyError(f\"Decoded response does not contain 'tokens' field: {decoded_json}\")\n\n    if not isinstance(tokens, list) or not all(isinstance(t, str) for t in tokens):\n        raise TypeError(f\"'tokens' must be a list of strings, got: {tokens}\")\n\n    return tokens\n",
            "usage": "page_token_ids = decode_all_tokens_response(lcd_response)\n# page_token_ids is a list like [\"token_id_1\", \"token_id_2\", ...]\n# You would then do: state.token_ids.extend(page_token_ids)"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Step 7 orchestrates pagination: it repeatedly builds the all_tokens query, encodes it, calls the LCD smart query, decodes token IDs, and advances start_after until the final page is reached.",
            "code": "from typing import List\n\n# This function assumes the following helpers are available in the same module\n# or imported from where you defined them:\n#   - validate_contract_address (Step 1)\n#   - initialize_pagination_state (Step 2)\n#   - build_all_tokens_query_json (Step 3)\n#   - encode_query_to_base64 (Step 4)\n#   - lcd_smart_query_all_tokens (Step 5)\n#   - decode_all_tokens_response (Step 6)\n\n\nasync def fetch_all_cw721_token_ids(contract_address: str, page_limit: int = PAGE_LIMIT_DEFAULT) -> List[str]:\n    \"\"\"Fetch all CW721 token IDs for a contract by paginating the all_tokens query.\n\n    Pagination rule:\n      * If the number of token IDs returned in a page == page_limit,\n        set start_after to the last token ID and continue.\n      * If fewer than page_limit are returned, stop (final page).\n    \"\"\"\n    # Validate the contract address before making any network calls.\n    validate_contract_address(contract_address)\n\n    state = initialize_pagination_state(page_limit=page_limit)\n\n    while True:\n        # Build the all_tokens query for the current page.\n        query_json = build_all_tokens_query_json(\n            page_limit=state.page_limit,\n            start_after=state.start_after,\n        )\n\n        # Encode query JSON to base64 for the LCD smart endpoint.\n        query_b64 = encode_query_to_base64(query_json)\n\n        # Call the LCD smart query endpoint.\n        lcd_response = await lcd_smart_query_all_tokens(\n            contract_address=contract_address,\n            query_data_b64=query_b64,\n        )\n\n        # Decode token IDs from the LCD response.\n        page_tokens = decode_all_tokens_response(lcd_response)\n\n        if not page_tokens:\n            # No results in this page; we're done.\n            break\n\n        # Aggregate token IDs.\n        state.token_ids.extend(page_tokens)\n\n        # If fewer than page_limit were returned, this is the final page.\n        if len(page_tokens) < state.page_limit:\n            break\n\n        # Otherwise, set start_after to the last token ID and fetch the next page.\n        state.start_after = page_tokens[-1]\n\n    return state.token_ids\n",
            "usage": "all_token_ids = await fetch_all_cw721_token_ids(contract_address=validated, page_limit=100)\n# all_token_ids now contains every token ID exposed by the CW721 all_tokens query."
        },
        {
            "step": 8,
            "label": "backend",
            "introduction": "Step 8 exposes a simple BFF-style HTTP endpoint (using FastAPI) that returns the complete aggregated list of CW721 token IDs for a given CONTRACT_ADDRESS.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom typing import List\n\n# Reuse helpers from previous steps:\n#   - InvalidContractAddress\n#   - fetch_all_cw721_token_ids\n#   - PAGE_LIMIT_DEFAULT\n\napp = FastAPI()\n\n\n@app.get(\"/cw721/{contract_address}/all_tokens\")\nasync def get_all_token_ids(contract_address: str, page_limit: int = PAGE_LIMIT_DEFAULT) -> dict:\n    \"\"\"HTTP endpoint that returns all CW721 token IDs for a contract.\n\n    Query params:\n      - contract_address: Juno CW721 contract address (path param).\n      - page_limit: page size used for pagination (optional, default=100).\n    \"\"\"\n    try:\n        token_ids: List[str] = await fetch_all_cw721_token_ids(\n            contract_address=contract_address,\n            page_limit=page_limit,\n        )\n    except InvalidContractAddress as e:\n        # Bad user input -> 400\n        raise HTTPException(status_code=400, detail=str(e)) from e\n    except Exception as e:\n        # Unexpected errors -> 500\n        raise HTTPException(status_code=500, detail=str(e)) from e\n\n    return {\n        \"contract_address\": contract_address,\n        \"page_limit\": page_limit,\n        \"token_ids\": token_ids,\n    }\n",
            "usage": "Frontend example (JavaScript):\n\n// Assume your Python FastAPI service is exposed under /api on the same origin.\nconst contractAddress = \"juno1yourcontractaddresshere...\";\nconst pageLimit = 100;\n\nconst res = await fetch(`/api/cw721/${contractAddress}/all_tokens?page_limit=${pageLimit}`);\nif (!res.ok) {\n  const error = await res.json().catch(() => ({}));\n  console.error('Backend error', res.status, error);\n  throw new Error('Failed to fetch CW721 token IDs');\n}\n\nconst data = await res.json();\nconsole.log('All token IDs:', data.token_ids);"
        }
    ]
}