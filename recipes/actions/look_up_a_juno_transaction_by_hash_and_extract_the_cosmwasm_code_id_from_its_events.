{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 provides a backend Python helper to validate that a transaction hash is a 64-character hexadecimal string and normalize it.",
            "code": "import re\n\n\nclass TxValidationError(ValueError):\n    \"\"\"Raised when a transaction hash fails validation.\"\"\"\n\n\ndef validate_tx_hash(tx_hash: str) -> str:\n    \"\"\"Validate that tx_hash is a 64-character hex string.\n\n    Returns the normalized (lowercase) hash or raises TxValidationError.\n    \"\"\"\n    if not isinstance(tx_hash, str):\n        raise TxValidationError(\"Transaction hash must be a string.\")\n\n    normalized = tx_hash.strip()\n\n    # Must be exactly 64 hex characters (0-9, a-f, A-F)\n    if not re.fullmatch(r\"[0-9a-fA-F]{64}\", normalized):\n        raise TxValidationError(\n            \"Invalid transaction hash format. Expected a 64-character hex string.\"\n        )\n\n    return normalized.lower()\n",
            "usage": "from your_module import validate_tx_hash\n\nnormalized_hash = validate_tx_hash(\"38330E909CD219B80927009DA37FD69D334D19B2AD4EC47456A24E85034F0085\")"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 defines a backend Python function that calls the Juno LCD /cosmos/tx/v1beta1/txs/{hash} endpoint after validating the hash.",
            "code": "import requests\nfrom typing import Any, Dict\n\n\nBASE_LCD_URL = \"https://lcd-archive.junonetwork.io\"\n\n\nclass LcdRequestError(RuntimeError):\n    \"\"\"Raised when the LCD endpoint cannot be reached or returns an invalid response.\"\"\"\n\n\ndef fetch_tx_by_hash(tx_hash: str) -> Dict[str, Any]:\n    \"\"\"Fetch a transaction and its tx_response from the Juno LCD by hash.\n\n    This function validates the hash format and then performs an HTTP GET.\n    It returns a dict with keys `status_code` and `data` (parsed JSON body).\n    \"\"\"\n    # Reuse step 1 validation\n    normalized_hash = validate_tx_hash(tx_hash)\n\n    url = f\"{BASE_LCD_URL}/cosmos/tx/v1beta1/txs/{normalized_hash}\"\n\n    try:\n        response = requests.get(url, timeout=10)\n    except requests.RequestException as exc:\n        raise LcdRequestError(f\"Failed to reach LCD endpoint: {exc}\") from exc\n\n    try:\n        payload = response.json()\n    except ValueError as exc:\n        # Non-JSON or malformed response\n        raise LcdRequestError(\n            f\"LCD returned non-JSON response with status {response.status_code}.\"\n        ) from exc\n\n    return {\"status_code\": response.status_code, \"data\": payload}\n",
            "usage": "from your_module import fetch_tx_by_hash\n\nresult = fetch_tx_by_hash(\"38330E909CD219B80927009DA37FD69D334D19B2AD4EC47456A24E85034F0085\")\nstatus_code = result[\"status_code\"]\npayload = result[\"data\"]"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 checks that the LCD call returned HTTP 200 and that tx_response.code == 0, raising detailed errors otherwise.",
            "code": "from typing import Any, Dict\n\n\nclass TxQueryError(RuntimeError):\n    \"\"\"Raised when the transaction is not found or failed on-chain.\"\"\"\n\n\ndef check_tx_found_and_success(status_code: int, payload: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Validate LCD HTTP status and tx_response.code.\n\n    Returns the tx_response dict on success or raises TxQueryError otherwise.\n    \"\"\"\n    if status_code != 200:\n        # Include as much context as is reasonably safe\n        message = payload.get(\"message\") if isinstance(payload, dict) else None\n        raise TxQueryError(\n            f\"LCD query failed with HTTP status {status_code}. \"\n            f\"Message: {message or payload}\"\n        )\n\n    tx_response = payload.get(\"tx_response\") if isinstance(payload, dict) else None\n    if tx_response is None:\n        raise TxQueryError(\"LCD response missing 'tx_response' field.\")\n\n    code = tx_response.get(\"code\")\n    raw_log = tx_response.get(\"raw_log\", \"\")\n\n    if code is None:\n        raise TxQueryError(\"'tx_response.code' is missing in LCD response.\")\n\n    if code != 0:\n        # Non-zero code indicates on-chain failure; include raw_log if available\n        raise TxQueryError(\n            f\"Transaction execution failed with code {code}. raw_log: {raw_log}\"\n        )\n\n    return tx_response\n",
            "usage": "from your_module import check_tx_found_and_success\n\n# Using the result from step 2\n# status_code = result[\"status_code\"]\n# payload = result[\"data\"]\n\ntx_response = check_tx_found_and_success(status_code, payload)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 walks through tx_response.logs events and collects any code_id attributes from store_code or instantiate events.",
            "code": "from typing import Any, Dict, List\n\n\ndef extract_code_id_from_events(tx_response: Dict[str, Any]) -> List[Dict[str, Any]]:\n    \"\"\"Extract candidate code IDs from tx_response.logs events.\n\n    Looks for events of type 'store_code' or 'instantiate' with an attribute\n    whose key is exactly 'code_id'. Returns a list of dicts containing the\n    code_id and minimal context (event type and indices).\n    \"\"\"\n    candidates: List[Dict[str, Any]] = []\n\n    logs = tx_response.get(\"logs\") or []\n    if not isinstance(logs, list):\n        return candidates\n\n    for log_index, log in enumerate(logs):\n        events = log.get(\"events\") or []\n        if not isinstance(events, list):\n            continue\n\n        for event_index, event in enumerate(events):\n            event_type = event.get(\"type\")\n            if event_type not in (\"store_code\", \"instantiate\"):\n                continue\n\n            attributes = event.get(\"attributes\") or []\n            if not isinstance(attributes, list):\n                continue\n\n            for attribute_index, attr in enumerate(attributes):\n                key = attr.get(\"key\")\n                if key != \"code_id\":\n                    continue\n\n                value = attr.get(\"value\")\n                if value is None:\n                    continue\n\n                candidates.append(\n                    {\n                        \"code_id\": str(value),\n                        \"event_type\": event_type,\n                        \"log_index\": log_index,\n                        \"event_index\": event_index,\n                        \"attribute_index\": attribute_index,\n                    }\n                )\n\n    return candidates\n",
            "usage": "from your_module import extract_code_id_from_events\n\n# tx_response from step 3\ncandidates = extract_code_id_from_events(tx_response)\n# candidates is a list like:\n# [{\"code_id\": \"123\", \"event_type\": \"store_code\", \"log_index\": 0, ...}, ...]"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 adds a fallback that parses tx_response.raw_log text with a regex to find a code_id when structured events do not expose one.",
            "code": "import re\nfrom typing import Any, Dict, Optional\n\n\ndef fallback_parse_raw_log_for_code_id(tx_response: Dict[str, Any]) -> Optional[str]:\n    \"\"\"Attempt to parse a code_id from tx_response.raw_log using regex.\n\n    This is used only when structured events do not expose a code_id.\n    Returns the extracted code_id string or None if no match is found.\n    \"\"\"\n    raw_log = tx_response.get(\"raw_log\", \"\")\n    if not raw_log or not isinstance(raw_log, str):\n        return None\n\n    # Regex is intentionally permissive to handle formats like:\n    # - \"code_id\":\"12\"\n    # - code_id: 12\n    # - code_id = \"12\"\n    pattern = re.compile(r\"code_id[\\\"']?\\s*[:=]\\s*\\\"?(\\d+)\\\"?\", re.IGNORECASE)\n    match = pattern.search(raw_log)\n\n    if not match:\n        return None\n\n    return match.group(1)\n",
            "usage": "from your_module import fallback_parse_raw_log_for_code_id\n\n# tx_response from step 3\nfallback_code_id = fallback_parse_raw_log_for_code_id(tx_response)\n# fallback_code_id is a string like \"123\" or None if not found"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 resolves the final code_id result from event candidates and the raw_log fallback, and also provides a convenience helper to run the full pipeline for a given tx hash.",
            "code": "from typing import Any, Dict, List, Optional\n\n\nclass CodeIdNotFoundError(RuntimeError):\n    \"\"\"Raised when no code_id can be found in the transaction data.\"\"\"\n\n\ndef return_code_id(\n    event_candidates: List[Dict[str, Any]],\n    fallback_code_id: Optional[str],\n) -> Dict[str, Any]:\n    \"\"\"Resolve code_id(s) from event candidates and fallback value.\n\n    - If one unique code_id is found in events, return {\"code_id\": <id>, \"source\": \"events\"}.\n    - If multiple distinct code_ids are found, return them with minimal context.\n    - If none in events but a fallback exists, return the fallback code_id.\n    - If no code_id can be found, raise CodeIdNotFoundError with an explicit message.\n    \"\"\"\n    # Deduplicate code_ids from events\n    unique_ids = list({c[\"code_id\"] for c in event_candidates})\n\n    if unique_ids:\n        if len(unique_ids) == 1:\n            return {\n                \"code_id\": unique_ids[0],\n                \"source\": \"events\",\n            }\n        else:\n            return {\n                \"code_ids\": unique_ids,\n                \"source\": \"events\",\n                \"details\": event_candidates,\n            }\n\n    # No event-based code_id, fall back to raw_log parsing\n    if fallback_code_id:\n        return {\n            \"code_id\": fallback_code_id,\n            \"source\": \"raw_log\",\n        }\n\n    # Nothing found at all\n    raise CodeIdNotFoundError(\n        \"This transaction does not include a CosmWasm store_code or \"\n        \"instantiate event exposing a code_id.\"\n    )\n\n\ndef get_code_id_from_tx_hash(tx_hash: str) -> Dict[str, Any]:\n    \"\"\"High-level helper that runs all steps 1\u20136 for a given transaction hash.\n\n    This function:\n    1. Validates the tx hash.\n    2. Fetches the transaction from the LCD.\n    3. Ensures the tx exists and succeeded (code == 0).\n    4. Extracts code_id candidates from structured events.\n    5. Optionally parses raw_log for a fallback code_id.\n    6. Returns a resolved code_id result or raises CodeIdNotFoundError.\n    \"\"\"\n    # Step 2: fetch from LCD (includes step 1 validation internally)\n    fetch_result = fetch_tx_by_hash(tx_hash)\n\n    # Step 3: ensure tx found and successful\n    tx_response = check_tx_found_and_success(\n        fetch_result[\"status_code\"], fetch_result[\"data\"]\n    )\n\n    # Step 4: extract from events\n    event_candidates = extract_code_id_from_events(tx_response)\n\n    # Step 5: fallback raw_log parsing only if no event-based code_id\n    fallback_code_id = None\n    if not event_candidates:\n        fallback_code_id = fallback_parse_raw_log_for_code_id(tx_response)\n\n    # Step 6: resolve result\n    return return_code_id(event_candidates, fallback_code_id)\n",
            "usage": "from your_module import (\n    get_code_id_from_tx_hash,\n    return_code_id,\n    extract_code_id_from_events,\n    fallback_parse_raw_log_for_code_id,\n)\n\n# Recommended: use the high-level helper\nresult = get_code_id_from_tx_hash(\"38330E909CD219B80927009DA37FD69D334D19B2AD4EC47456A24E85034F0085\")\n\n# result will be one of:\n# {\"code_id\": \"123\", \"source\": \"events\"}\n# {\"code_ids\": [\"123\", \"124\"], \"source\": \"events\", \"details\": [...]}\n# {\"code_id\": \"123\", \"source\": \"raw_log\"}\n\n# Or CodeIdNotFoundError will be raised if no code_id can be found."
        }
    ]
}