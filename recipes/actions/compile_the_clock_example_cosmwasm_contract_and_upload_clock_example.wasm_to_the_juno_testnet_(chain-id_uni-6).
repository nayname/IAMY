{
    "label": "upload",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 runs the dockerized CosmWasm Rust optimizer to compile the `clock_example` contract and produce `artifacts/clock_example.wasm`.",
            "code": "import subprocess\nfrom pathlib import Path\n\ndef compile_clock_example(contract_root: str = '.') -> str:\n    '''Run cosmwasm/rust-optimizer in Docker and return the artifact path.'''\n    root_path = Path(contract_root).resolve()\n    if not root_path.exists():\n        raise FileNotFoundError(f'Contract root directory not found: {root_path}')\n\n    artifacts_dir = root_path / 'artifacts'\n    artifacts_dir.mkdir(exist_ok=True)\n\n    cmd = [\n        'docker',\n        'run',\n        '--rm',\n        '-v',\n        f'{root_path}:/code',\n        '--mount',\n        'type=volume,source=clock_example_cache,target=/code/target',\n        'cosmwasm/rust-optimizer:0.12.11',\n    ]\n\n    try:\n        subprocess.run(\n            cmd,\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError as exc:\n        raise RuntimeError('Docker is not installed or not found in PATH.') from exc\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(f'cosmwasm/rust-optimizer failed: {exc.stderr}') from exc\n\n    wasm_path = artifacts_dir / 'clock_example.wasm'\n    if not wasm_path.exists():\n        raise FileNotFoundError(f'Expected artifact not found at {wasm_path}')\n\n    return str(wasm_path)\n",
            "usage": "artifact_path = compile_clock_example('/absolute/path/to/clock_example')"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 loads the compiled WASM artifact from disk into memory as a byte array, ensuring the file exists and is non-empty.",
            "code": "from pathlib import Path\n\ndef load_wasm_artifact_bytes(wasm_path: str) -> bytes:\n    '''Load the compiled WASM artifact into memory and ensure it is non-empty.'''\n    path = Path(wasm_path)\n    if not path.is_file():\n        raise FileNotFoundError(f'WASM artifact not found at {path}')\n\n    size = path.stat().st_size\n    if size <= 0:\n        raise ValueError(f'WASM artifact at {path} is empty.')\n\n    with path.open('rb') as f:\n        data = f.read()\n\n    if not data:\n        raise ValueError('Failed to read WASM artifact or file is empty.')\n\n    return data\n",
            "usage": "wasm_bytes = load_wasm_artifact_bytes(artifact_path)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 queries the Juno LCD config endpoint to fetch and parse the node's `minimum_gas_price`, which will be used to compute transaction fees.",
            "code": "from decimal import Decimal\nfrom typing import Tuple\nimport re\n\nimport requests\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef fetch_minimum_gas_price(base_url: str = LCD_BASE_URL) -> Tuple[Decimal, str]:\n    '''Fetch the node's minimum_gas_price and parse it into (amount, denom).'''\n    url = f'{base_url}/cosmos/base/node/v1beta1/config'\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to fetch node config from {url}: {exc}') from exc\n\n    data = resp.json()\n    mgp = data.get('minimum_gas_price')\n    if not mgp:\n        raise ValueError('minimum_gas_price not present in node config response.')\n\n    match = re.match(r'^([0-9.]+)([a-zA-Z/]+)$', mgp)\n    if not match:\n        raise ValueError(f'Unexpected minimum_gas_price format: {mgp}')\n\n    amount_str, denom = match.groups()\n    try:\n        amount = Decimal(amount_str)\n    except Exception as exc:\n        raise ValueError(f'Invalid gas price amount {amount_str!r}: {exc}') from exc\n\n    return amount, denom\n",
            "usage": "gas_price_amount, gas_price_denom = fetch_minimum_gas_price()"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 fetches the sender's account number and sequence from the auth module, and checks spendable `ujunox` balance from the bank module.",
            "code": "from decimal import Decimal\nfrom typing import Any, Dict, Optional\nimport base64\n\nimport requests\nfrom cosmpy.protos.cosmos.auth.v1beta1.auth_pb2 import BaseAccount\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef fetch_sender_account_state(\n    address: str,\n    base_url: str = LCD_BASE_URL,\n    fee_denom: str = 'ujunox',\n    required_balance: Optional[Decimal] = None,\n) -> Dict[str, Any]:\n    '''Query account number, sequence, and spendable balance for the sender.'''\n    account_url = f'{base_url}/cosmos/auth/v1beta1/accounts/{address}'\n    balances_url = f'{base_url}/cosmos/bank/v1beta1/spendable_balances/{address}'\n\n    try:\n        acc_resp = requests.get(account_url, timeout=10)\n        acc_resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to fetch account data: {exc}') from exc\n\n    acc_data = acc_resp.json()\n    account_any = acc_data.get('account')\n    if not account_any or 'value' not in account_any:\n        raise ValueError('Account response missing account.value field.')\n\n    try:\n        raw = base64.b64decode(account_any['value'])\n        base_account = BaseAccount.FromString(raw)\n    except Exception as exc:\n        raise RuntimeError(f'Failed to decode BaseAccount protobuf: {exc}') from exc\n\n    account_number = int(base_account.account_number)\n    sequence = int(base_account.sequence)\n\n    try:\n        bal_resp = requests.get(balances_url, timeout=10)\n        bal_resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to fetch spendable balances: {exc}') from exc\n\n    bal_data = bal_resp.json()\n    balances = bal_data.get('balances', [])\n    spendable = Decimal(0)\n    for coin in balances:\n        if coin.get('denom') == fee_denom:\n            spendable = Decimal(coin.get('amount', '0'))\n            break\n\n    if required_balance is not None and spendable < required_balance:\n        raise ValueError(\n            f'Insufficient balance: have {spendable} {fee_denom}, '\n            f'required at least {required_balance}.'\n        )\n\n    return {\n        'account_number': account_number,\n        'sequence': sequence,\n        'balances': balances,\n        'fee_denom': fee_denom,\n        'spendable_for_fee': str(spendable),\n    }\n",
            "usage": "from decimal import Decimal\naccount_state = fetch_sender_account_state(sender_address, required_balance=Decimal('5000000'))  # e.g. require 5,000,000 ujunox"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 constructs an unsigned `MsgStoreCode` transaction for chain `uni-6` with an initial gas limit and fee, suitable for simulation.",
            "code": "from decimal import Decimal, ROUND_UP\nfrom typing import Any, Dict\n\nfrom google.protobuf.any_pb2 import Any as AnyProto\nfrom cosmpy.protos.cosmwasm.wasm.v1.tx_pb2 import MsgStoreCode\nfrom cosmpy.protos.cosmos.tx.v1beta1.tx_pb2 import TxBody, AuthInfo, Tx, Fee\nfrom cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin\n\ndef construct_msg_store_code_tx_for_simulation(\n    sender: str,\n    wasm_bytes: bytes,\n    gas_price_amount: Decimal,\n    gas_price_denom: str,\n    initial_gas_limit: int = 2_000_000,\n    chain_id: str = 'uni-6',\n) -> Dict[str, Any]:\n    '''\n    Construct an unsigned MsgStoreCode transaction suitable for /cosmos/tx/v1beta1/simulate.\n    The chain_id is recorded for reference but is only required at signing time.\n    '''\n    msg = MsgStoreCode(\n        sender=sender,\n        wasm_byte_code=wasm_bytes,\n    )\n    msg_any = AnyProto()\n    msg_any.Pack(msg)\n\n    tx_body = TxBody(\n        messages=[msg_any],\n        memo='',\n        timeout_height=0,\n    )\n\n    fee_amount = int(\n        (gas_price_amount * Decimal(initial_gas_limit)).to_integral_value(rounding=ROUND_UP)\n    )\n    fee = Fee(\n        amount=[Coin(denom=gas_price_denom, amount=str(fee_amount))],\n        gas_limit=initial_gas_limit,\n    )\n\n    auth_info = AuthInfo(\n        signer_infos=[],\n        fee=fee,\n    )\n\n    tx = Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[],\n    )\n\n    tx_bytes = tx.SerializeToString()\n\n    return {\n        'tx_bytes': tx_bytes,\n        'tx_body': tx_body,\n        'auth_info': auth_info,\n        'initial_gas_limit': initial_gas_limit,\n        'fee_amount': fee_amount,\n        'gas_price_amount': str(gas_price_amount),\n        'gas_price_denom': gas_price_denom,\n        'chain_id': chain_id,\n    }\n",
            "usage": "sim_tx = construct_msg_store_code_tx_for_simulation(sender_address, wasm_bytes, gas_price_amount, gas_price_denom)\nunsigned_tx_bytes = sim_tx['tx_bytes']"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 simulates the unsigned `MsgStoreCode` transaction via `/cosmos/tx/v1beta1/simulate` to obtain `gas_info.gas_used` and compute an adjusted gas limit.",
            "code": "import base64\nfrom typing import Any, Dict\n\nimport requests\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef simulate_store_code_tx(tx_bytes: bytes, base_url: str = LCD_BASE_URL) -> Dict[str, Any]:\n    '''\n    Call /cosmos/tx/v1beta1/simulate to estimate gas usage for the MsgStoreCode transaction.\n    Returns gas_used and an adjusted_gas_limit with a safety multiplier.\n    '''\n    url = f'{base_url}/cosmos/tx/v1beta1/simulate'\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('ascii'),\n    }\n\n    try:\n        resp = requests.post(url, json=payload, timeout=20)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Simulation request failed: {exc}') from exc\n\n    data = resp.json()\n    gas_info = data.get('gas_info') or {}\n    gas_used_str = gas_info.get('gas_used')\n    if gas_used_str is None:\n        raise ValueError(f'Simulation response missing gas_info.gas_used: {data}')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError as exc:\n        raise ValueError(f'Invalid gas_used value {gas_used_str!r}: {exc}') from exc\n\n    safety_factor = 1.3\n    adjusted_gas_limit = int(gas_used * safety_factor)\n\n    return {\n        'raw_response': data,\n        'gas_used': gas_used,\n        'adjusted_gas_limit': adjusted_gas_limit,\n    }\n",
            "usage": "sim_result = simulate_store_code_tx(unsigned_tx_bytes)\nadjusted_gas_limit = sim_result['adjusted_gas_limit']"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Step 7 rebuilds the `MsgStoreCode` transaction with the adjusted gas limit and signs it using the sender\u2019s secp256k1 private key for chain-id `uni-6`.",
            "code": "from decimal import Decimal, ROUND_UP\nfrom typing import Any, Dict\n\nfrom ecdsa import SECP256k1, SigningKey\nfrom google.protobuf.any_pb2 import Any as AnyProto\n\nfrom cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin\nfrom cosmpy.protos.cosmos.crypto.secp256k1.keys_pb2 import PubKey as Secp256k1PubKey\nfrom cosmpy.protos.cosmos.tx.signing.v1beta1.signing_pb2 import SignMode\nfrom cosmpy.protos.cosmos.tx.v1beta1.tx_pb2 import (\n    TxBody,\n    AuthInfo,\n    Tx,\n    SignerInfo,\n    ModeInfo,\n    Fee,\n    SignDoc,\n)\nfrom cosmpy.protos.cosmwasm.wasm.v1.tx_pb2 import MsgStoreCode\n\ndef sign_store_code_tx(\n    sender: str,\n    wasm_bytes: bytes,\n    gas_price_amount: Decimal,\n    gas_price_denom: str,\n    gas_limit: int,\n    account_number: int,\n    sequence: int,\n    chain_id: str,\n    privkey_hex: str,\n) -> Dict[str, Any]:\n    '''\n    Construct and sign a MsgStoreCode transaction using SIGN_MODE_DIRECT.\n    Returns the signed tx_bytes ready for broadcast.\n    '''\n    msg = MsgStoreCode(sender=sender, wasm_byte_code=wasm_bytes)\n    msg_any = AnyProto()\n    msg_any.Pack(msg)\n\n    tx_body = TxBody(messages=[msg_any], memo='', timeout_height=0)\n\n    fee_amount = int(\n        (gas_price_amount * Decimal(gas_limit)).to_integral_value(rounding=ROUND_UP)\n    )\n    fee = Fee(\n        amount=[Coin(denom=gas_price_denom, amount=str(fee_amount))],\n        gas_limit=gas_limit,\n    )\n\n    try:\n        privkey_bytes = bytes.fromhex(privkey_hex)\n    except ValueError as exc:\n        raise ValueError('Private key must be a 64-character hex string.') from exc\n\n    if len(privkey_bytes) != 32:\n        raise ValueError('Private key must be 32 bytes (64 hex characters).')\n\n    sk = SigningKey.from_string(privkey_bytes, curve=SECP256k1)\n    vk = sk.get_verifying_key()\n    try:\n        pubkey_bytes = vk.to_string('compressed')\n    except TypeError as exc:\n        raise RuntimeError(\n            'ecdsa library is too old; upgrade to a version that supports compressed keys.'\n        ) from exc\n\n    pk_msg = Secp256k1PubKey(key=pubkey_bytes)\n    pk_any = AnyProto()\n    pk_any.Pack(pk_msg)\n    pk_any.type_url = '/cosmos.crypto.secp256k1.PubKey'\n\n    mode_info = ModeInfo(single=ModeInfo.Single(mode=SignMode.SIGN_MODE_DIRECT))\n    signer_info = SignerInfo(\n        public_key=pk_any,\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    auth_info = AuthInfo(\n        signer_infos=[signer_info],\n        fee=fee,\n    )\n\n    sign_doc = SignDoc(\n        body_bytes=tx_body.SerializeToString(),\n        auth_info_bytes=auth_info.SerializeToString(),\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n    sign_bytes = sign_doc.SerializeToString()\n\n    import hashlib\n\n    signature = sk.sign_deterministic(sign_bytes, hashfunc=hashlib.sha256)\n\n    tx = Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[signature],\n    )\n\n    tx_bytes = tx.SerializeToString()\n    return {\n        'tx': tx,\n        'tx_bytes': tx_bytes,\n        'fee_amount': fee_amount,\n    }\n",
            "usage": "signed = sign_store_code_tx(sender_address, wasm_bytes, gas_price_amount, gas_price_denom, adjusted_gas_limit, account_state['account_number'], account_state['sequence'], 'uni-6', sender_privkey_hex)\nsigned_tx_bytes = signed['tx_bytes']"
        },
        {
            "step": 8,
            "label": "backend",
            "introduction": "Step 8 broadcasts the signed transaction to `/cosmos/tx/v1beta1/txs` in `BROADCAST_MODE_BLOCK` and returns the resulting `tx_response` including `txhash`.",
            "code": "import base64\nfrom typing import Any, Dict\n\nimport requests\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef broadcast_store_code_tx(tx_bytes: bytes, base_url: str = LCD_BASE_URL) -> Dict[str, Any]:\n    '''\n    Broadcast the signed transaction via /cosmos/tx/v1beta1/txs using BROADCAST_MODE_BLOCK.\n    Returns the tx_response object.\n    '''\n    url = f'{base_url}/cosmos/tx/v1beta1/txs'\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('ascii'),\n        'mode': 'BROADCAST_MODE_BLOCK',\n    }\n\n    try:\n        resp = requests.post(url, json=payload, timeout=60)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Broadcast failed: {exc}') from exc\n\n    data = resp.json()\n    tx_response = data.get('tx_response') or {}\n    if not tx_response:\n        raise ValueError(f'Broadcast response missing tx_response field: {data}')\n\n    code = tx_response.get('code', 0)\n    if code != 0:\n        raw_log = tx_response.get('raw_log')\n        raise RuntimeError(\n            f'Transaction failed with code {code}: {raw_log}'\n        )\n\n    return tx_response\n",
            "usage": "tx_response = broadcast_store_code_tx(signed_tx_bytes)\ntxhash = tx_response['txhash']"
        },
        {
            "step": 9,
            "label": "backend",
            "introduction": "Step 9 parses the successful `tx_response.logs` to locate the `code_id` attribute emitted by the `store_code` event and returns it.",
            "code": "from typing import Any, Dict\n\ndef extract_code_id_from_logs(tx_response: Dict[str, Any]) -> str:\n    '''\n    Scan tx_response.logs[*].events[*].attributes for a code_id attribute and return it.\n    Raises ValueError if not found.\n    '''\n    logs = tx_response.get('logs', [])\n    for log in logs:\n        events = log.get('events', [])\n        for event in events:\n            attributes = event.get('attributes', [])\n            for attr in attributes:\n                key = attr.get('key')\n                value = attr.get('value')\n                if key in ('code_id', 'codeID'):\n                    return str(value)\n\n    raise ValueError(f'code_id not found in transaction logs: {logs}')\n",
            "usage": "code_id = extract_code_id_from_logs(tx_response)"
        },
        {
            "step": 10,
            "label": "backend",
            "introduction": "Step 10 queries `/cosmwasm/wasm/v1/code/{code_id}` to verify that the uploaded code exists on-chain and that its `creator` matches the sender address.",
            "code": "from typing import Any, Dict\n\nimport requests\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef verify_code_uploaded_on_chain(\n    code_id: str,\n    expected_creator: str,\n    base_url: str = LCD_BASE_URL,\n) -> Dict[str, Any]:\n    '''\n    Query /cosmwasm/wasm/v1/code/{code_id} and verify the creator matches expected_creator.\n    Returns the code_info and a verified flag.\n    '''\n    url = f'{base_url}/cosmwasm/wasm/v1/code/{code_id}'\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query code_id {code_id}: {exc}') from exc\n\n    data = resp.json()\n    code_info = data.get('code_info')\n    if not code_info:\n        raise ValueError(f'No code_info returned for code_id {code_id}: {data}')\n\n    creator = code_info.get('creator')\n    if creator != expected_creator:\n        raise ValueError(\n            f'Code creator mismatch for code_id {code_id}: '\n            f'expected {expected_creator}, got {creator}'\n        )\n\n    code_id_in_payload = code_info.get('code_id')\n    if str(code_id_in_payload) != str(code_id):\n        raise ValueError(\n            f'code_id mismatch in response: path={code_id}, payload={code_id_in_payload}'\n        )\n\n    return {\n        'code_info': code_info,\n        'verified': True,\n    }\n",
            "usage": "verification = verify_code_uploaded_on_chain(code_id, expected_creator=sender_address)\nassert verification['verified'] is True"
        }
    ]
}