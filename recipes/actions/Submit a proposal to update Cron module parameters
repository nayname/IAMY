{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Query the Cron module parameters and extract the DAO (authority) address that is permitted to update them.",
            "code": "import requests\n\nREST_ENDPOINT = \"https://rest-kralum.neutron.org\"  # <-- change to your preferred REST endpoint\n\n\ndef get_dao_authority_address(node_url: str = REST_ENDPOINT) -> str:\n    \"\"\"Returns the authority address defined in the Cron module params.\n\n    Args:\n        node_url: Base REST endpoint of a Neutron full-node.\n\n    Raises:\n        RuntimeError: If the request fails or the authority parameter is missing.\n    \"\"\"\n    url = f\"{node_url}/cosmos/params/v1beta1/params?subspace=cron\"\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        data = resp.json()\n\n        # The response schema is { \"param\": [ { \"key\": \"Authority\", \"value\": \"ntrn1...\"}, ...] }\n        for param in data.get(\"param\", []):\n            if param.get(\"key\") == \"Authority\":\n                return param.get(\"value\")\n        raise RuntimeError(\"'Authority' field not found in cron params response\")\n    except requests.RequestException as err:\n        raise RuntimeError(f\"Unable to query cron params: {err}\")",
            "usage": "authority = get_dao_authority_address()\nprint(f\"DAO authority address: {authority}\")"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Build a protobuf MsgUpdateParams message that updates Cron module parameters (e.g., max_schedules=1000).",
            "code": "from google.protobuf.any_pb2 import Any\n# Proto imports generated from Neutron's proto definitions\nfrom neutron.cron.v1.tx_pb2 import MsgUpdateParams, Params  # make sure your PYTHONPATH includes compiled protos\n\n\ndef build_msg_update_params(authority: str, *, max_schedules: int | None = None, default_gas_limit: int | None = None) -> MsgUpdateParams:\n    \"\"\"Constructs MsgUpdateParams with only the fields that need updating.\n\n    Args:\n        authority: Address allowed to perform the update (DAO address).\n        max_schedules: New maximum number of active cron schedules.\n        default_gas_limit: Optional default gas limit per cron execution.\n    \"\"\"\n    params = Params()\n    if max_schedules is not None:\n        params.max_schedules = max_schedules\n    if default_gas_limit is not None:\n        params.default_gas_limit = default_gas_limit\n\n    return MsgUpdateParams(authority=authority, params=params)",
            "usage": "msg_update = build_msg_update_params(authority, max_schedules=1000)\nprint(msg_update)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Wrap MsgUpdateParams inside a governance MsgSubmitProposal so it can be voted on by NTRN holders.",
            "code": "from google.protobuf.any_pb2 import Any\nfrom cosmos.gov.v1beta1.gov_pb2 import MsgSubmitProposal  # SDK <0.50; replace with gov.v1 for newer chains\nfrom cosmos.base.v1beta1.coin_pb2 import Coin\n\n\ndef package_into_gov_proposal(msg_update_params: MsgUpdateParams, proposer: str, title: str, description: str, *, deposit_amount: str = \"10000000\", deposit_denom: str = \"untrn\") -> MsgSubmitProposal:\n    \"\"\"Creates MsgSubmitProposal embedding MsgUpdateParams.\n\n    Args:\n        msg_update_params: The message produced in step 2.\n        proposer: Address that submits the proposal (DAO address).\n        title: Plain-text proposal title.\n        description: Long-form markdown/description.\n        deposit_amount: String amount of initial deposit (default 10 NTRN in micro-denom).\n        deposit_denom: Denomination (usually 'untrn').\n    \"\"\"\n    content_any = Any()\n    # Pack the update message; type_url_prefix=\"/\" satisfies most signing libraries\n    content_any.Pack(msg_update_params, type_url_prefix=\"/\")\n\n    proposal_msg = MsgSubmitProposal(\n        content=content_any,\n        initial_deposit=[Coin(amount=deposit_amount, denom=deposit_denom)],\n        proposer=proposer,\n    )\n    # v1beta1 requires title/description to be part of Content if not a gov TextProposal.\n    # If using gov.v1 (SDK >=0.50) you'd instead set these on \"MsgSubmitProposal\" directly.\n    proposal_msg.title = title\n    proposal_msg.description = description\n\n    return proposal_msg",
            "usage": "proposal_msg = package_into_gov_proposal(\n    msg_update,                    # from step 2\n    proposer=authority,            # DAO address\n    title=\"Increase Cron max_schedules to 1,000\",\n    description=\"This proposal raises the Cron module's max_schedules param to 1,000 so more protocols can use automation.\")"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Sign the MsgSubmitProposal with the DAO\u2019s key and broadcast the transaction to Neutron.",
            "code": "from cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import PrivateKey\nfrom cosmpy.aerial.tx import Transaction\n\n# Chain-specific settings (adjust for testnet / mainnet)\nCHAIN_ID = \"neutron-1\"\nGRPC_ENDPOINT = \"grpc-kralum.neutron.org:9090\"\nFEE_DENOM = \"untrn\"\nDEFAULT_GAS = 300000  # can be tuned after simulating\nDEFAULT_FEE = 5000    # 0.005 NTRN\n\n\ndef sign_and_broadcast_tx(msg_submit_proposal: MsgSubmitProposal, proposer_mnemonic: str) -> str:\n    \"\"\"Signs + broadcasts the governance proposal. Returns the transaction hash.\n\n    Args:\n        msg_submit_proposal: Message from step 3.\n        proposer_mnemonic: BIP-39 mnemonic for the DAO account (ensure it\u2019s secured!).\n    \"\"\"\n    try:\n        # 1. Initialise network client\n        net_cfg = NetworkConfig(chain_id=CHAIN_ID, grpc_endpoint=GRPC_ENDPOINT)\n        client = LedgerClient(net_cfg)\n\n        # 2. Load wallet / account details\n        priv = PrivateKey.from_mnemonic(proposer_mnemonic)\n        wallet = priv.to_wallet()\n        account = client.query_account(wallet.address())\n\n        # 3. Build TX\n        tx = Transaction()\n        tx.add_message(msg_submit_proposal)\n        tx.with_sequence(account.sequence)\n        tx.with_account_num(account.account_number)\n        tx.with_chain_id(CHAIN_ID)\n        tx.with_gas(DEFAULT_GAS)\n        tx.with_fee(DEFAULT_FEE, FEE_DENOM)\n\n        # 4. Sign & broadcast\n        tx.sign(priv)\n        resp = client.broadcast_tx(tx)\n\n        if resp.tx_response.code != 0:\n            raise RuntimeError(f\"Broadcast failed: {resp.tx_response.raw_log}\")\n\n        return resp.tx_response.txhash\n\n    except Exception as err:\n        raise RuntimeError(f\"sign_and_broadcast_tx failed: {err}\")",
            "usage": "tx_hash = sign_and_broadcast_tx(proposal_msg, proposer_mnemonic=\"your DAO seed phrase\")\nprint(f\"Proposal submitted! TX hash: {tx_hash}\")"
        }
    ]
}