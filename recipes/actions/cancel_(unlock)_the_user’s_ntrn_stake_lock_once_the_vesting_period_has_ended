{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Step 1 connects the user\u2019s Keplr wallet (or compatible Cosmos-SDK browser wallet) and returns the Neutron address that holds the locked NTRN stake.",
            "code": "// src/utils/wallet.js\nexport const getUserWalletAddress = async (chainId = 'neutron-1') => {\n  try {\n    if (!window || !window.keplr) {\n      throw new Error('Keplr wallet extension not found');\n    }\n\n    // Request wallet access\n    await window.keplr.enable(chainId);\n\n    // Obtain the signer and the first account\n    const offlineSigner = window.getOfflineSigner(chainId);\n    const accounts = await offlineSigner.getAccounts();\n\n    if (!accounts || accounts.length === 0) {\n      throw new Error('No account found in wallet');\n    }\n\n    return {\n      address: accounts[0].address,\n      offlineSigner\n    };\n  } catch (err) {\n    console.error('[getUserWalletAddress] ', err);\n    throw err;\n  }\n};",
            "usage": "const { address, offlineSigner } = await getUserWalletAddress();"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 creates a lightweight Python BFF endpoint that queries the lock contract to verify whether a given lock is already eligible for cancellation/unlocking.",
            "code": "# api/lock_status.py\nimport os\nimport base64\nimport json\nfrom typing import Dict\nfrom fastapi import APIRouter, HTTPException\nimport httpx\n\nrouter = APIRouter()\n\nLCD_ENDPOINT = os.getenv(\"LCD_ENDPOINT\", \"https://rest-kralum.neutron-1.neutron.org\")\nLOCK_CONTRACT_ADDR = os.getenv(\"LOCK_CONTRACT_ADDR\", \"neutron1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\")\n\n@router.get(\"/lock_status\")\nasync def lock_status(address: str, lock_id: int) -> Dict:\n    \"\"\"Return the lock information for <address, lock_id>. Raises 400 if lock not found.\"\"\"\n    try:\n        # Build CosmWasm smart-query\n        query_msg = {\n            \"lock\": {\n                \"address\": address,\n                \"lock_id\": lock_id\n            }\n        }\n        query_b64 = base64.b64encode(json.dumps(query_msg).encode()).decode()\n        url = f\"{LCD_ENDPOINT}/wasm/v1/contract/{LOCK_CONTRACT_ADDR}/smart/{query_b64}\"\n\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n        if resp.status_code != 200:\n            raise HTTPException(status_code=resp.status_code, detail=resp.text)\n\n        data = resp.json()\n        # Adjust the JSON path depending on contract schema\n        lock_info = data.get(\"data\") or data  # fallback\n\n        if not lock_info:\n            raise HTTPException(status_code=404, detail=\"Lock not found\")\n\n        if not lock_info.get(\"unlockable\", False):\n            return {\"eligible\": False, \"reason\": \"Lock period not finished\"}\n\n        return {\n            \"eligible\": True,\n            \"lock_info\": lock_info\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "GET /api/lock_status?address=<WALLET_ADDR>&lock_id=42  \u279c  { \"eligible\": true, \"lock_info\": { ... } }"
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "Step 3 builds the MsgExecuteContract payload that will cancel/unlock the specified lock.  No external JavaScript libraries are used; basic JSON is sufficient for Keplr\u2019s amino-signing flow.",
            "code": "// src/tx/constructUnlockTx.js\nexport const constructUnlockTx = async ({\n  chainId = 'neutron-1',\n  senderAddress,\n  contractAddress,\n  lockId,\n  fee = {\n    amount: [{ amount: '6000', denom: 'untrn' }],\n    gas: '300000'\n  },\n  memo = ''\n}) => {\n  // Cosmos SDK Tx requires accountNumber & sequence \u2192 fetch from LCD\n  const LCD_URL = 'https://rest-kralum.neutron-1.neutron.org';\n  const accountRes = await fetch(\n    `${LCD_URL}/cosmos/auth/v1beta1/accounts/${senderAddress}`\n  ).then((r) => r.json());\n\n  const baseAccount =\n    accountRes.account.base_account || accountRes.account; // handles vesting / eth-addr\n\n  const accountNumber = String(baseAccount.account_number);\n  const sequence = String(baseAccount.sequence);\n\n  // MsgExecuteContract to cancel the lock\n  const msg = {\n    type: 'wasm/MsgExecuteContract',\n    value: {\n      sender: senderAddress,\n      contract: contractAddress,\n      msg: {\n        cancel_lock: { lock_id: lockId }\n      },\n      funds: []\n    }\n  };\n\n  // Build the amino-compatible StdSignDoc\n  const signDoc = {\n    chain_id: chainId,\n    account_number: accountNumber,\n    sequence: sequence,\n    fee,\n    msgs: [msg],\n    memo\n  };\n\n  return {\n    signDoc,\n    msg,\n    fee,\n    memo\n  };\n};",
            "usage": "const { signDoc } = await constructUnlockTx({ senderAddress: address, contractAddress: LOCK_CONTRACT_ADDR, lockId: 42 });"
        },
        {
            "step": 4,
            "label": "frontend",
            "introduction": "Step 4 signs the `signDoc` with Keplr and broadcasts the raw transaction via Keplr\u2019s `sendTx` helper, completing the unlock process.",
            "code": "// src/tx/signAndBroadcast.js\nimport { toHex, fromAscii } from \"./utils\"; // helper functions to convert to hex if desired (implementation omitted for brevity)\n\nexport const signAndBroadcastTx = async ({\n  chainId = 'neutron-1',\n  signDoc,\n  offlineSigner\n}) => {\n  try {\n    if (!window || !window.keplr) {\n      throw new Error('Keplr wallet extension not found');\n    }\n\n    // Sign using Keplr's amino signer\n    const { signature, signed } = await window.keplr.signAmino(\n      chainId,\n      signDoc.msgs[0].value.sender,\n      signDoc,\n      {\n        // Signer data \u2192 indicates we don\u2019t want Keplr to override fields\n        preferNoSetFee: true,\n        preferNoSetMemo: true\n      }\n    );\n\n    // Build StdTx (amino)\n    const stdTx = {\n      msg: signed.msgs,\n      fee: signed.fee,\n      signatures: [\n        {\n          pub_key: signature.pub_key,\n          signature: signature.signature,\n          account_number: signed.account_number,\n          sequence: signed.sequence\n        }\n      ],\n      memo: signed.memo\n    };\n\n    // Marshal to bytes \u2192 Use Keplr to send raw bytes without CosmJS\n    const txBytes = Uint8Array.from(\n      Buffer.from(JSON.stringify(stdTx))\n    );\n\n    const result = await window.keplr.sendTx(chainId, txBytes, \"sync\");\n\n    return {\n      txhash: toHex(result),\n      raw_log: 'Check Neutron explorer for details'\n    };\n  } catch (err) {\n    console.error('[signAndBroadcastTx] ', err);\n    throw err;\n  }\n};",
            "usage": "const txResult = await signAndBroadcastTx({ chainId: 'neutron-1', signDoc, offlineSigner });\nconsole.log('Unlock Tx Hash:', txResult.txhash);"
        }
    ]
}