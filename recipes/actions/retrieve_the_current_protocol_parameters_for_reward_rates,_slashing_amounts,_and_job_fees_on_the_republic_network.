{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "This backend function queries the Republic chain for staking and reward-related parameters (staking, mint/inflation, and Republic-specific reward multipliers/bonuses).",
            "code": "import os\nimport httpx\nfrom typing import Any, Dict\n\n# Base URL of the Republic LCD (REST) endpoint.\n# Configure this via environment variable in your backend deployment.\nREPUBLIC_LCD_URL = os.getenv(\"REPUBLIC_LCD_URL\", \"https://lcd.republic.example.com\")\n\n\nasync def _get(path: str) -> Dict[str, Any]:\n    \"\"\"Internal helper to perform a GET request against the Republic LCD.\n\n    Raises RuntimeError with a descriptive message on network/HTTP/JSON errors.\n    \"\"\"\n    if not REPUBLIC_LCD_URL:\n        raise RuntimeError(\"REPUBLIC_LCD_URL environment variable is not set.\")\n\n    base_url = REPUBLIC_LCD_URL.rstrip(\"/\")\n    url = f\"{base_url}{path}\"\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            response = await client.get(url)\n            response.raise_for_status()\n            return response.json()\n    except httpx.RequestError as exc:\n        raise RuntimeError(f\"Network error while querying {url}: {exc}\") from exc\n    except httpx.HTTPStatusError as exc:\n        raise RuntimeError(\n            f\"HTTP {exc.response.status_code} while querying {url}: {exc.response.text}\"\n        ) from exc\n    except ValueError as exc:\n        raise RuntimeError(f\"Failed to decode JSON from {url}: {exc}\") from exc\n\n\nasync def backend_republic_get_staking_and_reward_params() -> Dict[str, Any]:\n    \"\"\"Query staking and reward-related parameters from the Republic chain.\n\n    Returns a dictionary with raw parameter payloads from:\n      - Cosmos staking module (bond denom, unbonding time, etc.).\n      - Cosmos mint module (inflation / blocks_per_year, etc.).\n      - Republic-specific rewards module (reputation/compute multipliers,\n        consensus participation bonuses, etc.).\n\n    Normalization and formatting into user-facing structures is handled in a\n    later step.\n    \"\"\"\n    # Cosmos standard staking parameters\n    staking_raw = await _get(\"/cosmos/staking/v1beta1/params\")\n\n    # Minting / inflation parameters, used as a proxy for base staking rewards.\n    mint_raw = await _get(\"/cosmos/mint/v1beta1/params\")\n\n    # Republic-specific reward configuration: reputation / compute multipliers,\n    # consensus participation bonuses, etc. The path is illustrative and may\n    # need to be updated once the concrete Republic API is finalized.\n    try:\n        compute_rewards_raw = await _get(\"/republic/rewards/v1/params\")\n    except RuntimeError:\n        # If the module is not deployed yet, degrade gracefully.\n        compute_rewards_raw = {\"params\": {}}\n\n    return {\n        \"staking_params\": staking_raw.get(\"params\", staking_raw),\n        \"mint_params\": mint_raw.get(\"params\", mint_raw),\n        \"compute_reward_params\": compute_rewards_raw.get(\"params\", compute_rewards_raw),\n    }\n",
            "usage": "In your backend service (for example inside a FastAPI route), call:\n\nparams = await backend_republic_get_staking_and_reward_params()\n\nand return `params` as JSON to the frontend, e.g. via `/api/economics/staking-and-rewards`."
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "This backend function queries slashing and penalty parameters, including standard slashing fractions, unbonding/jail durations, and Republic-specific compute slashing rules.",
            "code": "import os\nimport httpx\nfrom typing import Any, Dict\n\nREPUBLIC_LCD_URL = os.getenv(\"REPUBLIC_LCD_URL\", \"https://lcd.republic.example.com\")\n\n\nasync def _get(path: str) -> Dict[str, Any]:\n    \"\"\"Internal helper to perform a GET request against the Republic LCD.\n\n    Raises RuntimeError with a descriptive message on network/HTTP/JSON errors.\n    \"\"\"\n    if not REPUBLIC_LCD_URL:\n        raise RuntimeError(\"REPUBLIC_LCD_URL environment variable is not set.\")\n\n    base_url = REPUBLIC_LCD_URL.rstrip(\"/\")\n    url = f\"{base_url}{path}\"\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            response = await client.get(url)\n            response.raise_for_status()\n            return response.json()\n    except httpx.RequestError as exc:\n        raise RuntimeError(f\"Network error while querying {url}: {exc}\") from exc\n    except httpx.HTTPStatusError as exc:\n        raise RuntimeError(\n            f\"HTTP {exc.response.status_code} while querying {url}: {exc.response.text}\"\n        ) from exc\n    except ValueError as exc:\n        raise RuntimeError(f\"Failed to decode JSON from {url}: {exc}\") from exc\n\n\nasync def backend_republic_get_slashing_params() -> Dict[str, Any]:\n    \"\"\"Query slashing- and penalty-related parameters from the Republic chain.\n\n    Returns a dictionary combining:\n      - Cosmos slashing params (double-sign / downtime fractions, jail duration).\n      - Staking params (for unbonding_time alongside slashing context).\n      - Republic-specific compute slashing params (incorrect/delayed compute).\n    \"\"\"\n    # Core Cosmos-SDK slashing parameters: fractions for double-signing,\n    # downtime, jail duration, etc.\n    slashing_raw = await _get(\"/cosmos/slashing/v1beta1/params\")\n\n    # Staking params are reused here to expose unbonding_time with penalties.\n    staking_raw = await _get(\"/cosmos/staking/v1beta1/params\")\n\n    # Republic-specific compute slashing configuration (e.g., incorrect or\n    # delayed compute submissions). API path is illustrative.\n    try:\n        compute_slashing_raw = await _get(\"/republic/compute/v1/slashing_params\")\n    except RuntimeError:\n        compute_slashing_raw = {\"params\": {}}\n\n    return {\n        \"slashing_params\": slashing_raw.get(\"params\", slashing_raw),\n        \"staking_params\": staking_raw.get(\"params\", staking_raw),\n        \"compute_slashing_params\": compute_slashing_raw.get(\"params\", compute_slashing_raw),\n    }\n",
            "usage": "In your backend service, call:\n\nslashing = await backend_republic_get_slashing_params()\n\nand expose it (for example) at `/api/economics/slashing` for your frontend."
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "This backend function fetches job fee and compute marketplace parameters from Republic, such as base job fee, minimum fee, fee split, and dynamic fee controls.",
            "code": "import os\nimport httpx\nfrom typing import Any, Dict\n\nREPUBLIC_LCD_URL = os.getenv(\"REPUBLIC_LCD_URL\", \"https://lcd.republic.example.com\")\n\n\nasync def _get(path: str) -> Dict[str, Any]:\n    \"\"\"Internal helper to perform a GET request against the Republic LCD.\n\n    Raises RuntimeError with a descriptive message on network/HTTP/JSON errors.\n    \"\"\"\n    if not REPUBLIC_LCD_URL:\n        raise RuntimeError(\"REPUBLIC_LCD_URL environment variable is not set.\")\n\n    base_url = REPUBLIC_LCD_URL.rstrip(\"/\")\n    url = f\"{base_url}{path}\"\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            response = await client.get(url)\n            response.raise_for_status()\n            return response.json()\n    except httpx.RequestError as exc:\n        raise RuntimeError(f\"Network error while querying {url}: {exc}\") from exc\n    except httpx.HTTPStatusError as exc:\n        raise RuntimeError(\n            f\"HTTP {exc.response.status_code} while querying {url}: {exc.response.text}\"\n        ) from exc\n    except ValueError as exc:\n        raise RuntimeError(f\"Failed to decode JSON from {url}: {exc}\") from exc\n\n\nasync def backend_republic_get_job_fee_params() -> Dict[str, Any]:\n    \"\"\"Fetch job fee and compute marketplace parameters from the Republic chain.\n\n    Expected fields (illustrative, subject to actual Republic API):\n      - base_job_fee (micro-REP)\n      - min_job_fee (micro-REP)\n      - compute_unit_price (micro-REP per FLOP or compute unit)\n      - fee_split (validator / delegators / treasury ratios)\n      - dynamic_fee (load-based pricing configuration)\n    \"\"\"\n    try:\n        job_fee_raw = await _get(\"/republic/compute/v1/params\")\n    except RuntimeError as exc:\n        # Surface a clearer error so callers/frontends can handle/report it.\n        raise RuntimeError(f\"Failed to fetch job fee parameters: {exc}\") from exc\n\n    return {\n        \"job_fee_params\": job_fee_raw.get(\"params\", job_fee_raw),\n    }\n",
            "usage": "In your backend code, call:\n\njob_fees = await backend_republic_get_job_fee_params()\n\nand, for example, serve it at `/api/economics/job-fees` for your frontend UI."
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "This backend function normalizes raw on-chain economic parameters (from steps 1\u20133) into human-readable sections and attaches chain metadata like chain ID and revision height/hash.",
            "code": "from typing import Any, Dict, Optional\n\n\ndef _to_float(value: Any) -> Optional[float]:\n    \"\"\"Safely convert a value to float, returning None on failure.\"\"\"\n    try:\n        return float(value)\n    except (TypeError, ValueError):\n        return None\n\n\ndef _decimal_to_percent_str(value: Any) -> Optional[str]:\n    \"\"\"Convert a decimal string like \"0.1234\" to a percentage string like \"12.34%\".\"\"\"\n    rate = _to_float(value)\n    if rate is None:\n        return None\n    return f\"{rate * 100:.2f}%\"\n\n\ndef _micro_rep_to_rep(amount: Any, decimals: int = 6) -> Optional[float]:\n    \"\"\"Convert an amount in micro-REP (base units) to REP, assuming 6 decimals.\"\"\"\n    raw = _to_float(amount)\n    if raw is None:\n        return None\n    return raw / (10 ** decimals)\n\n\ndef _duration_to_seconds(duration: Optional[str]) -> Optional[int]:\n    \"\"\"Parse a Cosmos duration string (e.g., \"86400s\") into seconds as int.\"\"\"\n    if not isinstance(duration, str):\n        return None\n    duration = duration.strip()\n    if duration.endswith(\"s\"):\n        duration = duration[:-1]\n    try:\n        return int(float(duration))\n    except ValueError:\n        return None\n\n\ndef normalize_and_format_economic_params(\n    staking_and_rewards_raw: Dict[str, Any],\n    slashing_raw: Dict[str, Any],\n    job_fees_raw: Dict[str, Any],\n    chain_id: str,\n    revision_height: Optional[int] = None,\n    revision_hash: Optional[str] = None,\n) -> Dict[str, Any]:\n    \"\"\"Normalize raw on-chain Republic economic parameters into a UI-friendly summary.\n\n    Inputs:\n      - staking_and_rewards_raw: result of backend_republic_get_staking_and_reward_params()\n      - slashing_raw: result of backend_republic_get_slashing_params()\n      - job_fees_raw: result of backend_republic_get_job_fee_params()\n      - chain_id: network identifier (e.g., \"republic-1\").\n      - revision_height/hash: optional block height/hash associated with these params.\n\n    Behavior:\n      - Converts micro-REP amounts to REP.\n      - Converts decimal rates to percentage strings.\n      - Structures output into Staking & Rewards, Slashing & Penalties,\n        and Job Fees & Compute Rewards sections.\n    \"\"\"\n    staking_params = staking_and_rewards_raw.get(\"staking_params\", {})\n    mint_params = staking_and_rewards_raw.get(\"mint_params\", {})\n    compute_reward_params = staking_and_rewards_raw.get(\"compute_reward_params\", {})\n\n    slashing_params = slashing_raw.get(\"slashing_params\", {})\n    slashing_staking_params = slashing_raw.get(\"staking_params\", {})\n    compute_slashing_params = slashing_raw.get(\"compute_slashing_params\", {})\n\n    job_fee_params = job_fees_raw.get(\"job_fee_params\", {})\n\n    # -------------------------- Staking & Rewards --------------------------\n    unbonding_duration = slashing_staking_params.get(\"unbonding_time\") or staking_params.get(\"unbonding_time\")\n    unbonding_seconds = _duration_to_seconds(unbonding_duration)\n    unbonding_days = unbonding_seconds / 86400 if unbonding_seconds is not None else None\n\n    staking_and_rewards = {\n        \"staking_token_denom\": staking_params.get(\"bond_denom\"),\n        \"unbonding_time_days\": unbonding_days,\n        \"mint_denom\": mint_params.get(\"mint_denom\"),\n        \"inflation_max_percent\": _decimal_to_percent_str(mint_params.get(\"inflation_max\")),\n        \"inflation_min_percent\": _decimal_to_percent_str(mint_params.get(\"inflation_min\")),\n        \"inflation_rate_change_percent\": _decimal_to_percent_str(mint_params.get(\"inflation_rate_change\")),\n        \"goal_bonded_percent\": _decimal_to_percent_str(mint_params.get(\"goal_bonded\")),\n        # Republic-specific compute-related reward multipliers / bonuses (if present).\n        \"base_reward_apr_percent\": _decimal_to_percent_str(compute_reward_params.get(\"base_reward_rate\")),\n        \"max_reputation_multiplier\": _to_float(compute_reward_params.get(\"max_reputation_multiplier\")),\n        \"max_performance_multiplier\": _to_float(compute_reward_params.get(\"max_performance_multiplier\")),\n        \"consensus_participation_bonus_percent\": _decimal_to_percent_str(\n            compute_reward_params.get(\"consensus_participation_bonus_rate\")\n        ),\n        # Preserve the raw payload for advanced users / debugging.\n        \"raw_compute_reward_params\": compute_reward_params,\n    }\n\n    # ------------------------ Slashing & Penalties -------------------------\n    downtime_jail_duration = slashing_params.get(\"downtime_jail_duration\")\n    downtime_jail_seconds = _duration_to_seconds(downtime_jail_duration)\n    downtime_jail_minutes = downtime_jail_seconds / 60 if downtime_jail_seconds is not None else None\n\n    slashing_and_penalties = {\n        \"slash_fraction_double_sign_percent\": _decimal_to_percent_str(\n            slashing_params.get(\"slash_fraction_double_sign\")\n        ),\n        \"slash_fraction_downtime_percent\": _decimal_to_percent_str(\n            slashing_params.get(\"slash_fraction_downtime\")\n        ),\n        \"downtime_jail_duration_minutes\": downtime_jail_minutes,\n        \"signed_blocks_window\": slashing_params.get(\"signed_blocks_window\"),\n        \"min_signed_per_window_percent\": _decimal_to_percent_str(\n            slashing_params.get(\"min_signed_per_window\")\n        ),\n        # Unbonding time also surfaced here for penalty-related UX.\n        \"unbonding_time_days\": unbonding_days,\n        # Republic-specific compute slashing configuration.\n        \"compute_incorrect_result_slash_percent\": _decimal_to_percent_str(\n            compute_slashing_params.get(\"slash_fraction_incorrect_compute\")\n        ),\n        \"compute_delayed_result_slash_percent\": _decimal_to_percent_str(\n            compute_slashing_params.get(\"slash_fraction_delayed_compute\")\n        ),\n        \"compute_misbehavior_threshold\": compute_slashing_params.get(\"max_compute_missed\"),\n        \"raw_compute_slashing_params\": compute_slashing_params,\n    }\n\n    # ------------------- Job Fees & Compute Rewards ------------------------\n    fee_split = job_fee_params.get(\"fee_split\", {})\n    dynamic_fee = job_fee_params.get(\"dynamic_fee\", {})\n\n    job_fees_and_compute_rewards = {\n        \"base_job_fee_rep\": _micro_rep_to_rep(job_fee_params.get(\"base_job_fee\")),\n        \"min_job_fee_rep\": _micro_rep_to_rep(job_fee_params.get(\"min_job_fee\")),\n        \"compute_unit_price_rep\": _micro_rep_to_rep(job_fee_params.get(\"compute_unit_price\")),\n        \"fee_split_percent\": {\n            \"validator\": _decimal_to_percent_str(fee_split.get(\"validator\")),\n            \"delegators\": _decimal_to_percent_str(fee_split.get(\"delegators\")),\n            \"treasury\": _decimal_to_percent_str(fee_split.get(\"treasury\")),\n        },\n        \"dynamic_fee\": {\n            \"enabled\": bool(dynamic_fee.get(\"enabled\", False)),\n            \"max_multiplier\": _to_float(dynamic_fee.get(\"max_multiplier\")),\n            \"target_network_load_percent\": _decimal_to_percent_str(dynamic_fee.get(\"target_network_load\")),\n        },\n        # Preserve raw payload for transparency / debugging.\n        \"raw_job_fee_params\": job_fee_params,\n    }\n\n    # ---------------------------- Final output -----------------------------\n    return {\n        \"network\": {\n            \"chain_id\": chain_id,\n            \"revision_height\": revision_height,\n            \"revision_hash\": revision_hash,\n        },\n        \"staking_and_rewards\": staking_and_rewards,\n        \"slashing_and_penalties\": slashing_and_penalties,\n        \"job_fees_and_compute_rewards\": job_fees_and_compute_rewards,\n    }\n",
            "usage": "After fetching raw parameters via steps 1\u20133, call this in your backend:\n\nsummary = normalize_and_format_economic_params(\n    staking_and_rewards_raw=staking_params,\n    slashing_raw=slashing_params,\n    job_fees_raw=job_fee_params,\n    chain_id=\"republic-1\",\n    revision_height=123456,  # e.g., from a separate chain info query\n    revision_hash=\"ABCDEF...\"  # e.g., latest app hash\n)\n\nReturn `summary` as the payload for your frontend endpoint, such as `/api/economics/summary`."
        }
    ]
}