{
    "label": "send",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a Python helper that verifies the x/bank module is imported in app/app.go and registered in the ModuleManager.",
            "code": "import re\nimport sys\nfrom pathlib import Path\n\n\ndef verify_bank_module(app_go_path: str = \"app/app.go\") -> bool:\n    '''\n    Verifies that the x/bank module is imported in `app/app.go` and included in\n    the ModuleManager. Returns True when both conditions pass, else raises.\n    '''\n    path = Path(app_go_path)\n    if not path.exists():\n        raise FileNotFoundError(f\"{app_go_path} not found\")\n\n    content = path.read_text()\n\n    # Check for import statement\n    if '\"github.com/cosmos/cosmos-sdk/x/bank\"' not in content:\n        raise ValueError(\"x/bank module import not found in app/app.go\")\n\n    # Check for module registration\n    if \"bank.NewAppModule\" not in content and \"bank.AppModuleBasic\" not in content:\n        raise ValueError(\"x/bank module not registered in ModuleManager\")\n\n    print(\"\u2705 x/bank module is correctly imported and registered.\")\n    return True\n\n\nif __name__ == \"__main__\":\n    verify_bank_module(*sys.argv[1:])",
            "usage": "python scripts/verify_bank_module.py"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 creates cmd/bank_send.go with a TxBankSendCmd that builds and broadcasts a MsgSend.",
            "code": "import os\nfrom pathlib import Path\n\nGO_FILE_CONTENT = '''// Code generated by automation; DO NOT EDIT.\npackage cmd\n\nimport (\n    \"fmt\"\n\n    \"github.com/spf13/cobra\"\n    \"github.com/cosmos/cosmos-sdk/client\"\n    sdkcli \"github.com/cosmos/cosmos-sdk/client/flags\"\n    \"github.com/cosmos/cosmos-sdk/client/tx\"\n    sdk \"github.com/cosmos/cosmos-sdk/types\"\n    banktypes \"github.com/cosmos/cosmos-sdk/x/bank/types\"\n)\n\n// TxBankSendCmd creates and broadcasts a MsgSend transaction.\nfunc TxBankSendCmd() *cobra.Command {\n    cmd := &cobra.Command{\n        Use:   \"send [to_address] [amount]\",\n        Short: \"Send tokens to another account\",\n        Args:  cobra.ExactArgs(2),\n        RunE: func(cmd *cobra.Command, args []string) error {\n            clientCtx := client.GetClientContextFromCmd(cmd)\n            if clientCtx == nil {\n                return fmt.Errorf(\"client context is nil\")\n            }\n\n            toAddr, err := sdk.AccAddressFromBech32(args[0])\n            if err != nil {\n                return err\n            }\n\n            amount, err := sdk.ParseCoinsNormalized(args[1])\n            if err != nil {\n                return err\n            }\n\n            fromAddr := clientCtx.GetFromAddress()\n            msg := banktypes.NewMsgSend(fromAddr, toAddr, amount)\n            if err = msg.ValidateBasic(); err != nil {\n                return err\n            }\n\n            return tx.GenerateOrBroadcastTxCLI(clientCtx, cmd.Flags(), msg)\n        },\n    }\n\n    sdkcli.AddTxFlagsToCmd(cmd)\n    return cmd\n}\n'''\n\ndef create_cli_command_file(file_path: str = \"cmd/bank_send.go\") -> None:\n    '''\n    Creates `cmd/bank_send.go` with the TxBankSendCmd implementation.\n    '''\n    path = Path(file_path)\n    path.parent.mkdir(parents=True, exist_ok=True)\n\n    if path.exists():\n        print(f\"{file_path} already exists, skipping write.\")\n        return\n\n    path.write_text(GO_FILE_CONTENT)\n    print(f\"\u2705 {file_path} created with TxBankSendCmd.\")\n\n\nif __name__ == \"__main__\":\n    create_cli_command_file()",
            "usage": "python scripts/create_bank_send_cli.py"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 patches cmd/root.go so TxBankSendCmd is part of the tx sub-command tree.",
            "code": "import re\nfrom pathlib import Path\n\n\ndef register_command_root(root_file: str = \"cmd/root.go\") -> None:\n    '''\n    Inserts TxBankSendCmd into the tx sub-command tree within cmd/root.go.\n    '''\n    path = Path(root_file)\n    if not path.exists():\n        raise FileNotFoundError(f\"{root_file} not found\")\n\n    content = path.read_text()\n\n    # Skip if already exists\n    if \"TxBankSendCmd()\" in content:\n        print(\"TxBankSendCmd already registered, skipping.\")\n        return\n\n    pattern = r\"(?s)(func\\\\s+NewTxCmd\\\\s*\\\\(.*?\\\\)\\\\s*\\\\*cobra.Command\\\\s*{.*?})\"\n    match = re.search(pattern, content)\n    if not match:\n        raise ValueError(\"NewTxCmd definition not found in root.go\")\n\n    block = match.group(1)\n\n    if \"TxBankSendCmd()\" not in block:\n        modified_block = block.replace(\"return txCmd\", \"    txCmd.AddCommand(TxBankSendCmd())\\\\n\\\\n    return txCmd\")\n    else:\n        modified_block = block\n\n    updated_content = content.replace(block, modified_block)\n    path.write_text(updated_content)\n    print(\"\u2705 TxBankSendCmd registered in root.go.\")\n\n\nif __name__ == \"__main__\":\n    register_command_root()",
            "usage": "python scripts/register_command_root.py"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 compiles the binary so the new command becomes available.",
            "code": "import subprocess\nimport sys\nfrom pathlib import Path\n\n\ndef compile_binary() -> None:\n    '''\n    Compiles the binary so the new CLI command is available.\n    Tries `make install` first, then falls back to `go install ./...`.\n    '''\n    makefile_exists = Path(\"Makefile\").exists()\n\n    try:\n        if makefile_exists:\n            subprocess.run([\"make\", \"install\"], check=True)\n        else:\n            raise FileNotFoundError\n    except (subprocess.CalledProcessError, FileNotFoundError):\n        print(\"`make install` unavailable; falling back to `go install ./...`\")\n        try:\n            subprocess.run([\"go\", \"install\", \"./...\"], check=True)\n        except subprocess.CalledProcessError as e:\n            print(\"\u274c Binary compilation failed:\", e)\n            sys.exit(1)\n\n    print(\"\u2705 Binary compiled successfully.\")\n\n\nif __name__ == \"__main__\":\n    compile_binary()",
            "usage": "python scripts/compile_binary.py   # or simply run `make install`"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 executes the help flag to verify the command\u2019s flags and usage render.",
            "code": "import subprocess\nimport sys\n\n\ndef validate_cli_help() -> None:\n    '''\n    Runs `appd tx bank send --help` to ensure command wiring is correct.\n    '''\n    try:\n        subprocess.run([\"appd\", \"tx\", \"bank\", \"send\", \"--help\"], check=True)\n        print(\"\u2705 Help output rendered correctly.\")\n    except subprocess.CalledProcessError as e:\n        print(\"\u274c Unable to render help output:\", e)\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    validate_cli_help()",
            "usage": "python scripts/validate_cli_help.py"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 sends a small test transaction on a local node to confirm signing and broadcasting work.",
            "code": "import subprocess\nimport sys\n\n\ndef broadcast_test_tx(from_key: str, to_addr: str, amount: str = \"1stake\", chain_id: str = \"localnet\", node: str = \"tcp://localhost:26657\") -> None:\n    '''\n    Broadcasts a small MsgSend to verify the new CLI command works end-to-end.\n    '''\n    cmd = [\n        \"appd\", \"tx\", \"bank\", \"send\", to_addr, amount,\n        \"--from\", from_key,\n        \"--chain-id\", chain_id,\n        \"--node\", node,\n        \"-y\"\n    ]\n\n    try:\n        subprocess.run(cmd, check=True)\n        print(\"\u2705 Test transaction broadcasted successfully.\")\n    except subprocess.CalledProcessError as e:\n        print(\"\u274c Test transaction failed:\", e)\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 3:\n        print(\"Usage: broadcast_test_tx.py <from-key> <to-addr> [amount] [chain-id] [node]\")\n        sys.exit(1)\n\n    broadcast_test_tx(*sys.argv[1:])",
            "usage": "python scripts/broadcast_test_tx.py alice cosmos1xyz... 10stake"
        }
    ]
}