{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 provides a Python utility script that forks the Cosmos-SDK x/mint module into a local x/custommint directory and renames all internal package declarations.",
            "code": "# step1.py\nimport os\nimport shutil\nimport logging\nfrom pathlib import Path\n\n\ndef fork_mint_module(project_root: str, new_module_name: str = 'custommint') -> str:\n    # Copy Cosmos-SDK mint module into x/<new_module_name> and rename packages\n    mint_src = Path(project_root) / 'x' / 'mint'\n    mint_dst = Path(project_root) / 'x' / new_module_name\n\n    if not mint_src.exists():\n        raise FileNotFoundError(f'Original mint module not found at {mint_src}')\n\n    if mint_dst.exists():\n        logging.warning('Destination %s already exists. Overwriting...', mint_dst)\n        shutil.rmtree(mint_dst)\n\n    shutil.copytree(mint_src, mint_dst)\n\n    # Update package declarations inside .go files\n    for go_file in mint_dst.rglob('*.go'):\n        content = go_file.read_text()\n        content = content.replace('package mint', f'package {new_module_name}')\n        go_file.write_text(content)\n\n    logging.info('Forked mint module into %s', mint_dst)\n    return str(mint_dst)\n\n\nif __name__ == '__main__':\n    import argparse\n    parser = argparse.ArgumentParser(description='Fork Cosmos-SDK mint module')\n    parser.add_argument('--project_root', required=True, help='Path to the chain source root')\n    parser.add_argument('--module_name', default='custommint')\n    args = parser.parse_args()\n    fork_mint_module(args.project_root, args.module_name)\n",
            "usage": "python step1.py --project_root ./myapp"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 delivers a Python script that injects a custom exponential-decay inflation formula into the newly forked inflation.go file.",
            "code": "# step2.py\nimport re\nimport logging\nfrom pathlib import Path\n\n\ndef implement_custom_inflation_logic(project_root: str, new_module_name: str = 'custommint') -> None:\n    # Inject a new exponential-decay inflation model into x/<new_module_name>/inflation.go\n    inflation_file = Path(project_root) / 'x' / new_module_name / 'inflation.go'\n    if not inflation_file.exists():\n        raise FileNotFoundError(inflation_file)\n\n    content = inflation_file.read_text()\n    pattern = r'func\\s+CalculateInflation[\\s\\S]*?\\}'\n    custom_logic = (\n        '// CalculateInflation replaces the default Cosmos-SDK logic with an exponential\\n'\n        '// decay model.\\n\\n'\n        'func CalculateInflation(params types.Params, firstBlockTime time.Time, blockTime time.Time) sdk.Dec {\\n'\n        '    epochs := int(blockTime.Sub(firstBlockTime).Hours() / (24 * 365))\\n'\n        '    initialInflation := sdk.NewDecWithPrec(20, 2) // 0.20\\n'\n        '    decayFactor := sdk.NewDecWithPrec(98, 2)      // 0.98\\n\\n'\n        '    pow := sdk.OneDec()\\n'\n        '    for i := 0; i < epochs; i++ {\\n'\n        '        pow = pow.Mul(decayFactor)\\n'\n        '    }\\n'\n        '    return initialInflation.Mul(pow)\\n'\n        '}')\n\n    new_content = re.sub(pattern, custom_logic, content, flags=re.MULTILINE)\n    inflation_file.write_text(new_content)\n    logging.info('Custom inflation logic written to %s', inflation_file)\n\n\nif __name__ == '__main__':\n    import argparse\n    parser = argparse.ArgumentParser(description='Inject custom inflation logic')\n    parser.add_argument('--project_root', required=True)\n    parser.add_argument('--module_name', default='custommint')\n    args = parser.parse_args()\n    implement_custom_inflation_logic(args.project_root, args.module_name)\n",
            "usage": "python step2.py --project_root ./myapp"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 creates a Python helper that rewires app.go to import and register the custom mint keeper in place of the default one.",
            "code": "# step3.py\nimport logging\nfrom pathlib import Path\n\n\ndef register_custom_module(project_root: str, new_module_name: str = 'custommint', go_module_path: str = 'github.com/my/app') -> None:\n    # Wire the custom mint module into app.go, replacing the default mint module\n    app_file = Path(project_root) / 'app.go'\n    if not app_file.exists():\n        raise FileNotFoundError(app_file)\n\n    content = app_file.read_text()\n\n    # Replace import path for mint module\n    default_import = '\"github.com/cosmos/cosmos-sdk/x/mint\"'\n    custom_import = f'\"{go_module_path}/x/{new_module_name}\"'\n    if default_import in content and custom_import not in content:\n        content = content.replace(default_import, custom_import)\n\n    # Replace keeper and module registration references\n    content = content.replace('mint.NewKeeper(', f'{new_module_name}.NewKeeper(')\n    content = content.replace('mintmodule.NewAppModule', f'{new_module_name}.NewAppModule')\n\n    app_file.write_text(content)\n    logging.info('app.go updated to use %s module', new_module_name)\n\n\nif __name__ == '__main__':\n    import argparse\n    parser = argparse.ArgumentParser(description='Register custom mint module')\n    parser.add_argument('--project_root', required=True)\n    parser.add_argument('--module_name', default='custommint')\n    parser.add_argument('--go_module_path', default='github.com/my/app')\n    args = parser.parse_args()\n    register_custom_module(args.project_root, args.module_name, args.go_module_path)\n",
            "usage": "python step3.py --project_root ./myapp --go_module_path github.com/my/app"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 supplies a Python script that auto-generates a basic Go unit test for the custom inflation logic, then runs go test and go build to ensure compilation success.",
            "code": "# step4.py\nimport subprocess\nimport logging\nfrom pathlib import Path\n\n\ndef create_inflation_test(project_root: str, new_module_name: str = 'custommint') -> None:\n    test_dir = Path(project_root) / 'x' / new_module_name\n    test_file = test_dir / 'inflation_test.go'\n    if test_file.exists():\n        return\n\n    lines = [\n        f'package {new_module_name}',\n        '',\n        'import (',\n        '    \"testing\"',\n        '    \"time\"',\n        ')',\n        '',\n        'func TestCalculateInflation(t *testing.T) {',\n        '    params := DefaultParams()',\n        '    now := time.Now()',\n        '',\n        '    infStart := CalculateInflation(params, now, now)',\n        '    infNextYear := CalculateInflation(params, now, now.AddDate(1, 0, 0))',\n        '',\n        '    if !infNextYear.LT(infStart) {',\n        '        t.Fatalf(\"expected inflation to decay: got %s >= %s\", infNextYear, infStart)',\n        '    }',\n        '}',\n    ]\n    test_file.write_text('\\n'.join(lines))\n    logging.info('Created %s', test_file)\n\n\ndef go_build_and_unit_test(project_root: str) -> None:\n    create_inflation_test(project_root)\n\n    logging.info('Running go test ./...')\n    result = subprocess.run(['go', 'test', './...'], cwd=project_root)\n    if result.returncode != 0:\n        raise SystemExit('Go tests failed')\n\n    logging.info('Building binaries')\n    result2 = subprocess.run(['go', 'build', './...'], cwd=project_root)\n    if result2.returncode != 0:\n        raise SystemExit('Go build failed')\n\n\nif __name__ == '__main__':\n    import argparse\n    parser = argparse.ArgumentParser(description='Run build and unit tests')\n    parser.add_argument('--project_root', required=True)\n    args = parser.parse_args()\n    go_build_and_unit_test(args.project_root)\n",
            "usage": "python step4.py --project_root ./myapp"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 offers a Python runner that spins up a local devnet node, waits for it to produce blocks, and queries the mint REST endpoints to verify the new inflation values.",
            "code": "# step5.py\nimport subprocess\nimport time\nimport logging\nimport requests\nimport os\nimport signal\n\n\ndef launch_devnet_and_monitor(project_root: str, home: str = './sim_home') -> None:\n    logging.basicConfig(level=logging.INFO)\n    node_cmd = ['simd', 'start', '--home', home]\n    env = os.environ.copy()\n    env['DAEMON_HOME'] = home\n\n    proc = subprocess.Popen(node_cmd, cwd=project_root, stdout=subprocess.PIPE, stderr=subprocess.PIPE, env=env)\n    try:\n        rpc = 'http://localhost:1317'\n        # Wait until REST server is up\n        for _ in range(60):\n            try:\n                r = requests.get(f'{rpc}/node_info', timeout=2)\n                if r.status_code == 200:\n                    break\n            except requests.exceptions.RequestException:\n                pass\n            time.sleep(1)\n        else:\n            raise RuntimeError('REST API did not start in time')\n\n        logging.info('Node is running. Waiting for a few blocks...')\n        time.sleep(10)\n\n        inflation = requests.get(f'{rpc}/cosmos/mint/v1beta1/inflation').json()\n        provisions = requests.get(f'{rpc}/cosmos/mint/v1beta1/annual_provisions').json()\n        logging.info('Current inflation: %s', inflation)\n        logging.info('Annual provisions: %s', provisions)\n    finally:\n        logging.info('Terminating node')\n        proc.send_signal(signal.SIGINT)\n        proc.wait()\n\n\nif __name__ == '__main__':\n    import argparse\n    parser = argparse.ArgumentParser(description='Run local devnet and monitor inflation values')\n    parser.add_argument('--project_root', required=True)\n    parser.add_argument('--home', default='./sim_home')\n    args = parser.parse_args()\n    launch_devnet_and_monitor(args.project_root, args.home)\n",
            "usage": "python step5.py --project_root ./myapp"
        }
    ]
}