{
    "label": "query_balance",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Step 1 validates that an input string is a well-formed Juno (Bech32) address before it is sent to the backend.",
            "code": "/* validateAddress.js  ---------------------------------------------------\n * Utility-level function to confirm that a user-supplied address starts\n * with the required `juno1` prefix and contains the correct Bech32\n * character set/length (38 chars after the prefix).\n */\n\nexport const validateJunoAddress = (address) => {\n  // Basic Bech32 check for Juno addresses. Keeps the logic frontend-safe\n  // by avoiding external libraries.\n  const bech32Regex = /^juno1[0-9a-z]{38}$/;\n\n  if (!address || typeof address !== 'string' || !bech32Regex.test(address)) {\n    throw new Error('Invalid Juno address: must be a Bech32 string that starts with \"juno1\".');\n  }\n\n  return true; // Return true on success so callers can chain further logic\n};",
            "usage": "// In your React/Vue/Svelte component \u2026\ntry {\n  validateJunoAddress(userInputAddress);\n  // proceed to call backend in Step 2\n} catch (err) {\n  console.error(err.message);\n  alert('Please enter a valid Juno address.');\n}"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 spins up a lightweight FastAPI endpoint that fetches the raw balance JSON for a given address from a public LCD node.",
            "code": "'''backend_balances.py ------------------------------------------------------\nFastAPI microservice that proxies a balance query to a public Juno LCD API.\nThis keeps CORS & key-management concerns off the frontend.\n'''\n\nimport re\nfrom typing import Any, Dict\n\nimport httpx\nfrom fastapi import FastAPI, HTTPException\n\napp = FastAPI()\n\nJUNO_LCD_DEFAULT = \"https://api.juno.kingnodes.com\"  # Public LCD; replace if needed\nADDR_REGEX = re.compile(r\"^juno1[0-9a-z]{38}$\")\n\n@app.get(\"/api/raw_balances\", response_model=Dict[str, Any])\nasync def query_raw_balances(address: str, node_url: str = JUNO_LCD_DEFAULT):\n    \"\"\"Fetches *unmodified* balance JSON from the LCD for the provided address.\"\"\"\n    if not ADDR_REGEX.match(address):\n        raise HTTPException(status_code=400, detail=\"Invalid Juno address format.\")\n\n    endpoint = f\"{node_url}/cosmos/bank/v1beta1/balances/{address}\"\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        try:\n            response = await client.get(endpoint)\n            response.raise_for_status()\n        except httpx.HTTPError as exc:\n            # Surface LCD or network failures clearly to consumers\n            raise HTTPException(status_code=502, detail=str(exc)) from exc\n\n    return response.json()",
            "usage": "/* Frontend example */\nconst raw = await fetch(`/api/raw_balances?address=${encodeURIComponent(userInputAddress)}`)\n  .then(res => res.json());\n// Pass `raw` to Step 3 for parsing"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 provides a second FastAPI route that parses the raw LCD JSON into a concise list of denomination/amount pairs, mirroring the user\u2019s original CLI-parsing intent.",
            "code": "from typing import List, Dict, Any\n\n@app.post(\"/api/parse_balances\", response_model=List[Dict[str, str]])\nasync def parse_balances(raw_json: Dict[str, Any]):\n    \"\"\"Extracts `[{'denom': <denom>, 'amount': <amount>}, \u2026]` from the raw LCD payload.\"\"\"\n    try:\n        raw_balances = raw_json.get(\"balances\", [])\n        simplified = [\n            {\"denom\": entry.get(\"denom\", \"\"), \"amount\": entry.get(\"amount\", \"0\")}  \n            for entry in raw_balances\n        ]\n    except (AttributeError, TypeError):\n        raise HTTPException(status_code=400, detail=\"Malformed JSON supplied. Expecting LCD bank/balances response body.\")\n\n    return simplified",
            "usage": "/* Frontend example */\nconst parsed = await fetch('/api/parse_balances', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify(raw)\n}).then(res => res.json());\n\nconsole.table(parsed); // displays denom & amount columns"
        }
    ]
}