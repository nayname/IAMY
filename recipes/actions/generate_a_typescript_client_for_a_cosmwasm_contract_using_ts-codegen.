{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Step 1 provides a Node.js helper that runs `cargo schema` for a CosmWasm contract if needed and verifies that the instantiate, execute, and query JSON schema files exist.",
            "code": "/* scripts/ensureSchemas.js */\n\nconst { execSync } = require('child_process');\nconst fs = require('fs');\nconst path = require('path');\n\n/**\n * Ensure that CosmWasm JSON schema files exist for a contract.\n *\n * - Runs `cargo schema` in the contract directory if the schema folder is missing or empty.\n * - Verifies that execute, query, and instantiate schema files are present.\n *\n * @param {string} contractRootDir - Path to the contract's root directory (where Cargo.toml lives).\n * @param {string} [schemaDirName='schema'] - Name of the directory containing JSON schemas.\n */\nfunction ensureContractSchemas(contractRootDir, schemaDirName = 'schema') {\n  const schemaDir = path.join(contractRootDir, schemaDirName);\n\n  try {\n    // Run `cargo schema` if schema directory doesn't exist or is empty.\n    const schemaDirExists = fs.existsSync(schemaDir);\n    const schemaFiles = schemaDirExists ? fs.readdirSync(schemaDir) : [];\n\n    if (!schemaDirExists || schemaFiles.length === 0) {\n      console.log(`[ensureSchemas] Running 'cargo schema' in ${contractRootDir}...`);\n      execSync('cargo schema', {\n        cwd: contractRootDir,\n        stdio: 'inherit',\n      });\n    } else {\n      console.log(`[ensureSchemas] Found existing schema directory at ${schemaDir}.`);\n    }\n\n    // Re-read directory after possible generation.\n    const finalSchemaFiles = fs.readdirSync(schemaDir);\n\n    const requiredSchemas = [\n      'instantiate_msg.json',\n      'execute_msg.json',\n      'query_msg.json',\n    ];\n\n    const missing = requiredSchemas.filter(\n      (file) => !finalSchemaFiles.includes(file),\n    );\n\n    if (missing.length > 0) {\n      throw new Error(\n        `[ensureSchemas] Missing expected schema files in ${schemaDir}: ${missing.join(', ')}.`,\n      );\n    }\n\n    console.log(\n      `[ensureSchemas] All required schema files present in ${schemaDir}.`,\n    );\n    return { schemaDir, files: finalSchemaFiles };\n  } catch (error) {\n    console.error('[ensureSchemas] Failed to ensure contract schemas:', error);\n    throw error;\n  }\n}\n\n// Allow running as a standalone CLI script.\nif (require.main === module) {\n  const contractRootDir = process.argv[2] || process.cwd();\n  const schemaDirName = process.argv[3] || 'schema';\n\n  try {\n    const result = ensureContractSchemas(contractRootDir, schemaDirName);\n    console.log(\n      `[ensureSchemas] Success. Schema directory: ${result.schemaDir}`,\n    );\n  } catch (error) {\n    process.exit(1);\n  }\n}\n\nmodule.exports = { ensureContractSchemas };\n",
            "usage": "node scripts/ensureSchemas.js ./contracts/my-contract schema\n// Or from another script:\n// const { ensureContractSchemas } = require('./scripts/ensureSchemas');\n// ensureContractSchemas('./contracts/my-contract');"
        },
        {
            "step": 2,
            "label": "frontend",
            "introduction": "Step 2 defines a `ts-codegen.config.ts` file that points to the contract schema directory, sets the output directory for generated TypeScript, and exports reusable Juno network settings including the official LCD archive endpoint.",
            "code": "/* ts-codegen.config.ts */\n\n// Minimal contract list configuration for @cosmwasm/ts-codegen.\nconst contracts = [\n  {\n    // Human-readable name for your contract. Used in generated class/type names.\n    name: 'MyContract',\n    // Relative path to the directory containing JSON schema files.\n    dir: './contracts/my-contract/schema',\n  },\n];\n\n/**\n * Main ts-codegen configuration object.\n * The CLI will import the default export from this file.\n */\nconst config = {\n  contracts,\n  // Directory where generated TypeScript code will be written.\n  outPath: './src/contracts',\n};\n\nexport default config;\n\n/**\n * Optional: shared Juno network configuration used by tests or application code.\n * This is not consumed by ts-codegen directly, but you can import it in\n * your own scripts (for example, the smoke test in step 6).\n */\nexport const junoNetwork = {\n  chainId: 'juno-1',\n  // Use the documented LCD archive endpoint for Juno.\n  lcdEndpoint:\n    process.env.JUNO_LCD_ENDPOINT || 'https://lcd-archive.junonetwork.io',\n  // RPC endpoint is intentionally left to be provided via environment.\n  // See https://cosmos.directory/juno/nodes for public nodes or run your own.\n  rpcEndpoint: process.env.JUNO_RPC_ENDPOINT || 'http://localhost:26657',\n};\n",
            "usage": "// Create ts-codegen.config.ts at the project root with the content above.\n// ts-codegen will automatically load this file when you run, for example:\n// npx @cosmwasm/ts-codegen generate-ts --config ts-codegen.config.ts"
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "Step 3 adds a small Node.js helper that installs `@cosmwasm/ts-codegen` as a devDependency using npm or yarn so the CLI can be invoked via `npx` or scripts.",
            "code": "/* scripts/installTsCodegen.js */\n\nconst { execSync } = require('child_process');\n\n/**\n * Installs @cosmwasm/ts-codegen as a devDependency using npm or yarn.\n *\n * By default this script tries `npm`, and falls back to `yarn` if npm fails.\n */\nfunction installTsCodegen(version = 'latest') {\n  try {\n    console.log(\n      `[installTsCodegen] Installing @cosmwasm/ts-codegen@${version} as devDependency...`,\n    );\n    execSync(`npm install --save-dev @cosmwasm/ts-codegen@${version}`, {\n      stdio: 'inherit',\n    });\n    console.log('[installTsCodegen] Installation via npm completed.');\n  } catch (npmError) {\n    console.warn(\n      '[installTsCodegen] npm install failed, trying yarn add --dev...',\n    );\n    try {\n      execSync(`yarn add --dev @cosmwasm/ts-codegen@${version}`, {\n        stdio: 'inherit',\n      });\n      console.log('[installTsCodegen] Installation via yarn completed.');\n    } catch (yarnError) {\n      console.error(\n        '[installTsCodegen] Failed to install @cosmwasm/ts-codegen with npm and yarn.',\n      );\n      console.error('npm error:', npmError.message);\n      console.error('yarn error:', yarnError.message);\n      throw yarnError;\n    }\n  }\n}\n\n// Allow running as a standalone CLI script.\nif (require.main === module) {\n  const version = process.argv[2] || 'latest';\n  try {\n    installTsCodegen(version);\n  } catch (error) {\n    process.exit(1);\n  }\n}\n\nmodule.exports = { installTsCodegen };\n",
            "usage": "node scripts/installTsCodegen.js\n// Optionally pin a version:\n// node scripts/installTsCodegen.js 0.24.0\n// After running once, @cosmwasm/ts-codegen will be in devDependencies\n// and you can use it via `npx @cosmwasm/ts-codegen ...` or package.json scripts."
        },
        {
            "step": 4,
            "label": "frontend",
            "introduction": "Step 4 provides a Node.js script that invokes the ts-codegen CLI with the configuration file to generate a TypeScript client package into the specified output directory.",
            "code": "/* scripts/generateTsClient.js */\n\nconst { execSync } = require('child_process');\nconst path = require('path');\n\n/**\n * Runs the @cosmwasm/ts-codegen CLI with the provided config file.\n *\n * @param {string} [configPath='ts-codegen.config.ts'] - Path to the ts-codegen config file.\n */\nfunction generateTsClient(configPath = 'ts-codegen.config.ts') {\n  const resolvedConfigPath = path.resolve(configPath);\n\n  try {\n    console.log(\n      `[generateTsClient] Generating TypeScript client using config: ${resolvedConfigPath}`,\n    );\n    // Use npx so that the local devDependency CLI is picked up automatically.\n    execSync(\n      `npx @cosmwasm/ts-codegen generate-ts --config \"${resolvedConfigPath}\"`,\n      {\n        stdio: 'inherit',\n      },\n    );\n    console.log(\n      '[generateTsClient] ts-codegen completed successfully. Check the configured outPath for generated files.',\n    );\n  } catch (error) {\n    console.error(\n      '[generateTsClient] ts-codegen generation failed. See output above for details.',\n    );\n    throw error;\n  }\n}\n\n// Allow running as a standalone CLI script.\nif (require.main === module) {\n  const configPath = process.argv[2] || 'ts-codegen.config.ts';\n  try {\n    generateTsClient(configPath);\n  } catch (error) {\n    process.exit(1);\n  }\n}\n\nmodule.exports = { generateTsClient };\n",
            "usage": "node scripts/generateTsClient.js ts-codegen.config.ts\n// This will generate the contract TypeScript client into the `outPath`\n// defined in ts-codegen.config.ts (e.g., ./src/contracts)."
        },
        {
            "step": 5,
            "label": "frontend",
            "introduction": "Step 5 adds a small Node.js script that runs the TypeScript compiler in `--noEmit` mode to type-check the entire project, including the newly generated client code.",
            "code": "/* scripts/typecheckGeneratedClient.js */\n\nconst { execSync } = require('child_process');\n\n/**\n * Runs the TypeScript compiler in \"noEmit\" mode to type-check the project,\n * including the generated client code.\n *\n * @param {string[]} [extraArgs=[]] - Extra arguments passed to `tsc`.\n */\nfunction typecheckGeneratedClient(extraArgs = []) {\n  const baseCmd = ['npx', 'tsc', '--noEmit', ...extraArgs].join(' ');\n  try {\n    console.log(`[typecheckGeneratedClient] Running: ${baseCmd}`);\n    execSync(baseCmd, { stdio: 'inherit' });\n    console.log('[typecheckGeneratedClient] Type-check completed successfully.');\n  } catch (error) {\n    console.error(\n      '[typecheckGeneratedClient] Type-check failed. Fix TypeScript errors above.',\n    );\n    throw error;\n  }\n}\n\n// Allow running as a standalone CLI script.\nif (require.main === module) {\n  const extraArgs = process.argv.slice(2);\n  try {\n    typecheckGeneratedClient(extraArgs);\n  } catch (error) {\n    process.exit(1);\n  }\n}\n\nmodule.exports = { typecheckGeneratedClient };\n",
            "usage": "node scripts/typecheckGeneratedClient.js\n// Or pass extra args (for example, to use a specific tsconfig file):\n// node scripts/typecheckGeneratedClient.js --project tsconfig.app.json"
        },
        {
            "step": 6,
            "label": "frontend",
            "introduction": "Step 6 implements a TypeScript smoke test that imports the generated contract types, builds a typed query message, and performs a smart contract query against Juno using the official LCD archive endpoint.",
            "code": "/* tests/smokeTestMyContract.ts */\n\nimport { junoNetwork } from '../ts-codegen.config';\n// Adjust the import path and type name based on what ts-codegen generated for your contract.\nimport type { QueryMsg } from '../src/contracts/MyContract.types';\n\n// Use Node 18+ global fetch or bring your own polyfill (for example, node-fetch).\nconst fetchFn: typeof fetch = (globalThis as any).fetch;\n\n/**\n * Encodes a JSON query message to the base64-encoded string that the\n * Juno LCD smart-contract query endpoint expects.\n */\nfunction encodeQueryMsgToBase64(msg: QueryMsg): string {\n  const json = JSON.stringify(msg);\n  return Buffer.from(json, 'utf8').toString('base64');\n}\n\n/**\n * Perform a simple smart-contract query against Juno using the LCD endpoint.\n *\n * This function assumes your contract exposes a `config` query; adjust the\n * `queryMsg` shape to match your actual schema if needed.\n */\nexport async function smokeTestMyContractQuery() {\n  const lcdBaseUrl =\n    junoNetwork.lcdEndpoint || 'https://lcd-archive.junonetwork.io';\n  const contractAddress = process.env.MY_CONTRACT_ADDRESS;\n\n  if (!contractAddress) {\n    throw new Error(\n      'Missing MY_CONTRACT_ADDRESS environment variable (juno1... contract address).',\n    );\n  }\n\n  if (!fetchFn) {\n    throw new Error(\n      'Global fetch is not available. Run this with Node 18+ or provide a fetch polyfill.',\n    );\n  }\n\n  // Example query message: { config: {} }\n  const queryMsg: QueryMsg = {\n    // Replace this with the actual shape of your query.\n    // For example, if your schema has { \"config\": {} }, this is correct.\n    // @ts-expect-error - will be narrowed once you use the real QueryMsg type.\n    config: {},\n  };\n\n  const queryDataBase64 = encodeQueryMsgToBase64(queryMsg);\n  const url = `${lcdBaseUrl}/cosmwasm/wasm/v1/contract/${contractAddress}/smart/${encodeURIComponent(\n    queryDataBase64,\n  )}`;\n\n  console.log('[smokeTestMyContractQuery] Querying URL:', url);\n\n  const response = await fetchFn(url);\n\n  if (!response.ok) {\n    const bodyText = await response.text();\n    throw new Error(\n      `[smokeTestMyContractQuery] LCD request failed: ${response.status} ${response.statusText} - ${bodyText}`,\n    );\n  }\n\n  const body = (await response.json()) as { data: string };\n\n  if (!body || typeof body.data !== 'string') {\n    throw new Error(\n      `[smokeTestMyContractQuery] Unexpected LCD response shape: ${JSON.stringify(\n        body,\n      )}`,\n    );\n  }\n\n  // The `data` field is base64-encoded JSON returned by the contract.\n  const decodedJson = Buffer.from(body.data, 'base64').toString('utf8');\n\n  let parsed: unknown;\n  try {\n    parsed = JSON.parse(decodedJson);\n  } catch (e) {\n    throw new Error(\n      `[smokeTestMyContractQuery] Failed to parse contract response JSON: ${decodedJson}`,\n    );\n  }\n\n  console.log(\n    '[smokeTestMyContractQuery] Contract query successful. Parsed response:',\n  );\n  // eslint-disable-next-line no-console\n  console.dir(parsed, { depth: null });\n\n  return parsed;\n}\n\n// Allow running as a standalone script: `npx ts-node tests/smokeTestMyContract.ts`\nif (require.main === module) {\n  smokeTestMyContractQuery().catch((error) => {\n    console.error('[smokeTestMyContractQuery] Error:', error);\n    process.exit(1);\n  });\n}\n",
            "usage": "MY_CONTRACT_ADDRESS=juno1... npx ts-node tests/smokeTestMyContract.ts\n// The script will:\n// 1. Build a typed QueryMsg using your generated types.\n// 2. Call the Juno LCD endpoint at https://lcd-archive.junonetwork.io\n//    using the /cosmwasm/wasm/v1/contract/{address}/smart/{query_data} route.\n// 3. Decode and log the contract's JSON response for manual verification."
        }
    ]
}