{
    "label": "upload",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 compiles the CosmWasm smart-contract with the official rust-optimizer Docker image and returns the absolute path to the generated .wasm artifact.",
            "code": "import os\nimport subprocess\nfrom pathlib import Path\n\n\ndef compile_contract(source_dir: str, output_dir: str | None = None) -> str:\n    '''\n    Compile a CosmWasm contract using the rust-optimizer Docker image.\n\n    Args:\n        source_dir: root folder of the contract (where Cargo.toml lives).\n        output_dir: folder that will contain the optimized .wasm. Defaults to <source_dir>/artifacts.\n\n    Returns:\n        Absolute path to the optimized .wasm file.\n    '''\n    source_path = Path(source_dir).resolve()\n    if not source_path.exists():\n        raise FileNotFoundError(f'Contract directory {source_path} does not exist')\n\n    out_path = Path(output_dir) if output_dir else source_path / 'artifacts'\n    out_path = out_path.resolve()\n    out_path.mkdir(parents=True, exist_ok=True)\n\n    crate_name = source_path.name.replace('-', '_')\n    artifact_file = out_path / f'{crate_name}.wasm'\n\n    cmd = [\n        'docker', 'run', '--rm',\n        '-v', f'{source_path}:/code',\n        '-v', f'{out_path}:/code/artifacts',\n        '-w', '/code',\n        'cosmwasm/workspace-optimizer:0.14.0'\n    ]\n\n    try:\n        subprocess.run(cmd, check=True, capture_output=True)\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(\n            f'rust-optimizer failed (exit {e.returncode}):\\nSTDOUT:\\n{e.stdout.decode()}\\nSTDERR:\\n{e.stderr.decode()}'\n        )\n\n    if not artifact_file.exists():\n        raise RuntimeError(f'Compilation finished but {artifact_file} was not produced.')\n\n    return str(artifact_file)\n",
            "usage": "POST /api/build  { \"source_dir\": \"./contracts/clock_example\" }\n// \u2192 { \"wasm_path\": \"/abs/path/artifacts/clock_example.wasm\" }"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 uploads the optimized wasm to the Juno testnet (chain-id: uni-6) by broadcasting a MsgStoreCode transaction via cosmpy. It returns the transaction hash so the frontend can track progress.",
            "code": "import os\nfrom pathlib import Path\n\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.protos.cosmwasm.wasm.v1 import tx_pb2 as wasm_tx_pb\n\nJUNO_RPC = os.getenv('JUNO_RPC', 'https://rpc.uni.juno.deuslabs.fi:443')\nCHAIN_ID = os.getenv('CHAIN_ID', 'uni-6')\nFEE_DENOM = 'ujunox'\nGAS_PRICE = float(os.getenv('GAS_PRICE', '0.025'))  # ujunox per gas unit\n\n\ndef store_wasm(wasm_path: str, mnemonic: str) -> str:\n    '''\n    Upload a compiled CosmWasm contract to the chain and return the tx hash.\n    '''\n    path = Path(wasm_path).expanduser().resolve()\n    if not path.exists():\n        raise FileNotFoundError(f'Wasm file {path} does not exist')\n\n    wallet = LocalWallet.from_mnemonic(mnemonic)\n\n    cfg = NetworkConfig(\n        chain_id=CHAIN_ID,\n        url=JUNO_RPC,\n        fee_minimum_gas_price=GAS_PRICE,\n        fee_denomination=FEE_DENOM,\n        staking_denomination=FEE_DENOM,\n    )\n    client = LedgerClient(cfg)\n\n    msg = wasm_tx_pb.MsgStoreCode(\n        sender=wallet.address(),\n        wasm_byte_code=path.read_bytes(),\n    )\n\n    tx = (\n        Transaction()\n        .with_messages(msg)\n        .with_chain_id(CHAIN_ID)\n        .with_fee_denomination(FEE_DENOM)\n        .with_gas_auto_estimate(client, wallet.address())\n    )\n\n    signed = wallet.sign(tx)\n    resp = client.broadcast_tx_async(signed)\n    if resp.is_ok():\n        return resp.txhash\n    raise RuntimeError(f'Broadcast failed: {resp.raw_log}')\n",
            "usage": "POST /api/store  { \"wasm_path\": \"/abs/path/artifacts/clock_example.wasm\", \"mnemonic\": \"<secure-secret>\" }\n// \u2192 { \"tx_hash\": \"0xABCDEF\u2026\" }"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 repeatedly polls the previously returned tx-hash until it is included in a block and then extracts the resulting `code_id` from the transaction logs.",
            "code": "import json\nimport os\nimport time\nfrom typing import Optional\n\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\n\nJUNO_RPC = os.getenv('JUNO_RPC', 'https://rpc.uni.juno.deuslabs.fi:443')\nCHAIN_ID = os.getenv('CHAIN_ID', 'uni-6')\nPOLL_INTERVAL = int(os.getenv('POLL_INTERVAL', '5'))  # seconds\nMAX_POLLS = int(os.getenv('MAX_POLLS', '60'))\n\n\ndef _extract_code_id(raw_log: str) -> Optional[str]:\n    try:\n        logs = json.loads(raw_log or '[]')\n    except Exception:\n        return None\n    for entry in logs:\n        for event in entry.get('events', []):\n            if event.get('type') == 'store_code':\n                for attr in event.get('attributes', []):\n                    if attr.get('key') == 'code_id':\n                        return attr.get('value')\n    return None\n\n\ndef poll_tx_for_code_id(tx_hash: str) -> str:\n    '''Polls for tx inclusion and returns the emitted code_id.'''    \n    cfg = NetworkConfig(url=JUNO_RPC, chain_id=CHAIN_ID)\n    client = LedgerClient(cfg)\n\n    for _ in range(MAX_POLLS):\n        tx = client.query_tx(tx_hash)\n        if tx:\n            if tx.get('code', 0) != 0:\n                raise RuntimeError(f'Tx failed with code {tx[\"code\"]}: {tx.get(\"raw_log\")}')\n            code_id = _extract_code_id(tx.get('raw_log', ''))\n            if code_id:\n                return code_id\n            raise RuntimeError('Tx succeeded but code_id not found in logs.')\n        time.sleep(POLL_INTERVAL)\n    raise TimeoutError('Timed out waiting for transaction to be included.')\n",
            "usage": "GET /api/poll?tx_hash=0xABCDEF\u2026\n// \u2192 { \"code_id\": \"42\" }"
        }
    ]
}