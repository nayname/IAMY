{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a backend helper that maps the symbolic 'republic' label to a concrete chain configuration (chain ID, RPC/REST/indexer URLs).",
            "code": "from dataclasses import dataclass\nfrom typing import Optional\n\n\nclass NetworkResolutionError(Exception):\n    # Raised when a network label cannot be resolved to a known configuration.\n    pass\n\n\n@dataclass\nclass NetworkConfig:\n    chain_id: str\n    rpc_url: str\n    rest_url: str\n    indexer_url: Optional[str] = None\n\n\ndef resolve_network_from_label(network_label: str) -> NetworkConfig:\n    # Map a human-friendly network label (for example, 'republic') to a concrete chain configuration.\n    normalized = network_label.strip().lower()\n\n    # In production, this mapping would usually come from config or environment variables.\n    known_networks = {\n        'republic': NetworkConfig(\n            chain_id='republic-1',\n            rpc_url='https://rpc.republic.org',\n            rest_url='https://api.republic.org',\n            indexer_url='https://indexer.republic.org',\n        ),\n        'republic-mainnet': NetworkConfig(\n            chain_id='republic-1',\n            rpc_url='https://rpc.republic.org',\n            rest_url='https://api.republic.org',\n            indexer_url='https://indexer.republic.org',\n        ),\n        'republic-testnet': NetworkConfig(\n            chain_id='republic-testnet-1',\n            rpc_url='https://rpc-testnet.republic.org',\n            rest_url='https://api-testnet.republic.org',\n            indexer_url='https://indexer-testnet.republic.org',\n        ),\n    }\n\n    cfg = known_networks.get(normalized)\n    if cfg is None:\n        expected = ', '.join(sorted(known_networks.keys()))\n        raise NetworkResolutionError(\n            f'Unknown Republic network label: {network_label!r}. Expected one of: {expected}'\n        )\n\n    return cfg\n",
            "usage": "cfg = resolve_network_from_label('republic')"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 defines an async backend function that queries the Republic staking module for the full validator set, transparently following pagination.",
            "code": "import httpx\nfrom typing import Any, Dict, List, Optional\n\n\nclass ValidatorQueryError(Exception):\n    # Raised when the Republic validator list cannot be fetched.\n    pass\n\n\nasync def query_republic_validators(cfg: NetworkConfig, status: str = 'BOND_STATUS_BONDED') -> List[Dict[str, Any]]:\n    # Fetch the full active validator set from the Republic staking module.\n    # Automatically handles pagination until all validators are retrieved.\n    validators: List[Dict[str, Any]] = []\n    next_key: Optional[str] = None\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            while True:\n                params = {\n                    'status': status,\n                    'pagination.limit': 100,\n                }\n                if next_key:\n                    params['pagination.key'] = next_key\n\n                resp = await client.get(\n                    f'{cfg.rest_url}/cosmos/staking/v1beta1/validators',\n                    params=params,\n                )\n                resp.raise_for_status()\n                data = resp.json()\n\n                batch = data.get('validators', [])\n                validators.extend(batch)\n\n                next_key = data.get('pagination', {}).get('next_key')\n                if not next_key:\n                    break\n\n    except httpx.HTTPStatusError as e:\n        # Surface useful diagnostic information for operators.\n        raise ValidatorQueryError(\n            f'Error response from Republic API while querying validators: {e.response.status_code} {e.response.text}'\n        ) from e\n    except httpx.RequestError as e:\n        raise ValidatorQueryError(\n            f'Network error while querying Republic validators: {e}'\n        ) from e\n\n    return validators\n",
            "usage": "cfg = resolve_network_from_label('republic')\nvalidators = await query_republic_validators(cfg)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 computes total delegated REP stake per validator from staking metadata and attaches it to each validator record.",
            "code": "from decimal import Decimal\nfrom typing import Any, Dict, List\n\n\nREP_DECIMALS = 6  # Assume REP uses 6 decimal places like most Cosmos-SDK tokens.\n\n\ndef query_republic_validator_stake_totals(\n    validators: List[Dict[str, Any]],\n) -> List[Dict[str, Any]]:\n    # For each validator, compute and attach the total delegated stake in REP.\n    # This uses the staking 'tokens' field (total voting power, including self-bond + delegations).\n    enriched: List[Dict[str, Any]] = []\n\n    factor = Decimal(10) ** REP_DECIMALS\n\n    for v in validators:\n        # Defensive copy so we do not mutate the original list in-place unintentionally.\n        record = dict(v)\n\n        raw_tokens = record.get('tokens', '0')\n        try:\n            total_urep = int(raw_tokens)\n        except (TypeError, ValueError):\n            total_urep = 0\n\n        total_rep = Decimal(total_urep) / factor\n\n        record['total_delegated_stake_urep'] = total_urep\n        # Convert to a float for JSON-friendliness; use string if exact precision is critical.\n        record['total_delegated_stake_rep'] = float(total_rep)\n\n        enriched.append(record)\n\n    return enriched\n",
            "usage": "validators_with_stake = query_republic_validator_stake_totals(validators)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 pulls compute benchmark metrics (throughput, inference, achieved FLOPs) for each validator from the Republic compute module.",
            "code": "import asyncio\nfrom typing import Any, Dict, List\n\nimport httpx\n\n\nclass ComputeBenchmarkQueryError(Exception):\n    # Raised when compute benchmark data cannot be fetched from Republic.\n    pass\n\n\nasync def query_republic_compute_benchmarks(\n    cfg: NetworkConfig,\n    validators: List[Dict[str, Any]],\n    concurrency: int = 10,\n) -> Dict[str, Dict[str, Any]]:\n    # Retrieve the latest compute benchmarks for each validator from the Republic\n    # compute module / benchmark registry.\n    #\n    # Returns a mapping:\n    #   { operator_address: { 'throughput': ..., 'inference': ..., 'achieved_flops': ... }, ... }\n    results: Dict[str, Dict[str, Any]] = {}\n\n    semaphore = asyncio.Semaphore(concurrency)\n\n    async def fetch_one(client: httpx.AsyncClient, operator_address: str) -> None:\n        url = f'{cfg.rest_url}/republic/compute/v1/validators/{operator_address}/benchmarks'\n        try:\n            async with semaphore:\n                resp = await client.get(url)\n                if resp.status_code == 404:\n                    # Validator may not yet have benchmark data; record an empty entry.\n                    results[operator_address] = {}\n                    return\n\n                resp.raise_for_status()\n                data = resp.json()\n                # Shape of 'data' is hypothetical and should be aligned with the actual Republic API.\n                results[operator_address] = data.get('benchmarks', data)\n        except httpx.HTTPStatusError:\n            # On any server error, record an empty record so the caller can decide how to surface this.\n            results[operator_address] = {}\n        except httpx.RequestError:\n            results[operator_address] = {}\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            tasks = []\n            for v in validators:\n                operator_address = v.get('operator_address')\n                if not operator_address:\n                    continue\n                tasks.append(fetch_one(client, operator_address))\n            await asyncio.gather(*tasks)\n    except Exception as e:\n        raise ComputeBenchmarkQueryError(\n            f'Failed to query compute benchmarks from Republic: {e}'\n        ) from e\n\n    return results\n",
            "usage": "benchmarks_by_operator = await query_republic_compute_benchmarks(cfg, validators_with_stake)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Step 5 fetches the current reputation score for each validator from the Republic reputation module.",
            "code": "import asyncio\nfrom typing import Any, Dict, List\n\nimport httpx\n\n\nclass ReputationQueryError(Exception):\n    # Raised when reputation scores cannot be fetched from Republic.\n    pass\n\n\nasync def query_republic_reputation_scores(\n    cfg: NetworkConfig,\n    validators: List[Dict[str, Any]],\n    concurrency: int = 10,\n) -> Dict[str, Dict[str, Any]]:\n    # Fetch the current reputation score for each validator from the Republic\n    # reputation module.\n    #\n    # Returns a mapping:\n    #   { operator_address: { 'score': float, ... }, ... }\n    results: Dict[str, Dict[str, Any]] = {}\n    semaphore = asyncio.Semaphore(concurrency)\n\n    async def fetch_one(client: httpx.AsyncClient, operator_address: str) -> None:\n        url = f'{cfg.rest_url}/republic/reputation/v1/validators/{operator_address}'\n        try:\n            async with semaphore:\n                resp = await client.get(url)\n                if resp.status_code == 404:\n                    results[operator_address] = {}\n                    return\n                resp.raise_for_status()\n                data = resp.json()\n                results[operator_address] = data.get('reputation', data)\n        except httpx.HTTPStatusError:\n            results[operator_address] = {}\n        except httpx.RequestError:\n            results[operator_address] = {}\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            tasks = []\n            for v in validators:\n                operator_address = v.get('operator_address')\n                if not operator_address:\n                    continue\n                tasks.append(fetch_one(client, operator_address))\n            await asyncio.gather(*tasks)\n    except Exception as e:\n        raise ReputationQueryError(\n            f'Failed to query reputation scores from Republic: {e}'\n        ) from e\n\n    return results\n",
            "usage": "reputation_by_operator = await query_republic_reputation_scores(cfg, validators_with_stake)"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Step 6 merges staking, benchmark, and reputation data into a unified validator record list keyed by operator address.",
            "code": "from typing import Any, Dict, List\n\n\ndef merge_validator_datasets(\n    validators_with_stake: List[Dict[str, Any]],\n    benchmarks_by_operator: Dict[str, Dict[str, Any]],\n    reputation_by_operator: Dict[str, Dict[str, Any]],\n) -> List[Dict[str, Any]]:\n    # Join the staking, compute benchmark, and reputation datasets into a unified\n    # list of validator records.\n    merged: List[Dict[str, Any]] = []\n\n    for v in validators_with_stake:\n        operator_address = v.get('operator_address')\n        # Work on a shallow copy to avoid side effects on caller data.\n        record = dict(v)\n\n        record['compute_benchmarks'] = benchmarks_by_operator.get(operator_address, {})\n        record['reputation'] = reputation_by_operator.get(operator_address, {})\n\n        merged.append(record)\n\n    return merged\n",
            "usage": "merged_validators = merge_validator_datasets(validators_with_stake, benchmarks_by_operator, reputation_by_operator)"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Step 7 formats the merged validator list into an API-ready response structure for UI consumption and supports basic ordering.",
            "code": "from typing import Any, Dict, List\n\n\ndef format_validator_list_response(\n    merged_validators: List[Dict[str, Any]],\n    order_by: str = 'operator_address',\n) -> Dict[str, Any]:\n    # Convert the merged validator dataset into an API-friendly structure suitable\n    # for serving directly from a backend endpoint.\n    if order_by == 'operator_address':\n        sorted_validators = sorted(\n            merged_validators,\n            key=lambda v: v.get('operator_address', ''),\n        )\n    elif order_by == 'total_stake_desc':\n        sorted_validators = sorted(\n            merged_validators,\n            key=lambda v: int(v.get('total_delegated_stake_urep', 0)),\n            reverse=True,\n        )\n    else:\n        sorted_validators = list(merged_validators)\n\n    output: List[Dict[str, Any]] = []\n\n    for v in sorted_validators:\n        description = v.get('description') or {}\n        if not isinstance(description, dict):\n            description = {}\n\n        output.append(\n            {\n                'operator_address': v.get('operator_address'),\n                'moniker': description.get('moniker'),\n                'identity': description.get('identity'),\n                'website': description.get('website'),\n                'details': description.get('details'),\n                'total_stake_urep': v.get('total_delegated_stake_urep'),\n                'total_stake_rep': v.get('total_delegated_stake_rep'),\n                'benchmarks': v.get('compute_benchmarks', {}),\n                'reputation': v.get('reputation', {}),\n            }\n        )\n\n    return {\n        'validators': output,\n        'count': len(output),\n    }\n",
            "usage": "response_payload = format_validator_list_response(merged_validators, order_by='operator_address')"
        }
    ]
}