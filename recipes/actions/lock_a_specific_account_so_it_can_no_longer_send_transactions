{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Step 1 adds a small helper that requests the user\u2019s Ethereum account from an injected provider (e.g. MetaMask) and returns the first address. No external libraries are required.",
            "code": "/* wallet.js */\nexport const getAccountAddress = async () => {\n  if (typeof window === \"undefined\" || !window.ethereum) {\n    throw new Error(\"No Ethereum provider found. Make sure MetaMask is installed.\");\n  }\n\n  try {\n    // Prompt user to connect their wallet\n    const accounts = await window.ethereum.request({\n      method: \"eth_requestAccounts\"\n    });\n\n    if (!accounts || accounts.length === 0) {\n      throw new Error(\"No accounts returned from provider.\");\n    }\n\n    // Return the first account by convention\n    return accounts[0];\n  } catch (err) {\n    console.error(\"Failed to fetch account address\", err);\n    throw new Error(\"Could not obtain account address. Check console for details.\");\n  }\n};",
            "usage": "const address = await getAccountAddress();"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 defines a reusable Python helper that wraps JSON-RPC calls with optional bearer-token authentication for private namespaces such as `personal_*`.",
            "code": "######################## rpc_helpers.py ########################\nimport os\nimport json\nimport logging\nfrom typing import Any, Dict, List, Optional\n\nimport httpx\n\nJSON_RPC_URL = os.getenv(\"JSON_RPC_URL\", \"http://localhost:8545\")\nAUTH_TOKEN = os.getenv(\"RPC_AUTH_TOKEN\")  # set this in your environment if required\n\nlogger = logging.getLogger(__name__)\n\nclass RPCError(Exception):\n    \"\"\"Custom exception for JSON-RPC errors.\"\"\"\n\n    def __init__(self, code: int, message: str, data: Optional[Any] = None):\n        super().__init__(f\"RPC error {code}: {message}\")\n        self.code = code\n        self.data = data\n\n\ndef _rpc_headers() -> Dict[str, str]:\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    if AUTH_TOKEN:\n        headers[\"Authorization\"] = f\"Bearer {AUTH_TOKEN}\"\n    return headers\n\n\ndef rpc_request(method: str, params: Optional[List[Any]] = None, *, id: int = 1) -> Any:\n    \"\"\"Low-level JSON-RPC request with bearer-token authentication and basic error handling.\"\"\"\n    payload = {\n        \"jsonrpc\": \"2.0\",\n        \"method\": method,\n        \"params\": params or [],\n        \"id\": id,\n    }\n\n    try:\n        response = httpx.post(JSON_RPC_URL, headers=_rpc_headers(), json=payload, timeout=10)\n        response.raise_for_status()\n    except httpx.HTTPError as http_err:\n        logger.exception(\"HTTP error while calling %s\", method)\n        raise RuntimeError(f\"HTTP error while calling {method}: {http_err}\") from http_err\n\n    data = response.json()\n\n    if \"error\" in data:\n        err = data[\"error\"]\n        raise RPCError(err.get(\"code\", -1), err.get(\"message\", \"Unknown error\"), err.get(\"data\"))\n\n    return data.get(\"result\")",
            "usage": "result = rpc_request(\"web3_clientVersion\")"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 exposes a small Flask endpoint that locks the given account by delegating to the helper from Step 2, invoking the `personal_lockAccount` RPC method.",
            "code": "######################## app.py ########################\nimport os\nfrom flask import Flask, request, jsonify\nfrom rpc_helpers import rpc_request, RPCError\n\napp = Flask(__name__)\n\n@app.route(\"/api/lock_account\", methods=[\"POST\"])\ndef lock_account():\n    \"\"\"HTTP endpoint \u2192 personal_lockAccount JSON-RPC call.\"\"\"\n    data = request.get_json(force=True, silent=True) or {}\n    address = data.get(\"address\")\n\n    if not address or not isinstance(address, str):\n        return jsonify({\"error\": \"Missing or invalid 'address' field\"}), 400\n\n    try:\n        result = rpc_request(\"personal_lockAccount\", [address])\n        # Geth returns 'true' if the account was successfully removed from memory\n        return jsonify({\"address\": address, \"locked\": bool(result)})\n    except RPCError as rpc_err:\n        return jsonify({\"error\": str(rpc_err), \"code\": rpc_err.code}), 500\n    except Exception as exc:\n        return jsonify({\"error\": str(exc)}), 500\n\nif __name__ == \"__main__\":\n    port = int(os.getenv(\"PORT\", 5000))\n    app.run(host=\"0.0.0.0\", port=port)",
            "usage": "// frontend usage example\nconst response = await fetch(\"/api/lock_account\", {\n  method: \"POST\",\n  headers: { \"Content-Type\": \"application/json\" },\n  body: JSON.stringify({ address }),\n});\nconst data = await response.json();\nif (data.locked) {\n  console.log(`${data.address} successfully locked.`);\n} else {\n  console.error(\"Locking failed:\", data.error);\n}"
        }
    ]
}