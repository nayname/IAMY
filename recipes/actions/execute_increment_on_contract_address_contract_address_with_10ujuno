{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Build the `{ \"increment\": {} }` execute message in the browser and forward it to a backend endpoint that will actually submit the transaction on behalf of the user.",
            "code": "/* utils/wasmExecute.js */\nexport const sendIncrementRequest = async (contractAddress) => {\n  try {\n    // 1.  Compose the execute message exactly as the contract expects\n    const executeMsg = { increment: {} };\n\n    // 2.  POST the payload to the backend-for-frontend (BFF)\n    const res = await fetch('/api/execute_increment', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ contractAddress, executeMsg })\n    });\n\n    if (!res.ok) {\n      const text = await res.text();\n      throw new Error(`Backend error: ${text}`);\n    }\n\n    // 3.  Return the tx hash so the caller can display a link to a block-explorer\n    const json = await res.json();\n    return json; // { txHash: '...', height: 123456 }\n  } catch (err) {\n    console.error('[sendIncrementRequest] failed', err);\n    throw err;\n  }\n};",
            "usage": "const { txHash } = await sendIncrementRequest(CONTRACT_ADDRESS);"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Receive the request from Step 1, create a MsgExecuteContract, sign it with a server-side key (kept secret in an environment variable) and broadcast it.  This uses cosmpy, so it belongs in the backend.",
            "code": "### api/execute_increment.py\nimport os\nimport json\nimport logging\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.wallet import PrivateKey\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.gas import GasPrice, calculate_fee\nfrom cosmpy.common.types import Coins\nfrom cosmpy.protos.cosmwasm.wasm.v1.tx_pb2 import MsgExecuteContract\n\nrouter = APIRouter()\n\n# --------- configuration (override with env vars in production) ---------\nRPC_ENDPOINT = os.getenv(\"RPC_ENDPOINT\", \"https://rpc.juno.deuslabs.fi\")\nCHAIN_ID     = os.getenv(\"CHAIN_ID\", \"juno-1\")\nGAS_PRICE    = GasPrice(0.025, \"ujuno\")  # 0.025 ujuno / gas is typical for Juno\n\nNETWORK = NetworkConfig(\n    chain_id=CHAIN_ID,\n    url=RPC_ENDPOINT,\n    fee_minimum_gas_price=GAS_PRICE.amount,\n    fee_denomination=GAS_PRICE.denom,\n)\n\n# ------------------------ request schema -------------------------------\nclass ExecuteRequest(BaseModel):\n    contractAddress: str\n    executeMsg: dict\n\n# ---------------------------- endpoint ---------------------------------\n@router.post(\"/api/execute_increment\")\nasync def execute_increment(req: ExecuteRequest):\n    \"\"\"Broadcast a MsgExecuteContract that sends `{increment:{}}` and 10 ujuno funds.\"\"\"\n    mnemonic = os.getenv(\"WALLET_MNEMONIC\")\n    if not mnemonic:\n        raise HTTPException(status_code=500, detail=\"Missing WALLET_MNEMONIC environment variable\")\n\n    try:\n        # 1.  Initialise wallet & client\n        key     = PrivateKey.from_mnemonic(mnemonic)\n        address = key.address()\n        client  = LedgerClient(NETWORK)\n\n        # 2.  Build the protobuf MsgExecuteContract\n        msg = MsgExecuteContract(\n            sender   = address,\n            contract = req.contractAddress,\n            msg      = json.dumps(req.executeMsg).encode(),\n            funds    = Coins.from_coins(\"10ujuno\")  # attach 10 ujuno as payment\n        )\n\n        # 3.  Craft & sign the transaction (automatic fee & gas-adjustment)\n        tx = Transaction()\n        tx.add_message(msg)\n        tx.with_sender(address)\n        tx.with_gas(calculate_fee(tx, gas_price=GAS_PRICE, gas_adjustment=1.3))\n        signed_tx = tx.sign(key)\n\n        # 4.  Broadcast and wait for finalization (\"block\" mode)\n        result = client.broadcast_tx_block(signed_tx)\n        if result.is_err():\n            #  Broadcast succeeded but blockchain returned error code\n            logging.error(\"execute_increment error: %s\", result)\n            raise HTTPException(status_code=400, detail=str(result))\n\n        return {\"txHash\": result.tx_hash, \"height\": result.height}\n\n    except Exception as e:\n        logging.exception(\"execute_increment failed\")\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "POST /api/execute_increment { \"contractAddress\": \"juno1...\", \"executeMsg\": { \"increment\": {} } }"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Optional utility that actively polls the node until the transaction hash from Step 2 is found.  This can be useful when the broadcast mode is set to `sync` or `async` instead of `block`.",
            "code": "### utils/tx_waiter.py\nimport time\nfrom typing import Optional\nfrom cosmpy.aerial.client import LedgerClient\nfrom .execute_increment import NETWORK  # reuse the same network config\n\nclient = LedgerClient(NETWORK)\n\nasync def wait_for_tx_commit(tx_hash: str, timeout: int = 60) -> Optional[dict]:\n    \"\"\"Poll the node every 2 s until the tx is indexed or the timeout elapses.\"\"\"\n    deadline = time.time() + timeout\n    while time.time() < deadline:\n        tx_info = client.query_tx(tx_hash)\n        if tx_info:\n            return tx_info\n        time.sleep(2)\n    raise TimeoutError(f\"Transaction {tx_hash} not found within {timeout}s\")",
            "usage": "await wait_for_tx_commit(txHash)"
        },
        {
            "step": 4,
            "label": "frontend",
            "introduction": "Perform a read-only smart query (`{ \"get_count\": {} }`) directly from the browser via the chain\u2019s public LCD endpoint.  No external libraries are required\u2014just `fetch`.",
            "code": "/* utils/queryCount.js */\nexport const queryCount = async (contractAddress) => {\n  // 1.  Prepare base64-encoded query payload (LCD expects this format)\n  const query = { get_count: {} };\n  const queryB64 = btoa(JSON.stringify(query));\n\n  // 2.  Craft LCD URL.  You can replace the endpoint with any public Juno LCD.\n  const lcd = 'https://lcd.juno.deuslabs.fi';\n  const url = `${lcd}/cosmwasm/wasm/v1/contract/${contractAddress}/smart/${queryB64}`;\n\n  // 3.  Execute HTTP GET\n  const res = await fetch(url);\n  if (!res.ok) {\n    const errText = await res.text();\n    throw new Error(`Smart-query failed: ${errText}`);\n  }\n\n  const json = await res.json();\n  /* Expected response shape:\n     {\n       \"data\": {\n         \"count\": 42\n       }\n     }\n  */\n  return json.data;\n};",
            "usage": "const { count } = await queryCount(CONTRACT_ADDRESS);"
        }
    ]
}