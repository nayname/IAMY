{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Backend Python helper that queries the Juno LCD to ensure a CosmWasm contract exists at the given CONTRACT_ADDRESS.",
            "code": "import requests\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef lcd_verify_contract_exists(contract_address: str) -> dict:\n    '''\n    Confirm that a CosmWasm contract exists at the given address on Juno.\n    Raises an exception if the contract is not found or the LCD call fails.\n    '''\n    if not contract_address:\n        raise ValueError('contract_address must be a non-empty Bech32 address.')\n\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}'\n\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query contract info from LCD: {exc}') from exc\n\n    data = response.json()\n\n    # The LCD should return an object containing the contract_info field on success.\n    if 'contract_info' not in data:\n        raise ValueError(f'LCD response does not contain contract_info for {contract_address}: {data}')\n\n    return data",
            "usage": "contract_info = lcd_verify_contract_exists(CONTRACT_ADDRESS)"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Backend helper that constructs the CosmWasm execute message for incrementing a counter and returns both the normalized JSON and UTF-8 bytes.",
            "code": "import json\nfrom typing import Tuple, Dict, Any\n\ndef bff_prepare_execute_msg_increment() -> Tuple[Dict[str, Any], bytes]:\n    '''\n    Build the CosmWasm execute message for incrementing a counter and\n    return both the normalized JSON object and its UTF-8 encoded bytes.\n    '''\n    msg = {'increment': {}}\n\n    try:\n        # Normalize JSON: no extra spaces and deterministic key ordering.\n        json_str = json.dumps(msg, separators=(',', ':'), sort_keys=True)\n        msg_bytes = json_str.encode('utf-8')\n    except (TypeError, ValueError) as exc:\n        raise RuntimeError(f'Failed to encode execute message as JSON: {exc}') from exc\n\n    return msg, msg_bytes",
            "usage": "execute_msg_json, execute_msg_bytes = bff_prepare_execute_msg_increment()"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Backend function that queries Juno LCD for chain-id and the sender\u2019s account_number and sequence.",
            "code": "import requests\nfrom typing import Dict, Any\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef bff_get_chain_and_account_info(address: str) -> Dict[str, Any]:\n    '''\n    Fetch the Juno chain_id and the account_number/sequence for the given address\n    using the LCD node_info and accounts endpoints.\n    '''\n    if not address:\n        raise ValueError('address must be a non-empty Bech32 string.')\n\n    # Fetch chain-id from node_info\n    node_info_url = f'{LCD_BASE_URL}/cosmos/base/tendermint/v1beta1/node_info'\n    try:\n        node_resp = requests.get(node_info_url, timeout=10)\n        node_resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query node_info from LCD: {exc}') from exc\n\n    node_data = node_resp.json()\n    default_node_info = node_data.get('default_node_info') or {}\n    chain_id = default_node_info.get('network')\n    if not chain_id:\n        raise RuntimeError(f'Could not determine chain_id from node_info response: {node_data}')\n\n    # Fetch account information\n    acct_url = f'{LCD_BASE_URL}/cosmos/auth/v1beta1/accounts/{address}'\n    try:\n        acct_resp = requests.get(acct_url, timeout=10)\n        acct_resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query account data from LCD: {exc}') from exc\n\n    acct_data = acct_resp.json()\n    account = acct_data.get('account')\n    if not account:\n        raise RuntimeError(f'No account data found for address {address}: {acct_data}')\n\n    # BaseAccount is typically inlined in JSON with these fields.\n    account_number_str = account.get('account_number')\n    sequence_str = account.get('sequence')\n\n    if account_number_str is None or sequence_str is None:\n        raise RuntimeError(\n            f'Account number or sequence missing in LCD response for {address}: {account}'\n        )\n\n    try:\n        account_number = int(account_number_str)\n        sequence = int(sequence_str)\n    except ValueError as exc:\n        raise RuntimeError(\n            f'Failed to parse account_number/sequence as integers: {account_number_str}/{sequence_str}'\n        ) from exc\n\n    return {\n        'chain_id': chain_id,\n        'account_number': account_number,\n        'sequence': sequence,\n        'raw_account': account,\n    }",
            "usage": "acct_info = bff_get_chain_and_account_info(sender_address)\nchain_id = acct_info['chain_id']\naccount_number = acct_info['account_number']\nsequence = acct_info['sequence']"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Backend helper that checks the sender\u2019s spendable ujuno balance via LCD and ensures it covers 10ujuno plus estimated fees.",
            "code": "import requests\nfrom typing import Dict, Any\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef lcd_check_spendable_balance_for_ujuno(address: str, required_ujuno: int) -> Dict[str, Any]:\n    '''\n    Ensure the address has at least `required_ujuno` (in ujuno, the base denom) available.\n    This should cover both the 10ujuno contract funds and anticipated fee amount.\n    '''\n    if not address:\n        raise ValueError('address must be a non-empty Bech32 string.')\n\n    if required_ujuno <= 0:\n        raise ValueError('required_ujuno must be a positive integer representing ujuno.')\n\n    url = f'{LCD_BASE_URL}/cosmos/bank/v1beta1/balances/{address}/by_denom'\n    params = {'denom': 'ujuno'}\n\n    try:\n        resp = requests.get(url, params=params, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query ujuno balance from LCD: {exc}') from exc\n\n    data = resp.json()\n    balance_obj = data.get('balance') or {}\n    amount_str = balance_obj.get('amount', '0')\n\n    try:\n        available = int(amount_str)\n    except ValueError as exc:\n        raise RuntimeError(f'LCD returned non-integer balance amount: {amount_str}') from exc\n\n    if available < required_ujuno:\n        raise RuntimeError(\n            f'Insufficient ujuno balance. Required {required_ujuno}, available {available}.'\n        )\n\n    return {\n        'available_ujuno': available,\n        'required_ujuno': required_ujuno,\n    }",
            "usage": "balance_info = lcd_check_spendable_balance_for_ujuno(sender_address, required_ujuno=10 + estimated_fee_ujuno)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Backend builder that constructs an unsigned TxRaw with a single MsgExecuteContract increment call and provisional gas and fee for later simulation.",
            "code": "from decimal import Decimal, ROUND_UP\n\nfrom cosmos_sdk_proto.cosmwasm.wasm.v1.tx_pb2 import MsgExecuteContract\nfrom cosmos_sdk_proto.cosmos.base.v1beta1.coin_pb2 import Coin\nfrom cosmos_sdk_proto.cosmos.tx.v1beta1.tx_pb2 import TxBody, AuthInfo, TxRaw, Fee\nfrom google.protobuf.any_pb2 import Any as AnyMessage\n\ndef bff_construct_execute_contract_tx(\n    sender: str,\n    contract_address: str,\n    msg_bytes: bytes,\n    funds_ujuno: int = 10,\n    initial_gas_limit: int = 200000,\n    gas_price_ujuno: Decimal = Decimal('0.025'),\n) -> TxRaw:\n    '''\n    Build an unsigned TxRaw with a single MsgExecuteContract for simulation.\n    signer_infos are left empty; this Tx should only be used for gas simulation.\n\n    funds_ujuno is the amount of ujuno to send to the contract (10 by default).\n    initial_gas_limit and gas_price_ujuno are used to compute a provisional fee.\n    '''\n    if not sender or not contract_address:\n        raise ValueError('sender and contract_address must be non-empty strings.')\n\n    if initial_gas_limit <= 0:\n        raise ValueError('initial_gas_limit must be positive.')\n\n    # Build the CosmWasm execute message.\n    exec_msg = MsgExecuteContract(\n        sender=sender,\n        contract=contract_address,\n        msg=msg_bytes,\n        funds=[Coin(denom='ujuno', amount=str(funds_ujuno))],\n    )\n\n    any_msg = AnyMessage(\n        type_url='/cosmwasm.wasm.v1.MsgExecuteContract',\n        value=exec_msg.SerializeToString(),\n    )\n\n    tx_body = TxBody(\n        messages=[any_msg],\n        memo='',\n        timeout_height=0,\n    )\n    body_bytes = tx_body.SerializeToString()\n\n    # Provisional fee based on initial gas limit and gas price.\n    fee_amount = (Decimal(initial_gas_limit) * gas_price_ujuno).to_integral_value(\n        rounding=ROUND_UP\n    )\n\n    fee = Fee(\n        amount=[Coin(denom='ujuno', amount=str(fee_amount))],\n        gas_limit=initial_gas_limit,\n        payer='',\n        granter='',\n    )\n\n    auth_info = AuthInfo(\n        signer_infos=[],  # filled later when signing\n        fee=fee,\n    )\n    auth_info_bytes = auth_info.SerializeToString()\n\n    tx_raw = TxRaw(\n        body_bytes=body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        signatures=[],  # no signatures for simulation\n    )\n\n    return tx_raw",
            "usage": "unsigned_tx_for_sim = bff_construct_execute_contract_tx(sender_address, CONTRACT_ADDRESS, execute_msg_bytes)"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Backend function that simulates the unsigned execute transaction via Juno LCD, and returns recommended gas_limit and fee in ujuno.",
            "code": "import base64\nfrom decimal import Decimal, ROUND_UP\nfrom typing import Dict, Any\n\nimport requests\nfrom cosmos_sdk_proto.cosmos.tx.v1beta1.tx_pb2 import TxRaw\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef lcd_simulate_tx(\n    tx_raw: TxRaw,\n    gas_adjustment: float = 1.3,\n    gas_price_ujuno: Decimal = Decimal('0.025'),\n) -> Dict[str, Any]:\n    '''\n    Simulate the given unsigned TxRaw via LCD and compute a recommended gas limit\n    and fee (in ujuno).\n    '''\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive.')\n\n    tx_bytes = tx_raw.SerializeToString()\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('ascii'),\n    }\n\n    url = f'{LCD_BASE_URL}/cosmos/tx/v1beta1/simulate'\n    try:\n        resp = requests.post(url, json=payload, timeout=20)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to simulate transaction via LCD: {exc}') from exc\n\n    sim_result = resp.json()\n    gas_info = sim_result.get('gas_info') or {}\n    gas_used_str = gas_info.get('gas_used')\n\n    if gas_used_str is None:\n        raise RuntimeError(f'LCD simulation response missing gas_used: {sim_result}')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError as exc:\n        raise RuntimeError(f'Invalid gas_used value: {gas_used_str}') from exc\n\n    recommended_gas_limit = int(gas_used * gas_adjustment)\n    fee_amount = (Decimal(recommended_gas_limit) * gas_price_ujuno).to_integral_value(\n        rounding=ROUND_UP\n    )\n\n    return {\n        'gas_used': gas_used,\n        'recommended_gas_limit': recommended_gas_limit,\n        'recommended_fee_ujuno': int(fee_amount),\n        'raw_response': sim_result,\n    }",
            "usage": "simulation = lcd_simulate_tx(unsigned_tx_for_sim)\nrecommended_gas_limit = simulation['recommended_gas_limit']\nrecommended_fee_ujuno = simulation['recommended_fee_ujuno']"
        },
        {
            "step": 7,
            "label": "backend",
            "introduction": "Backend signer that builds final AuthInfo with the latest account_number and sequence, signs the execute transaction, and returns raw tx bytes.",
            "code": "from typing import Dict, Any\n\nfrom cosmpy.crypto.keypairs import PrivateKey\nfrom cosmos_sdk_proto.cosmos.tx.v1beta1.tx_pb2 import (\n    TxRaw,\n    AuthInfo,\n    SignerInfo,\n    ModeInfo,\n    Fee,\n    SignDoc,\n)\nfrom cosmos_sdk_proto.cosmos.tx.signing.v1beta1.signing_pb2 import SignMode\nfrom cosmos_sdk_proto.cosmos.crypto.secp256k1.keys_pb2 import PubKey\nfrom cosmos_sdk_proto.cosmos.base.v1beta1.coin_pb2 import Coin\nfrom google.protobuf.any_pb2 import Any as AnyMessage\n\ndef bff_sign_execute_tx(\n    unsigned_tx: TxRaw,\n    chain_id: str,\n    account_number: int,\n    sequence: int,\n    fee_amount_ujuno: int,\n    gas_limit: int,\n    private_key_hex: str,\n) -> bytes:\n    '''\n    Sign the execute transaction with the provided private key and return raw tx bytes.\n\n    unsigned_tx should contain the body_bytes from the MsgExecuteContract built earlier.\n    fee_amount_ujuno and gas_limit should come from the simulation step.\n    '''\n    if fee_amount_ujuno < 0:\n        raise ValueError('fee_amount_ujuno must be non-negative.')\n    if gas_limit <= 0:\n        raise ValueError('gas_limit must be positive.')\n    if not chain_id:\n        raise ValueError('chain_id must be a non-empty string.')\n\n    # Load the private key (secp256k1)\n    try:\n        privkey = PrivateKey(bytes.fromhex(private_key_hex))\n    except Exception as exc:\n        raise RuntimeError('Failed to load private key from hex.') from exc\n\n    pubkey = PubKey(key=privkey.public_key.bytes)\n    any_pubkey = AnyMessage(\n        type_url='/cosmos.crypto.secp256k1.PubKey',\n        value=pubkey.SerializeToString(),\n    )\n\n    mode_info = ModeInfo(single=ModeInfo.Single(mode=SignMode.SIGN_MODE_DIRECT))\n\n    signer_info = SignerInfo(\n        public_key=any_pubkey,\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    fee = Fee(\n        amount=[Coin(denom='ujuno', amount=str(fee_amount_ujuno))],\n        gas_limit=gas_limit,\n        payer='',\n        granter='',\n    )\n\n    auth_info = AuthInfo(\n        signer_infos=[signer_info],\n        fee=fee,\n    )\n    auth_info_bytes = auth_info.SerializeToString()\n\n    sign_doc = SignDoc(\n        body_bytes=unsigned_tx.body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n    sign_doc_bytes = sign_doc.SerializeToString()\n\n    # cosmpy PrivateKey.sign returns a 64-byte secp256k1 signature compatible with Cosmos.\n    signature = privkey.sign(sign_doc_bytes)\n\n    signed_tx = TxRaw(\n        body_bytes=unsigned_tx.body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        signatures=[signature],\n    )\n\n    return signed_tx.SerializeToString()",
            "usage": "signed_tx_bytes = bff_sign_execute_tx(\n    unsigned_tx=unsigned_tx_for_sim,\n    chain_id=chain_id,\n    account_number=account_number,\n    sequence=sequence,\n    fee_amount_ujuno=recommended_fee_ujuno,\n    gas_limit=recommended_gas_limit,\n    private_key_hex=BACKEND_HEX_PRIVATE_KEY,\n)"
        },
        {
            "step": 8,
            "label": "backend",
            "introduction": "Backend function that broadcasts the signed execute transaction to the Juno LCD and returns the tx_response, including txhash, height, code, and logs.",
            "code": "import base64\nfrom typing import Dict, Any\n\nimport requests\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef lcd_broadcast_tx(tx_bytes: bytes, mode: str = 'BROADCAST_MODE_BLOCK') -> Dict[str, Any]:\n    '''\n    Broadcast a signed transaction to the Juno LCD and return the full tx_response.\n    '''\n    if not tx_bytes:\n        raise ValueError('tx_bytes must not be empty.')\n\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('ascii'),\n        'mode': mode,\n    }\n\n    url = f'{LCD_BASE_URL}/cosmos/tx/v1beta1/txs'\n    try:\n        resp = requests.post(url, json=payload, timeout=30)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to broadcast transaction via LCD: {exc}') from exc\n\n    data = resp.json()\n    tx_response = data.get('tx_response')\n    if tx_response is None:\n        raise RuntimeError(f'LCD broadcast response missing tx_response: {data}')\n\n    return tx_response",
            "usage": "tx_response = lcd_broadcast_tx(signed_tx_bytes, mode='BROADCAST_MODE_BLOCK')"
        },
        {
            "step": 9,
            "label": "backend",
            "introduction": "Backend helper that validates the execute tx succeeded (code == 0), checks for wasm events in the logs, and provides an optional query helper for the counter.",
            "code": "import base64\nimport json\nfrom typing import Dict, Any\n\nimport requests\n\nLCD_BASE_URL = 'https://lcd-archive.junonetwork.io'\n\ndef query_counter(contract_address: str) -> int:\n    '''\n    Query the contract's `get_count` smart query and return the current counter value.\n    This assumes the contract responds with JSON like {'count': <int>}.\n    '''\n    if not contract_address:\n        raise ValueError('contract_address must be a non-empty Bech32 address.')\n\n    query_msg = {'get_count': {}}\n    try:\n        query_json = json.dumps(query_msg, separators=(',', ':'), sort_keys=True)\n        query_bytes = query_json.encode('utf-8')\n    except (TypeError, ValueError) as exc:\n        raise RuntimeError(f'Failed to encode get_count query: {exc}') from exc\n\n    query_b64 = base64.b64encode(query_bytes).decode('ascii')\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_b64}'\n\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query contract counter via LCD: {exc}') from exc\n\n    data = resp.json()\n\n    # Some chains wrap smart-query responses as {'data': {...}}.\n    if 'data' in data:\n        payload = data['data']\n    else:\n        payload = data\n\n    if not isinstance(payload, dict) or 'count' not in payload:\n        raise RuntimeError(f'Unexpected get_count response: {data}')\n\n    try:\n        return int(payload['count'])\n    except (TypeError, ValueError) as exc:\n        raise RuntimeError(f'Counter value is not an integer: {payload}') from exc\n\n\ndef lcd_verify_execute_effect(contract_address: str, tx_response: Dict[str, Any]) -> Dict[str, Any]:\n    '''\n    Verify that the execute transaction succeeded and emitted at least one wasm event.\n    Returns a summary including txhash, height, and the collected wasm events.\n    '''\n    if tx_response is None:\n        raise ValueError('tx_response must not be None.')\n\n    code = int(tx_response.get('code', 0))\n    if code != 0:\n        raise RuntimeError(f'Execute transaction failed with code {code}: {tx_response.get(\"raw_log\")}')\n\n    wasm_events = []\n    for log in tx_response.get('logs', []):\n        for event in log.get('events', []):\n            if event.get('type') == 'wasm':\n                wasm_events.append(event)\n\n    if not wasm_events:\n        raise RuntimeError('No wasm events found in tx_response logs; execute may not have run as expected.')\n\n    return {\n        'success': True,\n        'txhash': tx_response.get('txhash'),\n        'height': tx_response.get('height'),\n        'wasm_events': wasm_events,\n    }",
            "usage": "verification = lcd_verify_execute_effect(CONTRACT_ADDRESS, tx_response)\n\n# Optional pattern to assert the counter increased by 1:\n# before = query_counter(CONTRACT_ADDRESS)\n# ... broadcast execute tx ...\n# after = query_counter(CONTRACT_ADDRESS)\n# assert after == before + 1"
        }
    ]
}