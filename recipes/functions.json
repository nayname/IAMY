{
	"_ping": "def _ping(url: str, timeout: float = 1.5) -> float:\n    \"\"\"Return response-time in seconds (∞ if unreachable).\"\"\"\n    start = time.time()\n    try:\n        requests.head(url, timeout=timeout)\n        return time.time() - start\n    except requests.RequestException:\n        return float(\"inf\")",
	"select_data_provider": "def select_data_provider(prefer_graphql: bool = True) -> Dict[str, str]:\n    \"\"\"Choose the fastest available provider and return a descriptor dict.\"\"\"\n    providers = [\n        {\n            \"name\": \"celatone\",\n            \"base_url\": \"https://celatone-api.neutron.org/v1/graphql\",\n            \"api_type\": \"graphql\",\n        },\n        {\n            \"name\": \"lcd\",\n            \"base_url\": \"https://lcd.neutron.org\",\n            \"api_type\": \"rest\",\n        },\n    ]\n\n    # If GraphQL is preferred, try it first.\n    if prefer_graphql:\n        graphql_providers = [p for p in providers if p[\"api_type\"] == \"graphql\"]\n        if graphql_providers and _ping(graphql_providers[0][\"base_url\"]) != float(\"inf\"):\n            return graphql_providers[0]\n\n    # Fallback: choose the provider with the lowest latency.\n    best = min(providers, key=lambda p: _ping(p[\"base_url\"]))\n    if _ping(best[\"base_url\"]) == float(\"inf\"):\n        raise RuntimeError(\"No data provider is reachable at the moment.\")\n    return best",
	"build_history_query": "def build_history_query(\n    provider: Dict[str, str],\n    address: str,\n    limit: int = 50,\n    cursor: Optional[str] = None,\n    offset: int = 0,\n) -> Tuple[str, Union[Dict[str, Any], None]]:\n    \"\"\"Return (query_or_endpoint, variables_or_params) ready for Step 3.\"\"\"\n    if provider[\"api_type\"] == \"graphql\":\n        # Celatone GraphQL query string with optional cursor for pagination.\n        gql_query = (\n            \"\"\"\n            query ($address: String!, $limit: Int!, $cursor: String) {\n              messages(\n                where: {sender: {_eq: $address}},\n                order_by: {block: {time: desc}},\n                limit: $limit,\n                %s\n              ) {\n                transaction_hash\n                block { height time }\n                type\n                success\n                fee { amount denom }\n              }\n              pageInfo: messages_aggregate(where: {sender: {_eq: $address}}) {\n                aggregate { count }\n              }\n            }\n            \"\"\"\n            % (\"offset: 0\" if cursor is None else \"cursor: $cursor\")\n        )\n        variables: Dict[str, Any] = {\"address\": address, \"limit\": limit}\n        if cursor:\n            variables[\"cursor\"] = cursor\n        return gql_query, variables\n\n    # ---------- REST / LCD ----------\n    endpoint = f\"{provider['base_url']}/cosmos/tx/v1beta1/txs\"\n    params: Dict[str, Any] = {\n        \"events\": f\"message.sender='{address}'\",\n        \"order_by\": \"ORDER_BY_DESC\",\n        \"pagination.limit\": str(limit),\n        \"pagination.offset\": str(offset),\n    }\n    return endpoint, params",
	"execute_query_request": "def execute_query_request(\n    provider: Dict[str, str],\n    query_or_url: str,\n    variables_or_params: Optional[Union[Dict[str, Any], None]] = None,\n    timeout: int = 10,\n) -> Tuple[List[Dict[str, Any]], Optional[str]]:\n    \"\"\"Return (raw_results, next_cursor_or_offset).\"\"\"\n    try:\n        if provider[\"api_type\"] == \"graphql\":\n            resp = requests.post(\n                provider[\"base_url\"],\n                json={\"query\": query_or_url, \"variables\": variables_or_params or {}},\n                timeout=timeout,\n            )\n            resp.raise_for_status()\n            data = resp.json()\n            if \"errors\" in data:\n                raise RuntimeError(f\"GraphQL error: {data['errors']}\")\n            results = data[\"data\"][\"messages\"]\n            # Cursor-based pagination (Celatone may not expose pageInfo directly − adjust if needed)\n            next_cursor = variables_or_params.get(\"cursor\") if variables_or_params else None\n            return results, next_cursor\n        # ---------------- REST / LCD ----------------\n        resp = requests.get(query_or_url, params=variables_or_params, timeout=timeout)\n        resp.raise_for_status()\n        data = resp.json()\n        results = data.get(\"txs\", []) or data.get(\"tx_responses\", [])\n        next_key = data.get(\"pagination\", {}).get(\"next_key\")\n        return results, next_key\n    except requests.RequestException as exc:\n        raise RuntimeError(f\"Failed to query {provider['name']}: {exc}\") from exc",
	"normalize_tx_results": "def normalize_tx_results(provider: Dict[str, str], raw_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"Map each transaction to {hash, blockHeight, action, fee, success}.\"\"\"\n    normalized: List[Dict[str, Any]] = []\n\n    if provider[\"api_type\"] == \"graphql\":\n        for item in raw_results:\n            fee_obj = item.get(\"fee\", {}) or {}\n            fee_str = (\n                f\"{fee_obj.get('amount', '0')}{fee_obj.get('denom', '')}\"\n                if fee_obj else \"0\"\n            )\n            normalized.append(\n                {\n                    \"hash\": item.get(\"transaction_hash\"),\n                    \"blockHeight\": item.get(\"block\", {}).get(\"height\"),\n                    \"timestamp\": item.get(\"block\", {}).get(\"time\"),\n                    \"action\": item.get(\"type\"),\n                    \"fee\": fee_str,\n                    \"success\": bool(item.get(\"success\")),\n                }\n            )\n    else:  # REST / LCD\n        for tx in raw_results:\n            # Transaction hash and height\n            hash_ = tx.get(\"txhash\") or tx.get(\"hash\")\n            height = int(tx.get(\"height\", 0))\n            timestamp = tx.get(\"timestamp\")\n\n            # First message type as action indicator\n            first_msg = (\n                (tx.get(\"tx\", {}) or {}).get(\"body\", {}).get(\"messages\", [])\n            )\n            action = first_msg[0].get(\"@type\", \"\") if first_msg else \"\"\n\n            # Fee formatting\n            fee_info = (tx.get(\"tx\", {}) or {}).get(\"auth_info\", {}).get(\"fee\", {})\n            fee_amounts = fee_info.get(\"amount\", [])\n            fee_str = (\n                f\"{fee_amounts[0]['amount']}{fee_amounts[0]['denom']}\" if fee_amounts else \"0\"\n            )\n\n            success = tx.get(\"code\", 0) == 0  # code == 0 indicates success\n\n            normalized.append(\n                {\n                    \"hash\": hash_,\n                    \"blockHeight\": height,\n                    \"timestamp\": timestamp,\n                    \"action\": action,\n                    \"fee\": fee_str,\n                    \"success\": success,\n                }\n            )\n    return normalized",
	"compile_wasm_contract": "def compile_wasm_contract(contract_dir: str) -> str:\n    \"\"\"Compile a CosmWasm contract and return the path to the optimised .wasm file.\"\"\"\n    try:\n        # 1. Compile to Wasm (un-optimised)\n        subprocess.run(['cargo', 'wasm'], cwd=contract_dir, check=True)\n        # 2. Run the optimiser (expects `cargo run-script optimize` set up by rust-optimizer)\n        subprocess.run(['cargo', 'run-script', 'optimize'], cwd=contract_dir, check=True)\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(f'Contract compilation failed: {err}') from err\n\n    # Locate the optimised file (typically placed in <contract>/artifacts)\n    artifacts_dir = os.path.join(contract_dir, 'artifacts')\n    wasm_files = [f for f in os.listdir(artifacts_dir) if f.endswith('.wasm')]\n    if not wasm_files:\n        raise FileNotFoundError('Optimised wasm not found in artifacts directory.')\n    return os.path.join(artifacts_dir, wasm_files[0])",
	"get_local_chain_account": "def get_local_chain_account(key_name: str = 'cosmopark', faucet_url: str | None = 'http://localhost:4500/credit') -> dict:\n    \"\"\"Load or create a key and optionally request faucet funds.\"\"\"\n    try:\n        key_info_raw = subprocess.check_output([\n            'neutrond', 'keys', 'show', key_name,\n            '--output', 'json', '--keyring-backend', 'test'\n        ])\n    except subprocess.CalledProcessError:\n        # Key does not exist – create it\n        subprocess.run([\n            'neutrond', 'keys', 'add', key_name,\n            '--output', 'json', '--keyring-backend', 'test'\n        ], check=True)\n        key_info_raw = subprocess.check_output([\n            'neutrond', 'keys', 'show', key_name,\n            '--output', 'json', '--keyring-backend', 'test'\n        ])\n\n    key_info = json.loads(key_info_raw)\n    address = key_info['address']\n\n    # Ask faucet to top-up (optional / local-net only)\n    if faucet_url:\n        try:\n            requests.post(faucet_url, json={'address': address, 'denom': 'untrn'})\n        except Exception as faucet_err:\n            print(f'Faucet funding skipped/failed: {faucet_err}')\n\n    return {'name': key_name, 'address': address}",
	"query_contract_state": "def query_contract_state(client: LedgerClient, contract_address: str, query_msg: dict):\n    \"\"\"Query the contract’s state using a custom query message.\"\"\"\n    try:\n        return client.wasm_query(contract_address, query_msg)\n    except Exception as err:\n        raise RuntimeError(f'Contract query failed: {err}') from err",
	"query_bank_balance": "def query_bank_balance(address: str, denom: str = \"untrn\") -> int:\n    \"\"\"Return current balance for `address` in the given `denom`.\"\"\"\n    try:\n        balance = client.query_bank_balance(address, denom=denom)\n        return int(balance.amount)\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to query balance: {exc}\") from exc",
	"parse_balance_response": "def parse_balance_response(raw_json: str, denom: str = 'untrn') -> Dict[str, str]:\n    \"\"\"Extracts the balance for the specified denom and formats it for display.\"\"\"\n    try:\n        data = json.loads(raw_json)\n        balances = data.get('balances', [])\n        micro_amount = 0\n        for coin in balances:\n            if coin.get('denom') == denom:\n                micro_amount = int(coin.get('amount', '0'))\n                break\n        human_amount = Decimal(micro_amount) / Decimal(1_000_000)  # 1e6 micro = 1 NTRN\n        return {\n            'denom': denom,\n            'micro_amount': str(micro_amount),\n            'amount': f'{human_amount.normalize()} NTRN'\n        }\n    except (json.JSONDecodeError, ValueError) as err:\n        raise ValueError('Invalid JSON supplied to parser: ' + str(err))",
	"ensure_cosmopark_installed": "def ensure_cosmopark_installed() -> None:\n    \"\"\"Ensure that CosmoPark CLI and its Docker images are available.\"\"\"\n    # 1. Check CosmoPark binary\n    if shutil.which(\"cosmopark\") is None:\n        print(\"CosmoPark CLI not found. Attempting installation via pip…\")\n        try:\n            subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"cosmopark-cli\"])\n        except subprocess.CalledProcessError as err:\n            raise RuntimeError(\"Automatic installation of CosmoPark CLI failed.\") from err\n    else:\n        print(\"CosmoPark CLI detected ✅\")\n\n    # 2. Verify Docker is installed – required by CosmoPark\n    if shutil.which(\"docker\") is None:\n        raise RuntimeError(\"Docker is required but not installed or not in PATH.\")\n\n    # 3. Pull (or update) all CosmoPark Docker images\n    try:\n        subprocess.check_call([\"cosmopark\", \"pull\", \"--all\"])\n        print(\"CosmoPark Docker images pulled ✅\")\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(\"Failed to pull CosmoPark Docker images.\") from err",
	"run_cosmopark_init": "def run_cosmopark_init(workspace_path: str = \"./localnet\") -> None:\n    \"\"\"Run `cosmopark init` inside the chosen workspace directory.\"\"\"\n    workspace = Path(workspace_path).expanduser().resolve()\n    workspace.mkdir(parents=True, exist_ok=True)\n\n    cmd = [\"cosmopark\", \"init\"]\n    try:\n        subprocess.check_call(cmd, cwd=str(workspace))\n        print(f\"Workspace initialised at {workspace} ✅\")\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(\"`cosmopark init` failed.\") from err",
	"run_cosmopark_start": "def run_cosmopark_start(workspace_path: str = \"./localnet\") -> None:\n    \"\"\"Run `cosmopark start` inside the workspace to spin up the chain.\"\"\"\n    cmd = [\"cosmopark\", \"start\"]\n    try:\n        subprocess.check_call(cmd, cwd=workspace_path)\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(\"`cosmopark start` failed.\") from err",
	"verify_local_chain_running": "def verify_local_chain_running(rpc_url: str = \"http://localhost:26657/status\", timeout: int = 60) -> int:\n    \"\"\"Wait until the RPC endpoint returns a status with a block height or raise on timeout.\"\"\"\n    start = time.time()\n    while True:\n        try:\n            resp = requests.get(rpc_url, timeout=3)\n            if resp.status_code == 200:\n                data = resp.json()\n                height = int(data[\"result\"][\"sync_info\"][\"latest_block_height\"])\n                print(f\"Local chain is up ✅  (latest height={height})\")\n                return height\n        except Exception:\n            # Ignore and retry until timeout\n            pass\n\n        if time.time() - start > timeout:\n            raise RuntimeError(f\"Local chain did not start within {timeout} seconds.\")\n\n        print(\"⏳ Waiting for local chain…\")\n        time.sleep(3)",
	"format_amount": "def format_amount(raw_balance: int) -> str:\n    \"\"\"Convert micro-denom (`untrn`) to a formatted NTRN string.\"\"\"\n    try:\n        micro = int(raw_balance)\n    except (TypeError, ValueError):\n        raise ValueError(\"raw_balance must be an integer-compatible value\")\n\n    ntrn_value = micro / 1_000_000  # 1 NTRN = 1,000,000 untrn\n    return f\"{ntrn_value:,.6f} NTRN\"",
	"get_admin_wallet": "def get_admin_wallet() -> LocalWallet:\n    \"\"\"Return the admin LocalWallet defined by the ADMIN_MNEMONIC env-var.\"\"\"\n    mnemonic = os.getenv(\"ADMIN_MNEMONIC\")\n    if not mnemonic:\n        raise EnvironmentError(\"ADMIN_MNEMONIC environment variable is not set.\")\n\n    try:\n        wallet = LocalWallet.from_mnemonic(mnemonic)\n    except Exception as err:\n        raise ValueError(f\"Failed to create wallet from mnemonic: {err}\") from err\n\n    return wallet",
	"get_contract_address": "def get_contract_address() -> str:\n    \"\"\"Return the contract address defined by CONTRACT_ADDRESS env-var.\"\"\"\n    contract_addr = os.getenv(\"CONTRACT_ADDRESS\") or \"\"\n    if not _BECH32_RE.match(contract_addr):\n        raise ValueError(\"CONTRACT_ADDRESS env-var is missing or not a valid Neutron bech32 address.\")\n    return contract_addr",
	"construct_tx_execute_contract": "def construct_tx_execute_contract(contract_addr: str, wallet, gas: int = 200000) -> Transaction:\n    \"\"\"Create an unsigned Transaction carrying the reset execute message.\"\"\"\n    execute_msg = {\"reset\": {}}\n\n    # Build protobuf MsgExecuteContract using the helper (encodes & sets funds = [])\n    msg = create_msg_execute_contract(\n        sender=str(wallet.address()),\n        contract=contract_addr,\n        msg=json.dumps(execute_msg).encode(),\n        funds=[],\n    )\n\n    tx = Transaction()\n    tx.add_message(msg)\n    tx.with_chain_id(NETWORK_CFG.chain_id)\n    tx.with_sender(wallet.address())\n    tx.with_gas(gas)\n    # Fee is automatically derived from gas*gas_price if not specified explicitly\n    return tx",
	"get_neutron_client": "def get_neutron_client() -> LedgerClient:\n    \"\"\"Initialises a LedgerClient pointed at Pion-1.\n\n    Raises:\n        EnvironmentError: If an RPC endpoint is missing.\n    \"\"\"\n    rpc_url = os.getenv(\"PION_RPC\", \"https://rpc.pion-1.ntrn.tech:443\")\n\n    if not rpc_url:\n        raise EnvironmentError(\"RPC endpoint for Pion-1 is not set.\")\n\n    cfg = NetworkConfig(\n        chain_id=\"pion-1\",\n        url=rpc_url,\n        fee_minimum_gas_price=0.025,  # 0.025 NTRN / gas\n        fee_denomination=\"untrn\",\n        staking_denomination=\"untrn\",\n        bech32_hrp=\"neutron\"\n    )\n\n    return LedgerClient(cfg)",
	"load_signing_key": "def load_signing_key() -> PrivateKey:\n    \"\"\"Loads (or creates) a PrivateKey from a MNEMONIC env-var.\"\"\"\n    global _SIGNING_KEY\n    if _SIGNING_KEY is None:\n        mnemonic = os.getenv(\"NEUTRON_MNEMONIC\")\n        if not mnemonic:\n            raise EnvironmentError(\"Please export NEUTRON_MNEMONIC before running.\")\n        _SIGNING_KEY = PrivateKey.from_mnemonic(mnemonic)\n    return _SIGNING_KEY",
	"get_code_id": "def get_code_id(client: LedgerClient, uploader: str, explicit_code_id: Optional[int] = None) -> int:\n    \"\"\"Determine the code_id to instantiate.\n\n    Args:\n        client:   The LedgerClient from Step 1.\n        uploader: Address that stored the code (usually our wallet).\n        explicit_code_id: Optional override (e.g. via CLI flag).\n\n    Returns:\n        int: The wasm `code_id`.\n\n    Raises:\n        ValueError: If we cannot discover a code_id.\n    \"\"\"\n    # Highest priority: explicit argument / env-var\n    if explicit_code_id is None:\n        env_code_id = os.getenv(\"CODE_ID\")\n        explicit_code_id = int(env_code_id) if env_code_id else None\n\n    if explicit_code_id is not None:\n        return explicit_code_id\n\n    # Fallback: query the chain for all codes uploaded by `uploader`\n    response = client.query(\"/cosmwasm/wasm/v1/code\")  # REST path for all codes\n    codes = json.loads(response)[\"code_infos\"]\n\n    # Filter codes by creator and pick the latest\n    user_codes = [int(c[\"code_id\"]) for c in codes if c.get(\"creator\") == uploader]\n    if not user_codes:\n        raise ValueError(\"No code_id found for uploader – pass CODE_ID env-var or argument.\")\n    return max(user_codes)",
	"construct_update_admin_tx": "def construct_update_admin_tx(\n    sender_address: str,\n    contract_address: str,\n    new_admin_address: str,\n) -> Tuple[Transaction, LedgerClient]:\n    \"\"\"Create an unsigned Transaction containing a MsgUpdateAdmin message.\n\n    Args:\n        sender_address: Current admin / governance address signing the tx.\n        contract_address: Address of the CosmWasm contract.\n        new_admin_address: Address that will become the new admin.\n\n    Returns:\n        A tuple of (tx, ledger_client) ready for signing & broadcasting.\n    \"\"\"\n    # Initialize client\n    network_cfg = NetworkConfig(\n        chain_id=CHAIN_ID,\n        url=RPC_ENDPOINT,\n    )\n    client = LedgerClient(network_cfg)\n\n    # Build the MsgUpdateAdmin protobuf message\n    msg = MsgUpdateAdmin(\n        sender=sender_address,\n        contract=contract_address,\n        new_admin=new_admin_address,\n    )\n\n    # Pack into Any type\n    any_msg = Any()\n    any_msg.Pack(msg, type_url_prefix='')  # cosmpy handles type_url internally\n\n    # Create transaction and add message\n    tx = Transaction()\n    tx.add_message(any_msg)\n\n    # Set a placeholder fee & gas (will be adjusted when we sign)\n    tx.set_fee(FEE_DENOM, amount=5000, gas_limit=DEFAULT_GAS_LIMIT)\n\n    return tx, client",
	"query_contract_info": "def query_contract_info(contract_address: str, lcd: str = REST_ENDPOINT) -> Dict:\n    \"\"\"Request contract metadata from the LCD endpoint.\n\n    Args:\n        contract_address (str): Bech32 contract address.\n        lcd (str): Base URL for the LCD server.\n\n    Returns:\n        Dict: Parsed JSON with contract metadata.\n    \"\"\"\n    url = f\"{lcd}/cosmwasm/wasm/v1/contract/{contract_address}\"\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        data = response.json()\n        return data.get(\"contract_info\", {})\n    except requests.RequestException as exc:\n        raise ContractQueryError(f\"LCD request failed: {exc}\") from exc\n    except ValueError:\n        raise ContractQueryError(\"LCD returned malformed JSON\")",
	"query_code_info": "def query_code_info(code_id: str, lcd: str = REST_ENDPOINT) -> Dict:\n    \"\"\"Retrieve code-info (including `code_hash`) from the LCD.\n\n    Args:\n        code_id (str): The code ID extracted in Step 3.\n        lcd (str): Base URL for the LCD server.\n\n    Returns:\n        Dict: JSON payload containing code-info.\n    \"\"\"\n    url = f\"{lcd}/cosmwasm/wasm/v1/code/{code_id}\"\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        return response.json().get(\"code_info\", {})\n    except requests.RequestException as exc:\n        raise CodeInfoQueryError(f\"LCD request failed: {exc}\") from exc\n    except ValueError:\n        raise CodeInfoQueryError(\"Malformed JSON in LCD response\")",
	"extract_code_hash": "def extract_code_hash(code_info: Dict) -> str:\n    \"\"\"Safely extract the `code_hash` value.\n\n    Args:\n        code_info (Dict): Output from `query_code_info`.\n\n    Returns:\n        str: The hexadecimal code hash.\n    \"\"\"\n    try:\n        code_hash = code_info[\"data_hash\"] or code_info[\"code_hash\"]  # field name may differ\n        if not code_hash:\n            raise KeyError\n        return code_hash\n    except KeyError:\n        raise CodeHashExtractionError(\"`code_hash` not present in code-info payload\")",
	"validate_new_code_id": "async def validate_new_code_id(contract_address: str, new_code_id: int, rpc_url: str = \"https://rpc-kralum.neutron-1.neutron.org\") -> bool:\n    \"\"\"Validate that `new_code_id` exists and differs from the contract's current code ID.\n\n    Args:\n        contract_address (str): Address of the contract to migrate.\n        new_code_id (int): The code ID to migrate to.\n        rpc_url (str): RPC endpoint for Neutron.\n    Returns:\n        bool: True if the validation succeeds, otherwise an exception is raised.\n    \"\"\"\n    try:\n        cfg = NetworkConfig(\n            chain_id=\"neutron-1\",\n            url=rpc_url,\n            fee_minimum_gas_price=\"0.025untrn\",\n            fee_denomination=\"untrn\",\n        )\n        client = LedgerClient(cfg)\n\n        # Ensure the new code ID exists\n        code_info = client.query.wasm.get_code_info(new_code_id)\n        if code_info is None:\n            raise ValueError(f\"Code ID {new_code_id} does not exist on-chain.\")\n\n        # Fetch current contract info\n        contract_info = client.query.wasm.get_contract_info(contract_address)\n        if int(contract_info[\"code_id\"]) == new_code_id:\n            raise ValueError(\"Contract already instantiated with this code ID.\")\n\n        return True\n    except (QueryError, Exception) as err:\n        raise RuntimeError(f\"Validation failed: {err}\") from err",
	"get_neutron_mainnet_client": "def get_neutron_mainnet_client(mnemonic: str, rpc_url: str = \"https://rpc-kralum.neutron-1.neutron.org:443\") -> LedgerClient:\n    # Returns a cosmpy LedgerClient configured for Neutron mainnet\n    if not mnemonic:\n        raise ValueError(\"Mnemonic must not be empty\")\n\n    cfg = NetworkConfig(\n        chain_id=\"neutron-1\",\n        url=rpc_url,\n        fee_min_denom=\"untrn\",\n        gas_price=0.025,  # 0.025 NTRN/gas is a reasonable default for mainnet\n    )\n\n    wallet = LocalWallet.create_from_mnemonic(mnemonic)\n    return LedgerClient(cfg, wallet)",
	"ensure_wasm_file": "def ensure_wasm_file(path: str) -> str:\n    # Validates the existence and size (< 4 MiB) of the compiled .wasm file\n    if not os.path.isfile(path):\n        raise FileNotFoundError(f\"WASM file not found at {path}\")\n\n    size = os.path.getsize(path)\n    if size > 4 * 1024 * 1024:\n        raise ValueError(f\"WASM binary is {size} bytes which exceeds the 4 MiB limit.\")\n\n    return os.path.abspath(path)",
	"build_store_code_tx": "def build_store_code_tx(client: LedgerClient, wasm_path: str, memo: str = \"Upload contract\") -> Transaction:\n    with open(wasm_path, \"rb\") as f:\n        wasm_bytes = f.read()\n\n    msg = wasm_tx.MsgStoreCode(\n        sender=client.wallet.address(),\n        wasm_byte_code=wasm_bytes,\n        instantiate_permission=wasm_types.AccessConfig(\n            permission=wasm_types.AccessType.ACCESS_TYPE_EVERYBODY\n        ),\n    )\n\n    tx = client.tx.create([msg], memo=memo, gas_limit=2_500_000)\n    return tx",
	"build_instantiate_tx": "def build_instantiate_tx(client: LedgerClient, code_id: int, init_msg: dict, label: str, admin: str | None = None) -> Transaction:\n    msg = wasm_tx.MsgInstantiateContract(\n        sender=client.wallet.address(),\n        admin=admin or client.wallet.address(),\n        code_id=code_id,\n        label=label,\n        msg=jsonlib.dumps(init_msg).encode(),\n        funds=[]  # add coins here if your contract expects an initial deposit\n    )\n    tx = client.tx.create([msg], memo=f\"Instantiate {label}\", gas_limit=1_000_000)\n    return tx",
	"extract_contract_address": "def extract_contract_address(response) -> str:\n    try:\n        logs = json.loads(response.raw_log)\n        for event in logs[0][\"events\"]:\n            if event[\"type\"] == \"instantiate\":\n                for attr in event[\"attributes\"]:\n                    if attr[\"key\"] in (\"_contract_address\", \"contract_address\"):\n                        return attr[\"value\"]\n    except (KeyError, ValueError, json.JSONDecodeError) as err:\n        raise RuntimeError(f\"Unable to find contract address: {err}\")\n    raise RuntimeError(\"Contract address not present in tx logs\")",
	"connect_rpc_endpoint": "def connect_rpc_endpoint(rpc_endpoint: str = 'https://rpc-kralum.neutron.org') -> str:\n    \"\"\"\n    Attempts to connect to the given Neutron RPC endpoint by querying the `/status`\n    route. Returns the endpoint string if successful; raises an exception otherwise.\n    \"\"\"\n    try:\n        # Hit `/status` to confirm the node is alive\n        url = rpc_endpoint.rstrip('/') + '/status'\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n\n        # Basic sanity check on the payload\n        if 'result' not in response.json():\n            raise ValueError('Unexpected response payload from RPC endpoint.')\n\n        return rpc_endpoint\n    except requests.RequestException as err:\n        raise ConnectionError(\n            f'Unable to reach Neutron RPC endpoint at {rpc_endpoint}: {err}'\n        ) from err",
	"neutrond_status": "def neutrond_status(rpc_endpoint: str) -> Dict:\n    \"\"\"\n    Executes `neutrond status --node <rpc_endpoint>` via subprocess and returns\n    the parsed JSON dictionary containing the node's sync information.\n    \"\"\"\n    try:\n        cmd = [\n            'neutrond',\n            'status',\n            '--node',\n            rpc_endpoint,\n        ]\n        result = subprocess.run(\n            cmd,\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        return json.loads(result.stdout)\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(f'`neutrond status` failed: {err.stderr}') from err\n    except json.JSONDecodeError as err:\n        raise ValueError('Failed to parse JSON from neutrond output.') from err",
	"extract_block_height": "def extract_block_height(status_json: Dict) -> int:\n    \"\"\"\n    Extracts the latest block height from the status JSON returned by `neutrond status`.\n    \"\"\"\n    try:\n        height_str = status_json['result']['sync_info']['latest_block_height']\n        return int(height_str)\n    except (KeyError, TypeError, ValueError) as err:\n        raise ValueError(\n            'Invalid status JSON format: unable to locate `latest_block_height`.'\n        ) from err",
	"open_celatone_explorer": "def open_celatone_explorer(chain_id: str, download_dir: str = \"/tmp\") -> webdriver.Chrome:\n    \"\"\"Launch Celatone (https://celatone.osmosis.zone) for the given chain and\n    return an initialized Selenium WebDriver.\n\n    Args:\n        chain_id (str): Either \"neutron-1\" (mainnet) or \"pion-1\" (testnet).\n        download_dir (str): Directory where Celatone will drop the metadata JSON.\n\n    Returns:\n        webdriver.Chrome: A configured Chrome WebDriver pointing at Celatone.\n    \"\"\"\n\n    if chain_id not in (\"neutron-1\", \"pion-1\"):\n        raise ValueError(\"Unsupported chain id. Use 'neutron-1' or 'pion-1'.\")\n\n    url = f\"https://celatone.osmosis.zone/{chain_id}\"\n\n    # Configure Chrome for head-less use and automatic downloads\n    chrome_opts = Options()\n    chrome_opts.add_argument(\"--headless=new\")\n    chrome_opts.add_argument(\"--window-size=1920,1080\")\n    chrome_opts.add_experimental_option(\n        \"prefs\",\n        {\n            \"download.default_directory\": download_dir,\n            \"download.prompt_for_download\": False,\n            \"download.directory_upgrade\": True,\n            \"safebrowsing.enabled\": True,\n        },\n    )\n\n    try:\n        driver = webdriver.Chrome(options=chrome_opts)\n        driver.get(url)\n\n        # Wait until the search bar is rendered so we know the page finished loading\n        WebDriverWait(driver, 15).until(\n            EC.presence_of_element_located((\"css selector\", \"input[type='search']\"))\n        )\n        return driver\n    except WebDriverException as exc:\n        raise RuntimeError(f\"Failed to open Celatone explorer: {exc}\") from exc",
	"search_contract_address": "def search_contract_address(driver: webdriver.Chrome, contract_address: str, timeout: int = 15) -> None:\n    \"\"\"Paste the contract address into Celatone's search bar and navigate to the\n    contract page.\n\n    Args:\n        driver (webdriver.Chrome): Active Celatone WebDriver.\n        contract_address (str): Bech32 address of the target contract.\n        timeout (int): Max seconds to wait for the contract page to load.\n    \"\"\"\n\n    try:\n        # Locate the search bar element and submit the address\n        search_box = driver.find_element(By.CSS_SELECTOR, \"input[type='search']\")\n        search_box.clear()\n        search_box.send_keys(contract_address + Keys.ENTER)\n\n        # Wait until URL contains the contract address, indicating navigation\n        WebDriverWait(driver, timeout).until(\n            EC.url_contains(contract_address.lower())\n        )\n    except TimeoutException:\n        raise RuntimeError(\"Celatone did not navigate to the contract page in time.\")",
	"navigate_to_metadata_tab": "def navigate_to_metadata_tab(driver: webdriver.Chrome, timeout: int = 10) -> None:\n    \"\"\"Click Celatone's \"Metadata\" tab for the currently opened contract page.\"\"\"\n    try:\n        # The tab usually appears as a button or anchor containing the visible text \"Metadata\"\n        metadata_tab = WebDriverWait(driver, timeout).until(\n            EC.element_to_be_clickable((By.XPATH, \"//button[contains(., 'Metadata')] | //a[contains(., 'Metadata')]\"))\n        )\n        metadata_tab.click()\n\n        # Wait until the JSON download (</>) icon is visible in the Metadata view\n        WebDriverWait(driver, timeout).until(\n            EC.presence_of_element_located((By.XPATH, \"//button[contains(@title, 'Download') or contains(@aria-label, 'Download')]\"))\n        )\n    except (TimeoutException, NoSuchElementException):\n        raise RuntimeError(\"Could not open the Metadata tab on Celatone.\")",
	"download_metadata_json": "def download_metadata_json(driver: webdriver.Chrome, download_dir: str, timeout: int = 30) -> Path:\n    \"\"\"Click the download button and wait until the metadata JSON is fully\n    written to disk.\n\n    Args:\n        driver (webdriver.Chrome): Active WebDriver on the Metadata tab.\n        download_dir (str): Directory configured in open_celatone_explorer().\n        timeout (int): Max seconds to wait for the file to finish downloading.\n\n    Returns:\n        Path: Absolute path to the downloaded metadata JSON file.\n    \"\"\"\n\n    # Grab a snapshot of existing files so we can detect the new one later\n    pre_existing = set(Path(download_dir).iterdir()) if os.path.isdir(download_dir) else set()\n\n    # Click the download (code / </>) button\n    try:\n        download_btn = driver.find_element(By.XPATH, \"//button[contains(@title, 'Download') or contains(@aria-label, 'Download')]\")\n        download_btn.click()\n    except Exception as exc:\n        raise RuntimeError(\"Failed to click Celatone's download button\") from exc\n\n    # Poll for a new .json file that was not present earlier\n    end_time = time.time() + timeout\n    while time.time() < end_time:\n        current_files = set(Path(download_dir).iterdir())\n        new_files = [f for f in current_files - pre_existing if f.suffix.lower() == \".json\"]\n        if new_files:\n            # Celatone sometimes writes a *.crdownload first; wait until file stabilises.\n            candidate = new_files[0]\n            if not candidate.name.endswith(\".crdownload\"):\n                return candidate.resolve()\n        time.sleep(0.5)\n\n    raise TimeoutException(\"Timed out waiting for metadata JSON download to complete.\")",
	"query_contracts_by_creator": "async def query_contracts_by_creator(\n    creator_address: str,\n    limit: int = 1000,\n    pagination_key: Optional[str] = None,\n) -> Dict[str, Any]:\n    \"\"\"Query one page of contracts created by `creator_address`.\n\n    Args:\n        creator_address (str): Bech32 Neutron address.\n        limit (int, optional): Maximum results per page. Defaults to 1000.\n        pagination_key (str, optional): The opaque `next_key` from the previous\n            response. If provided, the query continues from that key.\n\n    Returns:\n        Dict[str, Any]: JSON response from the LCD containing contracts and pagination data.\n    \"\"\"\n    params = {\n        \"creator\": creator_address,\n        \"pagination.limit\": str(limit),\n    }\n    if pagination_key:\n        params[\"pagination.key\"] = pagination_key\n\n    url = f\"{LCD_URL}/cosmwasm/wasm/v1/contracts\"\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        response = await client.get(url, params=params)\n        response.raise_for_status()  # Raises if HTTP != 200\n        return response.json()",
	"fetch_all_contracts_by_creator": "async def fetch_all_contracts_by_creator(creator_address: str, page_limit: int = 1000) -> List[str]:\n    \"\"\"Return a complete list of contract addresses deployed by `creator_address`.\"\"\"\n    contracts: List[str] = []\n    next_key: Optional[str] = None\n\n    while True:\n        page = await query_contracts_by_creator(\n            creator_address=creator_address,\n            limit=page_limit,\n            pagination_key=next_key,\n        )\n\n        # Extract contracts list from page data and extend our accumulator\n        contracts.extend(page.get(\"contracts\", []))\n\n        # Determine if more pages exist\n        next_key = page.get(\"pagination\", {}).get(\"next_key\")\n        if not next_key:\n            break  # No more pages\n\n    return contracts",
	"validate_wasm_checksum": "def validate_wasm_checksum(wasm_path: Path) -> str:\n    if not wasm_path.is_file():\n        raise FileNotFoundError(f'File not found: {wasm_path}')\n\n    sha256 = hashlib.sha256()\n    with wasm_path.open('rb') as f:\n        for chunk in iter(lambda: f.read(8192), b''):\n            sha256.update(chunk)\n    checksum = sha256.hexdigest()\n    return checksum",
	"sign_and_broadcast_tx": "def sign_and_broadcast_tx(tx: Transaction, wallet: LocalWallet, client: LedgerClient):\n    # Fill in sequence & account number from chain state\n    tx = tx.with_sequence(wallet.get_sequence(client)).with_account_number(wallet.get_account_number(client))\n\n    signed_tx = tx.sign(wallet)\n    response = client.broadcast_tx(signed_tx)\n\n    if response.tx_response.code != 0:\n        raise RuntimeError(f'Tx failed with log: {response.tx_response.raw_log}')\n\n    return response",
	"extract_code_id_from_tx": "def extract_code_id_from_tx(response) -> int:\n    raw_log = response.tx_response.raw_log\n\n    # Attempt JSON parsing (preferred because it is deterministic)\n    try:\n        parsed_logs = json.loads(raw_log)[0]\n        for event in parsed_logs.get('events', []):\n            if event.get('type') == 'store_code':\n                for attr in event.get('attributes', []):\n                    if attr.get('key') == 'code_id':\n                        return int(attr.get('value'))\n    except (json.JSONDecodeError, KeyError, IndexError):\n        pass\n\n    # Fallback: regex scanning for robustness\n    match = re.search(r'\\\"code_id\\\":\\s*\\\"?(\\d+)\\\"?', raw_log)\n    if match:\n        return int(match.group(1))\n\n    raise ValueError('code_id not found in transaction logs')",
	"construct_param_change_proposal": "def construct_param_change_proposal(new_security_address: str, deposit: str = \"10000000untrn\", output_path: str = \"proposal.json\") -> str:\n    \"\"\"Generate a Param-Change proposal file that updates the Cron module's security_address.\"\"\"\n    proposal = {\n        \"title\": \"Update Cron security_address\",\n        \"description\": f\"Updates Cron module security_address param to {new_security_address}.\",\n        \"changes\": [{\"subspace\": \"cron\", \"key\": \"SecurityAddress\", \"value\": f'\"{new_security_address}\"'}],\n        \"deposit\": deposit\n    }\n    try:\n        with open(output_path, \"w\", encoding=\"utf-8\") as fp:\n            json.dump(proposal, fp, indent=2)\n    except IOError as err:\n        raise RuntimeError(f\"Could not write proposal file: {err}\") from err\n    return output_path",
	"build_dao_proposal": "def build_dao_proposal(msg_update_params: Dict, title: str, description: str) -> Dict:\n    \"\"\"Return the message to execute against a cw-dao core contract.\"\"\"\n    proposal = {\n        \"propose\": {\n            \"title\": title,\n            \"description\": description,\n            \"msgs\": [{\"custom\": msg_update_params}],\n        }\n    }\n    return proposal",
	"wait_for_voting_result": "def wait_for_voting_result(proposal_id: str, chain_id: str = \"neutron-1\", node: str = \"https://rpc-kralum.neutron.org:443\", poll_interval: int = 15, max_attempts: int = 800) -> str:\n    \"\"\"Polls proposal status via CLI until it is finalized or times out.\"\"\"\n    for _ in range(max_attempts):\n        try:\n            proc = subprocess.run(\n                [\"neutrond\", \"query\", \"gov\", \"proposal\", str(proposal_id), \"--chain-id\", chain_id, \"--node\", node, \"--output\", \"json\"],\n                capture_output=True, text=True, check=True\n            )\n            status = json.loads(proc.stdout).get(\"status\")\n            print(f\"[poll] proposal {proposal_id} status: {status}\")\n            if status == \"PROPOSAL_STATUS_PASSED\":\n                return status\n            if status in (\"PROPOSAL_STATUS_REJECTED\", \"PROPOSAL_STATUS_FAILED\", \"PROPOSAL_STATUS_ABORTED\"):\n                raise RuntimeError(f\"Proposal {proposal_id} ended with status {status}\")\n        except (subprocess.CalledProcessError, json.JSONDecodeError) as e:\n            print(f\"Polling error: {e}. Retrying...\")\n        time.sleep(poll_interval)\n    raise TimeoutError(\"Exceeded maximum attempts while waiting for proposal to pass.\")",
	"query_cron_params": "def query_cron_params(chain_id: str = \"neutron-1\", node: str = \"https://rpc-kralum.neutron.org:443\") -> dict:\n    \"\"\"Fetches the current Cron module parameters via CLI.\"\"\"\n    proc = subprocess.run(\n        [\"neutrond\", \"query\", \"cron\", \"params\", \"--chain-id\", chain_id, \"--node\", node, \"--output\", \"json\"],\n        capture_output=True, text=True, check=True\n    )\n    return json.loads(proc.stdout).get(\"params\", {})",
	"query_cron_schedule": "def query_cron_schedule(schedule_name: str, node: str = \"https://rpc.neutron.org:443\") -> Dict:\n    \"\"\"Fetch schedule metadata from the Neutron Cron module via `neutrond` CLI.\"\"\"\n    try:\n        cmd = [\"neutrond\", \"query\", \"cron\", \"schedule\", schedule_name, \"--output\", \"json\", \"--node\", node]\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n        return json.loads(result.stdout)\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(f\"Failed to query schedule '{schedule_name}': {exc.stderr.strip()}\") from exc\n    except json.JSONDecodeError as exc:\n        raise ValueError(\"Received non-JSON response from neutrond CLI\") from exc",
	"query_all_cron_schedules": "def query_all_cron_schedules(limit: int = 1000) -> List[Dict]:\n    \"\"\"Return every cron schedule on-chain, handling pagination.\"\"\"\n    schedules: List[Dict] = []\n    next_key: str = \"\"\n    while True:\n        cmd = [\"neutrond\", \"query\", \"cron\", \"schedules\", \"--limit\", str(limit), \"--output\", \"json\"]\n        if next_key:\n            cmd += [\"--page-key\", next_key]\n        raw = subprocess.check_output(cmd, text=True)\n        data = json.loads(raw)\n        schedules.extend(data.get(\"schedules\", []))\n        next_key = data.get(\"pagination\", {}).get(\"next_key\")\n        if not next_key:\n            break\n    return schedules",
	"build_msg_add_schedule": "def build_msg_add_schedule(authority: str, name: str, period: int, msgs: List[Dict], execution_stage: str = \"EXECUTION_STAGE_END_BLOCKER\") -> Dict:\n    \"\"\"Return an SDK-compatible MsgAddSchedule dictionary.\"\"\"\n    return {\n        \"@type\": \"/neutron.cron.MsgAddSchedule\",\n        \"authority\": authority,\n        \"name\": name,\n        \"period\": str(period),\n        \"msgs\": msgs,\n        \"execution_stage\": execution_stage,\n    }",
	"build_msg_delete_schedule": "def build_msg_delete_schedule(authority: str, schedule_name: str = \"protocol_update\") -> dict:\n    \"\"\"Return an amino/JSON-encoded MsgDeleteSchedule body.\"\"\"\n    return {\n        \"@type\": \"/neutron.admin.MsgDeleteSchedule\",\n        \"authority_address\": authority,\n        \"name\": schedule_name\n    }",
	"schedule_removed": "def schedule_removed(name: str) -> bool:\n    \"\"\"Returns True only if the schedule no longer exists by checking the CLI.\"\"\"\n    try:\n        subprocess.run(\n            [\"neutrond\", \"query\", \"cron\", \"show-schedule\", name, \"--output=json\"],\n            capture_output=True, text=True, check=True,\n        )\n        return False\n    except subprocess.CalledProcessError as err:\n        if \"not found\" in err.stderr.lower():\n            return True\n        raise",
	"verify_security_address": "def verify_security_address(expected: str, chain_id: str = \"neutron-1\", node: str = \"https://rpc-kralum.neutron.org:443\") -> bool:\n    \"\"\"Validates that the on-chain security_address equals the expected value.\"\"\"\n    params = query_cron_params(chain_id, node)\n    actual = params.get(\"security_address\")\n    if actual == expected:\n        print(\"✅ Cron security_address matches expected value.\")\n        return True\n    raise ValueError(f\"security_address mismatch: expected {expected}, got {actual}\")",
	"extract_last_execution_height": "def extract_last_execution_height(schedule_data: dict) -> int:\n    \"\"\"Return the most recent execution height from schedule JSON.\"\"\"\n    for key in (\"last_execution_height\", \"last_executed_height\"):\n        if (value := schedule_data.get(key)) is not None:\n            return int(value)\n    raise KeyError(\"Could not find last execution height field in schedule data.\")",
	"ensureWalletConnected": "export const ensureWalletConnected = async () => {\n  try {\n    const chainId = 'neutron-1';\n    const keplr = window.keplr;\n\n    // Execute the full workflow\n    if (!keplr) {\n      throw new Error('Keplr wallet is not installed.');\n    }\n\n    await keplr.enable(chainId);\n    const signer = window.getOfflineSigner(chainId);\n\n    return signer;\n\n  } catch (err) {\n    alert(err.message);\n//     setError(err.message); // Update the error state\n  }\n};",
	"getWalletAddress": "export const getWalletAddress = async (signer) => {\n  try {\n      const accounts = await signer.getAccounts();\n      if (!accounts || accounts.length === 0) {\n        throw new Error('No account found in the signer.');\n      }\n\n      const address = accounts[0].address;\n      return address;\n  } catch (err) {\n    alert(err.message);\n//     setError(err.message); // Update the error state\n  }\n};",
	"connectWallet": "export const connectWallet = async (preferredWallet = 'keplr') => {\n  /*\n   * Attempt to detect and connect to the requested wallet extension.\n   * Currently supports Keplr and Leap; extend this switch-case to add more wallets.\n   */\n  let wallet;\n  switch (preferredWallet.toLowerCase()) {\n    case 'keplr':\n      wallet = window.keplr;\n      break;\n    case 'leap':\n      wallet = window.leap;\n      break;\n    default:\n      throw new Error(`${preferredWallet} wallet is not supported by this dApp.`);\n  }\n\n  if (!wallet) {\n    throw new Error(`${preferredWallet} extension not found. Please install it and refresh the page.`);\n  }\n\n  try {\n    // Ask the user to approve connection permissions (UI popup in the wallet).\n    await wallet.enable('neutron-1');\n    // Return an OfflineSigner required by CosmJS.\n    return wallet.getOfflineSigner('neutron-1');\n  } catch (err) {\n    console.error('Wallet connection failed:', err);\n    throw new Error('User rejected the wallet connection request or another error occurred.');\n  }\n};",
	"ensureNeutronNetwork": "export const ensureNeutronNetwork = async () => {\n  const chainId = 'neutron-1';\n  const keplr = window.keplr || window.leap;\n  if (!keplr) throw new Error('No compatible wallet detected.');\n\n  try {\n    // First try to enable Neutron if it already exists in the wallet.\n    await keplr.enable(chainId);\n    return true;\n  } catch (enableErr) {\n    console.warn('Neutron chain not yet added in the wallet, attempting experimentalSuggestChain');\n\n    // Fallback: suggest chain (only works if wallet supports the experimental API).\n    if (!keplr.experimentalSuggestChain) {\n      throw new Error('Wallet does not support chain suggestions. Please add Neutron manually.');\n    }\n\n    // Minimal and up-to-date Neutron chain configuration.\n    const neutronChainInfo = {\n      chainId,\n      chainName: 'Neutron',\n      rpc: 'https://rpc-kralum.neutron.org',\n      rest: 'https://api-kralum.neutron.org',\n      bip44: { coinType: 118 },\n      bech32Config: {\n        bech32PrefixAccAddr: 'neutron',\n        bech32PrefixAccPub: 'neutronpub',\n        bech32PrefixValAddr: 'neutronvaloper',\n        bech32PrefixValPub: 'neutronvaloperpub',\n        bech32PrefixConsAddr: 'neutronvalcons',\n        bech32PrefixConsPub: 'neutronvalconspub'\n      },\n      currencies: [{ coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 }],\n      feeCurrencies: [{ coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 }],\n      stakeCurrency: { coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 },\n      gasPriceStep: { low: 0.01, average: 0.025, high: 0.04 }\n    };\n\n    try {\n      await keplr.experimentalSuggestChain(neutronChainInfo);\n      // Chain suggested successfully; enable it now.\n      await keplr.enable(chainId);\n      return true;\n    } catch (suggestErr) {\n      console.error('Failed to suggest Neutron chain:', suggestErr);\n      throw new Error('Unable to add Neutron network automatically. Please add it to your wallet manually.');\n    }\n  }\n};",
	"storeSessionAccount": "export const storeSessionAccount = async (signer) => {\n  if (!signer) throw new Error('Signer instance is required.');\n\n  // CosmJS signers expose getAccounts() which returns an array of accounts.\n  const accounts = await signer.getAccounts();\n  if (!accounts || accounts.length === 0) {\n    throw new Error('No accounts found in the signer.');\n  }\n\n  const { address, pubkey } = accounts[0];\n\n  const pubkeyBase64 = btoa(String.fromCharCode.apply(null, pubkey));\n\n  const accountInfo = {\n    address,\n    pubkey: pubkeyBase64 // Use the browser-safe Base64 string\n  };\n\n  try {\n    // Persist to the browser session (cleared on tab close).\n    sessionStorage.setItem('neutron_account', JSON.stringify(accountInfo));\n    return accountInfo;\n  } catch (err) {\n    console.error('Failed to write account info to sessionStorage:', err);\n    throw new Error('Unable to store account data locally.');\n  }\n};",
	"getOfflineSignerAndAddress": "export const getOfflineSignerAndAddress = async (chainId = 'neutron-1') => {\n    if (typeof window === 'undefined') {\n        throw new Error('This function must be run in a browser.');\n    }\n    const wallet = window.keplr || window.leap;\n    if (!wallet) {\n        throw new Error('Keplr or Leap wallet is not installed.');\n    }\n    await wallet.enable(chainId);\n    const signer = wallet.getOfflineSigner(chainId);\n    const accounts = await signer.getAccounts();\n    if (!accounts || accounts.length === 0) {\n        throw new Error('No accounts found in the connected wallet.');\n    }\n    return {\n        address: accounts[0].address,\n        signer,\n    };\n};",
	"loadContractAddress": "export const loadContractAddress = () => {\n    const address =\n        import.meta.env.VITE_TEMPLATE_CONTRACT_ADDRESS ||\n        process.env.NEXT_PUBLIC_TEMPLATE_CONTRACT_ADDRESS;\n    if (!address) {\n        throw new Error(\n            'Contract address is not defined in environment variables.'\n        );\n    }\n    if (!/^neutron1[0-9a-z]{38}$/.test(address)) {\n        throw new Error('Invalid Neutron contract address format.');\n    }\n    return address;\n};",
	"getContractAddress": "export const getContractAddress = (elementId = 'contract-address-input') => {\n    const inputEl = document.getElementById(elementId);\n    if (!inputEl) {\n        throw new Error(`Element with id \"${elementId}\" not found in the DOM.`);\n    }\n    const address = inputEl.value.trim();\n    if (!address) {\n        throw new Error('Contract address cannot be empty.');\n    }\n    return address;\n};",
	"queryContractSmart": "export const queryContractSmart = async (contractAddress, queryMsg) => {\n    const response = await fetch('/api/query-contract', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ contractAddress, query: queryMsg }),\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Failed to query contract.');\n    }\n    return response.json();\n    /*\n     * == BACKEND IMPLEMENTATION NOTE (/api/query-contract) ==\n     *\n     * 1. The backend receives `{ contractAddress, query }` in the request body.\n     * 2. It uses `@cosmjs/cosmwasm-stargate`'s `CosmWasmClient.connect(RPC_ENDPOINT)`.\n     * 3. It calls `client.queryContractSmart(contractAddress, query)`.\n     * 4. It returns the result as JSON to the frontend.\n     */\n};",
	"validateAddressFormat": "export const validateAddressFormat = async (address) => {\n    const response = await fetch('/api/validate-address', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ address }),\n    });\n    const result = await response.json();\n    if (!response.ok || !result.isValid) {\n        throw new Error(result.message || 'Invalid address.');\n    }\n    return true;\n    /*\n     * == BACKEND IMPLEMENTATION NOTE (/api/validate-address) ==\n     *\n     * 1. The backend receives `{ address }` in the request body.\n     * 2. It uses the `bech32` or `@cosmjs/encoding` library to decode the address.\n     * 3. It checks for decoding errors and verifies the bech32 prefix (e.g., 'neutron').\n     * 4. It returns `{ isValid: true }` or `{ isValid: false, message: '...' }`.\n     */\n};",
	"signAndBroadcast": "export const signAndBroadcast = async (signer, senderAddress, messages, fee, memo = '') => {\n    // NOTE: A real implementation requires a library like @cosmjs/stargate to sign.\n    // This function demonstrates the pattern of signing on the client and sending\n    // the signed bytes to a backend for broadcasting.\n    const signedTxBytes = await \"/* (Use a library like @cosmjs/stargate to create signed transaction bytes here) */\";\n\n    const response = await fetch('/api/broadcast-tx', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ signedTxBytes }),\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Failed to broadcast transaction.');\n    }\n\n    const result = await response.json();\n    return result.transactionHash;\n    /*\n     * == BACKEND IMPLEMENTATION NOTE (/api/broadcast-tx) ==\n     *\n     * 1. The backend receives the raw, signed transaction bytes.\n     * 2. It connects to an RPC endpoint using `StargateClient.connect(RPC_ENDPOINT)`.\n     * 3. It calls `client.broadcastTx(signedTxBytes)` to submit the transaction.\n     * 4. It returns `{ transactionHash: '...' }` on success or an error message on failure.\n     */\n};",
	"constructWasmQueryMsg": "export const constructWasmQueryMsg = (senderAddress) => {\n    // This example is specific to the `get_personal_counter` query.\n    // In a real app, you might have multiple, more specific constructors.\n    if (!senderAddress) {\n        return { get_global_counter: {} };\n    }\n    return {\n        get_personal_counter: { address: senderAddress },\n    };\n};",
	"constructTxWasmExecute": "export const constructTxWasmExecute = (senderAddress, contractAddress, msg, funds = []) => {\n    // This function returns a generic structure. The specific `msg` payload\n    // would be created separately, e.g., `{ deposit: {} }`.\n    return {\n        typeUrl: '/cosmwasm.wasm.v1.MsgExecuteContract',\n        value: {\n            sender: senderAddress,\n            contract: contractAddress,\n            msg: new TextEncoder().encode(JSON.stringify(msg)),\n            funds: funds,\n        },\n    };\n};",
	"convertToBaseUnits": "export const convertToBaseUnits = (amount, decimals = 6) => {\n    const numericAmount = Number(amount);\n    if (!Number.isFinite(numericAmount) || numericAmount <= 0) {\n        throw new Error('Amount must be a positive number.');\n    }\n    const factor = 10 ** decimals;\n    return String(Math.floor(numericAmount * factor));\n};",
	"suggestNeutronChain": "export const suggestNeutronChain = async (wallet) => {\n    if (!wallet || !wallet.experimentalSuggestChain) {\n        throw new Error('Wallet does not support suggesting new chains.');\n    }\n    const chainConfig = {\n        chainId: 'neutron-1',\n        chainName: 'Neutron',\n        rpc: 'https://rpc-kralum.neutron-1.neutron.org',\n        rest: 'https://rest-kralum.neutron-1.neutron.org',\n        bip44: { coinType: 118 },\n        bech32Config: { bech32PrefixAccAddr: 'neutron' },\n        currencies: [{ coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 }],\n        feeCurrencies: [{ coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 }],\n        stakeCurrency: { coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 },\n    };\n    await wallet.experimentalSuggestChain(chainConfig);\n};"
}