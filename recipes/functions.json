{
	"_ping": "def _ping(url: str, timeout: float = 1.5) -> float:\n    \"\"\"Return response-time in seconds (∞ if unreachable).\"\"\"\n    start = time.time()\n    try:\n        requests.head(url, timeout=timeout)\n        return time.time() - start\n    except requests.RequestException:\n        return float(\"inf\")",
	"select_data_provider": "def select_data_provider(prefer_graphql: bool = True) -> Dict[str, str]:\n    \"\"\"Choose the fastest available provider and return a descriptor dict.\"\"\"\n    providers = [\n        {\n            \"name\": \"celatone\",\n            \"base_url\": \"https://celatone-api.neutron.org/v1/graphql\",\n            \"api_type\": \"graphql\",\n        },\n        {\n            \"name\": \"lcd\",\n            \"base_url\": \"https://lcd.neutron.org\",\n            \"api_type\": \"rest\",\n        },\n    ]\n\n    # If GraphQL is preferred, try it first.\n    if prefer_graphql:\n        graphql_providers = [p for p in providers if p[\"api_type\"] == \"graphql\"]\n        if graphql_providers and _ping(graphql_providers[0][\"base_url\"]) != float(\"inf\"):\n            return graphql_providers[0]\n\n    # Fallback: choose the provider with the lowest latency.\n    best = min(providers, key=lambda p: _ping(p[\"base_url\"]))\n    if _ping(best[\"base_url\"]) == float(\"inf\"):\n        raise RuntimeError(\"No data provider is reachable at the moment.\")\n    return best",
	"build_history_query": "def build_history_query(\n    provider: Dict[str, str],\n    address: str,\n    limit: int = 50,\n    cursor: Optional[str] = None,\n    offset: int = 0,\n) -> Tuple[str, Union[Dict[str, Any], None]]:\n    \"\"\"Return (query_or_endpoint, variables_or_params) ready for Step 3.\"\"\"\n    if provider[\"api_type\"] == \"graphql\":\n        # Celatone GraphQL query string with optional cursor for pagination.\n        gql_query = (\n            \"\"\"\n            query ($address: String!, $limit: Int!, $cursor: String) {\n              messages(\n                where: {sender: {_eq: $address}},\n                order_by: {block: {time: desc}},\n                limit: $limit,\n                %s\n              ) {\n                transaction_hash\n                block { height time }\n                type\n                success\n                fee { amount denom }\n              }\n              pageInfo: messages_aggregate(where: {sender: {_eq: $address}}) {\n                aggregate { count }\n              }\n            }\n            \"\"\"\n            % (\"offset: 0\" if cursor is None else \"cursor: $cursor\")\n        )\n        variables: Dict[str, Any] = {\"address\": address, \"limit\": limit}\n        if cursor:\n            variables[\"cursor\"] = cursor\n        return gql_query, variables\n\n    # ---------- REST / LCD ----------\n    endpoint = f\"{provider['base_url']}/cosmos/tx/v1beta1/txs\"\n    params: Dict[str, Any] = {\n        \"events\": f\"message.sender='{address}'\",\n        \"order_by\": \"ORDER_BY_DESC\",\n        \"pagination.limit\": str(limit),\n        \"pagination.offset\": str(offset),\n    }\n    return endpoint, params",
	"execute_query_request": "def execute_query_request(\n    provider: Dict[str, str],\n    query_or_url: str,\n    variables_or_params: Optional[Union[Dict[str, Any], None]] = None,\n    timeout: int = 10,\n) -> Tuple[List[Dict[str, Any]], Optional[str]]:\n    \"\"\"Return (raw_results, next_cursor_or_offset).\"\"\"\n    try:\n        if provider[\"api_type\"] == \"graphql\":\n            resp = requests.post(\n                provider[\"base_url\"],\n                json={\"query\": query_or_url, \"variables\": variables_or_params or {}},\n                timeout=timeout,\n            )\n            resp.raise_for_status()\n            data = resp.json()\n            if \"errors\" in data:\n                raise RuntimeError(f\"GraphQL error: {data['errors']}\")\n            results = data[\"data\"][\"messages\"]\n            # Cursor-based pagination (Celatone may not expose pageInfo directly − adjust if needed)\n            next_cursor = variables_or_params.get(\"cursor\") if variables_or_params else None\n            return results, next_cursor\n        # ---------------- REST / LCD ----------------\n        resp = requests.get(query_or_url, params=variables_or_params, timeout=timeout)\n        resp.raise_for_status()\n        data = resp.json()\n        results = data.get(\"txs\", []) or data.get(\"tx_responses\", [])\n        next_key = data.get(\"pagination\", {}).get(\"next_key\")\n        return results, next_key\n    except requests.RequestException as exc:\n        raise RuntimeError(f\"Failed to query {provider['name']}: {exc}\") from exc",
	"normalize_tx_results": "def normalize_tx_results(provider: Dict[str, str], raw_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:\n    \"\"\"Map each transaction to {hash, blockHeight, action, fee, success}.\"\"\"\n    normalized: List[Dict[str, Any]] = []\n\n    if provider[\"api_type\"] == \"graphql\":\n        for item in raw_results:\n            fee_obj = item.get(\"fee\", {}) or {}\n            fee_str = (\n                f\"{fee_obj.get('amount', '0')}{fee_obj.get('denom', '')}\"\n                if fee_obj else \"0\"\n            )\n            normalized.append(\n                {\n                    \"hash\": item.get(\"transaction_hash\"),\n                    \"blockHeight\": item.get(\"block\", {}).get(\"height\"),\n                    \"timestamp\": item.get(\"block\", {}).get(\"time\"),\n                    \"action\": item.get(\"type\"),\n                    \"fee\": fee_str,\n                    \"success\": bool(item.get(\"success\")),\n                }\n            )\n    else:  # REST / LCD\n        for tx in raw_results:\n            # Transaction hash and height\n            hash_ = tx.get(\"txhash\") or tx.get(\"hash\")\n            height = int(tx.get(\"height\", 0))\n            timestamp = tx.get(\"timestamp\")\n\n            # First message type as action indicator\n            first_msg = (\n                (tx.get(\"tx\", {}) or {}).get(\"body\", {}).get(\"messages\", [])\n            )\n            action = first_msg[0].get(\"@type\", \"\") if first_msg else \"\"\n\n            # Fee formatting\n            fee_info = (tx.get(\"tx\", {}) or {}).get(\"auth_info\", {}).get(\"fee\", {})\n            fee_amounts = fee_info.get(\"amount\", [])\n            fee_str = (\n                f\"{fee_amounts[0]['amount']}{fee_amounts[0]['denom']}\" if fee_amounts else \"0\"\n            )\n\n            success = tx.get(\"code\", 0) == 0  # code == 0 indicates success\n\n            normalized.append(\n                {\n                    \"hash\": hash_,\n                    \"blockHeight\": height,\n                    \"timestamp\": timestamp,\n                    \"action\": action,\n                    \"fee\": fee_str,\n                    \"success\": success,\n                }\n            )\n    return normalized",
	"compile_wasm_contract": "def compile_wasm_contract(contract_dir: str) -> str:\n    \"\"\"Compile a CosmWasm contract and return the path to the optimised .wasm file.\"\"\"\n    try:\n        # 1. Compile to Wasm (un-optimised)\n        subprocess.run(['cargo', 'wasm'], cwd=contract_dir, check=True)\n        # 2. Run the optimiser (expects `cargo run-script optimize` set up by rust-optimizer)\n        subprocess.run(['cargo', 'run-script', 'optimize'], cwd=contract_dir, check=True)\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(f'Contract compilation failed: {err}') from err\n\n    # Locate the optimised file (typically placed in <contract>/artifacts)\n    artifacts_dir = os.path.join(contract_dir, 'artifacts')\n    wasm_files = [f for f in os.listdir(artifacts_dir) if f.endswith('.wasm')]\n    if not wasm_files:\n        raise FileNotFoundError('Optimised wasm not found in artifacts directory.')\n    return os.path.join(artifacts_dir, wasm_files[0])",
	"get_local_chain_account": "def get_local_chain_account(key_name: str = 'cosmopark', faucet_url: str | None = 'http://localhost:4500/credit') -> dict:\n    \"\"\"Load or create a key and optionally request faucet funds.\"\"\"\n    try:\n        key_info_raw = subprocess.check_output([\n            'neutrond', 'keys', 'show', key_name,\n            '--output', 'json', '--keyring-backend', 'test'\n        ])\n    except subprocess.CalledProcessError:\n        # Key does not exist – create it\n        subprocess.run([\n            'neutrond', 'keys', 'add', key_name,\n            '--output', 'json', '--keyring-backend', 'test'\n        ], check=True)\n        key_info_raw = subprocess.check_output([\n            'neutrond', 'keys', 'show', key_name,\n            '--output', 'json', '--keyring-backend', 'test'\n        ])\n\n    key_info = json.loads(key_info_raw)\n    address = key_info['address']\n\n    # Ask faucet to top-up (optional / local-net only)\n    if faucet_url:\n        try:\n            requests.post(faucet_url, json={'address': address, 'denom': 'untrn'})\n        except Exception as faucet_err:\n            print(f'Faucet funding skipped/failed: {faucet_err}')\n\n    return {'name': key_name, 'address': address}",
	"query_contract_state": "def query_contract_state(client: LedgerClient, contract_address: str, query_msg: dict):\n    \"\"\"Query the contract’s state using a custom query message.\"\"\"\n    try:\n        return client.wasm_query(contract_address, query_msg)\n    except Exception as err:\n        raise RuntimeError(f'Contract query failed: {err}') from err",
	"query_bank_balance": "def query_bank_balance(address: str, denom: str = \"untrn\") -> int:\n    \"\"\"Return current balance for `address` in the given `denom`.\"\"\"\n    try:\n        balance = client.query_bank_balance(address, denom=denom)\n        return int(balance.amount)\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to query balance: {exc}\") from exc",
	"parse_balance_response": "def parse_balance_response(raw_json: str, denom: str = 'untrn') -> Dict[str, str]:\n    \"\"\"Extracts the balance for the specified denom and formats it for display.\"\"\"\n    try:\n        data = json.loads(raw_json)\n        balances = data.get('balances', [])\n        micro_amount = 0\n        for coin in balances:\n            if coin.get('denom') == denom:\n                micro_amount = int(coin.get('amount', '0'))\n                break\n        human_amount = Decimal(micro_amount) / Decimal(1_000_000)  # 1e6 micro = 1 NTRN\n        return {\n            'denom': denom,\n            'micro_amount': str(micro_amount),\n            'amount': f'{human_amount.normalize()} NTRN'\n        }\n    except (json.JSONDecodeError, ValueError) as err:\n        raise ValueError('Invalid JSON supplied to parser: ' + str(err))",
	"ensure_cosmopark_installed": "def ensure_cosmopark_installed() -> None:\n    \"\"\"Ensure that CosmoPark CLI and its Docker images are available.\"\"\"\n    # 1. Check CosmoPark binary\n    if shutil.which(\"cosmopark\") is None:\n        print(\"CosmoPark CLI not found. Attempting installation via pip…\")\n        try:\n            subprocess.check_call([sys.executable, \"-m\", \"pip\", \"install\", \"cosmopark-cli\"])\n        except subprocess.CalledProcessError as err:\n            raise RuntimeError(\"Automatic installation of CosmoPark CLI failed.\") from err\n    else:\n        print(\"CosmoPark CLI detected ✅\")\n\n    # 2. Verify Docker is installed – required by CosmoPark\n    if shutil.which(\"docker\") is None:\n        raise RuntimeError(\"Docker is required but not installed or not in PATH.\")\n\n    # 3. Pull (or update) all CosmoPark Docker images\n    try:\n        subprocess.check_call([\"cosmopark\", \"pull\", \"--all\"])\n        print(\"CosmoPark Docker images pulled ✅\")\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(\"Failed to pull CosmoPark Docker images.\") from err",
	"run_cosmopark_init": "def run_cosmopark_init(workspace_path: str = \"./localnet\") -> None:\n    \"\"\"Run `cosmopark init` inside the chosen workspace directory.\"\"\"\n    workspace = Path(workspace_path).expanduser().resolve()\n    workspace.mkdir(parents=True, exist_ok=True)\n\n    cmd = [\"cosmopark\", \"init\"]\n    try:\n        subprocess.check_call(cmd, cwd=str(workspace))\n        print(f\"Workspace initialised at {workspace} ✅\")\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(\"`cosmopark init` failed.\") from err",
	"run_cosmopark_start": "def run_cosmopark_start(workspace_path: str = \"./localnet\") -> None:\n    \"\"\"Run `cosmopark start` inside the workspace to spin up the chain.\"\"\"\n    cmd = [\"cosmopark\", \"start\"]\n    try:\n        subprocess.check_call(cmd, cwd=workspace_path)\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(\"`cosmopark start` failed.\") from err",
	"verify_local_chain_running": "def verify_local_chain_running(rpc_url: str = \"http://localhost:26657/status\", timeout: int = 60) -> int:\n    \"\"\"Wait until the RPC endpoint returns a status with a block height or raise on timeout.\"\"\"\n    start = time.time()\n    while True:\n        try:\n            resp = requests.get(rpc_url, timeout=3)\n            if resp.status_code == 200:\n                data = resp.json()\n                height = int(data[\"result\"][\"sync_info\"][\"latest_block_height\"])\n                print(f\"Local chain is up ✅  (latest height={height})\")\n                return height\n        except Exception:\n            # Ignore and retry until timeout\n            pass\n\n        if time.time() - start > timeout:\n            raise RuntimeError(f\"Local chain did not start within {timeout} seconds.\")\n\n        print(\"⏳ Waiting for local chain…\")\n        time.sleep(3)",
	"format_amount": "def format_amount(raw_balance: int) -> str:\n    \"\"\"Convert micro-denom (`untrn`) to a formatted NTRN string.\"\"\"\n    try:\n        micro = int(raw_balance)\n    except (TypeError, ValueError):\n        raise ValueError(\"raw_balance must be an integer-compatible value\")\n\n    ntrn_value = micro / 1_000_000  # 1 NTRN = 1,000,000 untrn\n    return f\"{ntrn_value:,.6f} NTRN\"",
	"get_admin_wallet": "def get_admin_wallet() -> LocalWallet:\n    \"\"\"Return the admin LocalWallet defined by the ADMIN_MNEMONIC env-var.\"\"\"\n    mnemonic = os.getenv(\"ADMIN_MNEMONIC\")\n    if not mnemonic:\n        raise EnvironmentError(\"ADMIN_MNEMONIC environment variable is not set.\")\n\n    try:\n        wallet = LocalWallet.from_mnemonic(mnemonic)\n    except Exception as err:\n        raise ValueError(f\"Failed to create wallet from mnemonic: {err}\") from err\n\n    return wallet",
	"get_contract_address": "def get_contract_address() -> str:\n    \"\"\"Return the contract address defined by CONTRACT_ADDRESS env-var.\"\"\"\n    contract_addr = os.getenv(\"CONTRACT_ADDRESS\") or \"\"\n    if not _BECH32_RE.match(contract_addr):\n        raise ValueError(\"CONTRACT_ADDRESS env-var is missing or not a valid Neutron bech32 address.\")\n    return contract_addr",
	"construct_tx_execute_contract": "def construct_tx_execute_contract(contract_addr: str, wallet, gas: int = 200000) -> Transaction:\n    \"\"\"Create an unsigned Transaction carrying the reset execute message.\"\"\"\n    execute_msg = {\"reset\": {}}\n\n    # Build protobuf MsgExecuteContract using the helper (encodes & sets funds = [])\n    msg = create_msg_execute_contract(\n        sender=str(wallet.address()),\n        contract=contract_addr,\n        msg=json.dumps(execute_msg).encode(),\n        funds=[],\n    )\n\n    tx = Transaction()\n    tx.add_message(msg)\n    tx.with_chain_id(NETWORK_CFG.chain_id)\n    tx.with_sender(wallet.address())\n    tx.with_gas(gas)\n    # Fee is automatically derived from gas*gas_price if not specified explicitly\n    return tx",
	"get_neutron_client": "def get_neutron_client() -> LedgerClient:\n    \"\"\"Initialises a LedgerClient pointed at Pion-1.\n\n    Raises:\n        EnvironmentError: If an RPC endpoint is missing.\n    \"\"\"\n    rpc_url = os.getenv(\"PION_RPC\", \"https://rpc.pion-1.ntrn.tech:443\")\n\n    if not rpc_url:\n        raise EnvironmentError(\"RPC endpoint for Pion-1 is not set.\")\n\n    cfg = NetworkConfig(\n        chain_id=\"pion-1\",\n        url=rpc_url,\n        fee_minimum_gas_price=0.025,  # 0.025 NTRN / gas\n        fee_denomination=\"untrn\",\n        staking_denomination=\"untrn\",\n        bech32_hrp=\"neutron\"\n    )\n\n    return LedgerClient(cfg)",
	"load_signing_key": "def load_signing_key() -> PrivateKey:\n    \"\"\"Loads (or creates) a PrivateKey from a MNEMONIC env-var.\"\"\"\n    global _SIGNING_KEY\n    if _SIGNING_KEY is None:\n        mnemonic = os.getenv(\"NEUTRON_MNEMONIC\")\n        if not mnemonic:\n            raise EnvironmentError(\"Please export NEUTRON_MNEMONIC before running.\")\n        _SIGNING_KEY = PrivateKey.from_mnemonic(mnemonic)\n    return _SIGNING_KEY",
	"get_code_id": "def get_code_id(client: LedgerClient, uploader: str, explicit_code_id: Optional[int] = None) -> int:\n    \"\"\"Determine the code_id to instantiate.\n\n    Args:\n        client:   The LedgerClient from Step 1.\n        uploader: Address that stored the code (usually our wallet).\n        explicit_code_id: Optional override (e.g. via CLI flag).\n\n    Returns:\n        int: The wasm `code_id`.\n\n    Raises:\n        ValueError: If we cannot discover a code_id.\n    \"\"\"\n    # Highest priority: explicit argument / env-var\n    if explicit_code_id is None:\n        env_code_id = os.getenv(\"CODE_ID\")\n        explicit_code_id = int(env_code_id) if env_code_id else None\n\n    if explicit_code_id is not None:\n        return explicit_code_id\n\n    # Fallback: query the chain for all codes uploaded by `uploader`\n    response = client.query(\"/cosmwasm/wasm/v1/code\")  # REST path for all codes\n    codes = json.loads(response)[\"code_infos\"]\n\n    # Filter codes by creator and pick the latest\n    user_codes = [int(c[\"code_id\"]) for c in codes if c.get(\"creator\") == uploader]\n    if not user_codes:\n        raise ValueError(\"No code_id found for uploader – pass CODE_ID env-var or argument.\")\n    return max(user_codes)",
	"construct_update_admin_tx": "def construct_update_admin_tx(\n    sender_address: str,\n    contract_address: str,\n    new_admin_address: str,\n) -> Tuple[Transaction, LedgerClient]:\n    \"\"\"Create an unsigned Transaction containing a MsgUpdateAdmin message.\n\n    Args:\n        sender_address: Current admin / governance address signing the tx.\n        contract_address: Address of the CosmWasm contract.\n        new_admin_address: Address that will become the new admin.\n\n    Returns:\n        A tuple of (tx, ledger_client) ready for signing & broadcasting.\n    \"\"\"\n    # Initialize client\n    network_cfg = NetworkConfig(\n        chain_id=CHAIN_ID,\n        url=RPC_ENDPOINT,\n    )\n    client = LedgerClient(network_cfg)\n\n    # Build the MsgUpdateAdmin protobuf message\n    msg = MsgUpdateAdmin(\n        sender=sender_address,\n        contract=contract_address,\n        new_admin=new_admin_address,\n    )\n\n    # Pack into Any type\n    any_msg = Any()\n    any_msg.Pack(msg, type_url_prefix='')  # cosmpy handles type_url internally\n\n    # Create transaction and add message\n    tx = Transaction()\n    tx.add_message(any_msg)\n\n    # Set a placeholder fee & gas (will be adjusted when we sign)\n    tx.set_fee(FEE_DENOM, amount=5000, gas_limit=DEFAULT_GAS_LIMIT)\n\n    return tx, client",
	"query_contract_info": "def query_contract_info(contract_address: str, lcd: str = REST_ENDPOINT) -> Dict:\n    \"\"\"Request contract metadata from the LCD endpoint.\n\n    Args:\n        contract_address (str): Bech32 contract address.\n        lcd (str): Base URL for the LCD server.\n\n    Returns:\n        Dict: Parsed JSON with contract metadata.\n    \"\"\"\n    url = f\"{lcd}/cosmwasm/wasm/v1/contract/{contract_address}\"\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        data = response.json()\n        return data.get(\"contract_info\", {})\n    except requests.RequestException as exc:\n        raise ContractQueryError(f\"LCD request failed: {exc}\") from exc\n    except ValueError:\n        raise ContractQueryError(\"LCD returned malformed JSON\")",
	"query_code_info": "def query_code_info(code_id: str, lcd: str = REST_ENDPOINT) -> Dict:\n    \"\"\"Retrieve code-info (including `code_hash`) from the LCD.\n\n    Args:\n        code_id (str): The code ID extracted in Step 3.\n        lcd (str): Base URL for the LCD server.\n\n    Returns:\n        Dict: JSON payload containing code-info.\n    \"\"\"\n    url = f\"{lcd}/cosmwasm/wasm/v1/code/{code_id}\"\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        return response.json().get(\"code_info\", {})\n    except requests.RequestException as exc:\n        raise CodeInfoQueryError(f\"LCD request failed: {exc}\") from exc\n    except ValueError:\n        raise CodeInfoQueryError(\"Malformed JSON in LCD response\")",
	"extract_code_hash": "def extract_code_hash(code_info: Dict) -> str:\n    \"\"\"Safely extract the `code_hash` value.\n\n    Args:\n        code_info (Dict): Output from `query_code_info`.\n\n    Returns:\n        str: The hexadecimal code hash.\n    \"\"\"\n    try:\n        code_hash = code_info[\"data_hash\"] or code_info[\"code_hash\"]  # field name may differ\n        if not code_hash:\n            raise KeyError\n        return code_hash\n    except KeyError:\n        raise CodeHashExtractionError(\"`code_hash` not present in code-info payload\")",
	"validate_new_code_id": "async def validate_new_code_id(contract_address: str, new_code_id: int, rpc_url: str = \"https://rpc-kralum.neutron-1.neutron.org\") -> bool:\n    \"\"\"Validate that `new_code_id` exists and differs from the contract's current code ID.\n\n    Args:\n        contract_address (str): Address of the contract to migrate.\n        new_code_id (int): The code ID to migrate to.\n        rpc_url (str): RPC endpoint for Neutron.\n    Returns:\n        bool: True if the validation succeeds, otherwise an exception is raised.\n    \"\"\"\n    try:\n        cfg = NetworkConfig(\n            chain_id=\"neutron-1\",\n            url=rpc_url,\n            fee_minimum_gas_price=\"0.025untrn\",\n            fee_denomination=\"untrn\",\n        )\n        client = LedgerClient(cfg)\n\n        # Ensure the new code ID exists\n        code_info = client.query.wasm.get_code_info(new_code_id)\n        if code_info is None:\n            raise ValueError(f\"Code ID {new_code_id} does not exist on-chain.\")\n\n        # Fetch current contract info\n        contract_info = client.query.wasm.get_contract_info(contract_address)\n        if int(contract_info[\"code_id\"]) == new_code_id:\n            raise ValueError(\"Contract already instantiated with this code ID.\")\n\n        return True\n    except (QueryError, Exception) as err:\n        raise RuntimeError(f\"Validation failed: {err}\") from err",
	"get_neutron_mainnet_client": "def get_neutron_mainnet_client(mnemonic: str, rpc_url: str = \"https://rpc-kralum.neutron-1.neutron.org:443\") -> LedgerClient:\n    # Returns a cosmpy LedgerClient configured for Neutron mainnet\n    if not mnemonic:\n        raise ValueError(\"Mnemonic must not be empty\")\n\n    cfg = NetworkConfig(\n        chain_id=\"neutron-1\",\n        url=rpc_url,\n        fee_min_denom=\"untrn\",\n        gas_price=0.025,  # 0.025 NTRN/gas is a reasonable default for mainnet\n    )\n\n    wallet = LocalWallet.create_from_mnemonic(mnemonic)\n    return LedgerClient(cfg, wallet)",
	"ensure_wasm_file": "def ensure_wasm_file(path: str) -> str:\n    # Validates the existence and size (< 4 MiB) of the compiled .wasm file\n    if not os.path.isfile(path):\n        raise FileNotFoundError(f\"WASM file not found at {path}\")\n\n    size = os.path.getsize(path)\n    if size > 4 * 1024 * 1024:\n        raise ValueError(f\"WASM binary is {size} bytes which exceeds the 4 MiB limit.\")\n\n    return os.path.abspath(path)",
	"build_store_code_tx": "def build_store_code_tx(client: LedgerClient, wasm_path: str, memo: str = \"Upload contract\") -> Transaction:\n    with open(wasm_path, \"rb\") as f:\n        wasm_bytes = f.read()\n\n    msg = wasm_tx.MsgStoreCode(\n        sender=client.wallet.address(),\n        wasm_byte_code=wasm_bytes,\n        instantiate_permission=wasm_types.AccessConfig(\n            permission=wasm_types.AccessType.ACCESS_TYPE_EVERYBODY\n        ),\n    )\n\n    tx = client.tx.create([msg], memo=memo, gas_limit=2_500_000)\n    return tx",
	"build_instantiate_tx": "def build_instantiate_tx(client: LedgerClient, code_id: int, init_msg: dict, label: str, admin: str | None = None) -> Transaction:\n    msg = wasm_tx.MsgInstantiateContract(\n        sender=client.wallet.address(),\n        admin=admin or client.wallet.address(),\n        code_id=code_id,\n        label=label,\n        msg=jsonlib.dumps(init_msg).encode(),\n        funds=[]  # add coins here if your contract expects an initial deposit\n    )\n    tx = client.tx.create([msg], memo=f\"Instantiate {label}\", gas_limit=1_000_000)\n    return tx",
	"extract_contract_address": "def extract_contract_address(response) -> str:\n    try:\n        logs = json.loads(response.raw_log)\n        for event in logs[0][\"events\"]:\n            if event[\"type\"] == \"instantiate\":\n                for attr in event[\"attributes\"]:\n                    if attr[\"key\"] in (\"_contract_address\", \"contract_address\"):\n                        return attr[\"value\"]\n    except (KeyError, ValueError, json.JSONDecodeError) as err:\n        raise RuntimeError(f\"Unable to find contract address: {err}\")\n    raise RuntimeError(\"Contract address not present in tx logs\")",
	"connect_rpc_endpoint": "def connect_rpc_endpoint(rpc_endpoint: str = 'https://rpc-kralum.neutron.org') -> str:\n    \"\"\"\n    Attempts to connect to the given Neutron RPC endpoint by querying the `/status`\n    route. Returns the endpoint string if successful; raises an exception otherwise.\n    \"\"\"\n    try:\n        # Hit `/status` to confirm the node is alive\n        url = rpc_endpoint.rstrip('/') + '/status'\n        response = requests.get(url, timeout=5)\n        response.raise_for_status()\n\n        # Basic sanity check on the payload\n        if 'result' not in response.json():\n            raise ValueError('Unexpected response payload from RPC endpoint.')\n\n        return rpc_endpoint\n    except requests.RequestException as err:\n        raise ConnectionError(\n            f'Unable to reach Neutron RPC endpoint at {rpc_endpoint}: {err}'\n        ) from err",
	"neutrond_status": "def neutrond_status(rpc_endpoint: str) -> Dict:\n    \"\"\"\n    Executes `neutrond status --node <rpc_endpoint>` via subprocess and returns\n    the parsed JSON dictionary containing the node's sync information.\n    \"\"\"\n    try:\n        cmd = [\n            'neutrond',\n            'status',\n            '--node',\n            rpc_endpoint,\n        ]\n        result = subprocess.run(\n            cmd,\n            capture_output=True,\n            text=True,\n            check=True,\n        )\n        return json.loads(result.stdout)\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(f'`neutrond status` failed: {err.stderr}') from err\n    except json.JSONDecodeError as err:\n        raise ValueError('Failed to parse JSON from neutrond output.') from err",
	"extract_block_height": "def extract_block_height(status_json: Dict) -> int:\n    \"\"\"\n    Extracts the latest block height from the status JSON returned by `neutrond status`.\n    \"\"\"\n    try:\n        height_str = status_json['result']['sync_info']['latest_block_height']\n        return int(height_str)\n    except (KeyError, TypeError, ValueError) as err:\n        raise ValueError(\n            'Invalid status JSON format: unable to locate `latest_block_height`.'\n        ) from err",
	"open_celatone_explorer": "def open_celatone_explorer(chain_id: str, download_dir: str = \"/tmp\") -> webdriver.Chrome:\n    \"\"\"Launch Celatone (https://celatone.osmosis.zone) for the given chain and\n    return an initialized Selenium WebDriver.\n\n    Args:\n        chain_id (str): Either \"neutron-1\" (mainnet) or \"pion-1\" (testnet).\n        download_dir (str): Directory where Celatone will drop the metadata JSON.\n\n    Returns:\n        webdriver.Chrome: A configured Chrome WebDriver pointing at Celatone.\n    \"\"\"\n\n    if chain_id not in (\"neutron-1\", \"pion-1\"):\n        raise ValueError(\"Unsupported chain id. Use 'neutron-1' or 'pion-1'.\")\n\n    url = f\"https://celatone.osmosis.zone/{chain_id}\"\n\n    # Configure Chrome for head-less use and automatic downloads\n    chrome_opts = Options()\n    chrome_opts.add_argument(\"--headless=new\")\n    chrome_opts.add_argument(\"--window-size=1920,1080\")\n    chrome_opts.add_experimental_option(\n        \"prefs\",\n        {\n            \"download.default_directory\": download_dir,\n            \"download.prompt_for_download\": False,\n            \"download.directory_upgrade\": True,\n            \"safebrowsing.enabled\": True,\n        },\n    )\n\n    try:\n        driver = webdriver.Chrome(options=chrome_opts)\n        driver.get(url)\n\n        # Wait until the search bar is rendered so we know the page finished loading\n        WebDriverWait(driver, 15).until(\n            EC.presence_of_element_located((\"css selector\", \"input[type='search']\"))\n        )\n        return driver\n    except WebDriverException as exc:\n        raise RuntimeError(f\"Failed to open Celatone explorer: {exc}\") from exc",
	"search_contract_address": "def search_contract_address(driver: webdriver.Chrome, contract_address: str, timeout: int = 15) -> None:\n    \"\"\"Paste the contract address into Celatone's search bar and navigate to the\n    contract page.\n\n    Args:\n        driver (webdriver.Chrome): Active Celatone WebDriver.\n        contract_address (str): Bech32 address of the target contract.\n        timeout (int): Max seconds to wait for the contract page to load.\n    \"\"\"\n\n    try:\n        # Locate the search bar element and submit the address\n        search_box = driver.find_element(By.CSS_SELECTOR, \"input[type='search']\")\n        search_box.clear()\n        search_box.send_keys(contract_address + Keys.ENTER)\n\n        # Wait until URL contains the contract address, indicating navigation\n        WebDriverWait(driver, timeout).until(\n            EC.url_contains(contract_address.lower())\n        )\n    except TimeoutException:\n        raise RuntimeError(\"Celatone did not navigate to the contract page in time.\")",
	"navigate_to_metadata_tab": "def navigate_to_metadata_tab(driver: webdriver.Chrome, timeout: int = 10) -> None:\n    \"\"\"Click Celatone's \"Metadata\" tab for the currently opened contract page.\"\"\"\n    try:\n        # The tab usually appears as a button or anchor containing the visible text \"Metadata\"\n        metadata_tab = WebDriverWait(driver, timeout).until(\n            EC.element_to_be_clickable((By.XPATH, \"//button[contains(., 'Metadata')] | //a[contains(., 'Metadata')]\"))\n        )\n        metadata_tab.click()\n\n        # Wait until the JSON download (</>) icon is visible in the Metadata view\n        WebDriverWait(driver, timeout).until(\n            EC.presence_of_element_located((By.XPATH, \"//button[contains(@title, 'Download') or contains(@aria-label, 'Download')]\"))\n        )\n    except (TimeoutException, NoSuchElementException):\n        raise RuntimeError(\"Could not open the Metadata tab on Celatone.\")",
	"download_metadata_json": "def download_metadata_json(driver: webdriver.Chrome, download_dir: str, timeout: int = 30) -> Path:\n    \"\"\"Click the download button and wait until the metadata JSON is fully\n    written to disk.\n\n    Args:\n        driver (webdriver.Chrome): Active WebDriver on the Metadata tab.\n        download_dir (str): Directory configured in open_celatone_explorer().\n        timeout (int): Max seconds to wait for the file to finish downloading.\n\n    Returns:\n        Path: Absolute path to the downloaded metadata JSON file.\n    \"\"\"\n\n    # Grab a snapshot of existing files so we can detect the new one later\n    pre_existing = set(Path(download_dir).iterdir()) if os.path.isdir(download_dir) else set()\n\n    # Click the download (code / </>) button\n    try:\n        download_btn = driver.find_element(By.XPATH, \"//button[contains(@title, 'Download') or contains(@aria-label, 'Download')]\")\n        download_btn.click()\n    except Exception as exc:\n        raise RuntimeError(\"Failed to click Celatone's download button\") from exc\n\n    # Poll for a new .json file that was not present earlier\n    end_time = time.time() + timeout\n    while time.time() < end_time:\n        current_files = set(Path(download_dir).iterdir())\n        new_files = [f for f in current_files - pre_existing if f.suffix.lower() == \".json\"]\n        if new_files:\n            # Celatone sometimes writes a *.crdownload first; wait until file stabilises.\n            candidate = new_files[0]\n            if not candidate.name.endswith(\".crdownload\"):\n                return candidate.resolve()\n        time.sleep(0.5)\n\n    raise TimeoutException(\"Timed out waiting for metadata JSON download to complete.\")",
	"query_contracts_by_creator": "async def query_contracts_by_creator(\n    creator_address: str,\n    limit: int = 1000,\n    pagination_key: Optional[str] = None,\n) -> Dict[str, Any]:\n    \"\"\"Query one page of contracts created by `creator_address`.\n\n    Args:\n        creator_address (str): Bech32 Neutron address.\n        limit (int, optional): Maximum results per page. Defaults to 1000.\n        pagination_key (str, optional): The opaque `next_key` from the previous\n            response. If provided, the query continues from that key.\n\n    Returns:\n        Dict[str, Any]: JSON response from the LCD containing contracts and pagination data.\n    \"\"\"\n    params = {\n        \"creator\": creator_address,\n        \"pagination.limit\": str(limit),\n    }\n    if pagination_key:\n        params[\"pagination.key\"] = pagination_key\n\n    url = f\"{LCD_URL}/cosmwasm/wasm/v1/contracts\"\n\n    async with httpx.AsyncClient(timeout=10) as client:\n        response = await client.get(url, params=params)\n        response.raise_for_status()  # Raises if HTTP != 200\n        return response.json()",
	"fetch_all_contracts_by_creator": "async def fetch_all_contracts_by_creator(creator_address: str, page_limit: int = 1000) -> List[str]:\n    \"\"\"Return a complete list of contract addresses deployed by `creator_address`.\"\"\"\n    contracts: List[str] = []\n    next_key: Optional[str] = None\n\n    while True:\n        page = await query_contracts_by_creator(\n            creator_address=creator_address,\n            limit=page_limit,\n            pagination_key=next_key,\n        )\n\n        # Extract contracts list from page data and extend our accumulator\n        contracts.extend(page.get(\"contracts\", []))\n\n        # Determine if more pages exist\n        next_key = page.get(\"pagination\", {}).get(\"next_key\")\n        if not next_key:\n            break  # No more pages\n\n    return contracts",
	"validate_wasm_checksum": "def validate_wasm_checksum(wasm_path: Path) -> str:\n    if not wasm_path.is_file():\n        raise FileNotFoundError(f'File not found: {wasm_path}')\n\n    sha256 = hashlib.sha256()\n    with wasm_path.open('rb') as f:\n        for chunk in iter(lambda: f.read(8192), b''):\n            sha256.update(chunk)\n    checksum = sha256.hexdigest()\n    return checksum",
	"sign_and_broadcast_tx": "def sign_and_broadcast_tx(tx: Transaction, wallet: LocalWallet, client: LedgerClient):\n    # Fill in sequence & account number from chain state\n    tx = tx.with_sequence(wallet.get_sequence(client)).with_account_number(wallet.get_account_number(client))\n\n    signed_tx = tx.sign(wallet)\n    response = client.broadcast_tx(signed_tx)\n\n    if response.tx_response.code != 0:\n        raise RuntimeError(f'Tx failed with log: {response.tx_response.raw_log}')\n\n    return response",
	"extract_code_id_from_tx": "def extract_code_id_from_tx(response) -> int:\n    raw_log = response.tx_response.raw_log\n\n    # Attempt JSON parsing (preferred because it is deterministic)\n    try:\n        parsed_logs = json.loads(raw_log)[0]\n        for event in parsed_logs.get('events', []):\n            if event.get('type') == 'store_code':\n                for attr in event.get('attributes', []):\n                    if attr.get('key') == 'code_id':\n                        return int(attr.get('value'))\n    except (json.JSONDecodeError, KeyError, IndexError):\n        pass\n\n    # Fallback: regex scanning for robustness\n    match = re.search(r'\\\"code_id\\\":\\s*\\\"?(\\d+)\\\"?', raw_log)\n    if match:\n        return int(match.group(1))\n\n    raise ValueError('code_id not found in transaction logs')",
	"construct_param_change_proposal": "def construct_param_change_proposal(new_security_address: str, deposit: str = \"10000000untrn\", output_path: str = \"proposal.json\") -> str:\n    \"\"\"Generate a Param-Change proposal file that updates the Cron module's security_address.\"\"\"\n    proposal = {\n        \"title\": \"Update Cron security_address\",\n        \"description\": f\"Updates Cron module security_address param to {new_security_address}.\",\n        \"changes\": [{\"subspace\": \"cron\", \"key\": \"SecurityAddress\", \"value\": f'\"{new_security_address}\"'}],\n        \"deposit\": deposit\n    }\n    try:\n        with open(output_path, \"w\", encoding=\"utf-8\") as fp:\n            json.dump(proposal, fp, indent=2)\n    except IOError as err:\n        raise RuntimeError(f\"Could not write proposal file: {err}\") from err\n    return output_path",
	"build_dao_proposal": "def build_dao_proposal(msg_update_params: Dict, title: str, description: str) -> Dict:\n    \"\"\"Return the message to execute against a cw-dao core contract.\"\"\"\n    proposal = {\n        \"propose\": {\n            \"title\": title,\n            \"description\": description,\n            \"msgs\": [{\"custom\": msg_update_params}],\n        }\n    }\n    return proposal",
	"wait_for_voting_result": "def wait_for_voting_result(proposal_id: str, chain_id: str = \"neutron-1\", node: str = \"https://rpc-kralum.neutron.org:443\", poll_interval: int = 15, max_attempts: int = 800) -> str:\n    \"\"\"Polls proposal status via CLI until it is finalized or times out.\"\"\"\n    for _ in range(max_attempts):\n        try:\n            proc = subprocess.run(\n                [\"neutrond\", \"query\", \"gov\", \"proposal\", str(proposal_id), \"--chain-id\", chain_id, \"--node\", node, \"--output\", \"json\"],\n                capture_output=True, text=True, check=True\n            )\n            status = json.loads(proc.stdout).get(\"status\")\n            print(f\"[poll] proposal {proposal_id} status: {status}\")\n            if status == \"PROPOSAL_STATUS_PASSED\":\n                return status\n            if status in (\"PROPOSAL_STATUS_REJECTED\", \"PROPOSAL_STATUS_FAILED\", \"PROPOSAL_STATUS_ABORTED\"):\n                raise RuntimeError(f\"Proposal {proposal_id} ended with status {status}\")\n        except (subprocess.CalledProcessError, json.JSONDecodeError) as e:\n            print(f\"Polling error: {e}. Retrying...\")\n        time.sleep(poll_interval)\n    raise TimeoutError(\"Exceeded maximum attempts while waiting for proposal to pass.\")",
	"query_cron_params": "def query_cron_params(chain_id: str = \"neutron-1\", node: str = \"https://rpc-kralum.neutron.org:443\") -> dict:\n    \"\"\"Fetches the current Cron module parameters via CLI.\"\"\"\n    proc = subprocess.run(\n        [\"neutrond\", \"query\", \"cron\", \"params\", \"--chain-id\", chain_id, \"--node\", node, \"--output\", \"json\"],\n        capture_output=True, text=True, check=True\n    )\n    return json.loads(proc.stdout).get(\"params\", {})",
	"query_cron_schedule": "def query_cron_schedule(schedule_name: str, node: str = \"https://rpc.neutron.org:443\") -> Dict:\n    \"\"\"Fetch schedule metadata from the Neutron Cron module via `neutrond` CLI.\"\"\"\n    try:\n        cmd = [\"neutrond\", \"query\", \"cron\", \"schedule\", schedule_name, \"--output\", \"json\", \"--node\", node]\n        result = subprocess.run(cmd, capture_output=True, text=True, check=True)\n        return json.loads(result.stdout)\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(f\"Failed to query schedule '{schedule_name}': {exc.stderr.strip()}\") from exc\n    except json.JSONDecodeError as exc:\n        raise ValueError(\"Received non-JSON response from neutrond CLI\") from exc",
	"query_all_cron_schedules": "def query_all_cron_schedules(limit: int = 1000) -> List[Dict]:\n    \"\"\"Return every cron schedule on-chain, handling pagination.\"\"\"\n    schedules: List[Dict] = []\n    next_key: str = \"\"\n    while True:\n        cmd = [\"neutrond\", \"query\", \"cron\", \"schedules\", \"--limit\", str(limit), \"--output\", \"json\"]\n        if next_key:\n            cmd += [\"--page-key\", next_key]\n        raw = subprocess.check_output(cmd, text=True)\n        data = json.loads(raw)\n        schedules.extend(data.get(\"schedules\", []))\n        next_key = data.get(\"pagination\", {}).get(\"next_key\")\n        if not next_key:\n            break\n    return schedules",
	"build_msg_add_schedule": "def build_msg_add_schedule(authority: str, name: str, period: int, msgs: List[Dict], execution_stage: str = \"EXECUTION_STAGE_END_BLOCKER\") -> Dict:\n    \"\"\"Return an SDK-compatible MsgAddSchedule dictionary.\"\"\"\n    return {\n        \"@type\": \"/neutron.cron.MsgAddSchedule\",\n        \"authority\": authority,\n        \"name\": name,\n        \"period\": str(period),\n        \"msgs\": msgs,\n        \"execution_stage\": execution_stage,\n    }",
	"build_msg_delete_schedule": "def build_msg_delete_schedule(authority: str, schedule_name: str = \"protocol_update\") -> dict:\n    \"\"\"Return an amino/JSON-encoded MsgDeleteSchedule body.\"\"\"\n    return {\n        \"@type\": \"/neutron.admin.MsgDeleteSchedule\",\n        \"authority_address\": authority,\n        \"name\": schedule_name\n    }",
	"schedule_removed": "def schedule_removed(name: str) -> bool:\n    \"\"\"Returns True only if the schedule no longer exists by checking the CLI.\"\"\"\n    try:\n        subprocess.run(\n            [\"neutrond\", \"query\", \"cron\", \"show-schedule\", name, \"--output=json\"],\n            capture_output=True, text=True, check=True,\n        )\n        return False\n    except subprocess.CalledProcessError as err:\n        if \"not found\" in err.stderr.lower():\n            return True\n        raise",
	"verify_security_address": "def verify_security_address(expected: str, chain_id: str = \"neutron-1\", node: str = \"https://rpc-kralum.neutron.org:443\") -> bool:\n    \"\"\"Validates that the on-chain security_address equals the expected value.\"\"\"\n    params = query_cron_params(chain_id, node)\n    actual = params.get(\"security_address\")\n    if actual == expected:\n        print(\"✅ Cron security_address matches expected value.\")\n        return True\n    raise ValueError(f\"security_address mismatch: expected {expected}, got {actual}\")",
	"extract_last_execution_height": "def extract_last_execution_height(schedule_data: dict) -> int:\n    \"\"\"Return the most recent execution height from schedule JSON.\"\"\"\n    for key in (\"last_execution_height\", \"last_executed_height\"):\n        if (value := schedule_data.get(key)) is not None:\n            return int(value)\n    raise KeyError(\"Could not find last execution height field in schedule data.\")",
	"ensureWalletConnected": "export const ensureWalletConnected = async () => {\n  try {\n    const chainId = 'neutron-1';\n    const keplr = window.keplr;\n\n    // Execute the full workflow\n    if (!keplr) {\n      throw new Error('Keplr wallet is not installed.');\n    }\n\n    await keplr.enable(chainId);\n    const signer = window.getOfflineSigner(chainId);\n\n    return signer;\n\n  } catch (err) {\n    alert(err.message);\n//     setError(err.message); // Update the error state\n  }\n};",
	"getWalletAddress": "export const getWalletAddress = async (signer) => {\n  try {\n      const accounts = await signer.getAccounts();\n      if (!accounts || accounts.length === 0) {\n        throw new Error('No account found in the signer.');\n      }\n\n      const address = accounts[0].address;\n      return address;\n  } catch (err) {\n    alert(err.message);\n//     setError(err.message); // Update the error state\n  }\n};",
	"connectWallet": "export const connectWallet = async (preferredWallet = 'keplr') => {\n  /*\n   * Attempt to detect and connect to the requested wallet extension.\n   * Currently supports Keplr and Leap; extend this switch-case to add more wallets.\n   */\n  let wallet;\n  switch (preferredWallet.toLowerCase()) {\n    case 'keplr':\n      wallet = window.keplr;\n      break;\n    case 'leap':\n      wallet = window.leap;\n      break;\n    default:\n      throw new Error(`${preferredWallet} wallet is not supported by this dApp.`);\n  }\n\n  if (!wallet) {\n    throw new Error(`${preferredWallet} extension not found. Please install it and refresh the page.`);\n  }\n\n  try {\n    // Ask the user to approve connection permissions (UI popup in the wallet).\n    await wallet.enable('neutron-1');\n    // Return an OfflineSigner required by CosmJS.\n    return wallet.getOfflineSigner('neutron-1');\n  } catch (err) {\n    console.error('Wallet connection failed:', err);\n    throw new Error('User rejected the wallet connection request or another error occurred.');\n  }\n};",
	"ensureNeutronNetwork": "export const ensureNeutronNetwork = async () => {\n  const chainId = 'neutron-1';\n  const keplr = window.keplr || window.leap;\n  if (!keplr) throw new Error('No compatible wallet detected.');\n\n  try {\n    // First try to enable Neutron if it already exists in the wallet.\n    await keplr.enable(chainId);\n    return true;\n  } catch (enableErr) {\n    console.warn('Neutron chain not yet added in the wallet, attempting experimentalSuggestChain');\n\n    // Fallback: suggest chain (only works if wallet supports the experimental API).\n    if (!keplr.experimentalSuggestChain) {\n      throw new Error('Wallet does not support chain suggestions. Please add Neutron manually.');\n    }\n\n    // Minimal and up-to-date Neutron chain configuration.\n    const neutronChainInfo = {\n      chainId,\n      chainName: 'Neutron',\n      rpc: 'https://rpc-kralum.neutron.org',\n      rest: 'https://api-kralum.neutron.org',\n      bip44: { coinType: 118 },\n      bech32Config: {\n        bech32PrefixAccAddr: 'neutron',\n        bech32PrefixAccPub: 'neutronpub',\n        bech32PrefixValAddr: 'neutronvaloper',\n        bech32PrefixValPub: 'neutronvaloperpub',\n        bech32PrefixConsAddr: 'neutronvalcons',\n        bech32PrefixConsPub: 'neutronvalconspub'\n      },\n      currencies: [{ coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 }],\n      feeCurrencies: [{ coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 }],\n      stakeCurrency: { coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 },\n      gasPriceStep: { low: 0.01, average: 0.025, high: 0.04 }\n    };\n\n    try {\n      await keplr.experimentalSuggestChain(neutronChainInfo);\n      // Chain suggested successfully; enable it now.\n      await keplr.enable(chainId);\n      return true;\n    } catch (suggestErr) {\n      console.error('Failed to suggest Neutron chain:', suggestErr);\n      throw new Error('Unable to add Neutron network automatically. Please add it to your wallet manually.');\n    }\n  }\n};",
	"storeSessionAccount": "export const storeSessionAccount = async (signer) => {\n  if (!signer) throw new Error('Signer instance is required.');\n\n  // CosmJS signers expose getAccounts() which returns an array of accounts.\n  const accounts = await signer.getAccounts();\n  if (!accounts || accounts.length === 0) {\n    throw new Error('No accounts found in the signer.');\n  }\n\n  const { address, pubkey } = accounts[0];\n\n  const pubkeyBase64 = btoa(String.fromCharCode.apply(null, pubkey));\n\n  const accountInfo = {\n    address,\n    pubkey: pubkeyBase64 // Use the browser-safe Base64 string\n  };\n\n  try {\n    // Persist to the browser session (cleared on tab close).\n    sessionStorage.setItem('neutron_account', JSON.stringify(accountInfo));\n    return accountInfo;\n  } catch (err) {\n    console.error('Failed to write account info to sessionStorage:', err);\n    throw new Error('Unable to store account data locally.');\n  }\n};",
	"getOfflineSignerAndAddress": "export const getOfflineSignerAndAddress = async (chainId = 'neutron-1') => {\n    if (typeof window === 'undefined') {\n        throw new Error('This function must be run in a browser.');\n    }\n    const wallet = window.keplr || window.leap;\n    if (!wallet) {\n        throw new Error('Keplr or Leap wallet is not installed.');\n    }\n    await wallet.enable(chainId);\n    const signer = wallet.getOfflineSigner(chainId);\n    const accounts = await signer.getAccounts();\n    if (!accounts || accounts.length === 0) {\n        throw new Error('No accounts found in the connected wallet.');\n    }\n    return {\n        address: accounts[0].address,\n        signer,\n    };\n};",
	"loadContractAddress": "export const loadContractAddress = () => {\n    const address =\n        import.meta.env.VITE_TEMPLATE_CONTRACT_ADDRESS ||\n        process.env.NEXT_PUBLIC_TEMPLATE_CONTRACT_ADDRESS;\n    if (!address) {\n        throw new Error(\n            'Contract address is not defined in environment variables.'\n        );\n    }\n    if (!/^neutron1[0-9a-z]{38}$/.test(address)) {\n        throw new Error('Invalid Neutron contract address format.');\n    }\n    return address;\n};",
	"getContractAddress": "export const getContractAddress = (elementId = 'contract-address-input') => {\n    const inputEl = document.getElementById(elementId);\n    if (!inputEl) {\n        throw new Error(`Element with id \"${elementId}\" not found in the DOM.`);\n    }\n    const address = inputEl.value.trim();\n    if (!address) {\n        throw new Error('Contract address cannot be empty.');\n    }\n    return address;\n};",
	"queryContractSmart": "export const queryContractSmart = async (contractAddress, queryMsg) => {\n    const response = await fetch('/api/query-contract', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ contractAddress, query: queryMsg }),\n    });\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Failed to query contract.');\n    }\n    return response.json();\n    /*\n     * == BACKEND IMPLEMENTATION NOTE (/api/query-contract) ==\n     *\n     * 1. The backend receives `{ contractAddress, query }` in the request body.\n     * 2. It uses `@cosmjs/cosmwasm-stargate`'s `CosmWasmClient.connect(RPC_ENDPOINT)`.\n     * 3. It calls `client.queryContractSmart(contractAddress, query)`.\n     * 4. It returns the result as JSON to the frontend.\n     */\n};",
	"validateAddressFormat": "export const validateAddressFormat = async (address) => {\n    const response = await fetch('/api/validate-address', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ address }),\n    });\n    const result = await response.json();\n    if (!response.ok || !result.isValid) {\n        throw new Error(result.message || 'Invalid address.');\n    }\n    return true;\n    /*\n     * == BACKEND IMPLEMENTATION NOTE (/api/validate-address) ==\n     *\n     * 1. The backend receives `{ address }` in the request body.\n     * 2. It uses the `bech32` or `@cosmjs/encoding` library to decode the address.\n     * 3. It checks for decoding errors and verifies the bech32 prefix (e.g., 'neutron').\n     * 4. It returns `{ isValid: true }` or `{ isValid: false, message: '...' }`.\n     */\n};",
	"signAndBroadcast": "export const signAndBroadcast = async (signer, senderAddress, messages, fee, memo = '') => {\n    // NOTE: A real implementation requires a library like @cosmjs/stargate to sign.\n    // This function demonstrates the pattern of signing on the client and sending\n    // the signed bytes to a backend for broadcasting.\n    const signedTxBytes = await \"/* (Use a library like @cosmjs/stargate to create signed transaction bytes here) */\";\n\n    const response = await fetch('/api/broadcast-tx', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ signedTxBytes }),\n    });\n\n    if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.message || 'Failed to broadcast transaction.');\n    }\n\n    const result = await response.json();\n    return result.transactionHash;\n    /*\n     * == BACKEND IMPLEMENTATION NOTE (/api/broadcast-tx) ==\n     *\n     * 1. The backend receives the raw, signed transaction bytes.\n     * 2. It connects to an RPC endpoint using `StargateClient.connect(RPC_ENDPOINT)`.\n     * 3. It calls `client.broadcastTx(signedTxBytes)` to submit the transaction.\n     * 4. It returns `{ transactionHash: '...' }` on success or an error message on failure.\n     */\n};",
	"constructWasmQueryMsg": "export const constructWasmQueryMsg = (senderAddress) => {\n    // This example is specific to the `get_personal_counter` query.\n    // In a real app, you might have multiple, more specific constructors.\n    if (!senderAddress) {\n        return { get_global_counter: {} };\n    }\n    return {\n        get_personal_counter: { address: senderAddress },\n    };\n};",
	"constructTxWasmExecute": "export const constructTxWasmExecute = (senderAddress, contractAddress, msg, funds = []) => {\n    // This function returns a generic structure. The specific `msg` payload\n    // would be created separately, e.g., `{ deposit: {} }`.\n    return {\n        typeUrl: '/cosmwasm.wasm.v1.MsgExecuteContract',\n        value: {\n            sender: senderAddress,\n            contract: contractAddress,\n            msg: new TextEncoder().encode(JSON.stringify(msg)),\n            funds: funds,\n        },\n    };\n};",
	"convertToBaseUnits": "export const convertToBaseUnits = (amount, decimals = 6) => {\n    const numericAmount = Number(amount);\n    if (!Number.isFinite(numericAmount) || numericAmount <= 0) {\n        throw new Error('Amount must be a positive number.');\n    }\n    const factor = 10 ** decimals;\n    return String(Math.floor(numericAmount * factor));\n};",
	"suggestNeutronChain": "export const suggestNeutronChain = async (wallet) => {\n    if (!wallet || !wallet.experimentalSuggestChain) {\n        throw new Error('Wallet does not support suggesting new chains.');\n    }\n    const chainConfig = {\n        chainId: 'neutron-1',\n        chainName: 'Neutron',\n        rpc: 'https://rpc-kralum.neutron-1.neutron.org',\n        rest: 'https://rest-kralum.neutron-1.neutron.org',\n        bip44: { coinType: 118 },\n        bech32Config: { bech32PrefixAccAddr: 'neutron' },\n        currencies: [{ coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 }],\n        feeCurrencies: [{ coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 }],\n        stakeCurrency: { coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 },\n    };\n    await wallet.experimentalSuggestChain(chainConfig);\n};",
	"submit_gov_proposal": "def submit_gov_proposal(proposal_file: str, from_key: str, chain_id: str = \"neutron-1\", node: str = \"https://rpc-kralum.neutron.org:443\", fees: str = \"2000untrn\", gas: str = \"400000\") -> str:\n    \"\"\"Submits the param-change proposal and extracts the proposal_id from the tx response.\"\"\"\n\n    cmd = [\n        \"neutrond\", \"tx\", \"gov\", \"submit-proposal\", \"param-change\", proposal_file,\n        \"--from\", from_key,\n        \"--chain-id\", chain_id,\n        \"--node\", node,\n        \"--fees\", fees,\n        \"--gas\", gas,\n        \"-y\",\n        \"--output\", \"json\"\n    ]\n\n    try:\n        completed = subprocess.run(cmd, check=True, capture_output=True, text=True)\n        tx_response = json.loads(completed.stdout)\n        proposal_id = None\n        for log in tx_response.get(\"logs\", []):\n            for event in log.get(\"events\", []):\n                if event.get(\"type\") == \"submit_proposal\":\n                    for attr in event.get(\"attributes\", []):\n                        if attr.get(\"key\") == \"proposal_id\":\n                            proposal_id = attr.get(\"value\")\n                            break\n        if not proposal_id:\n            raise RuntimeError(\"Proposal submitted but proposal_id not found in transaction logs.\")\n        return proposal_id\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(f\"Failed to submit proposal: {err.stderr}\") from err",
	"get_sender_address": "def get_sender_address(wallet_alias: str = 'lender'):\n    \"\"\"Return the Bech32 address for a configured backend wallet.\"\"\"\n    env_key = f\"{wallet_alias.upper()}_ADDRESS\"\n    address = os.getenv(env_key)\n    if not address:\n        raise HTTPException(status_code=404, detail=f'Wallet alias {wallet_alias} not configured')\n    return {\"wallet\": wallet_alias, \"address\": address}",
	"check_token_balance": "def check_token_balance(address: str, cw20_contract: str):\n    \"\"\"Return the CW20 balance for a given address.\"\"\"\n    query = {\"balance\": {\"address\": address}}\n    encoded_query = base64.b64encode(json.dumps(query).encode()).decode()\n    url = f\"{REST_ENDPOINT}/cosmwasm/wasm/v1/contract/{cw20_contract}/smart/{encoded_query}\"\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        balance = int(resp.json().get('data', {}).get('balance', '0'))\n        return {\"address\": address, \"cw20_contract\": cw20_contract, \"balance\": balance}\n    except requests.RequestException as err:\n        raise HTTPException(status_code=500, detail=str(err))",
	"construct_cw20_approve": "def construct_cw20_approve(spender: str, amount_micro: int) -> dict:\n    \"\"\"Build the CW20 increase_allowance message.\"\"\"\n    return {\n        'increase_allowance': {\n            'spender': spender,\n            'amount': str(amount_micro)\n        }\n    }",
	"sign_and_broadcast_approval": "def sign_and_broadcast_approval() -> dict:\n    \"\"\"Signs and broadcasts the CW20 approve (increase_allowance) transaction.\"\"\"\n    network = NetworkConfig(\n        chain_id='neutron-1',\n        url=os.getenv('NEUTRON_GRPC', 'grpc://grpc-kralum.neutron-1.neutron.org:443'),\n        fee_minimum_gas_price=0.025,\n        fee_denom='untrn'\n    )\n    client = LedgerClient(network)\n\n    private_key_hex = os.getenv('LENDER_PRIVKEY')\n    if not private_key_hex:\n        raise RuntimeError('Missing LENDER_PRIVKEY environment variable')\n    wallet = PrivateKey(bytes.fromhex(private_key_hex))\n\n    cw20_contract = os.getenv('SOLVBTC_CONTRACT')\n    spender = os.getenv('AMBER_MARKET_CONTRACT')\n    amount_micro = int(os.getenv('APPROVE_AMOUNT', '300000000'))  # 3 solvBTC * 1e8 (assuming 8 decimals)\n\n    # Build execute message\n    msg = MsgExecuteContract(\n        sender=wallet.address(),\n        contract=cw20_contract,\n        msg=json.dumps({'increase_allowance': {'spender': spender, 'amount': str(amount_micro)}}).encode(),\n        funds=[]\n    )\n\n    tx = (\n        Transaction()\n        .with_messages(msg)\n        .with_chain_id(network.chain_id)\n        .with_gas_estimate(client)\n        .sign(wallet)\n        .broadcast(client, mode='block')\n    )\n    return {'tx_hash': tx.tx_hash}\n\n\nif __name__ == '__main__':\n    print(sign_and_broadcast_approval())",
	"construct_amber_lend_tx": "def construct_amber_lend_tx(amount_micro: int) -> dict:\n    \"\"\"Build the lend (supply) message for Amber Finance market contract.\"\"\"\n    return {\n        'lend': {\n            'amount': str(amount_micro)\n        }\n    }",
	"sign_and_broadcast_lend": "def sign_and_broadcast_lend() -> dict:\n    \"\"\"Signs and broadcasts the lend (supply) transaction to Amber Finance.\"\"\"\n    network = NetworkConfig(\n        chain_id='neutron-1',\n        url=os.getenv('NEUTRON_GRPC', 'grpc://grpc-kralum.neutron-1.neutron.org:443'),\n        fee_minimum_gas_price=0.025,\n        fee_denom='untrn'\n    )\n    client = LedgerClient(network)\n\n    private_key_hex = os.getenv('LENDER_PRIVKEY')\n    if not private_key_hex:\n        raise RuntimeError('Missing LENDER_PRIVKEY environment variable')\n    wallet = PrivateKey(bytes.fromhex(private_key_hex))\n\n    amber_market_contract = os.getenv('AMBER_MARKET_CONTRACT')\n    amount_micro = int(os.getenv('LEND_AMOUNT', '300000000'))  # 3 solvBTC * 1e8\n\n    # Build execute message\n    msg = MsgExecuteContract(\n        sender=wallet.address(),\n        contract=amber_market_contract,\n        msg=json.dumps({'lend': {'amount': str(amount_micro)}}).encode(),\n        funds=[]\n    )\n\n    tx = (\n        Transaction()\n        .with_messages(msg)\n        .with_chain_id(network.chain_id)\n        .with_gas_estimate(client)\n        .sign(wallet)\n        .broadcast(client, mode='block')\n    )\n    return {'tx_hash': tx.tx_hash}\n\n\nif __name__ == '__main__':\n    print(sign_and_broadcast_lend())",
	"getUserWalletAddress": "export const getUserWalletAddress = async () => {\n  const chainId = 'neutron-1';\n\n  // 1. Ensure Keplr is injected in the browser\n  if (!window.keplr) {\n    throw new Error('Keplr wallet not found. Please install the Keplr browser extension.');\n  }\n\n  // 2. Ask Keplr to enable the Neutron chain\n  await window.keplr.enable(chainId);\n\n  // 3. Retrieve the OfflineSigner and account list\n  const signer = window.getOfflineSigner(chainId);\n  const accounts = await signer.getAccounts();\n\n  if (!accounts || accounts.length === 0) {\n    throw new Error('No accounts detected for the selected chain.');\n  }\n\n  // 4. Return the first account address (default behaviour for Keplr)\n  return accounts[0].address;\n};",
	"_b64": "def _b64(query: dict) -> str:\n    \"\"\"Base64-encode a JSON query for /smart/ LCD endpoints.\"\"\"\n    return base64.b64encode(json.dumps(query).encode()).decode()\n\nasync def _cw20_balance(contract: str, addr: str) -> int:\n    url = f\"{NODE_LCD}/cosmwasm/wasm/v1/contract/{contract}/smart/{_b64({'balance': {'address': addr}})}\"\n    async with httpx.AsyncClient(timeout=10) as client:\n        r = await client.get(url)\n        r.raise_for_status()\n        return int(r.json()['data']['balance'])\n\n@router.get('/api/validate_balances')\nasync def validate_balances(address: str):\n    required_wbtc = int(MIN_WBTC * 10 ** WBTC_DECIMALS)\n    required_usdc = int(MIN_USDC * 10 ** USDC_DECIMALS)\n\n    wbtc_balance = await _cw20_balance(WBTC_CONTRACT, address)\n    usdc_balance = await _cw20_balance(USDC_CONTRACT, address)\n\n    if wbtc_balance < required_wbtc or usdc_balance < required_usdc:\n        raise HTTPException(\n            status_code=400,\n            detail={\n                'wbtc_balance': wbtc_balance,\n                'usdc_balance': usdc_balance,\n                'message': 'Insufficient token balances for deposit.'\n            }\n        )\n\n    return {\n        'status': 'ok',\n        'wbtc_raw': wbtc_balance,\n        'usdc_raw': usdc_balance\n    }",
	"supervault_address": "def supervault_address():\n    \"\"\"Return the current WBTC/USDC Supervault address.\"\"\"\n    return {'address': SUPERVAULT_CONTRACT}",
	"construct_deposit_msg": "def construct_deposit_msg():\n    wbtc_raw = int(Decimal('0.2') * 10 ** WBTC_DECIMALS)      # 0.2 WBTC → 20 000 000 raw\n    usdc_raw = int(Decimal('12000') * 10 ** USDC_DECIMALS)    # 12 000 USDC → 12 000 000 000 raw\n\n    msg = {\n        'deposit': {\n            'assets': [\n                {\n                    'info': {'token': {'contract_addr': WBTC_CONTRACT}},\n                    'amount': str(wbtc_raw)\n                },\n                {\n                    'info': {'token': {'contract_addr': USDC_CONTRACT}},\n                    'amount': str(usdc_raw)\n                }\n            ]\n        }\n    }\n\n    return {'msg': msg}",
	"_build_deposit_msg": "def _build_deposit_msg(sender: str) -> MsgExecuteContract:\n    \"\"\"Create a MsgExecuteContract for the deposit.\"\"\"\n    deposit_msg = {\n        'deposit': {\n            'assets': [\n                {\n                    'info': {'token': {'contract_addr': WBTC_CONTRACT}},\n                    'amount': str(int(0.2 * 10 ** 8))\n                },\n                {\n                    'info': {'token': {'contract_addr': USDC_CONTRACT}},\n                    'amount': str(int(12000 * 10 ** 6))\n                }\n            ]\n        }\n    }\n    return MsgExecuteContract(\n        sender=sender,\n        contract=SUPERVAULT_CONTRACT,\n        msg=json.dumps(deposit_msg).encode(),\n        funds=[]\n    )\n\n@router.post('/api/sign_and_broadcast')\nasync def sign_and_broadcast_tx():\n    \"\"\"\n    WARNING: Exposes a signing flow on the backend. Use only for server-controlled\n    treasury accounts – never end-user keys.\n    \"\"\"\n    if not MNEMONIC:\n        raise HTTPException(status_code=500, detail='FUNDER_MNEMONIC env var not set.')\n\n    # 1. Instantiate the private key\n    key = PrivateKey.from_mnemonic(MNEMONIC)\n    sender_addr = str(key.to_address())\n\n    # 2. Build the transaction\n    network = NetworkConfig(chain_id=CHAIN_ID, url=RPC_ENDPOINT)\n    ledger = LedgerClient(network)\n    account = ledger.query_account(sender_addr)\n\n    tx = (\n        Transaction()\n        .with_chain_id(CHAIN_ID)\n        .with_account_num(account.account_number)\n        .with_sequence(account.sequence)\n        .with_gas(400_000)\n        .with_fee_limit('60000untrn')\n    )\n    tx.add_message(_build_deposit_msg(sender_addr))\n\n    # 3. Sign and broadcast\n    tx_signed = tx.sign(key)\n    tx_hash = ledger.broadcast_tx(tx_signed)\n\n    return {'tx_hash': tx_hash.hex()}",
	"getUserAddress": "export const getUserAddress = async (chainId = 'neutron-1') => {\n  // Check that Keplr is available in the browser\n  if (!window.keplr) {\n    throw new Error('Keplr wallet not found. Please install or unlock the Keplr browser extension.');\n  }\n\n  // Ask Keplr to enable the target chain (this may prompt the user)\n  await window.keplr.enable(chainId);\n\n  // Obtain an OfflineSigner instance for the chain\n  const signer = window.getOfflineSigner(chainId);\n  const accounts = await signer.getAccounts();\n\n  if (!accounts || accounts.length === 0) {\n    throw new Error('No accounts detected in Keplr for the selected chain.');\n  }\n\n  // Return signer (for later use) and address\n  return {\n    signer,\n    address: accounts[0].address,\n  };\n};",
	"queryShareBalance": "export const queryShareBalance = async (restEndpoint, contractAddress, userAddress) => {\n  // The exact query key (\"balance\") should match the Supervault contract’s API.\n  const queryPayload = { \"balance\": { \"address\": userAddress } };\n\n  // CosmWasm REST endpoints expect the query JSON to be base64-encoded.\n  const base64Query = btoa(JSON.stringify(queryPayload));\n  const url = `${restEndpoint}/cosmwasm/wasm/v1/contract/${contractAddress}/smart/${base64Query}`;\n\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`Contract query failed: ${response.status} ${response.statusText}`);\n  }\n\n  const { data } = await response.json();\n  // Assume the contract returns `{ balance: \"<amount>\" }`. Adjust as needed.\n  return data?.balance || '0';\n};",
	"validateRedeemAmount": "export const validateRedeemAmount = (requestedAmount, availableShares) => {\n  const req = BigInt(requestedAmount);\n  const avail = BigInt(availableShares);\n\n  if (req <= 0n) {\n    throw new Error('Redeem amount must be greater than zero.');\n  }\n  if (req > avail) {\n    throw new Error('Redeem amount exceeds the available share balance.');\n  }\n  // Validation successful\n  return true;\n};",
	"construct_wasm_execute_msg": "def construct_wasm_execute_msg(sender: str, contract_address: str, shares_to_redeem: int) -> MsgExecuteContract:\n    \"\"\"Build a MsgExecuteContract for a Supervault `withdraw` call.\n\n    Args:\n        sender (str): The bech32 address initiating the transaction.\n        contract_address (str): The Supervault contract address.\n        shares_to_redeem (int): LP shares to redeem.\n\n    Returns:\n        MsgExecuteContract: Ready-to-sign protobuf message.\n    \"\"\"\n    withdraw_msg = {\"withdraw\": {\"amount\": str(shares_to_redeem)}}\n\n    msg = MsgExecuteContract(\n        sender=sender,\n        contract=contract_address,\n        msg=json.dumps(withdraw_msg).encode('utf-8'),\n        funds=[]  # No native coins sent along with the execute call\n    )\n    return msg",
	"queryContractGlobalCounter": "export const queryContractGlobalCounter = async (rpcEndpoint) => {\n  try {\n    // 1. Connect to the chain.\n    const client = await StargateClient.connect(rpcEndpoint);\n\n    // 2. Prepare contract address & query msg.\n    const contractAddress = loadContractAddress();\n    const queryMsg = constructWasmQueryMsg();\n\n    // 3. Execute the smart query.\n    const response = await client.queryContractSmart(contractAddress, queryMsg);\n    // Expected response shape: { count: <number> }\n\n    if (!response || typeof response.count !== 'number') {\n      throw new Error('Unexpected response format from contract.');\n    }\n\n    return response.count;\n  } catch (error) {\n    console.error('Failed to query global counter:', error);\n    throw error;\n  }\n};",
	"connectEthWallet": "export const connectEthWallet = async () => {\n  // --- Constants -----------------------------------------------------------\n  const MIN_ETH_WEI = 10n ** 16n;            // ≈ 0.01 ETH for gas\n  const MIN_WBTC_SATS = 100000000n;          // 1 WBTC (8 dp)\n  const WBTC_ADDRESS = '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599'; // main-net\n  const BALANCE_OF_SELECTOR = '0x70a08231';  // keccak256('balanceOf(address)')[0:4]\n\n  // --- Pre-checks ----------------------------------------------------------\n  if (typeof window === 'undefined' || !window.ethereum) {\n    throw new Error('MetaMask (or compatible) wallet is not installed.');\n  }\n\n  // --- Request account -----------------------------------------------------\n  const [account] = await window.ethereum.request({ method: 'eth_requestAccounts' });\n  if (!account) throw new Error('No Ethereum account returned by MetaMask.');\n\n  // --- Check ETH balance ---------------------------------------------------\n  const ethBalanceHex = await window.ethereum.request({\n    method: 'eth_getBalance',\n    params: [account, 'latest']\n  });\n  const ethBalanceWei = BigInt(ethBalanceHex);\n  if (ethBalanceWei < MIN_ETH_WEI) {\n    throw new Error('Insufficient ETH for gas (need at least ≈0.01 ETH).');\n  }\n\n  // --- Check WBTC balance --------------------------------------------------\n  const paddedAcct = account.slice(2).padStart(64, '0');\n  const data = BALANCE_OF_SELECTOR + paddedAcct;\n  const wbtcBalanceHex = await window.ethereum.request({\n    method: 'eth_call',\n    params: [{ to: WBTC_ADDRESS, data }, 'latest']\n  });\n  const wbtcBalance = BigInt(wbtcBalanceHex);\n  if (wbtcBalance < MIN_WBTC_SATS) {\n    throw new Error('At least 1 WBTC is required to continue.');\n  }\n\n  // --- Return account details ---------------------------------------------\n  return { account, wbtcBalance: wbtcBalance.toString() };\n};",
	"approveErc20Spend": "export const approveErc20Spend = async ({ ownerAddress, bridgeAddress, amountSats = '100000000' }) => {\n  const WBTC_ADDRESS = '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599';\n  const APPROVE_SELECTOR = '0x095ea7b3'; // keccak256('approve(address,uint256)')[0:4]\n\n  // --- Encode parameters ---------------------------------------------------\n  const spenderPadded = bridgeAddress.slice(2).padStart(64, '0');\n  const amountHex = BigInt(amountSats).toString(16).padStart(64, '0');\n  const data = APPROVE_SELECTOR + spenderPadded + amountHex;\n\n  // --- Send tx via MetaMask -------------------------------------------------\n  const txHash = await window.ethereum.request({\n    method: 'eth_sendTransaction',\n    params: [{\n      from: ownerAddress,\n      to: WBTC_ADDRESS,\n      data,\n      value: '0x0'\n    }]\n  });\n\n  return txHash; // user can track this tx for confirmation\n};",
	"depositWbtcToBridge": "export const depositWbtcToBridge = async ({\n  ownerAddress,\n  bridgeAddress,\n  neutronAddress,\n  amountSats = '100000000'\n}) => {\n  /*\n    NOTE: Every bridge has its own ABI.\n    Adjust `DEPOSIT_SELECTOR` and encoding if your bridge differs.\n    Example ABI (pseudo):\n      function deposit(address token, uint256 amount, bytes destination) external;\n    Keccak-256 selector => 0xb6b55f25 (placeholder here).\n  */\n  const TOKEN_ADDRESS = '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599';\n  const DEPOSIT_SELECTOR = '0xb6b55f25'; // placeholder selector – update to real one!\n\n  // --- Encode parameters ---------------------------------------------------\n  const pad = (hex, bytes = 64) => hex.replace(/^0x/, '').padStart(bytes, '0');\n\n  const tokenParam   = pad(TOKEN_ADDRESS);\n  const amountParam  = pad(BigInt(amountSats).toString(16));\n\n  // Destination (Neutron bech32) converted to raw UTF-8 hex -----------------\n  const destUtf8Hex  = Buffer.from(neutronAddress, 'utf8').toString('hex');\n  const destLen      = pad(Number(destUtf8Hex.length / 2).toString(16));\n  const destParam    = destUtf8Hex.padEnd(64, '0'); // right-pad to 32B\n\n  const data = DEPOSIT_SELECTOR + tokenParam + amountParam + destLen + destParam;\n\n  // --- Send tx via MetaMask -------------------------------------------------\n  const txHash = await window.ethereum.request({\n    method: 'eth_sendTransaction',\n    params: [{\n      from: ownerAddress,\n      to: bridgeAddress,\n      data,\n      value: '0x0'\n    }]\n  });\n\n  return txHash;\n};",
	"wait_for_confirmations": "def wait_for_confirmations(tx_hash: str, confirmations: int = 12, poll: int = 15) -> Dict:\n    \"\"\"Blocks until `confirmations` are reached for `tx_hash`.\"\"\"\n    try:\n        receipt = None\n        while receipt is None:\n            try:\n                receipt = web3.eth.get_transaction_receipt(tx_hash)\n            except exceptions.TransactionNotFound:\n                time.sleep(poll)\n        tx_block = receipt.blockNumber\n        while (web3.eth.block_number - tx_block) < confirmations:\n            time.sleep(poll)\n        return {\"status\": \"confirmed\", \"txHash\": tx_hash, \"confirmations\": confirmations}\n    except Exception as e:\n        return {\"status\": \"error\", \"error\": str(e)}",
	"wait_for_ibc_transfer": "def wait_for_ibc_transfer(neutron_addr: str, source_tx: str, poll: int = 15, timeout: int = 1800) -> Dict:\n    \"\"\"Polls Neutron txs until an IBC transfer that correlates to `source_tx` is observed.\"\"\"\n    end_time = time.time() + timeout\n    page_key = None\n    while time.time() < end_time:\n        url = f\"{LCD}/cosmos/tx/v1beta1/txs?events=transfer.recipient='\" + neutron_addr + \"'\" + (f\"&pagination.key={page_key}\" if page_key else '')\n        resp = requests.get(url, timeout=10)\n        if resp.status_code == 200:\n            data = resp.json()\n            for tx in data.get('txs', []):\n                # Very naive correlation: search for the Ethereum tx-hash in memo / events\n                if source_tx.lower()[2:12] in str(tx):  # quick substring match\n                    return {\"status\": \"ibc_received\", \"neutron_txhash\": tx['txhash']}\n            page_key = data.get('pagination', {}).get('next_key')\n        time.sleep(poll)\n    return {\"status\": \"timeout\", \"message\": \"No IBC packet seen in allotted time.\"}",
	"query_wbtc_balance": "def query_wbtc_balance(neutron_addr: str, ibc_denom: str) -> Dict:\n    url = f\"{LCD}/cosmos/bank/v1beta1/balances/{neutron_addr}\"\n    resp = requests.get(url, timeout=10)\n    if resp.status_code != 200:\n        return {\"status\": \"error\", \"error\": resp.text}\n    balances = resp.json().get('balances', [])\n    for coin in balances:\n        if coin.get('denom') == ibc_denom:\n            amount = int(coin.get('amount', '0'))\n            return {\"status\": \"ok\", \"amount_sats\": amount}\n    return {\"status\": \"ok\", \"amount_sats\": 0}",
	"parse_cron_params": "def parse_cron_params(params_json: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"\n    Extract important fields from the raw Cron parameters response.\n\n    Args:\n        params_json (Dict[str, Any]): Raw JSON structure returned by `query_cron_params`.\n\n    Returns:\n        Dict[str, Any]: A simplified dictionary containing selected Cron parameters.\n\n    Raises:\n        KeyError: If the expected keys are not found.\n    \"\"\"\n    try:\n        params = params_json[\"params\"]\n        parsed = {\n            \"max_msg_length\": int(params.get(\"max_msg_length\", 0)),\n            \"min_period\": int(params.get(\"min_period\", 0)),\n            \"security_address\": params.get(\"security_address\", \"\"),\n            \"fee_currency\": params.get(\"fee_currency\", \"\"),\n            \"fee_amount\": params.get(\"fee_amount\", \"\")\n        }\n        return parsed\n    except KeyError as exc:\n        raise KeyError(f\"Expected key not found while parsing Cron params: {exc}\") from exc",
	"construct_tx_wasm_store": "def construct_tx_wasm_store(wasm_path: str, wallet, chain_id: str, gas: int = 2_000_000, fee: int = 300_000):\n    \"\"\"Return an unsigned `Transaction` containing `MsgStoreCode`.\"\"\"\n    with open(wasm_path, 'rb') as wasm_file:\n        wasm_bytes = wasm_file.read()\n\n    msg = MsgStoreCode(\n        sender=wallet.address(),\n        wasm_byte_code=wasm_bytes\n    )\n\n    tx = (\n        Transaction()\n        .with_messages(msg)\n        .with_chain_id(chain_id)\n        .with_gas(gas)\n        .with_fee(fee)\n    )\n    return tx",
	"parse_code_id_from_receipt": "def parse_code_id_from_receipt(tx_response) -> int:\n    \"\"\"Search TxResponse logs for the `store_code` event and return its `code_id`.\"\"\"\n    logs = tx_response.logs if hasattr(tx_response, 'logs') else tx_response['logs']\n    for event in logs[0]['events']:\n        if event['type'] == 'store_code':\n            for attr in event['attributes']:\n                if attr['key'] in ('code_id', 'codeID'):\n                    return int(attr['value'])\n    raise ValueError('code_id not found in transaction logs.')",
	"construct_tx_wasm_instantiate": "def construct_tx_wasm_instantiate(code_id: int, init_msg: dict, label: str, wallet, chain_id: str, admin: str | None = None, gas: int = 500_000, fee: int = 150_000):\n    \"\"\"Return an unsigned instantiate transaction.\"\"\"\n    msg = MsgInstantiateContract(\n        sender=wallet.address(),\n        admin=admin or '',\n        code_id=code_id,\n        label=label,\n        msg=json.dumps(init_msg).encode('utf-8'),\n        funds=[]  # Provide coins if the contract expects them\n    )\n\n    tx = (\n        Transaction()\n        .with_messages(msg)\n        .with_chain_id(chain_id)\n        .with_gas(gas)\n        .with_fee(fee)\n    )\n    return tx",
	"broadcast_instantiate_tx": "def broadcast_instantiate_tx(instantiate_tx, wallet, client):\n    \"\"\"Helper that re-uses `sign_and_broadcast_tx` for the instantiate step.\"\"\"\n    return sign_and_broadcast_tx(instantiate_tx, wallet, client)",
	"parse_contract_address_from_receipt": "def parse_contract_address_from_receipt(tx_response) -> str:\n    \"\"\"Fetch `_contract_address` from the instantiate event.\"\"\"\n    logs = tx_response.logs if hasattr(tx_response, 'logs') else tx_response['logs']\n    for event in logs[0]['events']:\n        if event['type'] == 'instantiate':\n            for attr in event['attributes']:\n                if attr['key'] == '_contract_address':\n                    return attr['value']\n    raise ValueError('Contract address not found in instantiate logs.')",
	"getSenderAddress": "export const getSenderAddress = async () => {\n  const chainId = 'neutron-1';\n\n  // Check that Keplr is installed\n  if (!window.keplr) {\n    throw new Error('Keplr wallet is not installed.');\n  }\n\n  // Ask Keplr to enable the chain\n  await window.keplr.enable(chainId);\n\n  // Get an OfflineSigner to access the user’s account(s)\n  const offlineSigner = window.getOfflineSigner(chainId);\n  const accounts = await offlineSigner.getAccounts();\n\n  if (!accounts || accounts.length === 0) {\n    throw new Error('No accounts found in the connected wallet.');\n  }\n\n  // Return the first account (default behaviour for most dApps)\n  return accounts[0].address;\n};",
	"_fetch_balance": "def _fetch_balance(address: str, denom: str) -> int:\n    \"\"\"Query /cosmos/bank/v1beta1/balances/{address}/{denom}\"\"\"\n    url = f\"{REST_ENDPOINT}/cosmos/bank/v1beta1/balances/{address}/{denom}\"\n    async with httpx.AsyncClient(timeout=10) as client:\n        resp = await client.get(url)\n    if resp.status_code != 200:\n        raise HTTPException(status_code=resp.status_code, detail=\"Bank API error\")\n    amount = int(resp.json().get(\"balance\", {}).get(\"amount\", 0))\n    return amount\n\n# --- Route -----------------------------------------------------------------\n@app.get(\"/api/check-balance\")\nasync def check_token_balance(address: str, wbtc_needed: int = 1, usdc_needed: int = 60000):\n    \"\"\"Verify that the provided address owns ≥ required WBTC & USDC.\"\"\"\n    wbtc_balance = await _fetch_balance(address, WBTC_DENOM)\n    usdc_balance = await _fetch_balance(address, USDC_DENOM)\n\n    sufficient = (wbtc_balance >= wbtc_needed) and (usdc_balance >= usdc_needed)\n\n    return {\n        \"address\": address,\n        \"wbtc_balance\": wbtc_balance,\n        \"usdc_balance\": usdc_balance,\n        \"sufficient\": sufficient\n    }",
	"query_supervault_details": "def query_supervault_details():\n    return {\n        \"contract_address\": SUPER_VAULT_CONTRACT_ADDRESS,\n        \"tokens\": [\n            {\"denom\": WBTC_DENOM, \"symbol\": \"WBTC\"},\n            {\"denom\": USDC_DENOM, \"symbol\": \"USDC\"}\n        ]\n    }",
	"construct_supervault_deposit_tx": "def construct_supervault_deposit_tx(req: ConstructTxRequest = Body(...)):\n    # 1. Compose execute message expected by Supervault contract\n    exec_msg = {\n        \"deposit\": {\n            \"assets\": [\n                {\n                    \"info\": {\"native_token\": {\"denom\": WBTC_DENOM}},\n                    \"amount\": str(req.wbtc_amount)\n                },\n                {\n                    \"info\": {\"native_token\": {\"denom\": USDC_DENOM}},\n                    \"amount\": str(req.usdc_amount)\n                }\n            ]\n        }\n    }\n\n    # 2. Create Tx object\n    tx = Transaction()\n    tx.add_message(\n        ledger.execute_contract(\n            sender=req.address,\n            contract_address=SUPER_VAULT_CONTRACT,\n            msg=exec_msg,\n            funds=[]  # Contract pulls tokens from user’s balance; no explicit Coin[] required\n        )\n    )\n\n    # 3. Gas estimate (rough – add a safety buffer client-side if needed)\n    gas_estimate = ledger.estimate_gas(tx)\n    tx.set_gas(gas_estimate)\n\n    # 4. Return unsigned tx bytes for the next step\n    unsigned_bytes = tx.serialize()\n    return {\n        \"tx_base64\": base64.b64encode(unsigned_bytes).decode(),\n        \"gas_estimate\": gas_estimate\n    }",
	"getVaultContractAddress": "export const getVaultContractAddress = () => {\n  // In production you might fetch this from an API or .env file.\n  // Hard-coded here for demo purposes.\n  return 'neutron1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';\n};",
	"buildOptInAirdropsMsg": "export const buildOptInAirdropsMsg = (partnerId = 'all') => {\n  return {\n    opt_in_airdrops: {\n      partner_id: partnerId\n    }\n  };\n};",
	"execute_opt_in_airdrops": "def execute_opt_in_airdrops(req: ExecuteRequest):\n    \"\"\"Signs and broadcasts `{ opt_in_airdrops: { partner_id } }`\"\"\"\n    try:\n        # Create a wallet from the provided mnemonic\n        wallet = LocalWallet.from_mnemonic(req.mnemonic)\n        sender_addr = wallet.address()\n\n        # Create the execute message\n        wasm_msg = {\n            \"opt_in_airdrops\": {\n                \"partner_id\": req.partner_id\n            }\n        }\n\n        # Build transaction\n        tx = Transaction()\n        tx.add_execute_contract(\n            sender_addr,\n            req.contract_address,\n            wasm_msg,\n            gas_limit=req.gas_limit,\n        )\n        tx.with_chain_id(NETWORK.chain_id)\n        tx.with_fee(req.fee_denom)\n\n        # Sign\n        signed_tx = tx.sign(wallet)\n\n        # Broadcast\n        client = LedgerClient(NETWORK)\n        resp = client.broadcast_tx(signed_tx)\n\n        if resp.is_error():\n            raise HTTPException(status_code=400, detail=f\"Broadcast failed: {resp.raw_log}\")\n\n        return {\"txhash\": resp.tx_hash}\n\n    except Exception as e:\n        # Surface any unexpected error\n        raise HTTPException(status_code=500, detail=str(e))",
	"queryAirdropStatus": "export const queryAirdropStatus = async (\n  contractAddress,\n  userAddress,\n  lcdEndpoint = 'https://rest-kralum.neutron-1.neutron.org'\n) => {\n  // Build the query `{ airdrop_status: { address: <USER_ADDR> } }`\n  const query = {\n    airdrop_status: {\n      address: userAddress,\n    },\n  };\n\n  // The LCD expects the query message to be base64-encoded\n  const base64Query = btoa(JSON.stringify(query));\n\n  const url = `${lcdEndpoint}/cosmwasm/wasm/v1/contract/${contractAddress}/smart/${base64Query}`;\n\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`LCD query failed with status ${response.status}`);\n  }\n\n  const result = await response.json();\n  return result.data; // `data` holds the smart-query response\n};",
	"get_dao_authority_address": "def get_dao_authority_address(rpc_endpoint: str, chain_id: str, dao_contract: str) -> str:\n    \"\"\"Return the address that has Main-DAO authority.\n\n    Args:\n        rpc_endpoint (str): Full RPC URL, e.g. \"https://rpc-kralum.neutron.org:443\".\n        chain_id (str): The on-chain ID, e.g. \"neutron-1\".\n        dao_contract (str): Bech-32 address of the DAO WASM contract.\n\n    Returns:\n        str: Address with delete-schedule permissions.\n    \"\"\"\n    try:\n        cfg = NetworkConfig(chain_id=chain_id, url=rpc_endpoint, fee_minimum_gas_price=0)\n        client = LedgerClient(cfg)\n\n        # The DAO contract is expected to support `{ \"authority\": {} }` query.\n        query_msg = {\"authority\": {}}\n        res = client.wasm.contract_query(dao_contract, query_msg)\n        authority_addr = res.get(\"authority\")\n        if not authority_addr:\n            raise ValueError(\"DAO contract did not return an authority address.\")\n        return authority_addr\n    except (CosmPyException, ValueError) as err:\n        raise RuntimeError(f\"Unable to fetch DAO authority address: {err}\")\n",
	"package_into_gov_proposal": "def package_into_gov_proposal(authority: str, delete_msg: dict, deposit_amount: str = \"10000000\", denom: str = \"untrn\") -> dict:\n    \"\"\"Embed the delete-schedule message into a MsgSubmitProposal.\n\n    Args:\n        authority (str): DAO authority address (will be listed as proposer).\n        delete_msg (dict): Message from Step 2.\n        deposit_amount (str): Minimum deposit in micro-denom (10 NTRN default).\n        denom (str): Denomination for deposit.\n\n    Returns:\n        dict: MsgSubmitProposal ready for signing.\n    \"\"\"\n    title = \"Remove obsolete cron schedule: protocol_update\"\n    description = (\n        \"This proposal deletes the `protocol_update` cron schedule, which is no longer \"\n        \"needed after the successful upgrade executed on \" + datetime.utcnow().strftime(\"%Y-%m-%d\") + \".\"\n    )\n\n    proposal_msg = {\n        \"@type\": \"/cosmos.gov.v1beta1.MsgSubmitProposal\",\n        \"proposer\": authority,\n        \"initial_deposit\": [{\"denom\": denom, \"amount\": deposit_amount}],\n        \"content\": {\n            \"@type\": \"/cosmos.gov.v1beta1.TextProposal\",\n            \"title\": title,\n            \"description\": description\n        },\n        \"messages\": [delete_msg]  # custom message list supported by Neutron-gov\n    }\n\n    # Ensure JSON validity\n    json.dumps(proposal_msg)\n    return proposal_msg\n",
	"queryPersonalCounter": "export const queryPersonalCounter = async (rpcEndpoint, contractAddress, queryMsg) => {\n  try {\n    // Initialise a readonly CosmWasm client (no signer required for queries)\n    const client = await CosmWasmClient.connect(rpcEndpoint);\n\n    // Execute the smart query\n    const response = await client.queryContractSmart(contractAddress, queryMsg);\n\n    return response; // e.g. { counter: 7 }\n  } catch (error) {\n    // Forward the error after logging for debugging purposes\n    console.error(\"Contract smart-query failed:\", error);\n    throw error;\n  }\n};",
	"validateContractAddress": "export const validateContractAddress = (address, expectedPrefix = 'neutron') => {\n  try {\n    const { prefix } = fromBech32(address);\n    if (prefix !== expectedPrefix) {\n      throw new Error(`Prefix mismatch: expected ${expectedPrefix}, got ${prefix}`);\n    }\n    return true;\n  } catch (error) {\n    console.error('Invalid contract address:', error);\n    throw new Error('Provided contract address is invalid.');\n  }\n};",
	"signAndBroadcastTx": "export const signAndBroadcastTx = async (signer, executeMsg, rpcEndpoint = 'https://rpc-kralum.neutron.org') => {\n  try {\n    const client = await SigningCosmWasmClient.connectWithSigner(rpcEndpoint, signer);\n    // Use 'auto' for fee estimation or replace with a custom fee object.\n    const fee = 'auto';\n    const result = await client.execute(\n      executeMsg.sender,\n      executeMsg.contract,\n      executeMsg.msg,\n      fee,\n      undefined,\n      executeMsg.funds,\n    );\n    console.log('Transaction broadcasted. Hash:', result.transactionHash);\n    return result;\n  } catch (error) {\n    console.error('Failed to sign/broadcast transaction:', error);\n    throw error;\n  }\n};",
	"_query_wasm_smart": "def _query_wasm_smart(contract_addr: str, query_msg: dict):\n    \"\"\"Low-level helper that hits the LCD `/smart/` endpoint.\"\"\"\n    msg_b64 = base64.b64encode(json.dumps(query_msg).encode()).decode()\n    url = f\"{NEUTRON_LCD}/cosmwasm/wasm/v1/contract/{contract_addr}/smart/{msg_b64}\"\n    async with httpx.AsyncClient(timeout=10) as client:\n        r = await client.get(url)\n        if r.status_code != 200:\n            raise HTTPException(status_code=r.status_code, detail=r.text)\n        # LCD wraps contract results inside a `data` or `result` field depending on version.\n        data = r.json()\n        return data.get('data') or data.get('result') or data\n\n@app.get('/api/amber_positions')\nasync def amber_positions(address: str):\n    \"\"\"Public route => `/api/amber_positions?address=<bech32>`\"\"\"\n    try:\n        query_msg = {\"positions_by_owner\": {\"owner\": address}}\n        positions = await _query_wasm_smart(AMBER_CONTRACT_ADDR, query_msg)\n        return positions  # Forward raw contract JSON back to the caller.\n    except HTTPException:\n        raise  # Re-throw FastAPI HTTP errors untouched.\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=f\"Amber query failed: {exc}\")",
	"calculateHealthFactor": "export const calculateHealthFactor = (positions) => {\n  if (!Array.isArray(positions)) {\n    throw new Error('Invalid positions array received.');\n  }\n\n  return positions.map((p) => {\n    // Attempt to use the pre-computed value first\n    if (p.health_factor !== undefined) {\n      return {\n        id: p.id,\n        collateral: Number(p.collateral),\n        debt: Number(p.debt),\n        healthFactor: Number(p.health_factor)\n      };\n    }\n\n    const collateral = Number(p.collateral);\n    const debt = Number(p.debt);\n\n    // Protect against division by zero\n    const healthFactor = debt === 0 ? Infinity : collateral / debt;\n\n    return {\n      id: p.id,\n      collateral,\n      debt,\n      healthFactor\n    };\n  });\n};",
	"presentResults": "export const presentResults = (computedPositions) => {\n  if (!Array.isArray(computedPositions)) {\n    throw new Error('Expected an array from calculateHealthFactor().');\n  }\n\n  return computedPositions.map((p) => {\n    const fmt = (v) => (v / 1e6).toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });\n    const hf   = p.healthFactor === Infinity ? '∞' : p.healthFactor.toFixed(2);\n\n    return `Position #${p.id} → HF: ${hf}, Collateral: ${fmt(p.collateral)} NTRN, Debt: ${fmt(p.debt)} NTRN`;\n  }).join('\\n');\n};",
	"fetchNtrnBalance": "export const fetchNtrnBalance = async (address) => {\n  // Public LCD endpoint — replace with your preferred endpoint or a proxy if needed\n  const LCD = 'https://lcd-neutron.blockpane.com';\n  const denom = 'untrn';\n\n  try {\n    const res = await fetch(`${LCD}/cosmos/bank/v1beta1/balances/${address}`);\n    if (!res.ok) {\n      throw new Error(`LCD error: ${res.status} ${res.statusText}`);\n    }\n    const data = await res.json();\n\n    /*  The response shape is:\n        {\n          \"balances\": [ { \"denom\": \"untrn\", \"amount\": \"12345\" }, ... ],\n          ...\n        }\n    */\n    const coin = (data.balances || []).find((c) => c.denom === denom);\n    const amount = coin ? Number(coin.amount) : 0;\n    return amount; // returns micro-denom amount (e.g. 2 000 000 000 for 2 000 NTRN)\n  } catch (err) {\n    console.error('[fetchNtrnBalance] ', err);\n    throw err;\n  }\n};",
	"validateLockAmount": "export const validateLockAmount = (rawBalance, amountToLock = 2_000_000_000) => {\n  if (rawBalance < amountToLock) {\n    throw new Error('Insufficient spendable NTRN balance (need ≥ 2,000 NTRN).');\n  }\n  /*\n    NOTE: Detecting whether funds are already vested or locked normally requires\n    contract-specific queries that are out of scope for a client-side snippet.\n    For simple front-end validation we only check spendable balance.\n  */\n  return true;\n};",
	"calculateUnlockTimestamp": "export const calculateUnlockTimestamp = () => {\n  const NOW_SEC = Math.floor(Date.now() / 1000); // JS Date gives ms\n  const LOCK_DURATION = 7_776_000; // 90 days in seconds\n  return NOW_SEC + LOCK_DURATION;\n};",
	"constructLockExecuteMsg": "export const constructLockExecuteMsg = ({ sender, amount = '2000000000', durationSeconds = 7_776_000 }) => {\n  if (!sender) throw new Error('`sender` is required');\n\n  const executeMsg = {\n    lock: {\n      duration_seconds: durationSeconds.toString()\n    }\n  };\n\n  return {\n    contract_address: 'neutron14lnmj4k0tqsfn3x8kmnmacg64ct2utyz0aaxtm5g3uwwp8kk4f6shcgrtt',\n    sender,\n    msg: executeMsg,\n    funds: [\n      {\n        denom: 'untrn',\n        amount: amount.toString()\n      }\n    ]\n  };\n};",
	"lock_tokens": "def lock_tokens(req: LockRequest):\n    try:\n        # Defensive checks ----------------------------------------------------\n        if WALLET.address() != req.sender:\n            raise HTTPException(\n                status_code=400,\n                detail=\"Backend wallet address does not match provided sender.\"\n            )\n\n        # Build MsgExecuteContract -------------------------------------------\n        wasm_msg_bytes = json.dumps(req.msg).encode()\n        execute_msg = MsgExecuteContract(\n            sender=req.sender,\n            contract=req.contract_address,\n            msg=wasm_msg_bytes,\n            funds=[\n                {\n                    \"denom\": f.denom,\n                    \"amount\": f.amount,\n                }\n                for f in req.funds\n            ],\n        )\n\n        # Create & sign TX ----------------------------------------------------\n        tx = Transaction()\n        tx.add_message(execute_msg)\n        tx.with_sequence(LedgerClient(NETWORK).get_sequence(req.sender))\n        tx.with_chain_id(NETWORK.chain_id)\n        tx.with_gas(250_000)  # empirical gas; adjust if necessary\n        tx.with_memo(\"Lock 2K NTRN for 90d\")\n\n        # Sign using backend wallet\n        tx_signed = tx.sign(WALLET)\n\n        # Broadcast -----------------------------------------------------------\n        client = LedgerClient(NETWORK)\n        tx_response = client.broadcast_tx(tx_signed)\n\n        return {\n            \"tx_hash\": tx_response.tx_hash.hex(),\n            \"height\": tx_response.height,\n            \"raw_log\": tx_response.raw_log,\n        }\n\n    except HTTPException:\n        raise  # re-throw fastapi exceptions unchanged\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"queryBoostMultiplier": "export const queryBoostMultiplier = async (address) => {\n  const BOOST_POINTER_CONTRACT = 'neutron1xxxxxxxxxxxxxxxxxxxxxxxxxxxxx'; // TODO: replace with real addr\n  const queryMsg = {\n    multiplier: {\n      address\n    }\n  };\n\n  // LCD expects the smart-query to be Base64-encoded\n  const base64Query = btoa(JSON.stringify(queryMsg));\n  const LCD = 'https://lcd-neutron.blockpane.com';\n\n  try {\n    const url = `${LCD}/cosmwasm/wasm/v1/contract/${BOOST_POINTER_CONTRACT}/smart/${base64Query}`;\n    const res = await fetch(url);\n    if (!res.ok) {\n      throw new Error(`LCD error: ${res.status} ${res.statusText}`);\n    }\n    const data = await res.json();\n    /*  Expected shape (example):\n        {\n          \"data\": {\n            \"multiplier\": \"1.25\"\n          }\n        }\n    */\n    return data.data?.multiplier ?? null;\n  } catch (err) {\n    console.error('[queryBoostMultiplier] ', err);\n    throw err;\n  }\n};",
	"query_position_status": "def query_position_status(address: str):\n    \"\"\"Returns the address’ Amber position (if any).\"\"\"\n    try:\n        async with LedgerClient(RPC_ENDPOINT) as client:\n            query_msg = {\"position_status\": {\"address\": address}}\n            # Amber is a CosmWasm contract; `wasm_query` expects bytes\n            result = await client.wasm_query(\n                AMBER_CONTRACT,\n                json.dumps(query_msg).encode()\n            )\n            return result\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=f\"Position query failed: {exc}\")",
	"close_position_sign_doc": "def close_position_sign_doc(req: ClosePosRequest):\n    \"\"\"Returns `sign_doc`, `body_bytes`, and `auth_info_bytes` (all base-64) for Keplr’s signDirect.\"\"\"\n    try:\n        async with LedgerClient(RPC_ENDPOINT) as client:\n            # Look-up account info (account number & sequence)\n            acct = await client.query_auth_account(req.address)\n            acct = acct[\"base_account\"] if \"base_account\" in acct else acct\n            account_number = int(acct[\"account_number\"])\n            sequence       = int(acct[\"sequence\"])\n\n            # Build the execute message\n            close_msg = {\"close_position\": {\"id\": req.position_id}}\n            exec_msg  = MsgExecuteContract(\n                sender   = req.address,\n                contract = AMBER_CONTRACT,\n                msg      = close_msg,\n                funds    = []\n            )\n\n            # Prepare the Tx\n            tx = Transaction()\n            tx.add_message(exec_msg)\n            tx.with_gas(req.gas_limit)\n            tx.with_fee(req.fee_amount, req.fee_denom)\n            tx.with_chain_id(req.chain_id)\n            tx.with_memo(\"close Amber position\")\n\n            sign_doc = tx.get_sign_doc(account_number, sequence)\n\n            return {\n                \"sign_doc\":        base64.b64encode(sign_doc.SerializeToString()).decode(),\n                \"body_bytes\":      base64.b64encode(tx.body.SerializeToString()).decode(),\n                \"auth_info_bytes\": base64.b64encode(tx.auth_info.SerializeToString()).decode()\n            }\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=f\"Failed to build sign-doc: {exc}\")",
	"signAndBroadcastClosePosition": "export const signAndBroadcastClosePosition = async ({\n  chainId           = 'neutron-1',\n  signDocBase64,               // from step 3\n  backendBroadcastUrl = '/api/amber/broadcast_signed_tx'\n}) => {\n  try {\n    const address     = await getUserAddress(chainId);\n    const signDocBytes = b64ToUint8(signDocBase64);\n\n    // Keplr — sign the SignDoc using signDirect\n    const { signed, signature } = await window.keplr.signDirect(\n      chainId,\n      address,\n      { typeUrl: '/cosmos.tx.v1beta1.SignDoc', value: signDocBytes }\n    );\n\n    // Convert binary blobs → base64 so they can be sent over HTTP\n    const bodyB64       = btoa(String.fromCharCode(...signed.bodyBytes));\n    const authInfoB64   = btoa(String.fromCharCode(...signed.authInfoBytes));\n    const sigB64        = btoa(String.fromCharCode(...signature.signature));\n\n    const res = await fetch(backendBroadcastUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        body_bytes: bodyB64,\n        auth_info_bytes: authInfoB64,\n        signatures: [sigB64]\n      })\n    });\n\n    if (!res.ok) {\n      const err = await res.json();\n      throw new Error(err.detail || 'Broadcast failed');\n    }\n\n    return await res.json(); // { txhash, height, ... }\n  } catch (err) {\n    console.error('[signAndBroadcastClosePosition] error:', err);\n    throw err;\n  }\n};",
	"confirm_position_closed": "def confirm_position_closed(address: str):\n    \"\"\"Returns `{closed: true}` once the address has no outstanding debt.\"\"\"\n    try:\n        data = await query_position_status(address)\n        debt = data.get(\"position\", {}).get(\"debt\", 0)\n        return {\"closed\": int(debt) == 0, \"raw\": data}\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=f\"Confirmation failed: {exc}\")",
	"_get_client": "def _get_client():\n    \"\"\"Instantiate a LedgerClient for each request.\"\"\"\n    return LedgerClient(NETWORK)\n\n@app.get('/api/points')\nasync def get_user_points(address: str):\n    \"\"\"Return the caller's current point total from the Points contract.\"\"\"\n    try:\n        client = _get_client()\n        query_msg = {'points': {'address': address}}\n        response = client.query_contract_smart(CONTRACT_ADDRESS, query_msg)\n        # Expected shape: {'points': '12345'}\n        points = int(response.get('points', 0))\n        return {'address': address, 'points': points}\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=str(err))",
	"get_reward_params": "def get_reward_params():\n    \"\"\"Return constants used for reward calculations.\"\"\"\n    try:\n        return REWARD_PARAMS\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=str(err))",
	"projected_rewards": "def projected_rewards(address: str):\n    \"\"\"Compute and return projected NTRN rewards for the supplied address.\"\"\"\n    try:\n        # 1. Query the user’s point total (reuse logic from Step 2)\n        client = _get_client()\n        query_msg = {'points': {'address': address}}\n        points_response = client.query_contract_smart(CONTRACT_ADDRESS, query_msg)\n        points = int(points_response.get('points', 0))\n\n        # 2. Fetch campaign parameters (from Step 3 constant)\n        per_point_rate = REWARD_PARAMS['per_point_rate']  # micro-NTRN per point\n\n        # 3. Apply multipliers (if any). For now, multiplier = 1.\n        multiplier = 1\n        projected_untrn = points * per_point_rate * multiplier\n        projected_ntrn = projected_untrn / 1_000_000  # convert micro-denom → denom\n\n        return {\n            'address': address,\n            'points': points,\n            'projected_reward_untrn': projected_untrn,\n            'projected_reward_ntrn': projected_ntrn,\n            'assumptions': {\n                **REWARD_PARAMS,\n                'multiplier': multiplier\n            }\n        }\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=str(err))",
	"fetchProjectionAndDisplay": "export const fetchProjectionAndDisplay = async (address) => {\n  try {\n    const res = await fetch(`/api/projection?address=${address}`);\n    if (!res.ok) {\n      throw new Error(`Backend responded with status ${res.status}`);\n    }\n\n    const data = await res.json();\n    const { points, projected_reward_ntrn, assumptions } = data;\n\n    const message = `With ${points} points and a per-point rate of ${assumptions.per_point_rate / 1_000_000} NTRN, you are projected to earn ≈ ${projected_reward_ntrn} NTRN this phase.`;\n\n    // Display the message however your UI prefers. Here we log to console.\n    console.log(message);\n    return message;\n  } catch (error) {\n    console.error('Failed to fetch projection:', error);\n    return 'Unable to compute projection at this time.';\n  }\n};",
	"validate_token_balance": "def validate_token_balance(address: str, min_offer: int = 1_000_000, min_fee: int = 50_000) -> dict:\n    \"\"\"Verify that `address` owns\n    · `min_offer` micro-eBTC (1 eBTC = 1_000_000 micro-eBTC)\n    · `min_fee`  micro-NTRN for network fees.\n    Returns `{valid: True}` on success or `{valid: False, error: '...'}` otherwise.\n    \"\"\"\n    offer_denom = 'eBTC'\n    fee_denom = 'untrn'\n    try:\n        url = f\"{REST_ENDPOINT}/cosmos/bank/v1beta1/balances/{address}\"\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        balances = resp.json().get('balances', [])\n\n        def amount_of(denom: str) -> int:\n            for coin in balances:\n                if coin.get('denom') == denom:\n                    return int(coin.get('amount', '0'))\n            return 0\n\n        if amount_of(offer_denom) < min_offer:\n            raise ValueError('Insufficient eBTC balance.')\n        if amount_of(fee_denom) < min_fee:\n            raise ValueError('Insufficient untrn balance for fees.')\n\n        return {\"valid\": True}\n    except Exception as err:\n        return {\"valid\": False, \"error\": str(err)}",
	"query_dex_pool": "def query_dex_pool(offer_denom: str = 'eBTC', ask_denom: str = 'uniBTC') -> dict:\n    \"\"\"Returns raw pool data for the requested trading pair.\"\"\"\n    query_msg = {\n        \"pool\": {\n            \"pair\": {\n                \"asset_infos\": [\n                    {\"native_token\": {\"denom\": offer_denom}},\n                    {\"native_token\": {\"denom\": ask_denom}}\n                ]\n            }\n        }\n    }\n\n    try:\n        b64 = base64.b64encode(json.dumps(query_msg).encode()).decode()\n        url = f\"{REST_ENDPOINT}/cosmwasm/wasm/v1/contract/{PAIR_CONTRACT}/smart/{b64}\"\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        return resp.json()  # contains liquidity, price, etc.\n    except Exception as err:\n        return {\"error\": str(err)}",
	"constructSwapMsg": "export const constructSwapMsg = ({\n  sender,\n  contractAddress,\n  offerDenom = 'eBTC',\n  offerAmount = '1000000', // 1 eBTC in micro-units\n  askDenom = 'uniBTC',\n  maxSlippage = '0.005' // 0.5%\n}) => {\n  // Astroport-style swap execute message\n  const execMsg = {\n    swap: {\n      offer_asset: {\n        info: { native_token: { denom: offerDenom } },\n        amount: offerAmount\n      },\n      max_slippage: maxSlippage\n    }\n  };\n\n  // Construct the protobuf-ready envelope that cosmpy will later consume\n  return {\n    typeUrl: '/cosmwasm.wasm.v1.MsgExecuteContract',\n    value: {\n      sender,\n      contract: contractAddress,\n      msg: btoa(JSON.stringify(execMsg)), // base64-encoded JSON for CosmWasm\n      funds: [\n        { denom: offerDenom, amount: offerAmount }\n      ]\n    }\n  };\n};",
	"construct_msg_update_params": "def construct_msg_update_params(authority: str, schedules_per_block: int = 30) -> dict:\n    \"\"\"Return a dict that represents `/neutron.cron.MsgUpdateParams`.\n\n    Args:\n        authority (str): The DAO (gov) address that is allowed to change chain params.\n        schedules_per_block (int): Desired value for the `schedules_per_block` param.\n\n    Returns:\n        dict: JSON-serialisable message ready to be embedded in a proposal.\n    \"\"\"\n    # Basic validation -------------------------------------------------------\n    if not authority.startswith(\"neutron\"):\n        raise ValueError(\"`authority` must be a valid Neutron bech32 address\")\n    if schedules_per_block <= 0:\n        raise ValueError(\"`schedules_per_block` must be > 0\")\n\n    # Build the message ------------------------------------------------------\n    msg = {\n        \"@type\": \"/neutron.cron.MsgUpdateParams\",\n        \"authority\": authority,\n        \"params\": {\n            \"schedules_per_block\": schedules_per_block\n        }\n    }\n    return msg\n\n# OPTIONAL: pretty-print for audit / persistence\nif __name__ == \"__main__\":\n    DAO_ADDR = \"neutron1...\"  # <- replace with real address\n    print(json.dumps(construct_msg_update_params(DAO_ADDR), indent=2))",
	"_encode_cosmos_msg": "def _encode_cosmos_msg(msg: Dict) -> Dict:\n    \"\"\"Helper: builds a `CosmosMsg::Gov`-compatible JSON envelope.\n\n    Because cosmpy (and most clients) accept raw JSON in place of protobuf\n    for Custom messages, we simply return the dict itself. If your DAO core\n    requires base64-encoded `wasm/MsgExecuteContract`, encode as shown below.\n    \"\"\"\n    return msg  # no additional wrapping needed for most cw-dao versions\n\n\ndef build_dao_proposal(msg_update_params: Dict,\n                       title: str = \"Update Cron schedules_per_block to 30\",\n                       description: str = \"Set cron.schedules_per_block param to 30 via governance.\",\n                       deposit: str = \"1000000untrn\",\n                       proposer: str | None = None) -> Dict:\n    \"\"\"Return the message to execute against the DAO core contract.\"\"\"\n\n    if proposer is not None and not proposer.startswith(\"neutron\"):\n        raise ValueError(\"Invalid proposer address\")\n\n    proposal = {\n        \"propose\": {\n            \"title\": title,\n            \"description\": description,\n            \"msgs\": [\n                {\"custom\": _encode_cosmos_msg(msg_update_params)}\n            ],\n            \"deposit\": deposit\n        }\n    }\n    # Some DAO cores support an explicit `proposer` field\n    if proposer:\n        proposal[\"propose\"][\"proposer\"] = proposer\n\n    return proposal\n\nif __name__ == \"__main__\":\n    dao_contract_addr = \"neutron1dao...\"  # <- your DAO core address\n    cron_msg = construct_msg_update_params(authority=dao_contract_addr, schedules_per_block=30)\n    proposal_msg = build_dao_proposal(cron_msg)\n    print(json.dumps(proposal_msg, indent=2))",
	"monitor_proposal_status": "def monitor_proposal_status(dao_contract: str, proposal_id: int,\n                                  rpc: str = RPC,\n                                  chain_id: str = CHAIN_ID,\n                                  interval: int = 15):\n    \"\"\"Continuously poll DAO contract for proposal status until finalised.\"\"\"\n    client = LedgerClient(NetworkConfig(chain_id=chain_id, url=rpc))\n    try:\n        while True:\n            try:\n                result = client.query_contract_state(dao_contract, {\"proposal\": {\"proposal_id\": proposal_id}})\n                status = result[\"proposal\"].get(\"status\", \"unknown\")\n                print(f\"Proposal {proposal_id} ➜ {status}\")\n                if status.lower() in {\"executed\", \"rejected\", \"failed\"}:\n                    return status\n            except Exception as err:\n                print(f\"query error: {err}\")\n            await asyncio.sleep(interval)\n    finally:\n        client.close()\n\n# Usage example --------------------------------------------------------------\n# final_status = await monitor_proposal_status(DAO_CORE_ADDR, PROPOSAL_ID)",
	"get_cron_authority": "def get_cron_authority(lcd_endpoint: str) -> str:\n    \"\"\"Return the Cron module authority address (e.g. the Main DAO address).\"\"\"\n    try:\n        url = f\"{lcd_endpoint}/neutron/cron/v1/params\"\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        # The expected JSON shape is: {\"params\": {\"authority\": \"neutron1...\"}}\n        return response.json()[\"params\"][\"authority\"]\n    except (requests.RequestException, KeyError) as err:\n        raise RuntimeError(f\"Unable to fetch Cron authority: {err}\")",
	"validate_contract": "def validate_contract(address: str, lcd_endpoint: str) -> bool:\n    \"\"\"Return True when the contract exists and is instantiated.\"\"\"\n    try:\n        url = f\"{lcd_endpoint}/cosmwasm/wasm/v1/contract/{address}\"\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        info = response.json().get(\"contract_info\", {})\n        # Minimal sanity-check: the endpoint echoes back the queried address\n        return info.get(\"address\") == address\n    except requests.RequestException:\n        return False",
	"build_msg_execute_contract": "def build_msg_execute_contract(staking_contract: str, cron_sender: str = \"cron\") -> dict:\n    \"\"\"Return a MsgExecuteContract dict compatible with protobuf/CLI JSON.\"\"\"\n    inner_msg = {\"distribute_rewards\": {}}\n    return {\n        \"@type\": \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n        \"sender\": cron_sender,\n        \"contract\": staking_contract,\n        \"msg\": base64.b64encode(json.dumps(inner_msg).encode()).decode(),  # base64-encoded\n        \"funds\": []\n    }",
	"write_proposal_file": "def write_proposal_file(msg_add_schedule: dict, filename: str = \"proposal.json\") -> str:\n    \"\"\"Write the governance proposal to disk and return the file name.\"\"\"\n    proposal = {\n        \"title\": \"Add weekly staking-reward cron\",\n        \"description\": \"Distribute staking rewards every week automatically\",\n        \"messages\": [msg_add_schedule]\n    }\n    with open(filename, \"w\", encoding=\"utf-8\") as fp:\n        json.dump(proposal, fp, indent=2)\n    return filename",
	"submit_proposal": "def submit_proposal(file_path: str, from_key: str, chain_id: str, node: str) -> None:\n    \"\"\"Call neutrond CLI to submit the proposal for voting.\"\"\"\n    cmd = [\n        \"neutrond\", \"tx\", \"wasm\", \"submit-proposal\", file_path,\n        \"--from\", from_key,\n        \"--chain-id\", chain_id,\n        \"--node\", node,\n        \"--gas\", \"auto\",\n        \"--gas-adjustment\", \"1.3\",\n        \"-y\"\n    ]\n    try:\n        subprocess.run(cmd, check=True)\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(f\"Proposal submission failed: {err}\")",
	"wait_for_proposal_passage": "def wait_for_proposal_passage(proposal_id: int, lcd_endpoint: str, poll: int = 15, timeout: int = 3600) -> None:\n    \"\"\"Block until the proposal is PASSED or raise if REJECTED/EXPIRED/timeout.\"\"\"\n    deadline = time.time() + timeout\n    gov_url = f\"{lcd_endpoint}/cosmos/gov/v1/proposals/{proposal_id}\"\n    while time.time() < deadline:\n        response = requests.get(gov_url, timeout=10)\n        response.raise_for_status()\n        status = int(response.json()[\"proposal\"][\"status\"])\n        if status == 3:  # PASSED\n            print(f\"✅  Proposal {proposal_id} PASSED\")\n            return\n        if status in (4, 5):  # REJECTED or FAILED\n            raise RuntimeError(f\"❌  Proposal {proposal_id} failed with status {status}\")\n        print(f\"⏳  Waiting... current status = {status}\")\n        time.sleep(poll)\n    raise TimeoutError(\"Timed out waiting for proposal to pass\")",
	"build_msg_update_params": "def build_msg_update_params(authority: str, *, max_schedules: int | None = None, default_gas_limit: int | None = None) -> MsgUpdateParams:\n    \"\"\"Constructs MsgUpdateParams with only the fields that need updating.\n\n    Args:\n        authority: Address allowed to perform the update (DAO address).\n        max_schedules: New maximum number of active cron schedules.\n        default_gas_limit: Optional default gas limit per cron execution.\n    \"\"\"\n    params = Params()\n    if max_schedules is not None:\n        params.max_schedules = max_schedules\n    if default_gas_limit is not None:\n        params.default_gas_limit = default_gas_limit\n\n    return MsgUpdateParams(authority=authority, params=params)",
	"get_governance_authority": "def get_governance_authority(rest_endpoint: str = 'https://rest-kralum.neutron.org') -> str:\n    '''\n    Fetch the current Main DAO address from the cron params endpoint.\n    Fallback to the MAIN_DAO_ADDRESS environment variable if the\n    endpoint is unavailable or the field is missing.\n    '''\n    try:\n        resp = requests.get(f'{rest_endpoint}/neutron/cron/v1/params', timeout=10)\n        resp.raise_for_status()\n        data = resp.json()\n        # Try multiple likely field names for robustness.\n        authority = (\n            data.get('params', {}).get('governance_account')\n            or data.get('params', {}).get('authority')\n        )\n        if authority:\n            return authority\n        raise ValueError('Authority field not found in response.')\n    except Exception as err:\n        # Log and fall back to env var so the workflow can continue.\n        print(f'[WARN] Unable to fetch authority from REST API: {err}')\n        fallback = os.getenv('MAIN_DAO_ADDRESS')\n        if not fallback:\n            raise RuntimeError('MAIN_DAO_ADDRESS env var is not set.') from err\n        return fallback\n",
	"build_execute_msg": "def build_execute_msg(sender: str, contract: str, msg: dict, funds: List[dict] | None = None) -> wasm_tx.MsgExecuteContract:\n    '''\n    Converts a Python dict into the binary-encoded message required by\n    MsgExecuteContract and optionally attaches funds.\n    '''\n    try:\n        execute = wasm_tx.MsgExecuteContract(\n            sender=sender,\n            contract=contract,\n            msg=json.dumps(msg).encode('utf-8'),  # CosmWasm expects binary JSON\n        )\n        if funds:\n            for coin in funds:\n                execute.funds.add(denom=coin['denom'], amount=str(coin['amount']))\n        return execute\n    except Exception as err:\n        raise ValueError(f'Failed to build MsgExecuteContract: {err}')\n\n\n# ---------------------------------------------------------------------\n# Example placeholder calls\n# ---------------------------------------------------------------------\n\ndef build_placeholder_calls(authority: str):\n    call_1 = build_execute_msg(\n        sender=authority,\n        contract='neutron1contractaddr1...',\n        msg={'update_config': {'param': 42}},\n    )\n    call_2 = build_execute_msg(\n        sender=authority,\n        contract='neutron1contractaddr2...',\n        msg={'set_admin': {'new_admin': authority}},\n    )\n    call_3 = build_execute_msg(\n        sender=authority,\n        contract='neutron1contractaddr3...',\n        msg={'migrate': {'code_id': 99}},\n    )\n    return call_1, call_2, call_3\n",
	"build_add_schedule": "def build_add_schedule(authority: str, name: str, period: int, msgs: List) -> cron_tx.MsgAddSchedule:\n    '''Create a MsgAddSchedule for the Cron module.'''\n    if not msgs:\n        raise ValueError('Msgs list cannot be empty')\n    try:\n        schedule = cron_tx.MsgAddSchedule(\n            authority=authority,\n            name=name,\n            period=period,\n            msgs=msgs,\n        )\n        return schedule\n    except Exception as err:\n        raise RuntimeError(f'Unable to build MsgAddSchedule: {err}')\n",
	"wrap_into_submit_proposal": "def wrap_into_submit_proposal(schedule_msg, proposer: str, deposit: List[dict]):\n    '''Pack the MsgAddSchedule into a MsgSubmitProposal.'''    \n    try:\n        any_msg = Any()\n        any_msg.Pack(schedule_msg, type_url_prefix='/')\n\n        submit = gov_tx.MsgSubmitProposal(\n            messages=[any_msg],\n            initial_deposit=[base_coin.Coin(denom=c['denom'], amount=str(c['amount'])) for c in deposit],\n            proposer=proposer,\n            title='Register Cron schedule: protocol_update',\n            summary='Adds a cron schedule that executes three contract calls every 100,800 blocks.',\n        )\n        return submit\n    except Exception as err:\n        raise RuntimeError(f'Unable to create MsgSubmitProposal: {err}')\n",
	"query_cron_show_schedule": "def query_cron_show_schedule(schedule_name: str, node: str = \"https://rpc.neutron.org:26657\") -> Dict:\n    \"\"\"Fetch cron schedule metadata from a Neutron node.\n\n    Args:\n        schedule_name (str): The name of the cron schedule to query.\n        node (str): Optional RPC node URL. Defaults to a public Neutron RPC.\n\n    Returns:\n        Dict: Parsed JSON data describing the schedule.\n\n    Raises:\n        RuntimeError: If the neutrond binary is missing or the command fails.\n    \"\"\"\n    # Construct neutrond CLI command\n    cmd = [\n        \"neutrond\", \"query\", \"cron\", \"show-schedule\", schedule_name,\n        \"--node\", node,\n        \"--output\", \"json\"\n    ]\n\n    try:\n        completed = subprocess.run(cmd, check=True, capture_output=True, text=True)\n    except FileNotFoundError as err:\n        raise RuntimeError(\"'neutrond' CLI not found. Install it and ensure it is in your PATH.\") from err\n    except subprocess.CalledProcessError as err:\n        raise RuntimeError(f\"CLI returned error while querying schedule '{schedule_name}': {err.stderr}\") from err\n\n    # Parse the JSON output\n    try:\n        return json.loads(completed.stdout)\n    except json.JSONDecodeError as err:\n        raise RuntimeError(\"Failed to decode neutrond JSON output.\") from err\n\n\nif __name__ == \"__main__\":\n    # Example invocation\n    schedule_meta = query_cron_show_schedule(\"protocol_update\")\n    print(json.dumps(schedule_meta, indent=2))",
	"getNeutronAddress": "export const getNeutronAddress = async () => {\n  const chainId = 'neutron-1'; // main-net chain ID\n  try {\n    if (!window?.keplr) {\n      throw new Error('Keplr wallet is not installed.');\n    }\n\n    // Request wallet connection for the chain\n    await window.keplr.enable(chainId);\n\n    // Retrieve the signer and the account list\n    const signer = window.getOfflineSigner(chainId);\n    const accounts = await signer.getAccounts();\n\n    if (!accounts.length) {\n      throw new Error('No account found inside Keplr.');\n    }\n\n    return accounts[0].address;\n  } catch (err) {\n    console.error(err);\n    throw err;\n  }\n};",
	"getUserEvmAddressInput": "export const getUserEvmAddressInput = () => {\n  const input = prompt('Enter the destination Ethereum (EVM) address (0x…)');\n  if (!input) {\n    throw new Error('No Ethereum address supplied by user.');\n  }\n  return input.trim();\n};",
	"validateEthereumAddress": "export const validateEthereumAddress = (evmAddress) => {\n  const regex = /^0x[a-fA-F0-9]{40}$/;\n  if (!regex.test(evmAddress)) {\n    throw new Error('Invalid Ethereum address format.');\n  }\n  return true;\n};",
	"constructSetTargetMsg": "export const constructSetTargetMsg = ({\n  contractAddress,\n  senderAddress,\n  evmAddress,\n}) => {\n  // Contract-level JSON payload\n  const payload = { set_target: { evm_address: evmAddress } };\n\n  // CosmWasm execute envelope\n  return {\n    typeUrl: '/cosmwasm.wasm.v1.MsgExecuteContract',\n    value: {\n      sender: senderAddress,\n      contract: contractAddress,\n      msg: Array.from(\n        new TextEncoder().encode(JSON.stringify(payload))\n      ),\n      funds: [],\n    },\n  };\n};",
	"ensure_msg_execute": "def ensure_msg_execute(cls, v):\n        if v != '/cosmwasm.wasm.v1.MsgExecuteContract':\n            raise ValueError('Only MsgExecuteContract is supported by this endpoint.')\n        return v\n\n\n@router.post('/api/set_target')\nasync def set_target(payload: ExecutePayload):\n    \"\"\"Signs and broadcasts a MsgExecuteContract built on the frontend\"\"\"\n    try:\n        # Prepare LCD/RPC client\n        config = NetworkConfig(\n            chain_id=CHAIN_ID,\n            url=RPC,\n            fee_minimum_gas_price=GAS_PRICE,\n            fee_denom='untrn',\n        )\n        client = LedgerClient(config)\n\n        # Load server wallet\n        mnemonic = os.getenv('DEPLOYER_MNEMONIC')\n        if not mnemonic:\n            raise HTTPException(500, 'DEPLOYER_MNEMONIC environment variable not set.')\n        wallet = LocalWallet.from_mnemonic(mnemonic)\n\n        # Re-create the message\n        msg_execute = MsgExecuteContract(\n            sender=Address(payload.value.sender),\n            contract=Address(payload.value.contract),\n            msg=bytes(payload.value.msg),\n            funds=[],\n        )\n\n        # Build and sign the tx\n        tx = (\n            Transaction()\n            .with_messages(msg_execute)\n            .with_chain_id(CHAIN_ID)\n            .with_sender(wallet)\n            .with_fee(gas_limit=200_000, fee_amount=5000, fee_denom='untrn')\n            .with_memo('Update boost target')\n        )\n        signed_tx = tx.sign(wallet)\n\n        # Broadcast\n        tx_response = client.broadcast_tx(signed_tx)\n        if tx_response.is_err():\n            raise HTTPException(500, f'Broadcast failed: {tx_response.tx_response.raw_log}')\n\n        return {'tx_hash': tx_response.tx_hash}\n\n    except HTTPException:\n        raise\n    except Exception as exc:\n        raise HTTPException(500, str(exc))",
	"queryBoostTarget": "export const queryBoostTarget = async (contractAddress) => {\n  try {\n    const queryMsg = { target: {} };\n    const encoded = btoa(JSON.stringify(queryMsg)); // base64-encode the query JSON\n\n    const endpoint = `https://rest-kralum.neutron.org/cosmwasm/wasm/v1/contract/${contractAddress}/smart/${encoded}`;\n    const resp = await fetch(endpoint);\n\n    if (!resp.ok) {\n      throw new Error(`Query failed with ${resp.status}: ${resp.statusText}`);\n    }\n\n    const result = await resp.json();\n    return result; // Expected shape: { data: { evm_address: '0x...' } }\n  } catch (err) {\n    console.error(err);\n    throw err;\n  }\n};",
	"wasm_query": "def wasm_query(contract_address: str, query_msg: dict):\n    \"\"\"Utility function that performs a CosmWasm smart-query via the public LCD.\"\"\"\n    try:\n        msg_b64 = base64.b64encode(json.dumps(query_msg).encode()).decode()\n        url     = f\"{LCD_ENDPOINT}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{msg_b64}\"\n        resp    = requests.get(url, timeout=10)\n        resp.raise_for_status()\n        return resp.json().get('data', {})\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f'Smart-query failed: {e}')\n\n@app.get('/api/active_phase')\ndef fetch_current_campaign_phase():\n    \"\"\"Returns the ID of the currently active campaign phase.\"\"\"\n    query_msg = {\"get_current_phase\": {}}\n    data      = wasm_query(CAMPAIGN_CONTRACT, query_msg)\n    if 'phase_id' not in data:\n        raise HTTPException(status_code=500, detail=\"Invalid contract response: 'phase_id' missing\")\n    return {\"phase_id\": data['phase_id']}",
	"displayPoints": "export const displayPoints = (points) => {\n  // Locate—or create—the DOM element for displaying points\n  let container = document.getElementById('points-display');\n  if (!container) {\n    container = document.createElement('div');\n    container.id = 'points-display';\n    document.body.appendChild(container);\n  }\n  container.textContent = `You have ${points} point${points === 1 ? '' : 's'} in the current campaign phase.`;\n};",
	"get_controller_address": "def get_controller_address(env: str = \"mainnet\"):\n    \"\"\"Return the controller/lens contract address used to query market data.\"\"\"\n    address = AMBER_CONTROLLER_ADDRESSES.get(env)\n    if not address:\n        raise HTTPException(status_code=400, detail=\"Unsupported environment\")\n    return {\"env\": env, \"controller_address\": address}",
	"_query_smart": "def _query_smart(contract_address: str, query_msg: dict):\n    \"\"\"Helper to perform a CosmWasm smart-query using the LCD REST interface.\"\"\"\n    encoded_msg = base64.b64encode(json.dumps(query_msg).encode()).decode()\n    url = f\"{LCD_ENDPOINT}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{encoded_msg}\"\n    async with httpx.AsyncClient() as client:\n        resp = await client.get(url, timeout=10)\n        try:\n            resp.raise_for_status()\n        except httpx.HTTPStatusError as exc:\n            raise HTTPException(status_code=exc.response.status_code, detail=str(exc))\n        return resp.json().get(\"data\") or resp.json()\n\n@app.get(\"/api/amber/markets\")\nasync def get_markets(env: str = \"mainnet\"):\n    from amber_api import AMBER_CONTROLLER_ADDRESSES  # reuse mapping from step 1\n    controller = AMBER_CONTROLLER_ADDRESSES.get(env)\n    if not controller:\n        raise HTTPException(status_code=400, detail=\"Unsupported environment\")\n    markets = await _query_smart(controller, {\"markets\": {}})\n    return markets",
	"get_market_state": "def get_market_state(market_id: str, env: str = \"mainnet\"):\n    from amber_api import AMBER_CONTROLLER_ADDRESSES\n    controller = AMBER_CONTROLLER_ADDRESSES.get(env)\n    if not controller:\n        raise HTTPException(status_code=400, detail=\"Unsupported environment\")\n    state = await _query_smart(controller, {\"market_state\": {\"market_id\": market_id}})\n    return state",
	"rateToAPY": "export const rateToAPY = (ratePerSecond) => {\n  const r = Number(ratePerSecond);\n  if (isNaN(r)) {\n    throw new Error('rateToAPY received an invalid number');\n  }\n  const apy = (Math.pow(1 + r, SECONDS_PER_YEAR) - 1) * 100; // convert to %\n  return Number(apy.toFixed(2));\n};",
	"detectLeapProvider": "export const detectLeapProvider = async () => {\n  // Ensure we're in a browser environment\n  if (typeof window === 'undefined') {\n    throw new Error('This function must be run in a browser context.');\n  }\n\n  // 1) Check if the Leap extension has already injected itself\n  if (window.leap) {\n    return window.leap;\n  }\n\n  // 2) Fallback: attempt to dynamically import the Cosmos Kit Leap adapter\n  try {\n    const { LeapWallet } = await import('@cosmos-kit/leap');\n    const leapAdapter = new LeapWallet();\n\n    // The adapter offers helper methods to check installation status\n    if (await leapAdapter.isInstalled?.()) {\n      return leapAdapter;\n    }\n  } catch (err) {\n    console.error('Failed to load @cosmos-kit/leap adapter:', err);\n  }\n\n  // If we reach here, Leap is not available\n  throw new Error('Leap Wallet provider not found. Please install the Leap browser extension.');\n};",
	"enableNeutronChain": "export const enableNeutronChain = async (leap) => {\n  const chainId = 'neutron-1';\n  try {\n    await leap.enable(chainId);\n  } catch (error) {\n    console.error('User rejected or failed to enable Neutron chain:', error);\n    throw new Error('Failed to enable Neutron chain in Leap.');\n  }\n};",
	"retrieveLeapAccounts": "export const retrieveLeapAccounts = async (leap) => {\n  const chainId = 'neutron-1';\n\n  try {\n    // Prefer the more generic getOfflineSigner if available\n    const offlineSigner = leap.getOfflineSigner?.(chainId) || leap.getOfflineSignerOnlyAmino?.(chainId);\n\n    if (!offlineSigner) {\n      throw new Error('Could not obtain an OfflineSigner from Leap.');\n    }\n\n    const accounts = await offlineSigner.getAccounts();\n    if (!accounts || accounts.length === 0) {\n      throw new Error('No accounts returned by Leap.');\n    }\n\n    return {\n      offlineSigner,\n      address: accounts[0].address,\n    };\n  } catch (error) {\n    console.error('Error while retrieving Leap accounts:', error);\n    throw error;\n  }\n};",
	"query_wasm_contract_state": "def query_wasm_contract_state(contract_addr: str) -> int:\n    \"\"\"Query `{ \"get_count\": {} }` from the counter contract and return the integer count.\"\"\"\n    query_msg = {\"get_count\": {}}\n    try:\n        response = LEDGER.query_contract_smart(contract_addr, query_msg)\n    except Exception as err:\n        raise RuntimeError(f\"Smart-contract query failed: {err}\") from err\n\n    if \"count\" not in response:\n        raise ValueError(f\"Unexpected response shape: {response}\")\n    return int(response[\"count\"])",
	"connectNeutronWallet": "export const connectNeutronWallet = async (chainId = 'neutron-1') => {\n  // Ensure Keplr is available\n  if (typeof window === 'undefined' || !window.keplr) {\n    throw new Error('Keplr wallet is not installed.');\n  }\n\n  try {\n    await window.keplr.enable(chainId);\n    const signer = window.keplr.getOfflineSigner(chainId);\n    const accounts = await signer.getAccounts();\n    if (!accounts || accounts.length === 0) {\n      throw new Error('No account found in Keplr.');\n    }\n    return { signer, address: accounts[0].address };\n  } catch (err) {\n    console.error('Failed to connect to Keplr:', err);\n    throw err;\n  }\n};",
	"query_balance": "def query_balance(address: str, denom: str = 'untrn'):\n    # Returns the balance for a given Neutron address in micro-denom units (untrn)\n    try:\n        balance = client.query_bank_balance(address, denom=denom)\n        return {\n            'address': address,\n            'denom': denom,\n            'amount': int(balance),\n        }\n    except Exception as e:\n        raise HTTPException(status_code=400, detail=str(e))",
	"build_stake_and_mint_tx": "def build_stake_and_mint_tx(sender_address: str, contract_address: str, amount: int = 250000000, denom: str = 'untrn', duration: str = '12_months'):\n    # Build the JSON message expected by the Boost contract\n    execute_msg = {\n        'stake_and_mint_nft': {\n            'amount': f'{amount}{denom}',\n            'duration': duration,\n        }\n    }\n\n    # Funds that accompany the execute call\n    funds = [{ 'denom': denom, 'amount': str(amount) }]\n\n    # Construct the MsgExecuteContract protobuf wrapper\n    msg = MsgExecuteContract(\n        sender=sender_address,\n        contract=contract_address,\n        msg=execute_msg,\n        funds=funds,\n    )\n\n    # Wrap inside a Transaction for later signing\n    tx = Transaction()\n    tx.add_message(msg)\n    tx.with_sender(sender_address)\n    return tx",
	"sign_and_broadcast": "def sign_and_broadcast(tx, client: LedgerClient):\n    # Sign the provided Transaction using the mnemonic in the MNEMONIC env variable and broadcast it.\n    mnemonic = os.getenv('MNEMONIC')\n    if not mnemonic:\n        raise ValueError('MNEMONIC environment variable is not set.')\n\n    pk = PrivateKey.from_mnemonic(mnemonic)\n    signed_tx = tx.sign(pk)\n    resp = client.broadcast_transaction(signed_tx)\n\n    if resp.is_successful():\n        return { 'tx_hash': resp.tx_hash }\n    else:\n        raise RuntimeError(f'Broadcast failed with code {resp.code}: {resp.raw_log}')",
	"wait_for_tx_commit": "def wait_for_tx_commit(tx_hash: str, client: LedgerClient, timeout: int = 120, poll: float = 2.0):\n    # Poll the chain for the transaction result\n    deadline = time.time() + timeout\n    while time.time() < deadline:\n        tx_info = client.query_tx(tx_hash)\n        if tx_info is not None:\n            return {\n                'status': 'confirmed',\n                'height': tx_info.height,\n                'raw_log': tx_info.raw_log,\n            }\n        time.sleep(poll)\n    raise TimeoutError('Timed out waiting for transaction commitment.')",
	"query_nft_tokens": "def query_nft_tokens(client: LedgerClient, contract_address: str, owner_address: str):\n    query = { 'tokens': { 'owner': owner_address } }\n    try:\n        result = client.query_contract_smart(contract_address, query)\n        # The exact shape depends on the contract; assume `{ tokens: [id1,id2,...] }` is returned\n        return result.get('tokens', [])\n    except Exception as e:\n        raise RuntimeError(f'Contract query failed: {e}')",
	"extract_contract_address_from_tx": "def extract_contract_address_from_tx(tx_response):\n    \"\"\"Returns the contract address emitted by the instantiate event.\"\"\"\n    try:\n        logs = json.loads(tx_response.raw_log)\n        for event in logs[0].get(\"events\", []):\n            if event.get(\"type\") in (\"instantiate\", \"wasm\"):\n                for attr in event.get(\"attributes\", []):\n                    if attr.get(\"key\") == \"_contract_address\" or attr.get(\"key\") == \"contract_address\":\n                        return attr.get(\"value\")\n        raise RuntimeError(\"Contract address not found in tx events.\")\n    except (KeyError, ValueError, IndexError) as e:\n        raise RuntimeError(f\"Error parsing tx log: {e}\") from e",
	"query_vesting_contract": "def query_vesting_contract(address: str):\n    \"\"\"Return the claimable rewards for a given address.\"\"\"\n    try:\n        query_msg = {\"claimable_rewards\": {\"address\": address}}\n        query_b64 = base64.b64encode(json.dumps(query_msg).encode()).decode()\n        url = f\"{NEUTRON_LCD}/cosmwasm/wasm/v1/contract/{VESTING_CONTRACT}/smart/{query_b64}\"\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            resp.raise_for_status()\n        data = resp.json()\n        # Expected format: {\"data\": {\"amount\": \"123456\"}}\n        amount = int(data.get(\"data\", {}).get(\"amount\", 0))\n        return {\"claimable\": amount}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"validate_claimable_amount": "def validate_claimable_amount(amount: int):\n    \"\"\"Raise an HTTP 400 if amount == 0.\"\"\"\n    if int(amount) == 0:\n        raise HTTPException(status_code=400, detail=\"No claimable rewards for this address.\")\n    return {\"ok\": True}",
	"construct_execute_msg": "def construct_execute_msg():\n    \"\"\"Return the execute message required to start vesting.\"\"\"\n    execute_msg = {\"start_standard_vesting\": {}}\n    return execute_msg",
	"query_vesting_schedule": "def query_vesting_schedule(address: str):\n    \"\"\"Return the latest vesting schedule for the provided address.\"\"\"\n    query = {\"vesting_schedule\": {\"address\": address}}\n    query_b64 = base64.b64encode(json.dumps(query).encode()).decode()\n    url = f\"{NEUTRON_LCD}/cosmwasm/wasm/v1/contract/{VESTING_CONTRACT}/smart/{query_b64}\"\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            resp.raise_for_status()\n        return resp.json().get(\"data\", {})\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"promptContractAddress": "export const promptContractAddress = () => {\n  // Browser prompt for simplicity; replace with a nicer UI as needed\n  const contractAddr = prompt('Enter the CosmWasm contract address to update admin for:');\n\n  if (!contractAddr) {\n    throw new Error('Contract address is required.');\n  }\n\n  const trimmed = contractAddr.trim();\n\n  // Basic bech32 length sanity-check (optional: use full bech32 validation)\n  if (trimmed.length < 40 || trimmed.length > 90) {\n    throw new Error('Invalid contract address length.');\n  }\n\n  return trimmed;\n};",
	"build_release_tokens_msg": "def build_release_tokens_msg(sender: str, vesting_contract: str) -> MsgExecuteContract:\n    \"\"\"Constructs a MsgExecuteContract that triggers the `release_tokens` method of the vesting contract.\"\"\"\n    try:\n        execute_msg = {\"release_tokens\": {}}\n        msg = MsgExecuteContract(\n            sender=sender,\n            contract=vesting_contract,\n            msg=json.dumps(execute_msg).encode(),\n            funds=[]  # No funds sent with the call\n        )\n        return msg\n    except Exception as e:\n        raise ValueError(f\"Failed to build MsgExecuteContract: {e}\")",
	"build_add_schedule_msg": "def build_add_schedule_msg(authority: str, release_msg, period: int = 216000, name: str = \"token_unlock\") -> MsgAddSchedule:\n    \"\"\"Constructs a MsgAddSchedule message for the Cron module.\"\"\"\n    try:\n        schedule_msg = MsgAddSchedule(\n            authority=authority,\n            name=name,\n            period=period,\n            msgs=[release_msg]\n        )\n        return schedule_msg\n    except Exception as e:\n        raise ValueError(f\"Failed to build MsgAddSchedule: {e}\")",
	"wrap_into_gov_proposal": "def wrap_into_gov_proposal(schedule_msg, title: str = \"Add token_unlock schedule\", summary: str = \"Adds periodic token unlock via Cron\", deposit: str = \"10000000untrn\") -> str:\n    \"\"\"Serialises the schedule message into a governance proposal JSON string.\"\"\"\n    try:\n        schedule_dict = MessageToDict(schedule_msg, preserving_proto_field_name=True)\n        schedule_dict[\"@type\"] = \"/neutron.cron.MsgAddSchedule\"\n\n        proposal = {\n            \"messages\": [schedule_dict],\n            \"metadata\": \"\",\n            \"deposit\": deposit,\n            \"title\": title,\n            \"summary\": summary\n        }\n        return json.dumps(proposal, indent=2)\n    except Exception as e:\n        raise ValueError(f\"Failed to wrap proposal JSON: {e}\")",
	"ensureNetworkNeutron": "export const ensureNetworkNeutron = async (wallet) => {\n  const chainId = 'neutron-1';\n\n  // Neutron chain parameters — tweak RPC/REST endpoints as needed for production\n  const neutronChainInfo = {\n    chainId: 'neutron-1',\n    chainName: 'Neutron',\n    rpc: 'https://rpc-kralum.neutron-1.neutron.org',\n    rest: 'https://rest-kralum.neutron-1.neutron.org',\n    stakeCurrency: { coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 },\n    bip44: { coinType: 118 },\n    bech32Config: {\n      bech32PrefixAccAddr: 'neutron',\n      bech32PrefixAccPub: 'neutronpub',\n      bech32PrefixValAddr: 'neutronvaloper',\n      bech32PrefixValPub: 'neutronvaloperpub',\n      bech32PrefixConsAddr: 'neutronvalcons',\n      bech32PrefixConsPub: 'neutronvalconspub'\n    },\n    currencies: [\n      { coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6 }\n    ],\n    feeCurrencies: [\n      { coinDenom: 'NTRN', coinMinimalDenom: 'untrn', coinDecimals: 6, gasPriceStep: { low: 0.01, average: 0.025, high: 0.04 } }\n    ],\n    features: ['stargate', 'ibc-transfer', 'cosmwasm']\n  };\n\n  try {\n    // Attempt to query the chain; if it throws, the chain likely isn't added yet\n    await wallet.getKey(chainId);\n  } catch (_) {\n    // Use Keplr/Leap experimental API to suggest the chain\n    if (wallet.experimentalSuggestChain) {\n      await wallet.experimentalSuggestChain(neutronChainInfo);\n    } else {\n      throw new Error('The connected wallet does not support adding new chains.');\n    }\n  }\n\n  // Re-enable to make sure we have permission on the (new) chain\n  await wallet.enable(chainId);\n};",
	"extract_code_id": "def extract_code_id(contract_info: Dict) -> Union[int, str]:\n    \"\"\"Pull `code_id` out of the contract-info payload.\n\n    Args:\n        contract_info (Dict): Output from `query_contract_info`.\n\n    Returns:\n        int | str: The numeric (or string) code ID.\n    \"\"\"\n    try:\n        code_id = contract_info[\"code_id\"]\n        if code_id in (None, \"\"):\n            raise KeyError\n        return code_id\n    except KeyError:\n        raise CodeIdExtractionError(\"`code_id` not found in contract info payload\")",
	"isFeeDenomEligible": "export const isFeeDenomEligible = async (denom = \"uusdc\", restEndpoint = REST_ENDPOINT) => {\n  try {\n    const res = await fetch(`${restEndpoint}/neutron/dynamicfees/params`);\n    if (!res.ok) throw new Error(`HTTP ${res.status}`);\n\n    const json = await res.json();\n    const prices = json?.params?.ntrn_prices ?? [];\n    const eligible = prices.some((d) => d.denom === denom);\n\n    if (!eligible) {\n      throw new Error(`${denom} is not found in ntrn_prices ‑ it cannot be used to pay fees.`);\n    }\n\n    return {\n      eligible: true,\n      raw: json\n    };\n  } catch (err) {\n    console.error(\"Dynamic-fees query failed\", err);\n    throw err;\n  }\n};",
	"getMinGasPrice": "export const getMinGasPrice = async (denom = \"uusdc\", restEndpoint = REST_ENDPOINT) => {\n  try {\n    const res = await fetch(`${restEndpoint}/neutron/globalfee/min_gas_prices`);\n    if (!res.ok) throw new Error(`HTTP ${res.status}`);\n\n    const json = await res.json(); // [{ denom: \"untrn\", amount: \"0.015\" }, ...]\n    const entry = (json || []).find((e) => e.denom === denom);\n    if (!entry) throw new Error(`No gas-price entry for denom ${denom}`);\n\n    return entry.amount; // string, e.g. \"0.07\"\n  } catch (err) {\n    console.error(\"Global-fee query failed\", err);\n    throw err;\n  }\n};",
	"setDefaultFeeDenom": "export const setDefaultFeeDenom = (denom = \"uusdc\") => {\n  try {\n    localStorage.setItem(\"NEUTRON_FEE_DENOM\", denom);\n  } catch (err) {\n    console.warn(\"Unable to write NEUTRON_FEE_DENOM to localStorage\", err);\n  }\n};",
	"construct_and_sign": "def construct_and_sign(req: ConstructTxRequest):\n    try:\n        # Restore private key & derive sender address\n        pk = PrivateKey(bytes.fromhex(req.sender_privkey_hex))\n        sender_addr = pk.public_key().address()\n\n        client = LedgerClient(RPC_ENDPOINT)\n        onchain_account = await client.query_account(sender_addr)\n\n        # ----- Build bank MsgSend -----\n        send_msg = bank_tx.MsgSend(\n            from_address=sender_addr,\n            to_address=req.recipient,\n            amount=[{\"denom\": req.amount_denom, \"amount\": str(req.amount)}],\n        )\n\n        # ----- Create Tx wrapper -----\n        tx = Transaction()\n        tx.add_message(send_msg)\n        tx.with_sequence(onchain_account.sequence)\n        tx.with_account_num(onchain_account.account_number)\n        tx.with_chain_id(CHAIN_ID)\n        tx.with_gas(req.gas_limit)\n        tx.with_fee(req.fee_amount, req.fee_denom)\n\n        signed_tx = tx.get_tx_data(pk)\n        return {\"signed_tx_hex\": signed_tx.hex()}\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"broadcast_signed_tx": "def broadcast_signed_tx(req: BroadcastRequest):\n    try:\n        client = LedgerClient(RPC_ENDPOINT)\n        tx_bytes = bytes.fromhex(req.signed_tx_hex)\n        res = await client.broadcast_tx_sync(tx_bytes)\n\n        if res.code != 0:\n            raise TxCommitError(f\"Tx failed: code={res.code} log={res.raw_log}\")\n\n        return {\"tx_hash\": res.txhash, \"height\": res.height}\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"getDelegatorAddress": "export const getDelegatorAddress = async (chainId = 'neutron-1') => {\n  if (!window || !window.keplr) {\n    throw new Error('Keplr wallet is not installed.');\n  }\n\n  try {\n    // Prompt wallet connection / network enable\n    await window.keplr.enable(chainId);\n\n    // Retrieve signer & accounts\n    const signer = window.getOfflineSigner(chainId);\n    const accounts = await signer.getAccounts();\n\n    if (!accounts.length) {\n      throw new Error('No accounts found in the connected wallet.');\n    }\n\n    return {\n      address: accounts[0].address,\n      signer,\n    };\n  } catch (err) {\n    console.error('[Keplr-Connect] ::', err);\n    throw new Error('Failed to connect the wallet.');\n  }\n};",
	"queryPendingStakingRewards": "export const queryPendingStakingRewards = async (\n  delegatorAddress,\n  restEndpoint = 'https://rest-kralum.neutron-1.neutron.org'\n) => {\n  const url = `${restEndpoint}/cosmos/distribution/v1beta1/delegators/${delegatorAddress}/rewards`;\n  try {\n    const res = await fetch(url);\n    if (!res.ok) {\n      throw new Error(`Distribution query failed :: ${res.status}`);\n    }\n    return await res.json();\n  } catch (error) {\n    console.error('[Query-Rewards] ::', error);\n    throw error;\n  }\n};",
	"calculatePartialRewards": "export const calculatePartialRewards = (\n  rewardsResponse,\n  fraction = 0.5,\n  denom = 'untrn'\n) => {\n  if (!rewardsResponse || !Array.isArray(rewardsResponse.rewards)) {\n    throw new Error('Malformed rewards response.');\n  }\n\n  const partial = rewardsResponse.rewards\n    .map((entry) => {\n      const coin = (entry.reward || []).find((c) => c.denom === denom);\n      const rawAmount = coin ? Number(coin.amount) : 0;\n      const half = Math.floor(rawAmount * fraction);\n      return {\n        validator_address: entry.validator_address,\n        amount: half.toString(),\n        denom,\n      };\n    })\n    .filter((c) => Number(c.amount) > 0);\n\n  return partial;\n};",
	"build_withdraw_tx": "def build_withdraw_tx(req: BuildTxRequest):\n    try:\n        rpc = os.getenv('RPC_ENDPOINT', 'https://rpc-kralum.neutron-1.neutron.org')\n        client = LedgerClient(rpc)\n        account = client.query_account(req.delegator_address)\n\n        tx = Transaction()\n        # A MsgWithdrawDelegatorReward message per validator\n        for r in req.rewards:\n            tx.add_msg(\n                MsgWithdrawDelegatorReward(\n                    delegator_address=req.delegator_address,\n                    validator_address=r.validator_address,\n                )\n            )\n\n        # Basic fee / gas; adjust to your needs\n        tx.set_fee(2000, 'untrn')\n        tx.set_gas(200000 * len(req.rewards))\n\n        tx.set_account_num(account.account_number)\n        tx.set_sequence(account.sequence)\n        tx.set_chain_id(client.chain_id)\n\n        sign_doc = tx.get_sign_doc()\n\n        return SignDocResponse(\n            body_bytes=base64.b64encode(sign_doc.body_bytes).decode(),\n            auth_info_bytes=base64.b64encode(sign_doc.auth_info_bytes).decode(),\n            account_number=account.account_number,\n            chain_id=client.chain_id,\n        )\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"signAndBroadcastWithdrawal": "export const signAndBroadcastWithdrawal = async (\n  signerAddress,\n  signDoc,\n  apiUrl = '/api/broadcast_tx'\n) => {\n  if (!window.keplr) {\n    throw new Error('Keplr wallet missing.');\n  }\n\n  // Re-build the object expected by signDirect\n  const directSignDoc = {\n    bodyBytes: Uint8Array.from(atob(signDoc.body_bytes), (c) => c.charCodeAt(0)),\n    authInfoBytes: Uint8Array.from(atob(signDoc.auth_info_bytes), (c) => c.charCodeAt(0)),\n    chainId: signDoc.chain_id,\n    accountNumber: BigInt(signDoc.account_number),\n  };\n\n  // -------------------\n  // 1) Sign the TX bytes\n  // -------------------\n  const { signature } = await window.keplr.signDirect(\n    signDoc.chain_id,\n    signerAddress,\n    directSignDoc\n  );\n\n  // ------------------------------------------------\n  // 2) Send the signed payload to the backend (BFF)\n  // ------------------------------------------------\n  const res = await fetch(apiUrl, {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      body_bytes: signDoc.body_bytes,\n      auth_info_bytes: signDoc.auth_info_bytes,\n      signature: Buffer.from(signature.signature).toString('base64'),\n    }),\n  });\n\n  if (!res.ok) {\n    const err = await res.json();\n    throw new Error(err.detail || 'Broadcast failed');\n  }\n\n  return await res.json(); // { txhash: '...' }\n};",
	"broadcast_tx": "def broadcast_tx(req: BroadcastRequest):\n    try:\n        body_bytes = base64.b64decode(req.body_bytes)\n        auth_info_bytes = base64.b64decode(req.auth_info_bytes)\n        signature_bytes = base64.b64decode(req.signature)\n\n        tx_raw = TxRaw(\n            body_bytes=body_bytes,\n            auth_info_bytes=auth_info_bytes,\n            signatures=[signature_bytes],\n        )\n\n        rpc = os.getenv('RPC_ENDPOINT', 'https://rpc-kralum.neutron-1.neutron.org')\n        client = LedgerClient(rpc)\n        tx_response = client.broadcast_tx(tx_raw.SerializeToString(), broadcast_mode='sync')\n\n        return { 'txhash': tx_response.tx_hash.hex() }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"construct_msg_remove_schedule": "def construct_msg_remove_schedule(schedule_name: str, authority: str) -> dict:\n    \"\"\"Return a MsgRemoveSchedule ready for inclusion in a proposal.\"\"\"\n    return {\n        \"@type\": \"/neutron.cron.MsgRemoveSchedule\",\n        \"authority\": authority,\n        \"name\": schedule_name,\n    }",
	"construct_msg_add_schedule": "def construct_msg_add_schedule(schedule_name: str, period: int, msgs: list, authority: str) -> dict:\n    \"\"\"Return a MsgAddSchedule that runs at BEGIN_BLOCKER.\"\"\"\n    return {\n        \"@type\": \"/neutron.cron.MsgAddSchedule\",\n        \"authority\": authority,\n        \"name\": schedule_name,\n        \"period\": str(period),              # protobuf JSON expects strings for integers\n        \"execution_stages\": [\"BEGIN_BLOCKER\"],\n        \"msgs\": msgs,\n    }",
	"create_json_proposal_file": "def create_json_proposal_file(msgs: list, title: str, description: str, deposit: str, outfile: str = \"proposal.json\") -> str:\n    \"\"\"Writes a Neutron governance proposal JSON to disk.\"\"\"\n    proposal = {\n        \"title\": title,\n        \"description\": description,\n        \"deposit\": deposit,           # e.g. \"1000000untrn\"\n        \"messages\": msgs,\n    }\n    with open(outfile, \"w\", encoding=\"utf-8\") as fp:\n        json.dump(proposal, fp, indent=2)\n    return outfile",
	"submitProposalToMainDao": "export const submitProposalToMainDao = async (offlineSigner, sender, proposal) => {\n  try {\n    const client = await SigningCosmWasmClient.connectWithSigner(rpcEndpoint, offlineSigner);\n\n    // Wrap the Cron messages in a CW-dao single-choice proposal\n    const execMsg = {\n      propose: {\n        msg: {\n          propose_single: {\n            title: proposal.title,\n            description: proposal.description,\n            msgs: proposal.messages,\n          },\n        },\n      },\n    };\n\n    const fee = \"auto\";\n    const result = await client.execute(sender, daoAddress, execMsg, fee);\n    return result;\n  } catch (error) {\n    console.error(\"Failed to submit proposal\", error);\n    throw error;\n  }\n};",
	"vote_and_wait_for_passage": "def vote_and_wait_for_passage(rpc_endpoint: str, proposal_id: int, voter_priv_hex: str, chain_id: str, poll: int = 15):\n    \"\"\"Casts a YES vote, then waits until the proposal status is PASSED (or fails).\"\"\"\n    key = PrivateKey.from_hex(voter_priv_hex)\n    cfg = NetworkConfig(\n        chain_id=chain_id,\n        url=rpc_endpoint,\n        fee_denomination=\"untrn\",\n        fee_minimum_gas_price=0.025,\n    )\n    client = LedgerClient(cfg)\n\n    # VoteOptionYes = 1\n    client.gov_vote(proposal_id, key.address(), 1)\n    print(f\"YES vote submitted from {key.address()} on proposal {proposal_id}\")\n\n    while True:\n        status = client.gov_proposal(proposal_id)[\"status\"]\n        print(\"Current status:\", status)\n        if status == \"PROPOSAL_STATUS_PASSED\":\n            print(\"🎉 Proposal PASSED\")\n            return True\n        if status in (\"PROPOSAL_STATUS_REJECTED\", \"PROPOSAL_STATUS_FAILED\"):\n            raise RuntimeError(f\"Proposal ended with status {status}\")\n        time.sleep(poll)",
	"confirm_execution_stage": "def confirm_execution_stage(rest_endpoint: str, schedule_name: str) -> bool:\n    \"\"\"Returns True if the cron job now runs at BEGIN_BLOCKER.\"\"\"\n    schedule = query_cron_schedule(rest_endpoint, schedule_name)\n    return schedule.get(\"execution_stage\") == \"BEGIN_BLOCKER\"",
	"displayLastExecutionHeight": "export const displayLastExecutionHeight = (height) => {\n  if (height === undefined || height === null) {\n    console.error('Height is not provided.');\n    return;\n  }\n  console.log(`Last execution height: ${height}`);\n  // You can additionally inject this into the DOM, e.g.,\n  // document.getElementById('last-height').textContent = `Last execution height: ${height}`;\n};",
	"parse_json_response": "def parse_json_response(raw: Dict[str, Any]) -> ParsedSchedule:\n    \"\"\"Parse required fields from cron schedule JSON.\n\n    Args:\n        raw: The raw JSON dict returned by query_cron_schedule.\n\n    Returns:\n        A TypedDict containing the requested fields.\n\n    Raises:\n        KeyError: If any expected field is missing.\n        ValueError: If a field has an unexpected type/format.\n    \"\"\"\n    try:\n        schedule = raw[\"schedule\"]  # LCD nests data under the `schedule` key\n        parsed: ParsedSchedule = {\n            \"name\": schedule[\"name\"],\n            \"period\": schedule[\"period\"],\n            \"msgs\": schedule[\"msgs\"],\n            \"last_execution_height\": int(schedule[\"last_execution_height\"]),\n        }\n        return parsed\n    except KeyError as exc:\n        raise KeyError(f\"Expected key not found in response: {exc}\") from exc\n    except (TypeError, ValueError) as exc:\n        raise ValueError(f\"Malformed field in cron schedule response: {exc}\") from exc",
	"ensureKeplrInstalled": "export const ensureKeplrInstalled = async () => {\n  // Verifies Keplr is injected into the browser window.\n  if (typeof window === 'undefined' || !window.keplr) {\n    // If not installed, open the official download page and throw an error.\n    window.open('https://www.keplr.app/download', '_blank');\n    throw new Error('Keplr extension is not installed.');\n  }\n\n  // At this point Keplr exists; returning it allows subsequent steps to use the instance.\n  return window.keplr;\n};",
	"enableNeutron": "export const enableNeutron = async (chainId = 'neutron-1') => {\n  if (!window.keplr) {\n    throw new Error('Keplr extension not detected.');\n  }\n  try {\n    await window.keplr.enable(chainId); // Opens the Keplr approval popup.\n    return true; // Success indicates the site now has access to the chain.\n  } catch (err) {\n    console.error(`User rejected enabling ${chainId}:`, err);\n    throw err;\n  }\n};",
	"gatherScheduleInputs": "export const gatherScheduleInputs = () => {\n  // In a real app you would read these from form fields or a config file.\n  const scheduleName = \"daily_rewards\";            // Unique schedule identifier\n  const period = 7200;                              // Blocks between executions\n  const executionStage = \"EXECUTION_STAGE_END_BLOCKER\"; // When to fire (Begin/End block)\n  const targetContract = \"neutron1contract...\";     // Rewards contract address\n\n  // CosmWasm execute payload that the cron job will run each period\n  const rewardsMsg = {\n    distribute: {}\n  };\n\n  // MsgExecuteContract that the Cron module will invoke\n  const compiledExecuteMsg = {\n    \"@type\": \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n    \"sender\": targetContract,         // will be overwritten by Cron when executed\n    \"contract\": targetContract,\n    \"msg\": Buffer.from(JSON.stringify(rewardsMsg)).toString(\"base64\"),\n    \"funds\": []\n  };\n\n  return {\n    scheduleName,\n    period,\n    executionStage,\n    authority: \"neutron1mainDAOaddress...\", // DAO (gov) address that controls Cron\n    msgs: [compiledExecuteMsg]\n  };\n};",
	"wrap_in_dao_proposal": "def wrap_in_dao_proposal(\n    dao_contract: str,\n    proposer_addr: str,\n    schedule_msg: Dict,\n    title: str = \"Add daily_rewards cron schedule\",\n    description: str = \"Creates a cron job that distributes daily rewards at END_BLOCKER every 7200 blocks.\",\n) -> Dict:\n    \"\"\"Return a MsgExecuteContract that submits a `propose` call to a cw-dao-single contract.\"\"\"\n    if not dao_contract or not proposer_addr or not schedule_msg:\n        raise ProposalBuildError(\"dao_contract, proposer_addr, and schedule_msg are mandatory\")\n\n    # cw-dao expects its internal Cosmos messages to be passed as base64-encoded binary Anys.\n    # For simplicity we send the raw JSON (accepted by cosmjs), letting the chain pack it.\n    proposal_msg = {\n        \"propose\": {\n            \"title\": title,\n            \"description\": description,\n            \"msgs\": [\n                {\n                    \"stargate\": {\n                        \"type_url\": \"/neutron.cron.MsgAddSchedule\",\n                        \"value\": base64.b64encode(json.dumps(schedule_msg).encode()).decode()\n                    }\n                }\n            ],\n            \"latest\": None\n        }\n    }\n\n    return {\n        \"@type\": \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n        \"sender\": proposer_addr,\n        \"contract\": dao_contract,\n        \"msg\": base64.b64encode(json.dumps(proposal_msg).encode()).decode(),\n        \"funds\": []\n    }\n",
	"collectMigrateMessage": "export const collectMigrateMessage = () => {\n  let msgInput = window.prompt(\"Enter the migrate message in JSON (default {}):\", \"{}\");\n  if (!msgInput || msgInput.trim() === \"\") {\n    msgInput = \"{}\";\n  }\n  try {\n    const msg = JSON.parse(msgInput);\n    return msg;\n  } catch (err) {\n    throw new Error(\"Invalid JSON supplied for migrate message.\");\n  }\n};",
	"constructMigrateTx": "export const constructMigrateTx = async ({\n  rpcEndpoint,\n  signer,\n  senderAddress,\n  contractAddress,\n  newCodeId,\n  migrateMsg,\n  gasPrice = \"0.025untrn\",\n  gasLimit = 300000,\n}) => {\n  try {\n    const client = await SigningCosmWasmClient.connectWithSigner(rpcEndpoint, signer, {\n      gasPrice: GasPrice.fromString(gasPrice),\n    });\n\n    const msg = {\n      typeUrl: \"/cosmwasm.wasm.v1.MsgMigrateContract\",\n      value: {\n        sender: senderAddress,\n        contract: contractAddress,\n        codeId: Long.fromNumber(newCodeId),\n        msg: toUtf8(JSON.stringify(migrateMsg)),\n      },\n    };\n\n    const fee = calculateFee(gasLimit, gasPrice);\n\n    return { client, msg, fee };\n  } catch (error) {\n    console.error(error);\n    throw new Error(\"Failed to construct migrate transaction.\");\n  }\n};",
	"count_array_elements": "def count_array_elements(items: list) -> int:\n    \"\"\"Safely count array length with a sanity check.\"\"\"\n    if items is None:\n        raise ValueError(\"Input is None – expected a list.\")\n    if not isinstance(items, list):\n        raise TypeError(f\"Expected list, got {type(items)}\")\n    return len(items)",
	"display_result": "def display_result(count: int) -> None:\n    \"\"\"Print the final schedule count in the required format.\"\"\"\n    if count < 0:\n        raise ValueError(\"Count cannot be negative.\")\n    print(f\"Active schedules: {count}\")",
	"constructWasmExecuteMsg": "export const constructWasmExecuteMsg = () => {\n  // According to the NeutronTemplate contract schema, this message increments a global counter\n  return {\n    increment_global: {}\n  };\n};",
	"getBTCWalletAddress": "export const getBTCWalletAddress = async () => {\n  // Attempt to connect to Unisat (or any extension that injects `window.unisat`)\n  if (window.unisat && typeof window.unisat.requestAccounts === 'function') {\n    try {\n      const accounts = await window.unisat.requestAccounts();\n      if (accounts && accounts.length > 0) {\n        return accounts[0];\n      }\n    } catch (err) {\n      console.error('Failed to fetch address from Unisat:', err);\n    }\n  }\n\n  // Fallback: ask user to type it in\n  const address = prompt('Please enter the Bitcoin address that will fund 1 BTC:');\n  if (!address || address.trim() === '') {\n    throw new Error('A valid Bitcoin address is required.');\n  }\n  return address.trim();\n};",
	"generate_deposit_address": "def generate_deposit_address(payload: dict):\n    \"\"\"\n    Obtain a unique solvBTC deposit address bound to the user’s EVM address.\n    \"\"\"\n    evm_address = payload.get('evm_address')\n    if not evm_address:\n        raise HTTPException(status_code=400, detail='`evm_address` field is required.')\n\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.post(f'{SOLV_GATEWAY_URL}/deposit-address', json={'evm_address': evm_address})\n            resp.raise_for_status()\n            data = resp.json()\n            return {'deposit_address': data['deposit_address']}\n        except httpx.HTTPError as exc:\n            raise HTTPException(status_code=502, detail=f'SolvBTC gateway error: {exc}')",
	"fee_positive": "def fee_positive(cls, v):\n        if v <= 0:\n            raise ValueError('fee_sat_per_byte must be positive')\n        return v\n\n@router.post('/api/btc/construct-tx')\ndef construct_and_sign_btc_tx(payload: ConstructTxPayload):\n    \"\"\"\n    Build & sign a Bitcoin transaction for 1 BTC (100 000 000 sats). Returns raw hex.\n    WARNING: The WIF is sensitive; keep this endpoint protected.\n    \"\"\"\n    try:\n        pk = PrivateKey(payload.wif)\n        outputs = [(payload.destination, Decimal('1'), 'btc')]  # 1 BTC exactly\n        raw_tx_hex = pk.create_transaction(outputs, fee=payload.fee_sat_per_byte)\n        return {'raw_tx_hex': raw_tx_hex}\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=str(exc))",
	"broadcast_btc_tx": "def broadcast_btc_tx(payload: dict):\n    \"\"\"Broadcast raw BTC TX and return the resulting txid.\"\"\"\n    raw_tx_hex = payload.get('raw_tx_hex')\n    if not raw_tx_hex:\n        raise HTTPException(status_code=400, detail='raw_tx_hex is required.')\n\n    try:\n        async with httpx.AsyncClient() as client:\n            resp = await client.post('https://blockstream.info/api/tx', content=raw_tx_hex)\n            resp.raise_for_status()\n            txid = resp.text.strip()\n            return {'txid': txid}\n    except httpx.HTTPError as exc:\n        raise HTTPException(status_code=502, detail=f'Broadcast error: {exc}')",
	"attest_and_mint": "def attest_and_mint(payload: dict):\n    btc_txid = payload.get('btc_txid')\n    btc_destination = payload.get('btc_destination')\n    evm_address = payload.get('evm_address')\n    if not all([btc_txid, btc_destination, evm_address]):\n        raise HTTPException(status_code=400, detail='btc_txid, btc_destination, and evm_address are required.')\n\n    try:\n        w3 = Web3(Web3.HTTPProvider(ETH_RPC_URL))\n        acct = w3.eth.account.from_key(BACKEND_PRIVATE_KEY)\n        contract = w3.eth.contract(address=Web3.to_checksum_address(MINT_CONTRACT_ADDRESS), abi=MINT_ABI)\n        tx = contract.functions.mint(btc_txid, btc_destination, evm_address).build_transaction({\n            'from': acct.address,\n            'nonce': w3.eth.get_transaction_count(acct.address),\n            'gas': 500000,\n            'gasPrice': w3.to_wei('30', 'gwei'),\n        })\n        signed_tx = acct.sign_transaction(tx)\n        tx_hash = w3.eth.send_raw_transaction(signed_tx.rawTransaction)\n        return {'eth_tx_hash': tx_hash.hex()}\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=str(exc))",
	"bridge_to_neutron": "def bridge_to_neutron(payload: dict):\n    evm_tx_hash = payload.get('eth_tx_hash')\n    neutron_address = payload.get('neutron_address')\n    amount_wei = payload.get('amount_wei', '1000000000000000000')  # 1 solvBTC (18 decimals)\n    if not all([evm_tx_hash, neutron_address]):\n        raise HTTPException(status_code=400, detail='eth_tx_hash and neutron_address are required.')\n\n    request_body = {\n        'source_chain': 'Ethereum',\n        'destination_chain': 'Neutron',\n        'asset': 'solvBTC',\n        'amount': amount_wei,\n        'destination_address': neutron_address,\n        'deposit_tx_hash': evm_tx_hash,\n    }\n\n    async with httpx.AsyncClient() as client:\n        try:\n            resp = await client.post(f'{AXELAR_GATEWAY_URL}/transfer', json=request_body)\n            resp.raise_for_status()\n            data = resp.json()\n            return {'axelar_tx_hash': data['tx_hash']}\n        except httpx.HTTPError as exc:\n            raise HTTPException(status_code=502, detail=f'Axelar error: {exc}')",
	"instantiate_contract": "def instantiate_contract(client: LedgerClient, tx: Transaction):\n    resp = sign_and_broadcast_tx(client, tx)\n    print(\"✓ Contract instantiated\")\n    return resp\n",
	"query_amber_contract_positions": "def query_amber_contract_positions(address: str):\n    \"\"\"Return all Amber positions owned by the given wallet address.\"\"\"\n    # Build the smart-query `{ \"positions\": { \"owner\": <address> } }`\n    query_object = {\"positions\": {\"owner\": address}}\n    query_b64    = base64.b64encode(json.dumps(query_object).encode()).decode()\n\n    url = f\"{LCD_ENDPOINT}/cosmwasm/wasm/v1/contract/{AMBER_CONTRACT}/smart/{query_b64}\"\n\n    async with httpx.AsyncClient() as client:\n        resp = await client.get(url, timeout=10)\n\n    if resp.status_code != 200:\n        raise HTTPException(status_code=resp.status_code, detail=resp.text)\n\n    return resp.json()  # Forward Amber’s JSON response verbatim",
	"construct_tx_amber_emergency_withdraw": "def construct_tx_amber_emergency_withdraw(payload: dict):\n    \"\"\"\n    Body example:\n    {\n      \"sender\": \"neutron1...\",\n      \"position_id\": 42\n    }\n    \"\"\"\n    sender      = payload.get(\"sender\")\n    position_id = payload.get(\"position_id\")\n    if sender is None or position_id is None:\n        raise HTTPException(status_code=400, detail=\"'sender' and 'position_id' are required\")\n\n    # 1. Build MsgExecuteContract\n    msg = wasm_tx.MsgExecuteContract(\n        sender   = sender,\n        contract = AMBER_CONTRACT,\n        msg      = json.dumps({\"emergency_withdraw\": {\"position_id\": int(position_id)}}).encode(),\n        funds    = []  # No funds required\n    )\n\n    # 2. Ask the LCD for account_number / sequence\n    account_info = lcd.auth.account_info(Address(sender))\n    account_number = int(account_info.base_account.account_number)\n    sequence       = int(account_info.base_account.sequence)\n\n    # 3. Build the unsigned Tx\n    tx = Transaction()\n    tx.add_message(msg)\n    tx.seal(\n        gas_limit = FEE_GAS,\n        fee_denom = FEE_DENOM,\n        fee_amount = FEE_AMOUNT,\n        memo = \"Amber emergency withdraw\"\n    )\n\n    # 4. Encode SignDoc fields for Keplr\n    sign_doc = tx.get_sign_doc(chain_id=CHAIN_ID, account_number=account_number, sequence=sequence)\n\n    response = {\n        \"bodyBytes\":      base64.b64encode(sign_doc.body_bytes).decode(),\n        \"authInfoBytes\":  base64.b64encode(sign_doc.auth_info_bytes).decode(),\n        \"chainId\":        CHAIN_ID,\n        \"accountNumber\":  str(account_number)\n    }\n\n    # Return everything the frontend needs to call `keplr.signDirect`\n    return response",
	"signAndBroadcastEmergencyWithdraw": "export const signAndBroadcastEmergencyWithdraw = async (signDocFromBackend, chainId = 'neutron-1') => {\n  const { keplr } = window;\n  if (!keplr) throw new Error('Keplr extension not available.');\n\n  // Decode base64-encoded fields returned by the backend\n  const toUint8Array = (b64) => Uint8Array.from(atob(b64), c => c.charCodeAt(0));\n\n  const signDoc = {\n    bodyBytes:     toUint8Array(signDocFromBackend.bodyBytes),\n    authInfoBytes: toUint8Array(signDocFromBackend.authInfoBytes),\n    chainId:       signDocFromBackend.chainId,\n    accountNumber: Number(signDocFromBackend.accountNumber)\n  };\n\n  // Fetch the signer address again (defensive)\n  const offlineSigner = keplr.getOfflineSigner(chainId);\n  const [account]     = await offlineSigner.getAccounts();\n\n  // 1. Sign the proto‐SignDoc (DIRECT mode)\n  const { signature } = await keplr.signDirect(chainId, account.address, signDoc);\n\n  // 2. POST the signed doc + signature back to the backend for final assembly & broadcast\n  const res = await fetch('/api/tx/broadcast', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      bodyBytes:     signDocFromBackend.bodyBytes,\n      authInfoBytes: signDocFromBackend.authInfoBytes,\n      signature:     Buffer.from(signature.signature, 'base64').toString('base64')\n    })\n  });\n\n  if (!res.ok) {\n    const text = await res.text();\n    throw new Error(`Broadcast failed: ${text}`);\n  }\n\n  const { txhash } = await res.json();\n  return txhash;\n};",
	"hasMinBalance": "export const hasMinBalance = async (address, minAmount = 500000000) => {\n  const REST_ENDPOINT = 'https://rest-kralum.neutron.org';\n  const url = `${REST_ENDPOINT}/cosmos/bank/v1beta1/balances/${address}`;\n\n  const response = await fetch(url);\n  if (!response.ok) {\n    throw new Error(`LCD error: ${response.status} ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  const balanceEntry = data.balances?.find((b) => b.denom === 'untrn');\n  const balance = balanceEntry ? parseInt(balanceEntry.amount, 10) : 0;\n  return balance >= minAmount;\n};",
	"constructBoostLockMsg": "export const constructBoostLockMsg = (amount = '500000000', durationMonths = 24) => {\n  const msg = {\n    lock: {\n      amount,\n      duration: `${durationMonths}_months`,\n    },\n  };\n  return msg;\n};\n\nexport const encodeMsgForContract = (msg) => window.btoa(JSON.stringify(msg));",
	"_build_execute_msg": "def _build_execute_msg(sender: str, amount: str) -> MsgExecuteContract:\n    return MsgExecuteContract(\n        sender=sender,\n        contract=BOOST_CONTRACT_ADDRESS,\n        msg=json.dumps({\n            'lock': {\n                'amount': amount,\n                'duration': '24_months'\n            }\n        }).encode(),\n        funds=[{'amount': amount, 'denom': 'untrn'}]\n    )\n\n\n@app.post('/api/boost/lock')\nasync def sign_and_broadcast(payload: dict = Body(...)):\n    \"\"\"Signs & broadcasts the Boost lock transaction and returns `tx_hash`.\"\"\"\n    sender = payload.get('sender')\n    amount = payload.get('amount', '500000000')\n\n    if not sender:\n        raise HTTPException(status_code=400, detail='sender field is required')\n\n    mnemonic = os.getenv('NEUTRON_MNEMONIC')\n    if not mnemonic:\n        raise HTTPException(status_code=500, detail='Server wallet not configured')\n\n    key = PrivateKey.from_mnemonic(mnemonic)\n    if key.address() != sender:\n        raise HTTPException(status_code=400, detail='Sender must match backend wallet address.')\n\n    client = LedgerClient(NetworkConfig(chain_id=CHAIN_ID, url=RPC_ENDPOINT))\n\n    # Compose transaction\n    tx = Transaction()\n    tx.add_message(_build_execute_msg(sender, amount))\n    tx.with_gas(300000)  # gas limit estimate – adjust as needed\n    tx.with_chain_id(CHAIN_ID)\n\n    try:\n        signed_tx = tx.build_and_sign(key)\n        tx_response = client.send_tx_block_mode(signed_tx)\n        return {'tx_hash': tx_response.tx_hash}\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"tx_status": "def tx_status(tx_hash: str):\n    client = LedgerClient(NetworkConfig(chain_id=CHAIN_ID, url=RPC_ENDPOINT))\n    try:\n        tx_response = client.query_tx(tx_hash)\n        if not tx_response:\n            return { 'status': 'PENDING' }\n        return { 'status': 'COMMITTED', 'height': tx_response.height }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"queryBoostPosition": "export const queryBoostPosition = async (address) => {\n  const BOOST_CONTRACT_ADDRESS = 'neutron1boostcontractaddress…'; // TODO: replace\n  const REST_ENDPOINT = 'https://rest-kralum.neutron.org';\n\n  const queryMsg = { position: { address } };\n  const encoded = window.btoa(JSON.stringify(queryMsg));\n  const url = `${REST_ENDPOINT}/cosmwasm/wasm/v1/contract/${BOOST_CONTRACT_ADDRESS}/smart/${encoded}`;\n\n  const res = await fetch(url);\n  if (!res.ok) {\n    throw new Error(`Contract query failed: ${res.status}`);\n  }\n  const data = await res.json();\n  return data.data; // The exact schema depends on the contract implementation\n};",
	"checkTokenBalance": "export const checkTokenBalance = async (address) => {\n  try {\n    // TODO: replace with the real uniBTC CW20 contract address\n    const cw20Contract = 'neutron1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx';\n    const restEndpoint = 'https://rest-kralum.neutron.org';\n\n    // Build the CW20 balance query and base64-encode it for the REST endpoint\n    const query = { balance: { address } };\n    const encodedQuery = btoa(JSON.stringify(query));\n\n    const url = `${restEndpoint}/cosmwasm/wasm/v1/contract/${cw20Contract}/smart/${encodedQuery}`;\n    const res = await fetch(url);\n\n    if (!res.ok) {\n      throw new Error(`REST API returned ${res.status}`);\n    }\n\n    const json = await res.json();\n    const microAmount = BigInt(json?.data?.balance || 0n);\n\n    // Assume uniBTC uses 6 decimals on Neutron\n    const displayAmount = Number(microAmount) / 1_000_000;\n\n    return {\n      ok: displayAmount >= 2,\n      amount: displayAmount\n    };\n  } catch (err) {\n    console.error('Balance check failed', err);\n    throw err;\n  }\n};",
	"broadcast_approve": "def broadcast_approve(body: BroadcastBody):\n    try:\n        wallet = PrivateKey.from_mnemonic(body.mnemonic)\n        sender = wallet.public_key.address()\n\n        tx = Transaction()\n        tx.add_message(body.msg)            # Convert dict→proto inside cosmpy in real code\n\n        client = LedgerClient(NETWORK)\n        tx.with_sequence(client.get_sequence(sender))\n        tx.with_account_number(client.get_number(sender))\n        tx.with_chain_id(NETWORK.chain_id)\n        tx.sign(wallet)\n\n        result = client.broadcast_tx(tx)\n        return result                      # JSON tx response\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"construct_lend": "def construct_lend(body: LendBody):\n    try:\n        # Optional inner payload for the lending pool (often empty)\n        inner_msg = {}\n\n        wrapped_send = {\n            'send': {\n                'contract': body.amber_pool,\n                'amount': str(body.amount),\n                'msg': b64encode(json.dumps(inner_msg).encode()).decode()\n            }\n        }\n\n        encoded = b64encode(json.dumps(wrapped_send).encode()).decode()\n        exec_msg = {\n            'type_url': '/cosmwasm.wasm.v1.MsgExecuteContract',\n            'value': {\n                'sender': body.sender,\n                'contract': body.cw20_contract,\n                'msg': encoded,\n                'funds': []\n            }\n        }\n\n        return { 'msg': exec_msg }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"broadcast_lend": "def broadcast_lend(body: LendBroadcastBody):\n    try:\n        wallet = PrivateKey.from_mnemonic(body.mnemonic)\n        sender = wallet.public_key.address()\n        client = LedgerClient(NETWORK)\n\n        tx = Transaction()\n        tx.add_message(body.msg)\n        tx.with_sequence(client.get_sequence(sender))\n        tx.with_account_number(client.get_number(sender))\n        tx.with_chain_id(NETWORK.chain_id)\n        tx.sign(wallet)\n\n        return client.broadcast_tx(tx)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"lock_status": "def lock_status(address: str, lock_id: int) -> Dict:\n    \"\"\"Return the lock information for <address, lock_id>. Raises 400 if lock not found.\"\"\"\n    try:\n        # Build CosmWasm smart-query\n        query_msg = {\n            \"lock\": {\n                \"address\": address,\n                \"lock_id\": lock_id\n            }\n        }\n        query_b64 = base64.b64encode(json.dumps(query_msg).encode()).decode()\n        url = f\"{LCD_ENDPOINT}/wasm/v1/contract/{LOCK_CONTRACT_ADDR}/smart/{query_b64}\"\n\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n        if resp.status_code != 200:\n            raise HTTPException(status_code=resp.status_code, detail=resp.text)\n\n        data = resp.json()\n        # Adjust the JSON path depending on contract schema\n        lock_info = data.get(\"data\") or data  # fallback\n\n        if not lock_info:\n            raise HTTPException(status_code=404, detail=\"Lock not found\")\n\n        if not lock_info.get(\"unlockable\", False):\n            return {\"eligible\": False, \"reason\": \"Lock period not finished\"}\n\n        return {\n            \"eligible\": True,\n            \"lock_info\": lock_info\n        }\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"constructUnlockTx": "export const constructUnlockTx = async ({\n  chainId = 'neutron-1',\n  senderAddress,\n  contractAddress,\n  lockId,\n  fee = {\n    amount: [{ amount: '6000', denom: 'untrn' }],\n    gas: '300000'\n  },\n  memo = ''\n}) => {\n  // Cosmos SDK Tx requires accountNumber & sequence → fetch from LCD\n  const LCD_URL = 'https://rest-kralum.neutron-1.neutron.org';\n  const accountRes = await fetch(\n    `${LCD_URL}/cosmos/auth/v1beta1/accounts/${senderAddress}`\n  ).then((r) => r.json());\n\n  const baseAccount =\n    accountRes.account.base_account || accountRes.account; // handles vesting / eth-addr\n\n  const accountNumber = String(baseAccount.account_number);\n  const sequence = String(baseAccount.sequence);\n\n  // MsgExecuteContract to cancel the lock\n  const msg = {\n    type: 'wasm/MsgExecuteContract',\n    value: {\n      sender: senderAddress,\n      contract: contractAddress,\n      msg: {\n        cancel_lock: { lock_id: lockId }\n      },\n      funds: []\n    }\n  };\n\n  // Build the amino-compatible StdSignDoc\n  const signDoc = {\n    chain_id: chainId,\n    account_number: accountNumber,\n    sequence: sequence,\n    fee,\n    msgs: [msg],\n    memo\n  };\n\n  return {\n    signDoc,\n    msg,\n    fee,\n    memo\n  };\n};",
	"validateTokenBalance": "export const validateTokenBalance = async (\n  address,\n  {\n    min = BigInt(1_000000), // 1.0 maxBTC in micro-denom units (example: 1e6)\n    denom = 'amaxbtc',      // replace with the exact on-chain denom for maxBTC\n    restEndpoint = 'https://rest-kralum.neutron.org' // example REST endpoint\n  } = {}\n) => {\n  try {\n    const url = `${restEndpoint}/cosmos/bank/v1beta1/balances/${address}/${denom}`;\n    const res = await fetch(url);\n    if (!res.ok) throw new Error(`LCD error: ${res.status}`);\n\n    const { balance } = await res.json();\n    const amount = BigInt(balance?.amount || 0);\n\n    if (amount < min) {\n      throw new Error(`Insufficient balance: need ≥ ${min} ${denom}, have ${amount}`);\n    }\n    return { ok: true, amount };\n  } catch (err) {\n    console.error(err);\n    return { ok: false, reason: err.message };\n  }\n};",
	"queryAmberMarketParameters": "export const queryAmberMarketParameters = async (\n  {\n    contract = 'neutron1ambercontractaddressxxxxxxxxxxxx', // Amber contract address\n    restEndpoint = 'https://rest-kralum.neutron.org'\n  } = {}\n) => {\n  // The Amber contract is assumed to expose `{ \"config\": {} }` or similar.\n  const query = { market_params: {} };\n  const encoded = btoa(JSON.stringify(query));\n  const url = `${restEndpoint}/cosmwasm/wasm/v1/contract/${contract}/smart/${encoded}`;\n\n  const res = await fetch(url);\n  if (!res.ok) throw new Error(`Amber query failed: ${res.status}`);\n\n  return await res.json(); // → { data: { max_leverage: '6', collateral_factor: '0.8', ... } }\n};",
	"constructOpenLeverageMsg": "export const constructOpenLeverageMsg = (\n  {\n    sender,\n    collateralAmount = '1000000',           // 1.0 maxBTC in micro-units\n    collateralDenom = 'amaxbtc',            // actual on-chain denom\n    leverage = '5',\n    contract = 'neutron1ambercontractaddressxxxxxxxxxxxx'\n  }\n) => {\n  if (!sender) throw new Error('`sender` (wallet address) is required');\n\n  // Amber-specific execute message\n  const executeMsg = {\n    open_position: {\n      collateral: {\n        denom: collateralDenom,\n        amount: collateralAmount\n      },\n      leverage\n    }\n  };\n\n  // Standard CosmWasm MsgExecuteContract to be signed later\n  return {\n    typeUrl: '/cosmwasm.wasm.v1.MsgExecuteContract',\n    value: {\n      sender,\n      contract,\n      msg: new TextEncoder().encode(JSON.stringify(executeMsg)),\n      funds: [{ denom: collateralDenom, amount: collateralAmount }]\n    }\n  };\n};",
	"open_position": "def open_position(req: OpenPositionRequest):\n    try:\n        # 1. Build client & wallet\n        net_cfg = NetworkConfig(\n            chain_id=CHAIN_ID,\n            url=RPC_ENDPOINT,\n            fee_minimum_gas_price=req.gas_price,\n            fee_denomination='untrn'\n        )\n        client = LedgerClient(net_cfg)\n        wallet = Wallet(req.mnemonic)\n\n        # 2. Craft the transaction\n        tx = (\n            Transaction()\n            .with_messages(req.open_position_msg)\n            .with_sequence(client.query_account_sequence(wallet.address()))\n            .with_account_num(client.query_account_number(wallet.address()))\n            .with_gas(req.gas_limit)\n            .with_chain_id(net_cfg.chain_id)\n        )\n\n        # 3. Sign & broadcast\n        signed_tx = wallet.sign(tx)\n        tx_response = client.broadcast_tx_block(signed_tx)\n\n        if tx_response.is_error:\n            raise HTTPException(400, f'Broadcast failed: {tx_response.log}')\n        return {\"tx_hash\": tx_response.tx_hash, \"height\": tx_response.height}\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"queryPositionStatus": "export const queryPositionStatus = async (\n  {\n    owner,\n    contract = 'neutron1ambercontractaddressxxxxxxxxxxxx',\n    restEndpoint = 'https://rest-kralum.neutron.org',\n    retries = 10,\n    delayMs = 3000\n  }\n) => {\n  if (!owner) throw new Error('Owner address is required');\n\n  const query = { positions_by_owner: { owner } };\n  const encoded = btoa(JSON.stringify(query));\n  const url = `${restEndpoint}/cosmwasm/wasm/v1/contract/${contract}/smart/${encoded}`;\n\n  for (let i = 0; i < retries; i++) {\n    const res = await fetch(url);\n    if (res.ok) {\n      const data = await res.json();\n      if (data?.data?.positions?.length) {\n        return data.data.positions[0]; // Return the first position found\n      }\n    }\n    await new Promise(r => setTimeout(r, delayMs));\n  }\n  throw new Error('Position not found within timeout window');\n};",
	"queryVaultConfig": "export const queryVaultConfig = async (vaultAddress, lcdUrl = \"https://rest.neutron-1.neutron.org\") => {\n  /**\n   * Helper to base64-encode the JSON query in both browser and Node environments.\n   */\n  const base64Encode = (obj) => {\n    const jsonStr = JSON.stringify(obj);\n    if (typeof window !== \"undefined\" && window.btoa) {\n      return window.btoa(jsonStr);\n    }\n    return Buffer.from(jsonStr).toString(\"base64\");\n  };\n\n  try {\n    const queryMsg = { config: {} };        // ← { \"config\": {} }\n    const encoded = base64Encode(queryMsg); // base64\n\n    const endpoint = `${lcdUrl}/cosmwasm/wasm/v1/contract/${vaultAddress}/smart/${encoded}`;\n    const res = await fetch(endpoint);\n\n    if (!res.ok) {\n      throw new Error(`Contract query failed: ${res.status} ${res.statusText}`);\n    }\n\n    // Depending on LCD version the JSON key can be `data` or `result`.\n    const json = await res.json();\n    const config = json.data ?? json.result ?? json;\n\n    return config; // returns the full config object\n  } catch (err) {\n    console.error(\"[queryVaultConfig]\", err);\n    throw err;\n  }\n};",
	"parseRewardPolicy": "export const parseRewardPolicy = (config) => {\n  if (!config || typeof config !== \"object\") {\n    throw new Error(\"Invalid or empty config object supplied.\");\n  }\n\n  const forfeitableRewards = config.forfeitable_rewards ?? null;\n  const earlyExitPenalty = config.early_exit_penalty ?? null;\n\n  return {\n    forfeitableRewards,\n    earlyExitPenalty,\n    // Convenience flag\n    isForfeitable: Boolean(forfeitableRewards) || Boolean(earlyExitPenalty)\n  };\n};",
	"displayRewardPolicy": "export const displayRewardPolicy = (policy, targetElementId = \"reward-policy\") => {\n  try {\n    const el = document.getElementById(targetElementId);\n\n    // Fallback if no DOM target is available\n    const output = (msg) => {\n      if (el) {\n        el.innerHTML = msg;\n      } else {\n        console.log(msg);\n      }\n    };\n\n    if (!policy || !policy.isForfeitable) {\n      output(\"No early withdrawal penalties. All rewards are fully claimable.\");\n      return;\n    }\n\n    let html = \"<h4>Early Withdrawal Policy</h4>\";\n\n    if (policy.earlyExitPenalty && typeof policy.earlyExitPenalty === \"object\") {\n      html += \"<ul>\";\n      for (const [period, penalty] of Object.entries(policy.earlyExitPenalty)) {\n        html += `<li>Within ${period}: ${penalty}% penalty</li>`;\n      }\n      html += \"</ul>\";\n    } else if (policy.forfeitableRewards !== null) {\n      html += `<p>${policy.forfeitableRewards}% of accumulated rewards are forfeited on early exit.</p>`;\n    }\n\n    output(html);\n  } catch (err) {\n    console.error(\"[displayRewardPolicy]\", err);\n  }\n};",
	"ensureWalletAndGetAddress": "export const ensureWalletAndGetAddress = async () => {\n  try {\n    const chainId = 'neutron-1';\n\n    // Basic Keplr presence check\n    if (!window.keplr) {\n      throw new Error('Keplr wallet is not installed. Please install it first.');\n    }\n\n    // Request connection to Neutron chain\n    await window.keplr.enable(chainId);\n\n    // Fetch the offline signer & accounts list\n    const offlineSigner = window.keplr.getOfflineSigner(chainId);\n    const accounts      = await offlineSigner.getAccounts();\n\n    if (!accounts || accounts.length === 0) {\n      throw new Error('No Neutron account found in Keplr.');\n    }\n\n    return accounts[0].address; // sender / depositor address\n  } catch (err) {\n    console.error('[ensureWalletAndGetAddress] →', err);\n    throw err;\n  }\n};",
	"checkEbtcBalance": "export const checkEbtcBalance = async (address, minAmountMicro = '3000000') => {\n  try {\n    // Public Neutron LCD endpoint (you may replace with your own)\n    const lcd = 'https://lcd-kralum.neutron-1.nomusa.xyz';\n\n    // eBTC IBC denom on Neutron (see docs/btc-summer/technical/reference)\n    const EBTC_DENOM = 'ibc/E2A000FD3EDD91C9429B473995CE2C7C555BCC8CFC1D0A3D02F514392B7A80E8';\n\n    const resp   = await fetch(`${lcd}/cosmos/bank/v1beta1/balances/${address}`);\n    if (!resp.ok) throw new Error(`LCD error ${resp.status}`);\n\n    const { balances } = await resp.json();\n    const coin = balances.find((c) => c.denom === EBTC_DENOM);\n    const amount = coin ? coin.amount : '0';\n\n    if (BigInt(amount) < BigInt(minAmountMicro)) {\n      throw new Error(`Insufficient eBTC balance. Need ≥ ${minAmountMicro}, have ${amount}`);\n    }\n\n    return {\n      ok: true,\n      amountMicro: amount\n    };\n  } catch (err) {\n    console.error('[checkEbtcBalance] →', err);\n    throw err;\n  }\n};",
	"get_vault": "def get_vault(asset: str):\n    asset = asset.lower()\n    if asset not in SUPERVAULTS:\n        raise HTTPException(status_code=404, detail=\"Unsupported asset\")\n    return SUPERVAULTS[asset]",
	"build_deposit_tx": "def build_deposit_tx(vault_addr: str, sender_addr: str, amount_micro: int = 3_000_000):\n    \"\"\"Create an unsigned Transaction object with a single CosmWasm execute msg.\"\"\"\n\n    # CosmWasm messages require base64-encoded JSON inside the high-level msg\n    msg_inner = base64.b64encode(json.dumps({\"deposit\": {}}).encode()).decode()\n\n    exec_msg = {\n        \"type\": \"wasm/MsgExecuteContract\",\n        \"value\": {\n            \"sender\":   sender_addr,\n            \"contract\": vault_addr,\n            \"msg\":       msg_inner,\n            \"funds\":     [{\"denom\": EBTC_DENOM, \"amount\": str(amount_micro)}]\n        }\n    }\n\n    tx = (\n        Transaction()\n        .with_messages(exec_msg)\n        .with_sequence(client.query_sequence(sender_addr))\n        .with_account_num(client.query_account_number(sender_addr))\n        .with_chain_id(NETWORK.chain_id)\n        .with_gas(300000)  # rough estimate; adjust as needed\n        .with_fee_denom(NETWORK.fee_denom)\n        .with_fee(7500)\n        .with_memo(\"eBTC → Supervault deposit\")\n        .with_timeout_height(client.query_height() + 50)  # ~5 min sooner than current block\n    )\n    return tx\n",
	"cw20_balance": "def cw20_balance(contract: str, addr: str) -> int:\n    \"\"\"Query CW20 balance via the contract's `balance` endpoint.\"\"\"\n    sc = SmartContract(contract, client)\n    try:\n        resp = sc.query({\"balance\": {\"address\": addr}})\n        return int(resp.get('balance', '0'))\n    except Exception:\n        # If the query fails treat balance as zero\n        return 0\n\n@app.get('/api/validate_balances', response_model=BalanceStatus)\nasync def validate_token_balances(address: str):\n    \"\"\"Checks that the user holds ≥1 WBTC and ≥1 LBTC.\"\"\"\n    try:\n        wbtc_bal = cw20_balance(WBTC_CONTRACT, address)\n        lbtc_bal = cw20_balance(LBTC_CONTRACT, address)\n        return BalanceStatus(\n            has_wbtc=wbtc_bal >= MICRO_FACTOR,\n            has_lbtc=lbtc_bal >= MICRO_FACTOR,\n        )\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=str(err))",
	"get_supervault_contract_address": "def get_supervault_contract_address():\n    \"\"\"Simple helper so the frontend can discover the Supervault contract.\"\"\"\n    return {\n        'supervault_address': os.getenv('SUPERVAULT_CONTRACT', 'neutron1supervaultxxxxxxxxxxxxxxxxxxxxxx')\n    }",
	"construct_tx_supervault_deposit": "def construct_tx_supervault_deposit(address: str):\n    \"\"\"Creates an unsigned deposit Tx and returns the raw bytes (base64).\"\"\"\n    try:\n        # Payload that the Supervault expects (often empty for simple deposits)\n        deposit_msg = {\"deposit\": {}}\n        deposit_payload_b64 = base64.b64encode(json.dumps(deposit_msg).encode()).decode()\n\n        def build_cw20_send(token_contract: str):\n            return {\n                \"typeUrl\": \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n                \"value\": {\n                    \"sender\": address,\n                    \"contract\": token_contract,\n                    \"msg\": base64.b64encode(json.dumps({\n                        \"send\": {\n                            \"contract\": SUPERVAULT_CONTRACT,\n                            \"amount\": str(MICRO_FACTOR),  # 1 token\n                            \"msg\": deposit_payload_b64\n                        }\n                    }).encode()).decode(),\n                    \"funds\": []\n                }\n            }\n\n        # Compose both messages\n        msgs = [build_cw20_send(WBTC_CONTRACT), build_cw20_send(LBTC_CONTRACT)]\n\n        tx = Transaction()\n        for m in msgs:\n            tx.add_message(m[\"value\"])\n\n        # Gas/fee estimates — tune to production needs\n        tx.set_fee(5000, \"untrn\")\n        tx.set_gas(400000)\n\n        unsigned_tx = tx.get_unsigned()\n        return {\"tx_bytes\": base64.b64encode(unsigned_tx.SerializeToString()).decode()}\n\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=str(err))",
	"fetchCurrentAdmin": "export const fetchCurrentAdmin = async (\n  contractAddress,\n  rpcEndpoint = \"https://rpc-kralum.neutron-1.neutron.org:443\"\n) => {\n  try {\n    const client = await CosmWasmClient.connect(rpcEndpoint);\n    const info = await client.getContract(contractAddress);\n    return info.admin || \"\"; // empty string means no admin set\n  } catch (error) {\n    console.error(\"[fetchCurrentAdmin]\", error);\n    throw new Error(\"Unable to fetch contract admin: \" + error.message);\n  }\n};",
	"validateNewAdminAddress": "export const validateNewAdminAddress = (address, prefix = \"neutron\") => {\n  try {\n    const { prefix: addrPrefix } = bech32.decode(address);\n    if (addrPrefix !== prefix) {\n      throw new Error(`Invalid prefix: expected '${prefix}', got '${addrPrefix}'`);\n    }\n    return true;\n  } catch (err) {\n    console.error(\"[validateNewAdminAddress]\", err);\n    throw new Error(\"Provided new admin address is not a valid Bech32 string.\");\n  }\n};",
	"buildUpdateAdminMsg": "export const buildUpdateAdminMsg = (sender, contract, newAdmin) => {\n  return {\n    typeUrl: \"/cosmwasm.wasm.v1.MsgUpdateAdmin\",\n    value: {\n      sender: sender,\n      newAdmin: newAdmin,\n      contract: contract\n    }\n  };\n};",
	"signAndBroadcastUpdateAdminMsg": "export const signAndBroadcastUpdateAdminMsg = async (\n  signer,\n  sender,\n  msg,\n  rpcEndpoint = \"https://rpc-kralum.neutron-1.neutron.org:443\",\n  memo = \"\"\n) => {\n  try {\n    const gasPrice = GasPrice.fromString(\"0.05untrn\");\n    const client = await SigningCosmWasmClient.connectWithSigner(\n      rpcEndpoint,\n      signer,\n      { gasPrice }\n    );\n\n    // Estimate gas or set a flat fee\n    const fee = {\n      amount: coins(0, \"untrn\"), // 0-fee, gasPrice will calculate final fee\n      gas: \"250000\"               // adjust based on contract complexity\n    };\n\n    const result = await client.signAndBroadcast(sender, [msg], fee, memo);\n    if (result.code !== 0) {\n      throw new Error(`Broadcast failed with code ${result.code}: ${result.rawLog}`);\n    }\n    return result;\n  } catch (error) {\n    console.error(\"[signAndBroadcastUpdateAdminMsg]\", error);\n    throw new Error(\"Transaction failed: \" + error.message);\n  }\n};",
	"get_supervault_share_balance": "def get_supervault_share_balance(address: str):\n    \"\"\"Return the amount of Supervault shares owned by `address`.\"\"\"\n    try:\n        if not SUPER_VAULT_CONTRACT:\n            raise ValueError('SUPER_VAULT_CONTRACT env var not set')\n\n        # Connect to public Neutron endpoints\n        client = LedgerClient(NETWORKS[CHAIN_ID])\n\n        # Contract-specific query (may differ in your implementation)\n        query_msg = {\n            'share': {\n                'owner': address,\n            }\n        }\n\n        result = client.query_contract_smart(SUPER_VAULT_CONTRACT, query_msg)\n        shares_raw = int(result.get('shares', '0'))\n        return {'shares': shares_raw}\n\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=str(exc))",
	"calculateSharesToWithdraw": "export const calculateSharesToWithdraw = (totalShares) => {\n  const numericShares = Number(totalShares);\n  if (!Number.isFinite(numericShares) || numericShares <= 0) {\n    throw new Error('Invalid share balance.');\n  }\n\n  // Use Math.floor to avoid fractional shares (contracts expect integers)\n  const sharesToWithdraw = Math.floor(numericShares * 0.10);\n  if (sharesToWithdraw === 0) {\n    throw new Error('Calculated shares_to_withdraw equals zero.');\n  }\n\n  return sharesToWithdraw;\n};",
	"prepare_withdraw": "def prepare_withdraw(req: PrepareWithdrawRequest):\n    \"\"\"Returns components required for a DIRECT-SIGN transaction.\"\"\"\n    try:\n        if not SUPER_VAULT_CONTRACT:\n            raise ValueError('SUPER_VAULT_CONTRACT env var not set')\n\n        ledger = LedgerClient(NETWORKS[CHAIN_ID])\n        acct = ledger.query_account(req.address)\n\n        # Contract-level execute message\n        execute_msg = {\n            'withdraw': {\n                'shares': str(req.shares_to_withdraw)\n            }\n        }\n\n        msg = MsgExecuteContract(\n            sender=req.address,\n            contract_address=SUPER_VAULT_CONTRACT,\n            msg=execute_msg,\n            funds=[],\n        )\n\n        tx = (\n            Transaction()\n            .with_messages(msg)\n            .with_sequence(acct.sequence)\n            .with_account_number(acct.account_number)\n            .with_chain_id(CHAIN_ID)\n            .with_gas(300000)\n            .with_fee('2000untrn')  # Adjust fee & gas to your needs\n        )\n\n        body_bytes, auth_info_bytes, _ = tx.to_sign_doc()\n\n        return PrepareWithdrawResponse(\n            body_bytes=base64.b64encode(body_bytes).decode(),\n            auth_info_bytes=base64.b64encode(auth_info_bytes).decode(),\n            account_number=acct.account_number,\n            chain_id=CHAIN_ID,\n        )\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=str(exc))",
	"signAndBroadcastWithdrawTx": "export const signAndBroadcastWithdrawTx = async ({ address, signPayload }) => {\n  const { body_bytes, auth_info_bytes, account_number, chain_id } = signPayload;\n\n  // Helper to convert base64 → Uint8Array\n  const toUint8Array = (b64) => Uint8Array.from(atob(b64), (c) => c.charCodeAt(0));\n\n  const signDoc = {\n    bodyBytes: toUint8Array(body_bytes),\n    authInfoBytes: toUint8Array(auth_info_bytes),\n    chainId: chain_id,\n    accountNumber: account_number,\n  };\n\n  // 1. Ask Keplr to sign the Tx\n  const { signature } = await window.keplr.signDirect(chain_id, address, signDoc);\n\n  // 2. Hand the signature back to the backend so it can assemble & broadcast\n  const res = await fetch('/api/supervault/broadcast-withdraw', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({\n      body_bytes: body_bytes,\n      auth_info_bytes: auth_info_bytes,\n      signature: signature.signature, // already base64\n    }),\n  });\n\n  const data = await res.json();\n  if (!res.ok) {\n    throw new Error(data.detail || 'Broadcast failed');\n  }\n\n  return data.txhash;\n};",
	"broadcast_withdraw": "def broadcast_withdraw(req: BroadcastWithdrawRequest):\n    \"\"\"Takes the signed tx fragments, creates TxRaw, broadcasts, and returns the tx-hash.\"\"\"\n    try:\n        body_bytes = base64.b64decode(req.body_bytes)\n        auth_info_bytes = base64.b64decode(req.auth_info_bytes)\n        signature = base64.b64decode(req.signature)\n\n        tx_raw = TxRaw(\n            body_bytes=body_bytes,\n            auth_info_bytes=auth_info_bytes,\n            signatures=[signature],\n        )\n\n        ledger = LedgerClient(NETWORKS[CHAIN_ID])\n        result = ledger.broadcast_tx(tx_raw.SerializeToString())\n\n        if result.code != 0:\n            raise ValueError(f'Tx failed with code {result.code}: {result.raw_log}')\n\n        return {'txhash': result.txhash}\n    except Exception as exc:\n        raise HTTPException(status_code=500, detail=str(exc))",
	"getSupervaultContractAddress": "export const getSupervaultContractAddress = () => {\n  // TODO: Replace the placeholder with the real Supervault address\n  const CONTRACT_ADDRESS = 'neutron1supervaultcontractaddressxxx';\n\n  if (!CONTRACT_ADDRESS || !CONTRACT_ADDRESS.startsWith('neutron')) {\n    throw new Error('Invalid or missing Supervault contract address configuration.');\n  }\n\n  return CONTRACT_ADDRESS;\n};",
	"supervault_positions": "def supervault_positions(req: PositionsRequest):\n    \"\"\"Query Supervault for user positions via WASM smart-contract call.\"\"\"\n    try:\n        # Public Neutron main-net endpoints (no secrets required)\n        cfg = NetworkConfig(\n            chain_id='neutron-1',\n            lcd_url='https://rest-kralum.neutron-1.neutron.org',\n            grpc_url='grpc://grpc-kralum.neutron-1.neutron.org:443'\n        )\n\n        client = LedgerClient(cfg)\n\n        query_msg = {\n            'positions_by_user': {\n                'address': req.user_address\n            }\n        }\n\n        # Perform the query against Supervault\n        positions = client.query_contract(\n            contract_address=req.contract_address,\n            query=query_msg\n        )\n\n        return {'positions': positions}\n\n    except Exception as e:\n        # Always wrap low-level errors so the frontend gets a clean message\n        raise HTTPException(status_code=500, detail=str(e))",
	"filterPositionsByCampaign": "export const filterPositionsByCampaign = (positions, campaignName = 'Bitcoin Summer') => {\n  if (!Array.isArray(positions)) {\n    throw new Error('Expected positions to be an array.');\n  }\n\n  return positions.filter((position) => {\n    const campaigns = position.eligible_campaigns || [];\n    return campaigns.includes(campaignName);\n  });\n};",
	"PositionsTable": "export const PositionsTable = ({ positions }) => {\n  if (!positions || positions.length === 0) {\n    return <p>No Bitcoin Summer positions found.</p>;\n  }\n\n  return (\n    <table style={{ width: '100%', borderCollapse: 'collapse' }}>\n      <thead>\n        <tr>\n          <th style={{ borderBottom: '1px solid #ccc' }}>Position ID</th>\n          <th style={{ borderBottom: '1px solid #ccc' }}>Deposit Amount</th>\n          <th style={{ borderBottom: '1px solid #ccc' }}>Rewards Status</th>\n        </tr>\n      </thead>\n      <tbody>\n        {positions.map((p) => (\n          <tr key={p.position_id}>\n            <td style={{ padding: '4px 8px' }}>{p.position_id}</td>\n            <td style={{ padding: '4px 8px' }}>{p.deposit_amount}</td>\n            <td style={{ padding: '4px 8px' }}>{p.rewards_status}</td>\n          </tr>\n        ))}\n      </tbody>\n    </table>\n  );\n};",
	"captureSliderInput": "export const captureSliderInput = (sliderElementId) => {\n  const slider = document.getElementById(sliderElementId);\n  if (!slider) {\n    throw new Error(`Slider element with id \"${sliderElementId}\" not found.`);\n  }\n\n  const months = parseInt(slider.value, 10);\n  if (Number.isNaN(months) || months <= 0) {\n    throw new Error(`Invalid slider value: ${slider.value}`);\n  }\n\n  return months;\n};",
	"calculateBoostMultiplier": "export const calculateBoostMultiplier = (months) => {\n  const MAX_MONTHS = 48;\n  const multiplier = 1 + months / MAX_MONTHS; // 48 months → 1 + 48/48 = 2.0×\n  return +multiplier.toFixed(2);\n};",
	"saveLockDurationPreference": "export const saveLockDurationPreference = (months) => {\n  try {\n    localStorage.setItem('preferredLockDurationMonths', months.toString());\n  } catch (err) {\n    // localStorage can throw (e.g., in private mode)\n    console.error('Failed to store lock duration preference', err);\n  }\n};",
	"displayMultiplierPreview": "export const displayMultiplierPreview = ({ months, multiplier, minLockBase = 100 }) => {\n  const previewEl = document.getElementById('multiplierPreview');\n  if (!previewEl) {\n    console.warn('Preview element #multiplierPreview not found in DOM.');\n    return;\n  }\n\n  // Example heuristic: scale the base amount linearly with months.\n  const minLockAmount = ((minLockBase * months) / 48).toFixed(2);\n  previewEl.textContent = `Boost: ${multiplier}×  |  Minimum lock: ${minLockAmount} NTRN`;\n};",
	"validateRecipientAddress": "export const validateRecipientAddress = (address, expectedPrefix = 'neutron') => {\n  try {\n    const decoded = Bech32.decode(address);\n    if (decoded.prefix !== expectedPrefix) {\n      throw new Error(`Invalid Bech32 prefix: expected ${expectedPrefix}, got ${decoded.prefix}`);\n    }\n    return true;\n  } catch (error) {\n    console.error('Address validation failed:', error);\n    throw new Error('Provided recipient address is invalid.');\n  }\n};",
	"constructTxBankSend": "export const constructTxBankSend = (sender, recipient, amountMicro, denom = 'untrn') => {\n  return {\n    typeUrl: '/cosmos.bank.v1beta1.MsgSend',\n    value: {\n      fromAddress: sender,\n      toAddress: recipient,\n      amount: [coin(amountMicro, denom)],\n    },\n  };\n};",
	"query_cron_list_schedules": "def query_cron_list_schedules(node_url: str = \"https://rest.kralum.neutron-1.neutron.org\") -> list:\n    \"\"\"Fetch the list of cron schedules from a Neutron REST endpoint.\n\n    Args:\n        node_url: Base URL of the Neutron REST API (without a trailing slash).\n\n    Returns:\n        A list of schedule objects returned by the chain.\n\n    Raises:\n        RuntimeError: If the request fails or the response cannot be parsed.\n    \"\"\"\n    # Ensure the base URL has no trailing slash to avoid errors when composing the endpoint.\n    base_url = node_url.rstrip(\"/\")\n    endpoint = f\"{base_url}/neutron/cron/schedules\"\n\n    try:\n        response = requests.get(endpoint, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f\"Failed to query cron schedules: {exc}\") from exc\n\n    try:\n        json_data = response.json()\n    except ValueError as exc:\n        raise RuntimeError(\"Received invalid JSON from the Neutron REST endpoint\") from exc\n\n    # The REST API generally returns `{ \\\"schedules\\\": [...] }`.\n    return json_data.get(\"schedules\", [])\n",
	"constructIncrementMsg": "export const constructIncrementMsg = () => {\n  // The NeutronTemplate contract expects an execute payload of the form:\n  // {\n  //   increment_personal: {}\n  // }\n  return {\n    increment_personal: {},\n  };\n};",
	"constructMsgRemoveSchedule": "export const constructMsgRemoveSchedule = (authority, name = \"daily_rewards\") => {\n  if (!authority) {\n    throw new Error(\"Authority (DAO address) is required\");\n  }\n\n  // EncodeObject compatible with CosmJS\n  return {\n    typeUrl: \"/neutron.cron.MsgRemoveSchedule\",\n    value: {\n      authority,\n      name,\n    },\n  };\n};",
	"wrapInDaoProposal": "export const wrapInDaoProposal = (\n  registry,\n  msgs,\n  proposalModuleAddress,\n  title = \"Remove daily cron schedule\",\n  description = \"This proposal removes the 'daily_rewards' cron schedule.\"\n) => {\n  if (!proposalModuleAddress) throw new Error(\"proposalModuleAddress is required\");\n  if (!msgs.length) throw new Error(\"At least one message must be supplied\");\n\n  // Convert each EncodeObject -> stargate format expected by cw-dao\n  const encodedMsgs = msgs.map((msg) => {\n    const binary = registry.encode(msg);\n    return {\n      stargate: {\n        type_url: msg.typeUrl,\n        value: Buffer.from(binary).toString(\"base64\"),\n      },\n    };\n  });\n\n  // cw-proposal-single JSON payload\n  const proposeMsg = {\n    propose: {\n      title,\n      description,\n      msgs: encodedMsgs,\n    },\n  };\n\n  // Wrap into MsgExecuteContract (CosmWasm)\n  return {\n    typeUrl: \"/cosmwasm.wasm.v1.MsgExecuteContract\",\n    value: {\n      sender: \"\",                // filled automatically just before signing\n      contract: proposalModuleAddress,\n      msg: toUtf8(JSON.stringify(proposeMsg)),\n      funds: [],\n    },\n  };\n};",
	"getCreatorAddress": "export const getCreatorAddress = async (chainId = 'neutron-1') => {\n  // Make sure the browser has access to the Keplr extension\n  const { keplr } = window;\n  if (!keplr) {\n    throw new Error('Keplr extension was not detected. Please install/enable Keplr.');\n  }\n\n  // Ask Keplr to enable the Neutron chain if it is not already enabled\n  await keplr.enable(chainId);\n\n  // Obtain the OfflineSigner, then the account list\n  const offlineSigner = keplr.getOfflineSigner(chainId);\n  const accounts = await offlineSigner.getAccounts();\n\n  if (!accounts || accounts.length === 0) {\n    throw new Error('No accounts found in the connected wallet.');\n  }\n\n  // The first account will be used as the creator address\n  return accounts[0].address;\n};",
	"validateCreatorAddress": "export const validateCreatorAddress = (address, expectedPrefix = 'neutron') => {\n  try {\n    // Decode the bech32 string; will throw if invalid\n    const { prefix } = Bech32.decode(address);\n\n    // Ensure the address uses the expected bech32 prefix (\"neutron\")\n    if (prefix !== expectedPrefix) {\n      throw new Error(`Invalid bech32 prefix: expected \\\"${expectedPrefix}\\\", got \\\"${prefix}\\\".`);\n    }\n\n    return true; // valid\n  } catch (err) {\n    throw new Error(`Invalid bech32 address: ${err.message}`);\n  }\n};",
	"connectWalletAndGetAddress": "export const connectWalletAndGetAddress = async () => {\n  const chainId = 'neutron-1';\n  const keplr = window.keplr;\n\n  if (!keplr) {\n    throw new Error('Keplr wallet is not installed.');\n  }\n\n  // Request wallet connection if it has not yet been approved\n  await keplr.enable(chainId);\n\n  // Get the offline-signer injected by Keplr\n  const signer = window.getOfflineSigner(chainId);\n  const accounts = await signer.getAccounts();\n\n  if (!accounts || accounts.length === 0) {\n    throw new Error('No account found in the wallet.');\n  }\n\n  return { signer, address: accounts[0].address };\n};",
	"check_balance": "def check_balance(address: str):\n    \"\"\"Return each balance and whether both are ≥ 1.\"\"\"\n    try:\n        payload = { 'balance': { 'address': address } }\n\n        maxbtc = int(client.wasm_contract_query(CW20_MAXBTC, payload)['balance'])\n        unibtc = int(client.wasm_contract_query(CW20_UNIBTC, payload)['balance'])\n        ok = maxbtc >= REQUIRED_AMOUNT and unibtc >= REQUIRED_AMOUNT\n\n        return BalanceResponse(maxbtc=maxbtc, unibtc=unibtc, eligible=ok)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f'Balance query failed: {e}')",
	"get_supervault_details": "def get_supervault_details():\n    try:\n        details = {\n            'supervault_address': os.getenv('MAXUNI_SUPERVAULT', 'neutron1supervaultxxxxxxxxxxxxxxxxxxxx'),\n            'assets': [\n                { 'symbol': 'maxBTC', 'cw20': os.getenv('CW20_MAXBTC', 'neutron1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx') },\n                { 'symbol': 'uniBTC', 'cw20': os.getenv('CW20_UNIBTC', 'neutron1yyyyyyyyyyyyyyyyyyyyyyyyyyyyyy') }\n            ]\n        }\n        return details\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
	"build_deposit": "def build_deposit(req: BuildDepositRequest):\n    try:\n        supervault = os.getenv('MAXUNI_SUPERVAULT', 'neutron1supervaultxxxxxxxxxxxxxxxxxxxx')\n\n        # ExecuteMsg expected by the Supervault contract\n        exec_msg = {\n            'deposit': {\n                'assets': [\n                    { 'token': os.getenv('CW20_MAXBTC', 'neutron1xxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'), 'amount': str(req.amount_maxbtc) },\n                    { 'token': os.getenv('CW20_UNIBTC', 'neutron1yyyyyyyyyyyyyyyyyyyyyyyyyyyyyy'), 'amount': str(req.amount_unibtc) }\n                ]\n            }\n        }\n\n        tx = Transaction()\n        tx.add_message(\n            MsgExecuteContract(\n                sender = req.sender,\n                contract = supervault,\n                msg = exec_msg,\n                funds = []  # CW20 -> no native funds\n            )\n        )\n        # Fee/memo left empty so they can be set at signing time\n        unsigned_bytes = tx.get_tx_bytes(sign=False)  # Do **not** sign here!\n        return BuildDepositResponse(tx_bytes=unsigned_bytes.hex(), body=tx.get_tx_json(sign=False))\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f'Failed to build deposit tx: {e}')",
	"broadcast": "def broadcast(req: BroadcastRequest):\n    try:\n        # ------------  Recover server key (DO NOT USE IN PRODUCTION)  ------------\n        mnemonic = os.getenv('SERVER_MNEMONIC')\n        if not mnemonic:\n            raise ValueError('SERVER_MNEMONIC is not set in the environment.')\n        wallet = PrivateKey.from_mnemonic(mnemonic)\n\n        # ------------  Re-hydrate tx and sign  ------------\n        tx = Transaction(tx_bytes=bytes.fromhex(req.tx_bytes))\n        tx.sign(wallet)\n        signed_bytes = tx.get_tx_bytes()\n\n        # ------------  Broadcast  ------------\n        result = client.broadcast_tx_block(signed_bytes)\n        return BroadcastResponse(tx_hash=result.tx_hash, height=result.height)\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f'Broadcast failed: {e}')",
	"WalletProvider: React.FC<React.PropsWithChildren>": "export const WalletProvider: React.FC<React.PropsWithChildren> = ({ children }) => (\n  <ChainProvider\n    chains={[neutronChain]}\n    assetLists={[]}\n    wallets={wallets}\n    walletConnectOptions={wcOptions}\n    walletConnect={walletconnect}\n    signerOptions={{\n      signingStargate: {\n        preferredSignType: 'direct',\n      },\n    }}\n  >\n    {children}\n  </ChainProvider>\n);",
	"walletConnectV2Config: WalletConnectOptions": "export const walletConnectV2Config: WalletConnectOptions = {\n  signClient: {\n    projectId: process.env.NEXT_PUBLIC_WC_PROJECT_ID || '',\n    relayUrl: 'wss://relay.walletconnect.com',\n    metadata: {\n      name: 'NeutronTemplate',\n      description: 'Neutron Template WalletConnect Integration',\n      url: 'https://your-dapp.com',\n      icons: ['https://your-dapp.com/icon.png'],\n    },\n  },\n  namespaces: {\n    cosmos: {\n      chains: ['cosmos:neutron-1'],\n      methods: [\n        'cosmos_getAccounts',\n        'cosmos_signDirect',\n        'cosmos_signAmino',\n        'cosmos_sendTransaction',\n      ],\n      events: ['chainChanged', 'accountsChanged'],\n    },\n  },\n};\n\n// Mobile wallet IDs recognised by Cosmos Kit\nexport const supportedMobileWallets = [\n  'keplr-mobile',\n  'leap-mobile',\n  'cosmostation-mobile',\n];\n\n// Helper that returns a ready-to-use mobile config bundle\nexport const getMobileWalletConfig = () => ({\n  walletConnectOptions: walletConnectV2Config,\n  wallets: supportedMobileWallets,\n});",
	"ConnectWalletButton: React.FC": "export const ConnectWalletButton: React.FC = () => {\n  const { connect, disconnect, status, address, viewWalletRepo } = useWallet();\n\n  const handleClick = async () => {\n    try {\n      if (status === WalletStatus.Connected) {\n        await disconnect();\n        return;\n      }\n\n      if (isMobile) {\n        // Mobile: open wallet list to launch deep-link\n        viewWalletRepo();\n      } else {\n        // Desktop: opens Cosmos Kit QR modal automatically\n        await connect();\n      }\n    } catch (err) {\n      console.error('Wallet connect error:', err);\n      alert(`Wallet connection failed: ${(err as Error).message}`);\n    }\n  };\n\n  return (\n    <button onClick={handleClick} className='px-4 py-2 rounded bg-indigo-600 text-white'>\n      {status === WalletStatus.Connected ? shorten(address) : 'Connect Wallet'}\n    </button>\n  );\n};",
	"usePersistWcSession": "export const usePersistWcSession = () => {\n  const { client, status } = useWallet();\n\n  // Save active session whenever it changes\n  useEffect(() => {\n    if (status === 'Connected' && client?.session) {\n      try {\n        localStorage.setItem(WC_SESSION_KEY, JSON.stringify(client.session));\n      } catch (err) {\n        console.warn('Unable to persist WalletConnect session', err);\n      }\n    }\n  }, [client, status]);\n\n  // Attempt to restore a previous session on first render\n  useEffect(() => {\n    const restore = async () => {\n      try {\n        const raw = localStorage.getItem(WC_SESSION_KEY);\n        if (raw && client?.restoreSession && status !== 'Connected') {\n          await client.restoreSession(JSON.parse(raw));\n        }\n      } catch (err) {\n        console.error('Failed to restore WalletConnect session', err);\n      }\n    };\n\n    restore();\n  }, [client]);\n};",
	"get_wasm_file_path": "def get_wasm_file_path(relative_path: str) -> Path:\n    path = Path(relative_path).expanduser().resolve()\n    if not path.is_file():\n        raise FileNotFoundError(f'WASM file not found at {path}')\n    return path",
	"construct_tx_store_code": "def construct_tx_store_code(wasm_path: Path, sender_address: str) -> Transaction:\n    wasm_bytes = wasm_path.read_bytes()\n\n    access_config = types_pb2.AccessConfig(\n        permission=types_pb2.AccessType.ACCESS_TYPE_EVERYBODY,\n        address=''  # empty when permission is Everybody\n    )\n\n    msg = wasm_tx_pb2.MsgStoreCode(\n        sender=sender_address,\n        wasm_byte_code=wasm_bytes,\n        instantiate_permission=access_config\n    )\n\n    tx = Transaction()\n    tx.add_message(msg)\n    # You can still tweak gas / fee before signing, e.g.:\n    # tx = tx.with_gas(1_500_000).with_fee('5000untrn')\n    return tx"
}