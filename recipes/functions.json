{
	"verify_docker_installed": "def verify_docker_installed() -> Dict[str, str]:\n    '''Verify that Docker is installed and the daemon is responding by running `docker version`.'''\n    try:\n        completed = subprocess.run(\n            ['docker', 'version'],\n            check=True,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n        )\n    except FileNotFoundError as exc:\n        raise RuntimeError(\n            'Docker is not installed or not available in PATH. '\n            'Install Docker Desktop (on macOS/Apple Silicon) or Docker Engine, then try again.'\n        ) from exc\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            'Docker is installed but the daemon may not be running or is misconfigured.\\n'\n            f'Stdout:\\n{exc.stdout}\\nStderr:\\n{exc.stderr}'\n        ) from exc\n\n    return {\n        'status': 'ok',\n        'message': 'Docker is installed and responding.',\n        'stdout': completed.stdout,\n    }\n",
	"verify_contract_builds_locally": "def verify_contract_builds_locally(project_root: str) -> Dict[str, Any]:\n    '''Run `cargo check` in the given project root to ensure the Rust contract compiles locally.'''\n    root = Path(project_root).expanduser().resolve()\n    cargo_toml = root / 'Cargo.toml'\n    if not cargo_toml.is_file():\n        raise FileNotFoundError(f'No Cargo.toml found in {root}; ensure project_root is the contract root directory.')\n\n    try:\n        completed = subprocess.run(\n            ['cargo', 'check'],\n            cwd=str(root),\n            check=True,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n        )\n    except FileNotFoundError as exc:\n        raise RuntimeError('Cargo is not installed or not available in PATH. Install Rust and Cargo from https://rustup.rs/.') from exc\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            'cargo check failed. Fix the compilation errors before running the optimizer.\\n'\n            f'Stdout:\\n{exc.stdout}\\nStderr:\\n{exc.stderr}'\n        ) from exc\n\n    return {\n        'status': 'ok',\n        'message': 'cargo check completed successfully.',\n        'stdout': completed.stdout,\n    }\n",
	"run_rust_optimizer_arm64": "def run_rust_optimizer_arm64(project_root: str, tag: str = 'latest') -> Dict[str, Any]:\n    '''Run the cosmwasm/rust-optimizer-arm64 Docker image against the given contract root directory.'''\n    root = Path(project_root).expanduser().resolve()\n    if not (root / 'Cargo.toml').is_file():\n        raise FileNotFoundError(f'No Cargo.toml found in {root}; ensure project_root is the contract root directory.')\n\n    cache_volume = f'{root.name}_cache'\n    image = f'cosmwasm/rust-optimizer-arm64:{tag}'\n\n    cmd = [\n        'docker', 'run', '--rm',\n        '-v', f'{root}:/code',\n        '--mount', f'type=volume,source={cache_volume},target=/code/target',\n        image,\n    ]\n\n    try:\n        completed = subprocess.run(\n            cmd,\n            check=True,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n        )\n    except FileNotFoundError as exc:\n        raise RuntimeError('Docker is not installed or not available in PATH. Install Docker and try again.') from exc\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            'rust-optimizer Docker run failed.\\n'\n            f'Stdout:\\n{exc.stdout}\\nStderr:\\n{exc.stderr}'\n        ) from exc\n\n    return {\n        'status': 'ok',\n        'message': f'Optimization completed using image {image}.',\n        'stdout': completed.stdout,\n    }\n",
	"collect_optimized_wasm_artifacts": "def collect_optimized_wasm_artifacts(project_root: str) -> List[str]:\n    '''List optimized .wasm files from the ./artifacts directory in the given project root.'''\n    root = Path(project_root).expanduser().resolve()\n    artifacts_dir = root / 'artifacts'\n\n    if not artifacts_dir.is_dir():\n        raise FileNotFoundError(f'Artifacts directory not found at {artifacts_dir}. Have you run the rust-optimizer?')\n\n    wasm_files = sorted(str(p) for p in artifacts_dir.glob('*.wasm'))\n    if not wasm_files:\n        raise RuntimeError(f'No .wasm files found in {artifacts_dir}. Ensure the optimizer completed successfully.')\n\n    return wasm_files\n",
	"": "\n",
	"compile_clock_example": "def compile_clock_example(contract_root: str = '.') -> str:\n    '''Run cosmwasm/rust-optimizer in Docker and return the artifact path.'''\n    root_path = Path(contract_root).resolve()\n    if not root_path.exists():\n        raise FileNotFoundError(f'Contract root directory not found: {root_path}')\n\n    artifacts_dir = root_path / 'artifacts'\n    artifacts_dir.mkdir(exist_ok=True)\n\n    cmd = [\n        'docker',\n        'run',\n        '--rm',\n        '-v',\n        f'{root_path}:/code',\n        '--mount',\n        'type=volume,source=clock_example_cache,target=/code/target',\n        'cosmwasm/rust-optimizer:0.12.11',\n    ]\n\n    try:\n        subprocess.run(\n            cmd,\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError as exc:\n        raise RuntimeError('Docker is not installed or not found in PATH.') from exc\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(f'cosmwasm/rust-optimizer failed: {exc.stderr}') from exc\n\n    wasm_path = artifacts_dir / 'clock_example.wasm'\n    if not wasm_path.exists():\n        raise FileNotFoundError(f'Expected artifact not found at {wasm_path}')\n\n    return str(wasm_path)\n",
	"load_wasm_artifact_bytes": "def load_wasm_artifact_bytes(wasm_path: str) -> bytes:\n    '''Load the compiled WASM artifact into memory and ensure it is non-empty.'''\n    path = Path(wasm_path)\n    if not path.is_file():\n        raise FileNotFoundError(f'WASM artifact not found at {path}')\n\n    size = path.stat().st_size\n    if size <= 0:\n        raise ValueError(f'WASM artifact at {path} is empty.')\n\n    with path.open('rb') as f:\n        data = f.read()\n\n    if not data:\n        raise ValueError('Failed to read WASM artifact or file is empty.')\n\n    return data\n",
	"fetch_minimum_gas_price": "def fetch_minimum_gas_price(base_url: str = LCD_BASE_URL) -> Tuple[Decimal, str]:\n    '''Fetch the node's minimum_gas_price and parse it into (amount, denom).'''\n    url = f'{base_url}/cosmos/base/node/v1beta1/config'\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to fetch node config from {url}: {exc}') from exc\n\n    data = resp.json()\n    mgp = data.get('minimum_gas_price')\n    if not mgp:\n        raise ValueError('minimum_gas_price not present in node config response.')\n\n    match = re.match(r'^([0-9.]+)([a-zA-Z/]+)$', mgp)\n    if not match:\n        raise ValueError(f'Unexpected minimum_gas_price format: {mgp}')\n\n    amount_str, denom = match.groups()\n    try:\n        amount = Decimal(amount_str)\n    except Exception as exc:\n        raise ValueError(f'Invalid gas price amount {amount_str!r}: {exc}') from exc\n\n    return amount, denom\n",
	"fetch_sender_account_state": "def fetch_sender_account_state(\n    address: str,\n    base_url: str = LCD_BASE_URL,\n    fee_denom: str = 'ujunox',\n    required_balance: Optional[Decimal] = None,\n) -> Dict[str, Any]:\n    '''Query account number, sequence, and spendable balance for the sender.'''\n    account_url = f'{base_url}/cosmos/auth/v1beta1/accounts/{address}'\n    balances_url = f'{base_url}/cosmos/bank/v1beta1/spendable_balances/{address}'\n\n    try:\n        acc_resp = requests.get(account_url, timeout=10)\n        acc_resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to fetch account data: {exc}') from exc\n\n    acc_data = acc_resp.json()\n    account_any = acc_data.get('account')\n    if not account_any or 'value' not in account_any:\n        raise ValueError('Account response missing account.value field.')\n\n    try:\n        raw = base64.b64decode(account_any['value'])\n        base_account = BaseAccount.FromString(raw)\n    except Exception as exc:\n        raise RuntimeError(f'Failed to decode BaseAccount protobuf: {exc}') from exc\n\n    account_number = int(base_account.account_number)\n    sequence = int(base_account.sequence)\n\n    try:\n        bal_resp = requests.get(balances_url, timeout=10)\n        bal_resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to fetch spendable balances: {exc}') from exc\n\n    bal_data = bal_resp.json()\n    balances = bal_data.get('balances', [])\n    spendable = Decimal(0)\n    for coin in balances:\n        if coin.get('denom') == fee_denom:\n            spendable = Decimal(coin.get('amount', '0'))\n            break\n\n    if required_balance is not None and spendable < required_balance:\n        raise ValueError(\n            f'Insufficient balance: have {spendable} {fee_denom}, '\n            f'required at least {required_balance}.'\n        )\n\n    return {\n        'account_number': account_number,\n        'sequence': sequence,\n        'balances': balances,\n        'fee_denom': fee_denom,\n        'spendable_for_fee': str(spendable),\n    }\n",
	"construct_msg_store_code_tx_for_simulation": "def construct_msg_store_code_tx_for_simulation(\n    sender: str,\n    wasm_bytes: bytes,\n    gas_price_amount: Decimal,\n    gas_price_denom: str,\n    initial_gas_limit: int = 2_000_000,\n    chain_id: str = 'uni-6',\n) -> Dict[str, Any]:\n    '''\n    Construct an unsigned MsgStoreCode transaction suitable for /cosmos/tx/v1beta1/simulate.\n    The chain_id is recorded for reference but is only required at signing time.\n    '''\n    msg = MsgStoreCode(\n        sender=sender,\n        wasm_byte_code=wasm_bytes,\n    )\n    msg_any = AnyProto()\n    msg_any.Pack(msg)\n\n    tx_body = TxBody(\n        messages=[msg_any],\n        memo='',\n        timeout_height=0,\n    )\n\n    fee_amount = int(\n        (gas_price_amount * Decimal(initial_gas_limit)).to_integral_value(rounding=ROUND_UP)\n    )\n    fee = Fee(\n        amount=[Coin(denom=gas_price_denom, amount=str(fee_amount))],\n        gas_limit=initial_gas_limit,\n    )\n\n    auth_info = AuthInfo(\n        signer_infos=[],\n        fee=fee,\n    )\n\n    tx = Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[],\n    )\n\n    tx_bytes = tx.SerializeToString()\n\n    return {\n        'tx_bytes': tx_bytes,\n        'tx_body': tx_body,\n        'auth_info': auth_info,\n        'initial_gas_limit': initial_gas_limit,\n        'fee_amount': fee_amount,\n        'gas_price_amount': str(gas_price_amount),\n        'gas_price_denom': gas_price_denom,\n        'chain_id': chain_id,\n    }\n",
	"simulate_store_code_tx": "def simulate_store_code_tx(tx_bytes: bytes, base_url: str = LCD_BASE_URL) -> Dict[str, Any]:\n    '''\n    Call /cosmos/tx/v1beta1/simulate to estimate gas usage for the MsgStoreCode transaction.\n    Returns gas_used and an adjusted_gas_limit with a safety multiplier.\n    '''\n    url = f'{base_url}/cosmos/tx/v1beta1/simulate'\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('ascii'),\n    }\n\n    try:\n        resp = requests.post(url, json=payload, timeout=20)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Simulation request failed: {exc}') from exc\n\n    data = resp.json()\n    gas_info = data.get('gas_info') or {}\n    gas_used_str = gas_info.get('gas_used')\n    if gas_used_str is None:\n        raise ValueError(f'Simulation response missing gas_info.gas_used: {data}')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError as exc:\n        raise ValueError(f'Invalid gas_used value {gas_used_str!r}: {exc}') from exc\n\n    safety_factor = 1.3\n    adjusted_gas_limit = int(gas_used * safety_factor)\n\n    return {\n        'raw_response': data,\n        'gas_used': gas_used,\n        'adjusted_gas_limit': adjusted_gas_limit,\n    }\n",
	"sign_store_code_tx": "def sign_store_code_tx(\n    sender: str,\n    wasm_bytes: bytes,\n    gas_price_amount: Decimal,\n    gas_price_denom: str,\n    gas_limit: int,\n    account_number: int,\n    sequence: int,\n    chain_id: str,\n    privkey_hex: str,\n) -> Dict[str, Any]:\n    '''\n    Construct and sign a MsgStoreCode transaction using SIGN_MODE_DIRECT.\n    Returns the signed tx_bytes ready for broadcast.\n    '''\n    msg = MsgStoreCode(sender=sender, wasm_byte_code=wasm_bytes)\n    msg_any = AnyProto()\n    msg_any.Pack(msg)\n\n    tx_body = TxBody(messages=[msg_any], memo='', timeout_height=0)\n\n    fee_amount = int(\n        (gas_price_amount * Decimal(gas_limit)).to_integral_value(rounding=ROUND_UP)\n    )\n    fee = Fee(\n        amount=[Coin(denom=gas_price_denom, amount=str(fee_amount))],\n        gas_limit=gas_limit,\n    )\n\n    try:\n        privkey_bytes = bytes.fromhex(privkey_hex)\n    except ValueError as exc:\n        raise ValueError('Private key must be a 64-character hex string.') from exc\n\n    if len(privkey_bytes) != 32:\n        raise ValueError('Private key must be 32 bytes (64 hex characters).')\n\n    sk = SigningKey.from_string(privkey_bytes, curve=SECP256k1)\n    vk = sk.get_verifying_key()\n    try:\n        pubkey_bytes = vk.to_string('compressed')\n    except TypeError as exc:\n        raise RuntimeError(\n            'ecdsa library is too old; upgrade to a version that supports compressed keys.'\n        ) from exc\n\n    pk_msg = Secp256k1PubKey(key=pubkey_bytes)\n    pk_any = AnyProto()\n    pk_any.Pack(pk_msg)\n    pk_any.type_url = '/cosmos.crypto.secp256k1.PubKey'\n\n    mode_info = ModeInfo(single=ModeInfo.Single(mode=SignMode.SIGN_MODE_DIRECT))\n    signer_info = SignerInfo(\n        public_key=pk_any,\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    auth_info = AuthInfo(\n        signer_infos=[signer_info],\n        fee=fee,\n    )\n\n    sign_doc = SignDoc(\n        body_bytes=tx_body.SerializeToString(),\n        auth_info_bytes=auth_info.SerializeToString(),\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n    sign_bytes = sign_doc.SerializeToString()\n\n    import hashlib\n\n    signature = sk.sign_deterministic(sign_bytes, hashfunc=hashlib.sha256)\n\n    tx = Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[signature],\n    )\n\n    tx_bytes = tx.SerializeToString()\n    return {\n        'tx': tx,\n        'tx_bytes': tx_bytes,\n        'fee_amount': fee_amount,\n    }\n",
	"broadcast_store_code_tx": "def broadcast_store_code_tx(tx_bytes: bytes, base_url: str = LCD_BASE_URL) -> Dict[str, Any]:\n    '''\n    Broadcast the signed transaction via /cosmos/tx/v1beta1/txs using BROADCAST_MODE_BLOCK.\n    Returns the tx_response object.\n    '''\n    url = f'{base_url}/cosmos/tx/v1beta1/txs'\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('ascii'),\n        'mode': 'BROADCAST_MODE_BLOCK',\n    }\n\n    try:\n        resp = requests.post(url, json=payload, timeout=60)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Broadcast failed: {exc}') from exc\n\n    data = resp.json()\n    tx_response = data.get('tx_response') or {}\n    if not tx_response:\n        raise ValueError(f'Broadcast response missing tx_response field: {data}')\n\n    code = tx_response.get('code', 0)\n    if code != 0:\n        raw_log = tx_response.get('raw_log')\n        raise RuntimeError(\n            f'Transaction failed with code {code}: {raw_log}'\n        )\n\n    return tx_response\n",
	"extract_code_id_from_logs": "def extract_code_id_from_logs(tx_response: Dict[str, Any]) -> str:\n    '''\n    Scan tx_response.logs[*].events[*].attributes for a code_id attribute and return it.\n    Raises ValueError if not found.\n    '''\n    logs = tx_response.get('logs', [])\n    for log in logs:\n        events = log.get('events', [])\n        for event in events:\n            attributes = event.get('attributes', [])\n            for attr in attributes:\n                key = attr.get('key')\n                value = attr.get('value')\n                if key in ('code_id', 'codeID'):\n                    return str(value)\n\n    raise ValueError(f'code_id not found in transaction logs: {logs}')\n",
	"verify_code_uploaded_on_chain": "def verify_code_uploaded_on_chain(\n    code_id: str,\n    expected_creator: str,\n    base_url: str = LCD_BASE_URL,\n) -> Dict[str, Any]:\n    '''\n    Query /cosmwasm/wasm/v1/code/{code_id} and verify the creator matches expected_creator.\n    Returns the code_info and a verified flag.\n    '''\n    url = f'{base_url}/cosmwasm/wasm/v1/code/{code_id}'\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query code_id {code_id}: {exc}') from exc\n\n    data = resp.json()\n    code_info = data.get('code_info')\n    if not code_info:\n        raise ValueError(f'No code_info returned for code_id {code_id}: {data}')\n\n    creator = code_info.get('creator')\n    if creator != expected_creator:\n        raise ValueError(\n            f'Code creator mismatch for code_id {code_id}: '\n            f'expected {expected_creator}, got {creator}'\n        )\n\n    code_id_in_payload = code_info.get('code_id')\n    if str(code_id_in_payload) != str(code_id):\n        raise ValueError(\n            f'code_id mismatch in response: path={code_id}, payload={code_id_in_payload}'\n        )\n\n    return {\n        'code_info': code_info,\n        'verified': True,\n    }\n",
	"normalize_json_payload": "def normalize_json_payload(payload: Any) -> str:\n    \"\"\"\n    Normalize an input payload into a minified JSON string.\n\n    For this workflow, the payload is expected to represent {\"all_tokens\": {}}.\n    The function validates the structure and returns a compact JSON string\n    with no unnecessary whitespace, suitable for CosmWasm smart queries.\n    \"\"\"\n    try:\n        # If payload is already a JSON string, parse it to ensure validity\n        if isinstance(payload, str):\n            parsed = json.loads(payload)\n        else:\n            parsed = payload\n\n        # Enforce the expected structure for safety\n        if parsed != {\"all_tokens\": {}}:\n            raise ValueError(\n                f\"Unexpected payload structure: {parsed!r}. \"\n                \"Expected {'all_tokens': {}}.\"\n            )\n\n        # Minified JSON: no extra whitespace, double quotes only\n        normalized = json.dumps(parsed, separators=(\",\", \":\"), ensure_ascii=False)\n        return normalized\n    except (TypeError, json.JSONDecodeError) as exc:\n        raise ValueError(f\"Invalid payload, must be JSON-serializable: {exc}\") from exc\n",
	"utf8_encode": "def utf8_encode(json_str: str) -> bytes:\n    \"\"\"\n    Convert a JSON string to a UTF-8 encoded byte array.\n\n    Args:\n        json_str: JSON payload string, typically from normalize_json_payload.\n\n    Returns:\n        UTF-8 encoded bytes.\n\n    Raises:\n        ValueError: If input is not a string or encoding fails.\n    \"\"\"\n    if not isinstance(json_str, str):\n        raise ValueError(\"json_str must be a string containing JSON data.\")\n\n    try:\n        return json_str.encode(\"utf-8\")\n    except UnicodeError as exc:\n        raise ValueError(f\"Failed to encode JSON as UTF-8: {exc}\") from exc\n",
	"base64_encode_for_smart_query": "def base64_encode_for_smart_query(utf8_bytes: Union[bytes, bytearray]) -> str:\n    \"\"\"\n    Encode a UTF-8 byte array into a base64 string suitable for CosmWasm smart queries.\n\n    The returned string can be used as the `{query_data}` path parameter in:\n    /cosmwasm/wasm/v1/contract/{address}/smart/{query_data}\n    \"\"\"\n    if not isinstance(utf8_bytes, (bytes, bytearray)):\n        raise ValueError(\"utf8_bytes must be bytes or bytearray.\")\n\n    try:\n        # base64.b64encode returns bytes; decode to ASCII string for HTTP usage\n        b64_bytes = base64.b64encode(bytes(utf8_bytes))\n        b64_str = b64_bytes.decode(\"ascii\")\n        return b64_str\n    except Exception as exc:\n        raise ValueError(f\"Failed to base64-encode data: {exc}\") from exc\n",
	"base64_decode_and_verify": "def base64_decode_and_verify(b64_str: str, expected_json: str) -> bool:\n    \"\"\"\n    Decode a base64 string back to UTF-8 and verify it matches the expected JSON exactly.\n\n    For this workflow, `expected_json` should typically be the output of `normalize_json_payload`,\n    e.g. the string '{\"all_tokens\":{}}'.\n    \"\"\"\n    if not isinstance(b64_str, str):\n        raise ValueError(\"b64_str must be a base64-encoded string.\")\n\n    if not isinstance(expected_json, str):\n        raise ValueError(\"expected_json must be a JSON string.\")\n\n    try:\n        decoded_bytes = base64.b64decode(b64_str, validate=True)\n    except (binascii.Error, ValueError) as exc:\n        raise ValueError(f\"Invalid base64 string: {exc}\") from exc\n\n    try:\n        decoded_text = decoded_bytes.decode(\"utf-8\")\n    except UnicodeError as exc:\n        raise ValueError(f\"Decoded bytes are not valid UTF-8: {exc}\") from exc\n\n    if decoded_text != expected_json:\n        raise ValueError(\n            \"Verification failed: decoded JSON does not match expected value.\\n\"\n            f\"Decoded:   {decoded_text}\\n\"\n            f\"Expected:  {expected_json}\"\n        )\n\n    return True\n",
	"get_sender_wallet": "def get_sender_wallet(env_var: str = 'JUNO_SENDER_PRIVATE_KEY') -> dict:\n    \"\"\"\n    Loads the sender's private key from a backend-only environment variable and derives\n    the compressed secp256k1 public key and Juno bech32 address.\n\n    NEVER expose the private key or the full return object to frontend clients.\n    \"\"\"\n    try:\n        hex_key = os.environ.get(env_var)\n        if not hex_key:\n            raise RuntimeError(f'Private key environment variable {env_var} is not set.')\n\n        hex_key = hex_key.strip().lower().replace('0x', '')\n        if len(hex_key) != 64:\n            raise ValueError('Private key must be 32 bytes (64 hex characters).')\n\n        priv_bytes = bytes.fromhex(hex_key)\n        sk = SigningKey.from_string(priv_bytes, curve=SECP256k1)\n        vk = sk.get_verifying_key()\n\n        # Compressed secp256k1 pubkey (33 bytes)\n        compressed_pub = vk.to_string('compressed')\n\n        # Cosmos/Juno address = bech32(hrp=\"juno\", ripemd160(sha256(compressed_pub)))\n        sha = hashlib.sha256(compressed_pub).digest()\n        ripemd = hashlib.new('ripemd160', sha).digest()\n        five_bit_r = convertbits(list(ripemd), 8, 5, True)\n        bech32_addr = bech32_encode('juno', five_bit_r)\n\n        return {\n            'address': bech32_addr,\n            'private_key_hex': priv_bytes.hex(),\n            'public_key_bytes': compressed_pub,\n        }\n    except Exception as e:\n        raise RuntimeError(f'Failed to load or derive sender wallet: {e}') from e\n",
	"validate_contract_address": "def validate_contract_address(contract_address: str, check_on_chain: bool = True) -> bool:\n    \"\"\"\n    Validates that CONTRACT_ADDRESS is a well-formed Juno bech32 address (hrp == \"juno\").\n    If check_on_chain is True, also confirms that it is a valid on-chain account/contract\n    via /cosmos/auth/v1beta1/accounts/{address}.\n    \"\"\"\n    # Basic bech32 prefix and checksum validation\n    try:\n        hrp, data = bech32_decode(contract_address)\n        if data is None or hrp != 'juno':\n            raise ValueError('Invalid bech32 address or wrong prefix (expected \"juno\").')\n    except Exception as e:\n        raise ValueError(f'Invalid contract address format: {e}') from e\n\n    if not check_on_chain:\n        return True\n\n    url = f'{LCD_URL}/cosmos/auth/v1beta1/accounts/{contract_address}'\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            if resp.status_code == 404:\n                raise ValueError('Address not found on-chain (404 from auth module).')\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while validating contract address: {e}') from e\n\n    if 'account' not in data:\n        raise RuntimeError('LCD response does not contain an \"account\" field; cannot confirm account.')\n\n    return True\n",
	"check_sender_balance": "def check_sender_balance(\n    sender_address: str,\n    required_amount: int = 1_000_000,\n    fee_buffer: int = 200_000,\n) -> dict:\n    \"\"\"\n    Queries /cosmos/bank/v1beta1/balances/{address}/by_denom for ujuno and ensures the\n    balance is at least required_amount + fee_buffer. Raises ValueError if insufficient.\n    Returns a dict with the current balance and required_total.\n    \"\"\"\n    url = f'{LCD_URL}/cosmos/bank/v1beta1/balances/{sender_address}/by_denom'\n    params = {'denom': DENOM}\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url, params=params)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while querying sender balance: {e}') from e\n\n    balance_str = data.get('balance', {}).get('amount')\n    if balance_str is None:\n        raise RuntimeError('LCD response missing balance.amount for ujuno.')\n\n    try:\n        balance = int(balance_str)\n    except ValueError:\n        raise RuntimeError(f'Invalid balance amount returned: {balance_str}')\n\n    needed = required_amount + fee_buffer\n    if balance < needed:\n        raise ValueError(\n            f'Insufficient ujuno balance. Have {balance}, but need at least {needed} (1,000,000 for send + buffer).'\n        )\n\n    return {'balance': balance, 'required_total': needed}\n",
	"construct_msg_send": "def construct_msg_send(from_address: str, to_address: str, amount: int = 1_000_000) -> Any:\n    \"\"\"\n    Constructs a /cosmos.bank.v1beta1.MsgSend message wrapped in a google.protobuf.Any\n    with type_url \"/cosmos.bank.v1beta1.MsgSend\".\n    \"\"\"\n    if amount <= 0:\n        raise ValueError('Amount must be a positive integer of ujuno.')\n\n    msg = bank_tx_pb2.MsgSend(\n        from_address=from_address,\n        to_address=to_address,\n        amount=[coin_pb2.Coin(denom=DENOM, amount=str(amount))],\n    )\n\n    any_msg = Any()\n    any_msg.Pack(msg)\n    # Ensure canonical type_url used by Cosmos SDK\n    any_msg.type_url = '/cosmos.bank.v1beta1.MsgSend'\n    return any_msg\n",
	"build_unsigned_tx": "def build_unsigned_tx(msg_any, memo: str = '', initial_gas_limit: int = 200_000) -> tx_pb2.Tx:\n    \"\"\"\n    Creates an unsigned Tx containing the provided message. Sets an initial gas limit\n    on auth_info.fee.gas_limit and leaves signer_infos and signatures empty.\n    \"\"\"\n    if initial_gas_limit <= 0:\n        raise ValueError('initial_gas_limit must be positive.')\n\n    tx_body = tx_pb2.TxBody(\n        messages=[msg_any],\n        memo=memo,\n    )\n\n    fee = tx_pb2.Fee(\n        amount=[],   # to be filled after gas price calculation\n        gas_limit=initial_gas_limit,\n        payer='',\n        granter='',\n    )\n\n    auth_info = tx_pb2.AuthInfo(\n        signer_infos=[],  # to be filled during signing\n        fee=fee,\n    )\n\n    tx = tx_pb2.Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[],  # no signatures yet\n    )\n\n    return tx\n",
	"simulate_tx_for_gas": "def simulate_tx_for_gas(tx: tx_pb2.Tx, gas_adjustment: float = 1.2) -> int:\n    \"\"\"\n    Calls /cosmos/tx/v1beta1/simulate with tx_bytes for gas estimation.\n    Uses gas_info.gas_used from the response, multiplies by gas_adjustment, rounds up,\n    and updates tx.auth_info.fee.gas_limit. Returns the computed gas_limit.\n    \"\"\"\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive.')\n\n    tx_bytes = tx.SerializeToString()\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('utf-8'),\n    }\n\n    url = f'{LCD_URL}/cosmos/tx/v1beta1/simulate'\n    try:\n        async with httpx.AsyncClient(timeout=20) as client:\n            resp = await client.post(url, json=payload)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error during gas simulation: {e}') from e\n\n    gas_used_str = data.get('gas_info', {}).get('gas_used')\n    if gas_used_str is None:\n        raise RuntimeError('Simulation response missing gas_info.gas_used.')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError:\n        raise RuntimeError(f'Invalid gas_used value returned from simulate: {gas_used_str}')\n\n    gas_limit = math.ceil(gas_used * gas_adjustment)\n    tx.auth_info.fee.gas_limit = gas_limit\n    return gas_limit\n",
	"_parse_gas_price_entry": "def _parse_gas_price_entry(entry: str):\n    \"\"\"Splits an entry like \"0.0025ujuno\" into (Decimal('0.0025'), 'ujuno').\"\"\"\n    entry = entry.strip()\n    if not entry:\n        raise ValueError('Empty gas price entry.')\n    i = 0\n    while i < len(entry) and (entry[i].isdigit() or entry[i] == '.'):\n        i += 1\n    if i == 0:\n        raise ValueError(f'Gas price entry has no numeric prefix: {entry}')\n    amount_str = entry[:i]\n    denom_str = entry[i:]\n    return Decimal(amount_str), denom_str\n\nasync def apply_min_gas_price_fee(tx: tx_pb2.Tx, denom: str = DENOM) -> str:\n    \"\"\"\n    Fetches /cosmos/base/node/v1beta1/config, parses minimum_gas_price, and finds the\n    entry for the requested denom. Computes fee = gas_limit * gas_price (rounded up),\n    updates tx.auth_info.fee.amount, and returns the fee amount as a string.\n    \"\"\"\n    url = f'{LCD_URL}/cosmos/base/node/v1beta1/config'\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while fetching minimum_gas_price: {e}') from e\n\n    min_gas_price_str = data.get('minimum_gas_price')\n    if not min_gas_price_str:\n        raise RuntimeError('minimum_gas_price is empty or missing in node config.')\n\n    selected_price = None\n    for part in min_gas_price_str.split(','):\n        amount_dec, denom_str = _parse_gas_price_entry(part)\n        if denom_str == denom:\n            selected_price = amount_dec\n            break\n\n    if selected_price is None:\n        raise RuntimeError(f'No gas price entry for denom {denom} found in \"{min_gas_price_str}\".')\n\n    gas_limit = tx.auth_info.fee.gas_limit\n    if gas_limit <= 0:\n        raise RuntimeError('tx.auth_info.fee.gas_limit must be set before computing fees.')\n\n    fee_amount = (selected_price * Decimal(gas_limit)).quantize(Decimal('1'), rounding=ROUND_UP)\n    tx.auth_info.fee.amount[:] = [coin_pb2.Coin(denom=denom, amount=str(fee_amount))]\n    return str(fee_amount)\n",
	"fetch_account_number_and_sequence": "def fetch_account_number_and_sequence(address: str) -> dict:\n    \"\"\"\n    Calls /cosmos/auth/v1beta1/accounts/{address}, decodes the returned Any protobuf\n    into a known account type, and returns account_number and sequence.\n    Supports BaseAccount and common vesting account wrappers.\n    \"\"\"\n    url = f'{LCD_URL}/cosmos/auth/v1beta1/accounts/{address}'\n\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            resp = await client.get(url)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while fetching account data: {e}') from e\n\n    account_any = data.get('account')\n    if not account_any or 'value' not in account_any:\n        raise RuntimeError('LCD response missing account.value; cannot decode account.')\n\n    raw = base64.b64decode(account_any['value'])\n    any_msg = Any()\n    any_msg.ParseFromString(raw)\n\n    base_account = None\n\n    # Handle standard BaseAccount\n    if any_msg.type_url.endswith('BaseAccount'):\n        base_account = auth_pb2.BaseAccount()\n        any_msg.Unpack(base_account)\n\n    # Handle ContinuousVestingAccount or DelayedVestingAccount\n    elif any_msg.type_url.endswith('ContinuousVestingAccount'):\n        vesting = vesting_pb2.ContinuousVestingAccount()\n        any_msg.Unpack(vesting)\n        base_account = vesting.base_account\n    elif any_msg.type_url.endswith('DelayedVestingAccount'):\n        vesting = vesting_pb2.DelayedVestingAccount()\n        any_msg.Unpack(vesting)\n        base_account = vesting.base_account\n    else:\n        raise RuntimeError(f'Unsupported account type_url: {any_msg.type_url}')\n\n    return {\n        'account_number': int(base_account.account_number),\n        'sequence': int(base_account.sequence),\n    }\n",
	"sign_tx_with_sender_key": "def sign_tx_with_sender_key(\n    tx: tx_pb2.Tx,\n    private_key_hex: str,\n    account_number: int,\n    sequence: int,\n    chain_id: str = CHAIN_ID,\n) -> tx_pb2.Tx:\n    \"\"\"\n    Populates auth_info.signer_infos with the sender's public key and SIGN_MODE_DIRECT,\n    builds a SignDoc, signs it using the sender's secp256k1 private key, and sets\n    tx.signatures to contain the resulting signature bytes.\n    \"\"\"\n    if not private_key_hex:\n        raise ValueError('private_key_hex must be provided.')\n\n    priv_hex = private_key_hex.lower().replace('0x', '').strip()\n    if len(priv_hex) != 64:\n        raise ValueError('private_key_hex must be 32 bytes (64 hex characters).')\n\n    priv_bytes = bytes.fromhex(priv_hex)\n\n    # Derive compressed secp256k1 public key\n    sk = SigningKey.from_string(priv_bytes, curve=SECP256k1)\n    vk = sk.get_verifying_key()\n    compressed_pub = vk.to_string('compressed')\n\n    # Build PubKey Any: /cosmos.crypto.secp256k1.PubKey\n    pk = secp_keys_pb2.PubKey(key=compressed_pub)\n    pk_any = Any()\n    pk_any.Pack(pk)\n    pk_any.type_url = '/cosmos.crypto.secp256k1.PubKey'\n\n    mode_info = tx_pb2.ModeInfo(\n        single=tx_pb2.ModeInfo.Single(mode=signing_pb2.SignMode.SIGN_MODE_DIRECT)\n    )\n\n    signer_info = tx_pb2.SignerInfo(\n        public_key=pk_any,\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    tx.auth_info.signer_infos[:] = [signer_info]\n\n    # Build SignDoc\n    sign_doc = tx_pb2.SignDoc(\n        body_bytes=tx.body.SerializeToString(),\n        auth_info_bytes=tx.auth_info.SerializeToString(),\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n\n    sign_doc_bytes = sign_doc.SerializeToString()\n    sign_bytes = hashlib.sha256(sign_doc_bytes).digest()\n\n    # Deterministic 64-byte R||S signature\n    signature = sk.sign_deterministic(\n        sign_bytes,\n        hashfunc=hashlib.sha256,\n        sigencode=ecdsa_util.sigencode_string,\n    )\n\n    tx.signatures[:] = [signature]\n    return tx\n",
	"encode_tx_to_bytes": "def encode_tx_to_bytes(tx: tx_pb2.Tx) -> str:\n    \"\"\"\n    Serializes the signed Tx to bytes and returns a base64-encoded string for\n    the \"tx_bytes\" field used in LCD broadcast endpoints.\n    \"\"\"\n    if not tx.signatures:\n        raise RuntimeError('Tx has no signatures; call sign_tx_with_sender_key() first.')\n\n    tx_bytes = tx.SerializeToString()\n    return base64.b64encode(tx_bytes).decode('utf-8')\n",
	"broadcast_tx_via_lcd": "def broadcast_tx_via_lcd(tx_bytes_b64: str, mode: str = 'BROADCAST_MODE_SYNC') -> dict:\n    \"\"\"\n    POSTs the signed transaction to /cosmos/tx/v1beta1/txs with the given broadcast\n    mode (BROADCAST_MODE_SYNC or BROADCAST_MODE_BLOCK, etc.) and returns the\n    embedded tx_response JSON object.\n    \"\"\"\n    valid_modes = {\n        'BROADCAST_MODE_SYNC',\n        'BROADCAST_MODE_BLOCK',\n        'BROADCAST_MODE_ASYNC',\n        'BROADCAST_MODE_UNSPECIFIED',\n    }\n\n    if mode not in valid_modes:\n        raise ValueError(f'Invalid broadcast mode: {mode}')\n\n    url = f'{LCD_URL}/cosmos/tx/v1beta1/txs'\n    payload = {\n        'tx_bytes': tx_bytes_b64,\n        'mode': mode,\n    }\n\n    try:\n        async with httpx.AsyncClient(timeout=30) as client:\n            resp = await client.post(url, json=payload)\n            resp.raise_for_status()\n            data = resp.json()\n    except httpx.HTTPError as e:\n        raise RuntimeError(f'HTTP error while broadcasting transaction: {e}') from e\n\n    tx_response = data.get('tx_response')\n    if tx_response is None:\n        raise RuntimeError('LCD broadcast response missing \"tx_response\" field.')\n\n    return tx_response\n",
	"verify_broadcast_result": "def verify_broadcast_result(tx_response: dict) -> dict:\n    \"\"\"\n    Validates that the broadcasted transaction was accepted by the chain.\n    Expects a tx_response object (as returned from broadcast_tx_via_lcd).\n    Raises RuntimeError with raw_log if code != 0. On success, returns a\n    summary dict containing txhash, height, and raw_log.\n    \"\"\"\n    if tx_response is None:\n        raise ValueError('tx_response is None; cannot verify broadcast result.')\n\n    if 'code' not in tx_response:\n        raise RuntimeError('tx_response missing \"code\" field.')\n\n    code = tx_response['code']\n    raw_log = tx_response.get('raw_log', '')\n\n    if code != 0:\n        raise RuntimeError(f'Transaction failed with code {code}: {raw_log}')\n\n    return {\n        'txhash': tx_response.get('txhash'),\n        'height': tx_response.get('height'),\n        'raw_log': raw_log,\n    }\n",
	"prepare_backend_signer": "def prepare_backend_signer() -> LocalWallet:\n    \"\"\"Load a LocalWallet for the Juno chain using a mnemonic stored\n    in the JUNO_MNEMONIC environment variable.\"\"\"\n    mnemonic = os.getenv(\"JUNO_MNEMONIC\")\n    if not mnemonic:\n        raise RuntimeError(\n            \"JUNO_MNEMONIC environment variable is not set. \"\n            \"Generate a mnemonic and export it before starting the backend.\"\n        )\n    try:\n        # Juno uses the \"juno\" Bech32 prefix\n        wallet = LocalWallet.from_mnemonic(mnemonic, prefix=\"juno\")\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to initialize LocalWallet: {exc}\") from exc\n\n    return wallet\n",
	"init_signing_cosmwasm_client": "def init_signing_cosmwasm_client(wallet: LocalWallet) -> LedgerClient:\n    \"\"\"Create a LedgerClient connected to the Juno RPC endpoint.\n\n    The client will be used later to execute CosmWasm contracts with the\n    provided LocalWallet as signer.\n    \"\"\"\n    try:\n        network_cfg = NetworkConfig(\n            chain_id=CHAIN_ID,\n            url=RPC_ENDPOINT,\n            fee_minimum_gas_price=0.025,\n            fee_denomination=FEE_DENOM,\n            staking_denomination=FEE_DENOM,\n        )\n        client = LedgerClient(network_cfg)\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to initialize Juno LedgerClient: {exc}\") from exc\n\n    return client\n",
	"resolve_contract_address": "def resolve_contract_address() -> str:\n    \"\"\"Resolve the deployed counter contract address from configuration.\n\n    By default this reads the CONTRACT_ADDRESS environment variable.\n    \"\"\"\n    addr = os.getenv(\"CONTRACT_ADDRESS\")\n    if not addr:\n        raise RuntimeError(\n            \"CONTRACT_ADDRESS environment variable is not set. \"\n            \"Set it to the deployed counter contract address.\"\n        )\n\n    # Basic sanity check for Juno bech32 prefix\n    if not addr.startswith(\"juno1\"):\n        raise ValueError(f\"CONTRACT_ADDRESS does not look like a Juno address: {addr}\")\n\n    return addr\n",
	"execute_increment_msg_over_rpc": "def execute_increment_msg_over_rpc(\n    client: LedgerClient,\n    wallet: LocalWallet,\n    contract_address: str,\n    memo: Optional[str] = None,\n) -> Dict[str, Any]:\n    \"\"\"Execute the counter contract's `{\"increment\": {}}` message via RPC.\n\n    Uses the provided LedgerClient and LocalWallet to sign and broadcast\n    the transaction.\n\n    Returns a dictionary with the transaction hash and the raw result\n    object returned by cosmpy.\n    \"\"\"\n    msg = {\"increment\": {}}\n\n    try:\n        # The exact signature of `execute_contract` may vary slightly between\n        # cosmpy versions; this example assumes the high-level helper that\n        # takes a wallet, contract address, execute msg, and optional funds.\n        result = client.execute_contract(\n            wallet,\n            contract_address,\n            msg,\n            funds=[],\n            memo=memo or \"\",\n            gas_limit=200_000,\n        )\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to execute increment on contract: {exc}\") from exc\n\n    # Normalize txhash from the returned result (object or dict)\n    txhash = getattr(result, \"txhash\", None) or getattr(result, \"tx_hash\", None)\n    if txhash is None and isinstance(result, dict):\n        txhash = result.get(\"txhash\") or result.get(\"tx_hash\")\n\n    if not txhash:\n        raise RuntimeError(f\"Could not determine transaction hash from result: {result}\")\n\n    return {\"txhash\": txhash, \"raw_result\": result}\n",
	"confirm_tx_via_lcd": "def confirm_tx_via_lcd(\n    txhash: str,\n    max_attempts: int = 12,\n    poll_interval: float = 2.0,\n) -> Dict[str, Any]:\n    \"\"\"Poll the Juno LCD until the given txhash is found and confirmed.\n\n    This uses the documented endpoint:\n      GET /cosmos/tx/v1beta1/txs/{hash}\n\n    It returns the `tx_response` JSON object on success, or raises\n    RuntimeError if the transaction fails, is not found in time, or\n    the LCD returns an error.\n    \"\"\"\n    url = f\"{LCD_BASE_URL}/cosmos/tx/v1beta1/txs/{txhash}\"\n\n    with httpx.Client(timeout=10.0) as client:\n        for attempt in range(max_attempts):\n            try:\n                resp = client.get(url)\n            except httpx.HTTPError as exc:\n                raise RuntimeError(f\"Error querying LCD for tx {txhash}: {exc}\") from exc\n\n            if resp.status_code == 404:\n                # Transaction not indexed yet; wait and retry.\n                time.sleep(poll_interval)\n                continue\n\n            if resp.status_code != 200:\n                raise RuntimeError(\n                    f\"Unexpected status while fetching tx {txhash}: \"\n                    f\"{resp.status_code} {resp.text}\"\n                )\n\n            body = resp.json()\n            tx_response = body.get(\"tx_response\")\n            if not tx_response:\n                raise RuntimeError(f\"Malformed LCD response for tx {txhash}: {body}\")\n\n            code = int(tx_response.get(\"code\", 0))\n            if code != 0:\n                raise RuntimeError(\n                    f\"Transaction {txhash} failed with code={code}, \"\n                    f\"raw_log={tx_response.get('raw_log')}\"\n                )\n\n            # Success\n            return tx_response\n\n    raise RuntimeError(\n        f\"Transaction {txhash} not found in LCD after {max_attempts} attempts.\"\n    )\n",
	"_contract_smart_query": "def _contract_smart_query(address: str, query_msg: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Helper to perform a CosmWasm smart query via the Juno LCD.\n\n    Uses the documented endpoint:\n      GET /cosmwasm/wasm/v1/contract/{address}/smart/{query_data}\n\n    where `query_data` is base64-encoded JSON.\n    \"\"\"\n    query_bytes = json.dumps(query_msg, separators=(\",\", \":\")).encode(\"utf-8\")\n    query_b64 = base64.b64encode(query_bytes).decode(\"utf-8\")\n    url = f\"{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{address}/smart/{query_b64}\"\n\n    with httpx.Client(timeout=10.0) as client:\n        resp = client.get(url)\n\n    if resp.status_code != 200:\n        raise RuntimeError(\n            f\"Smart query failed with status {resp.status_code}: {resp.text}\"\n        )\n\n    body = resp.json()\n    data_b64 = body.get(\"data\")\n    if not data_b64:\n        raise RuntimeError(f\"Malformed smart query response: {body}\")\n\n    try:\n        decoded = base64.b64decode(data_b64)\n        return json.loads(decoded.decode(\"utf-8\"))\n    except Exception as exc:\n        raise RuntimeError(f\"Failed to decode smart query response: {exc}\") from exc\n\n\ndef get_current_count(contract_address: str) -> int:\n    \"\"\"Query the counter contract for its current count.\n\n    Assumes the contract exposes a `{ \\\"get_count\\\": {} }` query that\n    returns `{ \\\"count\\\": <int> }`.\n    \"\"\"\n    result = _contract_smart_query(contract_address, {\"get_count\": {}})\n    if \"count\" not in result:\n        raise RuntimeError(f\"'count' field missing in contract response: {result}\")\n    return int(result[\"count\"])\n\n\ndef verify_incremented_count(\n    contract_address: str,\n    before: Optional[int],\n) -> Dict[str, Any]:\n    \"\"\"Verify that the counter value increased by 1 after an increment.\n\n    The caller is expected to obtain `before` by calling\n    `get_current_count(contract_address)` prior to executing the\n    increment transaction.\n\n    Returns a dict: `{ \"before\": <int|None>, \"after\": <int>, \"verified\": <bool> }`.\n    \"\"\"\n    after = get_current_count(contract_address)\n    verified = before is not None and after == before + 1\n    return {\"before\": before, \"after\": after, \"verified\": verified}\n",
	"lcd_get_tx_by_hash": "def lcd_get_tx_by_hash(tx_hash: str) -> Dict[str, Any]:\n    # Fetch transaction details for a given txhash from the Juno LCD.\n    # This calls: GET /cosmos/tx/v1beta1/txs/{hash} and returns the tx_response object.\n    if not tx_hash:\n        raise ValueError(\"tx_hash is required\")\n\n    url = f\"{LCD_BASE_URL}/cosmos/tx/v1beta1/txs/{tx_hash}\"\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            response = await client.get(url)\n        except httpx.RequestError as exc:\n            raise LcdRequestError(f\"Error while requesting {url}: {exc}\") from exc\n\n    if response.status_code != 200:\n        # Propagate a clear error that callers can handle.\n        raise LcdRequestError(\n            f\"LCD returned non-200 status {response.status_code}: {response.text}\"\n        )\n\n    data = response.json()\n    tx_response = data.get(\"tx_response\")\n    if tx_response is None:\n        raise LcdRequestError(\"LCD response missing 'tx_response' field\")\n\n    return tx_response\n",
	"parse_tx_logs_for_contract_address": "def parse_tx_logs_for_contract_address(tx_response: Dict[str, Any]) -> str:\n    # Inspect tx_response.logs[].events[].attributes[] and try to extract the\n    # instantiated contract address.\n    #\n    # It looks for an event corresponding to a CosmWasm instantiate operation and\n    # reads an attribute with key \"_contract_address\" or \"contract_address\".\n    logs: List[Dict[str, Any]] = tx_response.get(\"logs\", [])\n    if not logs:\n        raise ContractAddressNotFoundError(\"CONTRACT_ADDRESS_NOT_FOUND_IN_TX_LOGS\")\n\n    target_keys = {\"_contract_address\", \"contract_address\"}\n    instantiate_event_types = {\"instantiate\", \"wasm\", \"instantiate_contract\"}\n\n    # First pass: look only at likely instantiate-related events.\n    for log in logs:\n        for event in log.get(\"events\", []):\n            if event.get(\"type\") in instantiate_event_types:\n                for attr in event.get(\"attributes\", []):\n                    key = attr.get(\"key\")\n                    if key in target_keys:\n                        value = attr.get(\"value\")\n                        if value:\n                            return value\n\n    # Second pass: fall back to scanning all events.\n    for log in logs:\n        for event in log.get(\"events\", []):\n            for attr in event.get(\"attributes\", []):\n                key = attr.get(\"key\")\n                if key in target_keys:\n                    value = attr.get(\"value\")\n                    if value:\n                        return value\n\n    # If we reach this point, nothing was found.\n    raise ContractAddressNotFoundError(\"CONTRACT_ADDRESS_NOT_FOUND_IN_TX_LOGS\")\n",
	"validate_contract_via_lcd": "def validate_contract_via_lcd(contract_address: str) -> Dict[str, Any]:\n    # Verify that the given address is a valid CosmWasm contract by calling:\n    #   GET /cosmwasm/wasm/v1/contract/{contract_address}\n    #\n    # Returns the full LCD response (including \"address\" and \"contract_info\")\n    # when the contract exists, otherwise raises ContractNotFoundOnChainError.\n    if not contract_address:\n        raise ValueError(\"contract_address is required\")\n\n    url = f\"{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}\"\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            response = await client.get(url)\n        except httpx.RequestError as exc:\n            # Reuse the LCD error type defined earlier.\n            raise LcdRequestError(f\"Error while requesting {url}: {exc}\") from exc\n\n    if response.status_code != 200:\n        # Treat any non-200 as \"not found / not valid\" for this use case.\n        raise ContractNotFoundOnChainError(\"CONTRACT_NOT_FOUND_ON_CHAIN\")\n\n    data = response.json()\n    contract_info = data.get(\"contract_info\")\n    if not isinstance(contract_info, dict):\n        raise ContractNotFoundOnChainError(\"CONTRACT_NOT_FOUND_ON_CHAIN\")\n\n    # Basic sanity check on expected fields.\n    if not contract_info.get(\"code_id\") or not contract_info.get(\"creator\"):\n        raise ContractNotFoundOnChainError(\"CONTRACT_NOT_FOUND_ON_CHAIN\")\n\n    return data\n",
	"_build_error_payload": "def _build_error_payload(code: str, details: Optional[str] = None) -> Dict[str, Any]:\n    # Helper to standardize backend error responses.\n    return {\n        \"ok\": False,\n        \"error\": {\n            \"code\": code,\n            \"message\": ERROR_MESSAGES.get(code, \"Unexpected error.\"),\n            \"details\": details,\n        },\n    }\n\n\nasync def resolve_contract_from_txhash(tx_hash: str) -> Dict[str, Any]:\n    # High-level helper that:\n    #   1. Fetches the tx_response by hash.\n    #   2. Parses logs to extract the instantiated contract address.\n    #   3. Validates that the address is a CosmWasm contract on-chain.\n    #\n    # On success, returns:\n    #   { \"ok\": True, \"contract_address\": \"...\", \"contract_info\": { ... } }\n    #\n    # On failure, returns a structured error object instead of raising.\n    try:\n        tx_response = await lcd_get_tx_by_hash(tx_hash)\n        contract_address = parse_tx_logs_for_contract_address(tx_response)\n        contract_data = await validate_contract_via_lcd(contract_address)\n\n        return {\n            \"ok\": True,\n            \"contract_address\": contract_address,\n            \"contract_info\": contract_data.get(\"contract_info\"),\n        }\n\n    except ContractAddressNotFoundError as exc:\n        return _build_error_payload(\n            \"CONTRACT_ADDRESS_NOT_FOUND_IN_TX_LOGS\",\n            details=str(exc),\n        )\n    except ContractNotFoundOnChainError as exc:\n        return _build_error_payload(\n            \"CONTRACT_NOT_FOUND_ON_CHAIN\",\n            details=str(exc),\n        )\n    except LcdRequestError as exc:\n        return _build_error_payload(\n            \"LCD_REQUEST_FAILED\",\n            details=str(exc),\n        )\n    except Exception as exc:\n        # Catch-all to prevent leaking internal errors to clients.\n        return _build_error_payload(\n            \"UNEXPECTED_ERROR\",\n            details=str(exc),\n        )\n",
	"contract_address_from_txhash_endpoint": "def contract_address_from_txhash_endpoint(\n    txhash: str = Query(\n        ...,\n        alias=\"hash\",\n        min_length=1,\n        description=\"Instantiate transaction hash (txhash) whose contract address should be resolved.\",\n    ),\n):\n    # Wrap the resolver and expose its result as a JSON HTTP response.\n    result = await resolve_contract_from_txhash(txhash)\n\n    if not result.get(\"ok\"):\n        error = (result.get(\"error\") or {})\n        code = error.get(\"code\")\n\n        # Map error codes to HTTP status codes.\n        status_code = 400\n        if code in (\"LCD_REQUEST_FAILED\", \"UNEXPECTED_ERROR\"):\n            status_code = 502\n\n        return JSONResponse(status_code=status_code, content=result)\n\n    return JSONResponse(status_code=200, content=result)\n\n\nif __name__ == \"__main__\":\n    # For local development only. In production, run with a proper ASGI server, e.g.:\n    #   uvicorn main:app --host 0.0.0.0 --port 8000\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n",
	"load_cargo_toml": "def load_cargo_toml(project_root: str = '.') -> Dict[str, Any]:\n    '''\n    Load the Cargo.toml file from the given project root and return it as a dict.\n\n    :param project_root: Path to the contract workspace root (where Cargo.toml lives).\n    :raises FileNotFoundError: If Cargo.toml is missing.\n    :raises RuntimeError: If the file cannot be parsed as TOML.\n    '''\n    path = Path(project_root).resolve() / 'Cargo.toml'\n    if not path.is_file():\n        raise FileNotFoundError(f'Cargo.toml not found at {path}')\n\n    try:\n        with path.open('r', encoding='utf-8') as fp:\n            data = toml.load(fp)\n    except Exception as exc:\n        raise RuntimeError(f'Failed to parse {path}: {exc}') from exc\n\n    return data\n\n\nif __name__ == '__main__':\n    # Example usage from the command line:\n    #   python load_cargo.py /path/to/contract\n    import sys\n\n    root = sys.argv[1] if len(sys.argv) > 1 else '.'\n    cargo = load_cargo_toml(root)\n    print(cargo)\n",
	"verify_cargo_with_cw_orch": "def verify_cargo_with_cw_orch(project_root: str = '.', cargo_subcommand: str = 'check') -> Dict[str, Any]:\n    '''\n    Run `cargo <subcommand> --features cw-orch` from the given project root\n    to verify that the workspace builds with cw-orch enabled.\n\n    :param project_root: Path to the contract workspace root.\n    :param cargo_subcommand: Either 'check' or 'test' (or another valid cargo subcommand).\n    :return: Dict with keys: returncode, stdout, stderr, command, cwd.\n    :raises FileNotFoundError: If cargo is not installed or not on PATH.\n    :raises RuntimeError: If the command fails (non-zero exit code).\n    '''\n    root = Path(project_root).resolve()\n    if not root.is_dir():\n        raise FileNotFoundError(f'Project root directory not found: {root}')\n\n    cmd = ['cargo', cargo_subcommand, '--features', 'cw-orch']\n\n    try:\n        proc = subprocess.run(\n            cmd,\n            cwd=str(root),\n            capture_output=True,\n            text=True,\n            check=False,\n        )\n    except FileNotFoundError as exc:\n        raise FileNotFoundError('cargo executable not found. Is Rust installed and on PATH?') from exc\n\n    result: Dict[str, Any] = {\n        'returncode': proc.returncode,\n        'stdout': proc.stdout,\n        'stderr': proc.stderr,\n        'command': ' '.join(cmd),\n        'cwd': str(root),\n    }\n\n    if proc.returncode != 0:\n        raise RuntimeError(\n            f'Command failed with exit code {proc.returncode}. '\n            f'Stdout: {proc.stdout}\\nStderr: {proc.stderr}'\n        )\n\n    return result\n\n\nif __name__ == '__main__':\n    # Example:\n    #   python verify_cargo_build.py /path/to/contract check\n    import sys\n\n    root = sys.argv[1] if len(sys.argv) > 1 else '.'\n    sub = sys.argv[2] if len(sys.argv) > 2 else 'check'\n    res = verify_cargo_with_cw_orch(root, sub)\n    print('cargo command succeeded:')\n    print('  command:', res['command'])\n    print('  cwd:', res['cwd'])\n",
	"build_get_count_query_payload": "def build_get_count_query_payload() -> str:\n    '''Construct the JSON query {\"get_count\": {}} and return it as a base64-encoded string.\n\n    The returned value is suitable for the {query_data} path parameter in the\n    /cosmwasm/wasm/v1/contract/{address}/smart/{query_data} endpoint.\n    '''\n    query_obj = {'get_count': {}}\n\n    try:\n        # Compact JSON encoding is fine; the contract only cares about semantic content.\n        json_bytes = json.dumps(query_obj, separators=(',', ':'), ensure_ascii=False).encode('utf-8')\n    except (TypeError, ValueError) as e:\n        # This should not happen for the static payload, but we fail clearly if it does.\n        raise ValueError(f'Failed to serialize get_count query JSON: {e}') from e\n\n    encoded = base64.b64encode(json_bytes).decode('ascii')\n    return encoded\n",
	"lcd_query_wasm_smart": "def lcd_query_wasm_smart(contract_address: str, query_data_b64: str, timeout: float = 10.0) -> Dict[str, Any]:\n    '''Call the Juno LCD smart query endpoint for a CosmWasm contract.\n\n    Args:\n        contract_address: Bech32 address of the target contract.\n        query_data_b64: Base64-encoded JSON query payload (as returned by build_get_count_query_payload).\n        timeout: Optional HTTP timeout in seconds.\n\n    Returns:\n        The decoded JSON body from the LCD, which should contain a 'data' field\n        that is itself a base64-encoded contract response, per Juno LCD schema.\n    '''\n    if not contract_address:\n        raise ValueError('contract_address is required')\n    if not query_data_b64:\n        raise ValueError('query_data_b64 is required')\n\n    # Ensure the base64 string is safe to embed in a URL path.\n    query_data_escaped = quote(query_data_b64, safe='')\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_data_escaped}'\n\n    try:\n        response = requests.get(url, timeout=timeout)\n    except requests.RequestException as e:\n        raise RuntimeError(f'Failed to reach LCD endpoint {url}: {e}') from e\n\n    if response.status_code != 200:\n        raise RuntimeError(\n            f'LCD query failed with status {response.status_code}: {response.text}'\n        )\n\n    try:\n        data = response.json()\n    except ValueError as e:\n        raise RuntimeError(\n            f'LCD response is not valid JSON: {e}. Raw body: {response.text}'\n        ) from e\n\n    # Per /cosmwasm/wasm/v1/contract/{address}/smart/{query_data} schema, we expect a top-level \"data\" field.\n    if 'data' not in data:\n        raise KeyError(f\"LCD JSON response is missing required 'data' field: {data}\")\n\n    return data\n",
	"decode_and_extract_count": "def decode_and_extract_count(lcd_response: Dict[str, Any]) -> int:\n    '''Decode the LCD smart-query response and extract the counter value.\n\n    Args:\n        lcd_response: JSON object returned by lcd_query_wasm_smart, expected to\n            contain a base64-encoded 'data' field.\n\n    Returns:\n        The 'count' field from the decoded contract response, coerced to int.\n    '''\n    if 'data' not in lcd_response:\n        raise KeyError(\"lcd_response does not contain required 'data' field\")\n\n    data_b64 = lcd_response['data']\n    if not isinstance(data_b64, str):\n        raise TypeError(\n            f\"lcd_response['data'] must be a base64-encoded string, got {type(data_b64)}\"\n        )\n\n    try:\n        raw_bytes = base64.b64decode(data_b64)\n    except (base64.binascii.Error, ValueError) as e:\n        raise ValueError(f\"Failed to base64-decode lcd_response['data']: {e}\") from e\n\n    try:\n        payload = json.loads(raw_bytes.decode('utf-8'))\n    except (UnicodeDecodeError, json.JSONDecodeError) as e:\n        raise ValueError(\n            f'Decoded contract response is not valid UTF-8 JSON: {e}. Raw bytes: {raw_bytes!r}'\n        ) from e\n\n    if 'count' not in payload:\n        raise KeyError(f\"Contract query result does not contain 'count' field: {payload}\")\n\n    count_value = payload['count']\n    try:\n        return int(count_value)\n    except (TypeError, ValueError) as e:\n        raise ValueError(f\"Contract 'count' field is not an integer: {count_value!r}\") from e\n",
	"run_cargo_check": "def run_cargo_check(crate_dir: str | Path = \".\") -> None:\n    \"\"\"\n    Run `cargo check` in the given crate directory.\n\n    Raises a SystemExit with a non-zero code if the command fails.\n    \"\"\"\n    crate_dir = Path(crate_dir)\n\n    if not (crate_dir / \"Cargo.toml\").exists():\n        raise SystemExit(f\"Cargo.toml not found in {crate_dir!s}\")\n\n    try:\n        result = subprocess.run(\n            [\"cargo\", \"check\"],\n            cwd=crate_dir,\n            check=False,\n            capture_output=True,\n            text=True,\n        )\n    except OSError as exc:\n        # Typically raised if `cargo` is not installed or not on PATH.\n        raise SystemExit(f\"Failed to execute `cargo`: {exc}\") from exc\n\n    if result.returncode != 0:\n        # Print stderr/stdout to help debugging and exit with same code.\n        sys.stderr.write(result.stdout)\n        sys.stderr.write(result.stderr)\n        raise SystemExit(result.returncode)\n\n    print(result.stdout or \"`cargo check` completed successfully.\")\n\n\nif __name__ == \"__main__\":\n    # Optionally accept a path to the crate as the first CLI argument.\n    run_cargo_check(sys.argv[1] if len(sys.argv) > 1 else \".\")\n",
	"validate_contract_and_token": "def validate_contract_and_token(contract_address: str, token_id: Union[str, int]) -> Tuple[str, str]:\n    '''\n    Validate that the contract_address looks like a Juno bech32 address and\n    normalize token_id to a non-empty string (e.g., '8').\n    '''\n    if not isinstance(contract_address, str) or not JUNO_ADDRESS_REGEX.match(contract_address):\n        raise ValidationError(f'Invalid Juno contract address: {contract_address!r}')\n\n    # Normalize token_id into a string as expected by CW721 contracts\n    if isinstance(token_id, int):\n        if token_id < 0:\n            raise ValidationError('token_id must be non-negative.')\n        token_id_str = str(token_id)\n    elif isinstance(token_id, str):\n        token_id_str = token_id.strip()\n        if not token_id_str:\n            raise ValidationError('token_id string cannot be empty.')\n    else:\n        raise ValidationError('token_id must be either a string or an integer.')\n\n    return contract_address, token_id_str\n",
	"build_nft_info_query_json": "def build_nft_info_query_json(token_id: str) -> Dict:\n    '''\n    Build the CW721 nft_info query JSON:\n    {'nft_info': {'token_id': '<token_id>'}}\n    '''\n    if not isinstance(token_id, str) or not token_id:\n        raise ValueError('token_id must be a non-empty string.')\n\n    query = {\n        'nft_info': {\n            'token_id': token_id,\n        }\n    }\n    return query\n",
	"encode_query_to_base64": "def encode_query_to_base64(query: Dict) -> str:\n    '''\n    Serialize the query dict to JSON (UTF-8) and return a base64-encoded string.\n    '''\n    try:\n        json_bytes = json.dumps(query, separators=(',', ':'), ensure_ascii=False).encode('utf-8')\n    except (TypeError, ValueError) as exc:\n        raise ValueError(f'Failed to serialize query to JSON: {exc}') from exc\n\n    encoded = base64.b64encode(json_bytes).decode('ascii')\n    return encoded\n",
	"lcd_smart_query_nft_info": "def lcd_smart_query_nft_info(contract_address: str, query_data_b64: str, timeout: float = 10.0) -> Dict[str, Any]:\n    '''\n    Call the Juno LCD smart query endpoint for a CW721 nft_info query.\n    '''\n    if not isinstance(query_data_b64, str) or not query_data_b64:\n        raise ValueError('query_data_b64 must be a non-empty base64 string.')\n\n    # query_data must be URL-encoded because it is part of the path\n    encoded_query_data = quote(query_data_b64, safe='')\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{encoded_query_data}'\n\n    try:\n        response = requests.get(url, timeout=timeout)\n    except requests.RequestException as exc:\n        raise ContractQueryError(f'Network error while querying contract: {exc}') from exc\n\n    if response.status_code != 200:\n        # Attempt to surface a helpful error message from the LCD\n        try:\n            err_json = response.json()\n            message = err_json.get('message') or str(err_json)\n        except ValueError:\n            message = response.text\n\n        raise ContractQueryError(\n            f'LCD returned HTTP {response.status_code} for smart query: {message}'\n        )\n\n    try:\n        lcd_json = response.json()\n    except ValueError as exc:\n        raise ContractQueryError(f'Failed to parse LCD JSON response: {exc}') from exc\n\n    if 'data' not in lcd_json:\n        raise ContractQueryError(f'LCD response did not contain expected \\'data\\' field: {lcd_json}')\n\n    return lcd_json\n",
	"decode_response_data": "def decode_response_data(lcd_response: Dict[str, Any]) -> Dict[str, Any]:\n    '''\n    Decode the base64-encoded 'data' field from the LCD response and parse it as JSON.\n    '''\n    if 'data' not in lcd_response:\n        raise ResponseDecodeError('LCD response does not contain \\'data\\' field.')\n\n    data_field = lcd_response['data']\n    if not isinstance(data_field, str):\n        raise ResponseDecodeError(\n            f'Expected \\'data\\' to be a base64 string, got {type(data_field)} instead.'\n        )\n\n    try:\n        raw_bytes = base64.b64decode(data_field)\n    except (ValueError, TypeError) as exc:\n        raise ResponseDecodeError(f'Failed to base64-decode LCD data field: {exc}') from exc\n\n    try:\n        decoded_json = json.loads(raw_bytes.decode('utf-8'))\n    except (UnicodeDecodeError, json.JSONDecodeError) as exc:\n        raise ResponseDecodeError(f'Failed to decode JSON from contract data: {exc}') from exc\n\n    return decoded_json\n",
	"return_nft_metadata": "def return_nft_metadata(contract_address: str, token_id: Union[str, int]) -> Dict[str, Any]:\n    '''\n    Run the full CW721 nft_info workflow and return the parsed NFT metadata.\n    The result typically includes fields like 'token_uri' and 'extension'.\n    '''\n    # Step 1: validate address and token\n    normalized_address, token_id_str = validate_contract_and_token(contract_address, token_id)\n\n    # Step 2: build query JSON\n    query_json = build_nft_info_query_json(token_id_str)\n\n    # Step 3: encode query to base64\n    query_b64 = encode_query_to_base64(query_json)\n\n    # Step 4: send LCD smart query and handle potential 'not found' messages\n    try:\n        lcd_response = lcd_smart_query_nft_info(normalized_address, query_b64)\n    except ContractQueryError as exc:\n        msg = str(exc).lower()\n        if 'not found' in msg or 'no token' in msg or ('token_id' in msg and 'does not exist' in msg):\n            raise NftNotFoundError(f'NFT with token_id {token_id_str} does not exist.') from exc\n        raise\n\n    # Step 5: decode the 'data' field into the nft_info JSON\n    nft_info = decode_response_data(lcd_response)\n\n    # Step 6: return the parsed NFT metadata as-is\n    return nft_info\n",
	"get_sender_address": "def get_sender_address() -> str:\n    '''\n    Return the bech32 Juno address used to sign and pay for transactions.\n\n    The address is read from the JUNO_SENDER_ADDRESS environment variable, which\n    should be configured on the backend (custodial key management).\n    '''\n    address = os.getenv('JUNO_SENDER_ADDRESS')\n    if not address:\n        raise RuntimeError('Environment variable JUNO_SENDER_ADDRESS is not set.')\n    if not address.startswith('juno1'):\n        raise ValueError(f'JUNO_SENDER_ADDRESS must start with prefix juno1. Got: {address}')\n    return address\n",
	"get_account_info": "def get_account_info(sender_address: str):\n    '''\n    Query the chain via LCD to obtain account_number, sequence, and pub_key Any\n    for a given address.\n    '''\n    url = f'{LCD_URL}/cosmos/auth/v1beta1/accounts/{sender_address}'\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error querying account info: {e}') from e\n\n    data = resp.json()\n    account_any = data.get('account')\n    if not account_any:\n        raise RuntimeError(f'No account field in LCD response for {sender_address}')\n\n    value_b64 = account_any.get('value')\n    if not value_b64:\n        raise RuntimeError('LCD account response missing protobuf-encoded BaseAccount value.')\n\n    try:\n        raw = base64.b64decode(value_b64)\n    except (base64.binascii.Error, TypeError) as e:\n        raise RuntimeError(f'Failed to base64-decode account value: {e}') from e\n\n    base_account = auth_pb2.BaseAccount()\n    base_account.ParseFromString(raw)\n\n    if not base_account.address:\n        raise RuntimeError('Decoded BaseAccount has empty address.')\n    if base_account.address != sender_address:\n        # Not fatal, but worth surfacing.\n        raise RuntimeError(\n            f'Address mismatch: requested {sender_address}, got {base_account.address} from LCD.'\n        )\n\n    # pub_key may be unset if the account has never signed a tx.\n    if not base_account.pub_key.type_url:\n        raise RuntimeError(\n            'Account has no public key set on-chain (likely never used). '\n            'Cannot construct SignerInfo without a pub_key.'\n        )\n\n    return {\n        'account_number': int(base_account.account_number),\n        'sequence': int(base_account.sequence),\n        'pub_key': base_account.pub_key,  # google.protobuf.Any\n    }\n",
	"check_spendable_balance": "def check_spendable_balance(sender_address: str, required_amount: int, denom: str = 'ujuno') -> int:\n    '''\n    Query the spendable balance for sender_address and ensure it is >= required_amount.\n    required_amount is expressed in the base denom (e.g. ujuno).\n    Returns the actual balance for the denom on success.\n    '''\n    url = f'{LCD_URL}/cosmos/bank/v1beta1/spendable_balances/{sender_address}'\n    params = {'pagination.limit': '1000'}\n    try:\n        resp = requests.get(url, params=params, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error querying spendable balances: {e}') from e\n\n    data = resp.json()\n    balances = data.get('balances', [])\n    balance_amount = 0\n    for coin in balances:\n        if coin.get('denom') == denom:\n            try:\n                balance_amount = int(coin.get('amount', '0'))\n            except ValueError:\n                bad = coin.get('amount')\n                raise RuntimeError(f'Invalid amount for {denom} in LCD response: {bad}')\n            break\n\n    if balance_amount == 0:\n        raise RuntimeError(f'No spendable balance found for denom {denom} on address {sender_address}.')\n\n    if balance_amount < required_amount:\n        raise RuntimeError(\n            f'Insufficient {denom} balance. Required: {required_amount}, available: {balance_amount}.'\n        )\n\n    return balance_amount\n",
	"construct_msg_execute_reset": "def construct_msg_execute_reset(sender_address: str, contract_address: str) -> Any:\n    '''\n    Build a MsgExecuteContract to call `reset { count: 0 }` on a CosmWasm counter contract.\n    Returns the message wrapped in a google.protobuf.Any ready to be added to a TxBody.\n    '''\n    # CosmWasm execute message payload\n    execute_payload = {'reset': {'count': 0}}\n\n    msg = wasm_tx_pb2.MsgExecuteContract(\n        sender=sender_address,\n        contract=contract_address,\n        msg=json.dumps(execute_payload).encode('utf-8'),\n        funds=[],  # no funds attached\n    )\n\n    # Wrap in Any with the proper type_url: /cosmwasm.wasm.v1.MsgExecuteContract\n    any_msg = Any()\n    any_msg.Pack(msg, type_url_prefix='/')\n\n    # Sanity-check the type_url to avoid subtle bugs.\n    if any_msg.type_url != '/cosmwasm.wasm.v1.MsgExecuteContract':\n        raise RuntimeError(f'Unexpected type_url for MsgExecuteContract: {any_msg.type_url}')\n\n    return any_msg\n",
	"simulate_tx_and_update_fee": "def simulate_tx_and_update_fee(\n    tx: cosmos_tx_pb2.Tx,\n    gas_price: Decimal = Decimal('0.025'),  # example: 0.025 ujuno per gas\n    gas_adjustment: float = 1.2,\n    fee_denom: str = 'ujuno',\n) -> dict:\n    '''\n    Simulate the unsigned transaction via the LCD endpoint and update its\n    gas_limit and fee amount based on the returned gas_used.\n    Returns a dict with simulation details; the tx object is mutated in-place.\n    '''\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive.')\n\n    # Serialize Tx (signatures may be empty for simulation)\n    tx_bytes = tx.SerializeToString()\n    tx_bytes_b64 = base64.b64encode(tx_bytes).decode('utf-8')\n\n    url = f'{LCD_URL}/cosmos/tx/v1beta1/simulate'\n    payload = {'tx_bytes': tx_bytes_b64}\n\n    try:\n        resp = requests.post(url, json=payload, timeout=15)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error simulating transaction: {e}') from e\n\n    sim = resp.json()\n    gas_info = sim.get('gas_info') or {}\n    gas_used_str = gas_info.get('gas_used')\n    if gas_used_str is None:\n        raise RuntimeError(f'Simulation response missing gas_used: {sim}')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError:\n        raise RuntimeError(f'Invalid gas_used in simulation response: {gas_used_str}')\n\n    # Apply gas adjustment and compute fee = gas_limit * gas_price\n    gas_limit_decimal = Decimal(gas_used) * Decimal(str(gas_adjustment))\n    gas_limit = int(gas_limit_decimal.quantize(Decimal('1'), rounding=ROUND_UP))\n    fee_amount_decimal = Decimal(gas_limit) * gas_price\n    fee_amount = int(fee_amount_decimal.quantize(Decimal('1'), rounding=ROUND_UP))\n\n    # Update tx.auth_info.fee\n    tx.auth_info.fee.gas_limit = gas_limit\n    tx.auth_info.fee.amount[:] = [cosmos_coin_pb2.Coin(denom=fee_denom, amount=str(fee_amount))]\n\n    return {\n        'gas_used': gas_used,\n        'gas_limit': gas_limit,\n        'fee_amount': fee_amount,\n        'fee_denom': fee_denom,\n    }\n",
	"sign_tx": "def sign_tx(tx: cosmos_tx_pb2.Tx, account_number: int, chain_id: str = CHAIN_ID, private_key_hex: str = None) -> dict:\n    '''\n    Sign the provided Tx using the secp256k1 private key.\n    Returns a dict with the signed Tx object and raw/base64-encoded bytes.\n    '''\n    if private_key_hex is None:\n        private_key_hex = os.getenv('JUNO_PRIVATE_KEY_HEX')\n    if not private_key_hex:\n        raise RuntimeError(\n            'Missing private key. Set JUNO_PRIVATE_KEY_HEX or pass private_key_hex explicitly.'\n        )\n\n    try:\n        privkey_bytes = bytes.fromhex(private_key_hex)\n    except ValueError as e:\n        raise RuntimeError('JUNO_PRIVATE_KEY_HEX must be a valid hex string.') from e\n\n    privkey = PrivateKey(privkey_bytes)\n\n    # Build SignDoc\n    body_bytes = tx.body.SerializeToString()\n    auth_info_bytes = tx.auth_info.SerializeToString()\n    sign_doc = cosmos_tx_pb2.SignDoc(\n        body_bytes=body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n\n    sign_bytes = sign_doc.SerializeToString()\n    signature = privkey.sign(sign_bytes)\n\n    # Attach signature to Tx\n    tx.signatures[:] = [signature]\n\n    raw_tx_bytes = tx.SerializeToString()\n    tx_bytes_b64 = base64.b64encode(raw_tx_bytes).decode('utf-8')\n\n    return {\n        'tx': tx,\n        'raw_tx_bytes': raw_tx_bytes,\n        'tx_bytes_b64': tx_bytes_b64,\n    }\n",
	"broadcast_tx": "def broadcast_tx(tx_bytes_b64: str, mode: str = 'BROADCAST_MODE_SYNC') -> dict:\n    '''\n    Broadcast the signed transaction to the Juno LCD endpoint and return the tx_response.\n    Raises an exception if the endpoint returns an HTTP error or a non-zero ABCI code.\n    '''\n    url = f'{LCD_URL}/cosmos/tx/v1beta1/txs'\n    payload = {'tx_bytes': tx_bytes_b64, 'mode': mode}\n\n    try:\n        resp = requests.post(url, json=payload, timeout=30)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error broadcasting transaction: {e}') from e\n\n    data = resp.json()\n    tx_response = data.get('tx_response')\n    if not tx_response:\n        raise RuntimeError(f'LCD broadcast response missing tx_response: {data}')\n\n    code = int(tx_response.get('code', 0))\n    if code != 0:\n        raw_log = tx_response.get('raw_log')\n        raise RuntimeError(\n            f'Transaction failed with code {code}: {raw_log}'\n        )\n\n    return tx_response\n",
	"verify_reset_effect": "def verify_reset_effect(contract_address: str, expected_count: int = 0) -> int:\n    '''\n    Query the contract via its smart query endpoint to ensure that the current\n    count equals expected_count (default 0). Raises RuntimeError if not.\n    '''\n    query_msg = {'get_count': {}}\n    query_b64 = base64.b64encode(json.dumps(query_msg).encode('utf-8')).decode('utf-8')\n\n    url = f'{LCD_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_b64}'\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as e:\n        raise RuntimeError(f'Error querying contract state: {e}') from e\n\n    data = resp.json()\n    data_b64 = data.get('data')\n    if data_b64 is None:\n        raise RuntimeError(f'Unexpected smart query response (missing data field): {data}')\n\n    try:\n        raw = base64.b64decode(data_b64)\n        decoded = json.loads(raw.decode('utf-8'))\n    except Exception as e:\n        raise RuntimeError(f'Failed to decode smart query response payload: {e}') from e\n\n    count = decoded.get('count')\n    if count != expected_count:\n        raise RuntimeError(f'Contract count mismatch. Expected {expected_count}, got {count}.')\n\n    return count\n",
	"lcd_verify_contract_exists": "def lcd_verify_contract_exists(contract_address: str) -> dict:\n    '''\n    Confirm that a CosmWasm contract exists at the given address on Juno.\n    Raises an exception if the contract is not found or the LCD call fails.\n    '''\n    if not contract_address:\n        raise ValueError('contract_address must be a non-empty Bech32 address.')\n\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}'\n\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query contract info from LCD: {exc}') from exc\n\n    data = response.json()\n\n    # The LCD should return an object containing the contract_info field on success.\n    if 'contract_info' not in data:\n        raise ValueError(f'LCD response does not contain contract_info for {contract_address}: {data}')\n\n    return data",
	"bff_prepare_execute_msg_increment": "def bff_prepare_execute_msg_increment() -> Tuple[Dict[str, Any], bytes]:\n    '''\n    Build the CosmWasm execute message for incrementing a counter and\n    return both the normalized JSON object and its UTF-8 encoded bytes.\n    '''\n    msg = {'increment': {}}\n\n    try:\n        # Normalize JSON: no extra spaces and deterministic key ordering.\n        json_str = json.dumps(msg, separators=(',', ':'), sort_keys=True)\n        msg_bytes = json_str.encode('utf-8')\n    except (TypeError, ValueError) as exc:\n        raise RuntimeError(f'Failed to encode execute message as JSON: {exc}') from exc\n\n    return msg, msg_bytes",
	"bff_get_chain_and_account_info": "def bff_get_chain_and_account_info(address: str) -> Dict[str, Any]:\n    '''\n    Fetch the Juno chain_id and the account_number/sequence for the given address\n    using the LCD node_info and accounts endpoints.\n    '''\n    if not address:\n        raise ValueError('address must be a non-empty Bech32 string.')\n\n    # Fetch chain-id from node_info\n    node_info_url = f'{LCD_BASE_URL}/cosmos/base/tendermint/v1beta1/node_info'\n    try:\n        node_resp = requests.get(node_info_url, timeout=10)\n        node_resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query node_info from LCD: {exc}') from exc\n\n    node_data = node_resp.json()\n    default_node_info = node_data.get('default_node_info') or {}\n    chain_id = default_node_info.get('network')\n    if not chain_id:\n        raise RuntimeError(f'Could not determine chain_id from node_info response: {node_data}')\n\n    # Fetch account information\n    acct_url = f'{LCD_BASE_URL}/cosmos/auth/v1beta1/accounts/{address}'\n    try:\n        acct_resp = requests.get(acct_url, timeout=10)\n        acct_resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query account data from LCD: {exc}') from exc\n\n    acct_data = acct_resp.json()\n    account = acct_data.get('account')\n    if not account:\n        raise RuntimeError(f'No account data found for address {address}: {acct_data}')\n\n    # BaseAccount is typically inlined in JSON with these fields.\n    account_number_str = account.get('account_number')\n    sequence_str = account.get('sequence')\n\n    if account_number_str is None or sequence_str is None:\n        raise RuntimeError(\n            f'Account number or sequence missing in LCD response for {address}: {account}'\n        )\n\n    try:\n        account_number = int(account_number_str)\n        sequence = int(sequence_str)\n    except ValueError as exc:\n        raise RuntimeError(\n            f'Failed to parse account_number/sequence as integers: {account_number_str}/{sequence_str}'\n        ) from exc\n\n    return {\n        'chain_id': chain_id,\n        'account_number': account_number,\n        'sequence': sequence,\n        'raw_account': account,\n    }",
	"lcd_check_spendable_balance_for_ujuno": "def lcd_check_spendable_balance_for_ujuno(address: str, required_ujuno: int) -> Dict[str, Any]:\n    '''\n    Ensure the address has at least `required_ujuno` (in ujuno, the base denom) available.\n    This should cover both the 10ujuno contract funds and anticipated fee amount.\n    '''\n    if not address:\n        raise ValueError('address must be a non-empty Bech32 string.')\n\n    if required_ujuno <= 0:\n        raise ValueError('required_ujuno must be a positive integer representing ujuno.')\n\n    url = f'{LCD_BASE_URL}/cosmos/bank/v1beta1/balances/{address}/by_denom'\n    params = {'denom': 'ujuno'}\n\n    try:\n        resp = requests.get(url, params=params, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query ujuno balance from LCD: {exc}') from exc\n\n    data = resp.json()\n    balance_obj = data.get('balance') or {}\n    amount_str = balance_obj.get('amount', '0')\n\n    try:\n        available = int(amount_str)\n    except ValueError as exc:\n        raise RuntimeError(f'LCD returned non-integer balance amount: {amount_str}') from exc\n\n    if available < required_ujuno:\n        raise RuntimeError(\n            f'Insufficient ujuno balance. Required {required_ujuno}, available {available}.'\n        )\n\n    return {\n        'available_ujuno': available,\n        'required_ujuno': required_ujuno,\n    }",
	"bff_construct_execute_contract_tx": "def bff_construct_execute_contract_tx(\n    sender: str,\n    contract_address: str,\n    msg_bytes: bytes,\n    funds_ujuno: int = 10,\n    initial_gas_limit: int = 200000,\n    gas_price_ujuno: Decimal = Decimal('0.025'),\n) -> TxRaw:\n    '''\n    Build an unsigned TxRaw with a single MsgExecuteContract for simulation.\n    signer_infos are left empty; this Tx should only be used for gas simulation.\n\n    funds_ujuno is the amount of ujuno to send to the contract (10 by default).\n    initial_gas_limit and gas_price_ujuno are used to compute a provisional fee.\n    '''\n    if not sender or not contract_address:\n        raise ValueError('sender and contract_address must be non-empty strings.')\n\n    if initial_gas_limit <= 0:\n        raise ValueError('initial_gas_limit must be positive.')\n\n    # Build the CosmWasm execute message.\n    exec_msg = MsgExecuteContract(\n        sender=sender,\n        contract=contract_address,\n        msg=msg_bytes,\n        funds=[Coin(denom='ujuno', amount=str(funds_ujuno))],\n    )\n\n    any_msg = AnyMessage(\n        type_url='/cosmwasm.wasm.v1.MsgExecuteContract',\n        value=exec_msg.SerializeToString(),\n    )\n\n    tx_body = TxBody(\n        messages=[any_msg],\n        memo='',\n        timeout_height=0,\n    )\n    body_bytes = tx_body.SerializeToString()\n\n    # Provisional fee based on initial gas limit and gas price.\n    fee_amount = (Decimal(initial_gas_limit) * gas_price_ujuno).to_integral_value(\n        rounding=ROUND_UP\n    )\n\n    fee = Fee(\n        amount=[Coin(denom='ujuno', amount=str(fee_amount))],\n        gas_limit=initial_gas_limit,\n        payer='',\n        granter='',\n    )\n\n    auth_info = AuthInfo(\n        signer_infos=[],  # filled later when signing\n        fee=fee,\n    )\n    auth_info_bytes = auth_info.SerializeToString()\n\n    tx_raw = TxRaw(\n        body_bytes=body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        signatures=[],  # no signatures for simulation\n    )\n\n    return tx_raw",
	"lcd_simulate_tx": "def lcd_simulate_tx(\n    tx_raw: TxRaw,\n    gas_adjustment: float = 1.3,\n    gas_price_ujuno: Decimal = Decimal('0.025'),\n) -> Dict[str, Any]:\n    '''\n    Simulate the given unsigned TxRaw via LCD and compute a recommended gas limit\n    and fee (in ujuno).\n    '''\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive.')\n\n    tx_bytes = tx_raw.SerializeToString()\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('ascii'),\n    }\n\n    url = f'{LCD_BASE_URL}/cosmos/tx/v1beta1/simulate'\n    try:\n        resp = requests.post(url, json=payload, timeout=20)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to simulate transaction via LCD: {exc}') from exc\n\n    sim_result = resp.json()\n    gas_info = sim_result.get('gas_info') or {}\n    gas_used_str = gas_info.get('gas_used')\n\n    if gas_used_str is None:\n        raise RuntimeError(f'LCD simulation response missing gas_used: {sim_result}')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError as exc:\n        raise RuntimeError(f'Invalid gas_used value: {gas_used_str}') from exc\n\n    recommended_gas_limit = int(gas_used * gas_adjustment)\n    fee_amount = (Decimal(recommended_gas_limit) * gas_price_ujuno).to_integral_value(\n        rounding=ROUND_UP\n    )\n\n    return {\n        'gas_used': gas_used,\n        'recommended_gas_limit': recommended_gas_limit,\n        'recommended_fee_ujuno': int(fee_amount),\n        'raw_response': sim_result,\n    }",
	"bff_sign_execute_tx": "def bff_sign_execute_tx(\n    unsigned_tx: TxRaw,\n    chain_id: str,\n    account_number: int,\n    sequence: int,\n    fee_amount_ujuno: int,\n    gas_limit: int,\n    private_key_hex: str,\n) -> bytes:\n    '''\n    Sign the execute transaction with the provided private key and return raw tx bytes.\n\n    unsigned_tx should contain the body_bytes from the MsgExecuteContract built earlier.\n    fee_amount_ujuno and gas_limit should come from the simulation step.\n    '''\n    if fee_amount_ujuno < 0:\n        raise ValueError('fee_amount_ujuno must be non-negative.')\n    if gas_limit <= 0:\n        raise ValueError('gas_limit must be positive.')\n    if not chain_id:\n        raise ValueError('chain_id must be a non-empty string.')\n\n    # Load the private key (secp256k1)\n    try:\n        privkey = PrivateKey(bytes.fromhex(private_key_hex))\n    except Exception as exc:\n        raise RuntimeError('Failed to load private key from hex.') from exc\n\n    pubkey = PubKey(key=privkey.public_key.bytes)\n    any_pubkey = AnyMessage(\n        type_url='/cosmos.crypto.secp256k1.PubKey',\n        value=pubkey.SerializeToString(),\n    )\n\n    mode_info = ModeInfo(single=ModeInfo.Single(mode=SignMode.SIGN_MODE_DIRECT))\n\n    signer_info = SignerInfo(\n        public_key=any_pubkey,\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    fee = Fee(\n        amount=[Coin(denom='ujuno', amount=str(fee_amount_ujuno))],\n        gas_limit=gas_limit,\n        payer='',\n        granter='',\n    )\n\n    auth_info = AuthInfo(\n        signer_infos=[signer_info],\n        fee=fee,\n    )\n    auth_info_bytes = auth_info.SerializeToString()\n\n    sign_doc = SignDoc(\n        body_bytes=unsigned_tx.body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n    sign_doc_bytes = sign_doc.SerializeToString()\n\n    # cosmpy PrivateKey.sign returns a 64-byte secp256k1 signature compatible with Cosmos.\n    signature = privkey.sign(sign_doc_bytes)\n\n    signed_tx = TxRaw(\n        body_bytes=unsigned_tx.body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        signatures=[signature],\n    )\n\n    return signed_tx.SerializeToString()",
	"lcd_broadcast_tx": "def lcd_broadcast_tx(tx_bytes: bytes, mode: str = 'BROADCAST_MODE_BLOCK') -> Dict[str, Any]:\n    '''\n    Broadcast a signed transaction to the Juno LCD and return the full tx_response.\n    '''\n    if not tx_bytes:\n        raise ValueError('tx_bytes must not be empty.')\n\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('ascii'),\n        'mode': mode,\n    }\n\n    url = f'{LCD_BASE_URL}/cosmos/tx/v1beta1/txs'\n    try:\n        resp = requests.post(url, json=payload, timeout=30)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to broadcast transaction via LCD: {exc}') from exc\n\n    data = resp.json()\n    tx_response = data.get('tx_response')\n    if tx_response is None:\n        raise RuntimeError(f'LCD broadcast response missing tx_response: {data}')\n\n    return tx_response",
	"query_counter": "def query_counter(contract_address: str) -> int:\n    '''\n    Query the contract's `get_count` smart query and return the current counter value.\n    This assumes the contract responds with JSON like {'count': <int>}.\n    '''\n    if not contract_address:\n        raise ValueError('contract_address must be a non-empty Bech32 address.')\n\n    query_msg = {'get_count': {}}\n    try:\n        query_json = json.dumps(query_msg, separators=(',', ':'), sort_keys=True)\n        query_bytes = query_json.encode('utf-8')\n    except (TypeError, ValueError) as exc:\n        raise RuntimeError(f'Failed to encode get_count query: {exc}') from exc\n\n    query_b64 = base64.b64encode(query_bytes).decode('ascii')\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_b64}'\n\n    try:\n        resp = requests.get(url, timeout=10)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        raise RuntimeError(f'Failed to query contract counter via LCD: {exc}') from exc\n\n    data = resp.json()\n\n    # Some chains wrap smart-query responses as {'data': {...}}.\n    if 'data' in data:\n        payload = data['data']\n    else:\n        payload = data\n\n    if not isinstance(payload, dict) or 'count' not in payload:\n        raise RuntimeError(f'Unexpected get_count response: {data}')\n\n    try:\n        return int(payload['count'])\n    except (TypeError, ValueError) as exc:\n        raise RuntimeError(f'Counter value is not an integer: {payload}') from exc\n\n\ndef lcd_verify_execute_effect(contract_address: str, tx_response: Dict[str, Any]) -> Dict[str, Any]:\n    '''\n    Verify that the execute transaction succeeded and emitted at least one wasm event.\n    Returns a summary including txhash, height, and the collected wasm events.\n    '''\n    if tx_response is None:\n        raise ValueError('tx_response must not be None.')\n\n    code = int(tx_response.get('code', 0))\n    if code != 0:\n        raise RuntimeError(f'Execute transaction failed with code {code}: {tx_response.get(\"raw_log\")}')\n\n    wasm_events = []\n    for log in tx_response.get('logs', []):\n        for event in log.get('events', []):\n            if event.get('type') == 'wasm':\n                wasm_events.append(event)\n\n    if not wasm_events:\n        raise RuntimeError('No wasm events found in tx_response logs; execute may not have run as expected.')\n\n    return {\n        'success': True,\n        'txhash': tx_response.get('txhash'),\n        'height': tx_response.get('height'),\n        'wasm_events': wasm_events,\n    }",
	"collect_query_parameters": "def collect_query_parameters(payload: Dict[str, Any]) -> SmartQueryParameters:\n    '''\n    Normalize and validate inputs for a CosmWasm smart contract query.\n\n    Args:\n        payload: Dictionary typically obtained from an HTTP request body,\n                 e.g. {\n                     'contract_address': 'juno1...',\n                     'query': {'config': {}},\n                     'lcd_url': '...',        # optional\n                     'rpc_url': '...',        # optional\n                     'chain_id': 'juno-1',    # optional, mostly for CLI\n                     'keyring_backend': 'os'  # optional, mostly for CLI\n                 }\n\n    Returns:\n        SmartQueryParameters with sensible defaults applied.\n\n    Raises:\n        ValueError if required fields are missing or invalid.\n    '''\n    if not isinstance(payload, dict):\n        raise ValueError('payload must be a dict')\n\n    contract_address = payload.get('contract_address')\n    if not isinstance(contract_address, str) or not contract_address:\n        raise ValueError('contract_address (bech32) is required and must be a non-empty string')\n\n    raw_query = payload.get('query')\n    if raw_query is None:\n        raise ValueError('query is required (e.g. {config: {}})')\n\n    # Allow query to be provided as JSON string or already-parsed dict\n    if isinstance(raw_query, str):\n        try:\n            query_obj = json.loads(raw_query)\n        except json.JSONDecodeError as exc:\n            raise ValueError(f'query string must be valid JSON: {exc}') from exc\n    elif isinstance(raw_query, dict):\n        query_obj = raw_query\n    else:\n        raise ValueError('query must be either a dict or a JSON string')\n\n    lcd_url = (\n        payload.get('lcd_url')\n        or os.getenv('JUNO_LCD_URL')\n        or DEFAULT_LCD_URL\n    )\n\n    rpc_url = payload.get('rpc_url') or os.getenv('JUNO_RPC_URL')\n    chain_id = payload.get('chain_id') or os.getenv('JUNO_CHAIN_ID')\n    keyring_backend = payload.get('keyring_backend') or os.getenv('JUNO_KEYRING_BACKEND')\n\n    node_cfg = NodeConfig(\n        lcd_url=lcd_url,\n        rpc_url=rpc_url,\n        chain_id=chain_id,\n        keyring_backend=keyring_backend,\n    )\n\n    return SmartQueryParameters(\n        contract_address=contract_address,\n        query=query_obj,\n        node=node_cfg,\n    )",
	"encode_smart_query_for_lcd": "def encode_smart_query_for_lcd(query: Dict[str, Any]) -> str:\n    '''\n    Serialize and base64-encode the query for use in the LCD smart query path.\n\n    CosmWasm LCD expects the path parameter {query_data} to be a base64 encoding\n    of the raw JSON bytes of the query message.\n\n    Args:\n        query: Python dict representing the JSON query (e.g. {'config': {}}).\n\n    Returns:\n        Base64-encoded string suitable for insertion into the LCD path.\n    '''\n    if not isinstance(query, dict):\n        raise ValueError('query must be a dict representing the JSON payload')\n\n    try:\n        # Minified JSON string (no extra whitespace)\n        json_str = json.dumps(query, separators=(',', ':'), ensure_ascii=False)\n    except (TypeError, ValueError) as exc:\n        raise ValueError(f'query could not be serialized to JSON: {exc}') from exc\n\n    json_bytes = json_str.encode('utf-8')\n    b64 = base64.b64encode(json_bytes).decode('ascii')\n    return b64",
	"http_get_contract_smart_state": "def http_get_contract_smart_state(\n    contract_address: str,\n    query_data_b64: str,\n    lcd_url: str = DEFAULT_LCD_URL,\n    timeout: float = 10.0,\n) -> Dict[str, Any]:\n    '''\n    Perform an HTTP GET against Juno's LCD smart contract endpoint.\n\n    Args:\n        contract_address: Bech32 address of the CosmWasm contract.\n        query_data_b64: Base64-encoded query message (output of encode_smart_query_for_lcd).\n        lcd_url: Base URL of the LCD; defaults to Juno's archival LCD.\n        timeout: Request timeout in seconds.\n\n    Returns:\n        Parsed JSON response from the LCD (as a Python dict).\n\n    Raises:\n        ValueError for obvious input issues or unexpected response shape.\n        requests.RequestException for network-related errors.\n        requests.HTTPError for non-2xx HTTP responses.\n    '''\n    if not contract_address or not isinstance(contract_address, str):\n        raise ValueError('contract_address must be a non-empty string')\n\n    if not query_data_b64 or not isinstance(query_data_b64, str):\n        raise ValueError('query_data_b64 must be a non-empty base64 string')\n\n    base = lcd_url.rstrip('/')\n    encoded_addr = quote(contract_address, safe='')\n    encoded_query = quote(query_data_b64, safe='')\n\n    url = f'{base}/cosmwasm/wasm/v1/contract/{encoded_addr}/smart/{encoded_query}'\n\n    try:\n        resp = requests.get(url, timeout=timeout)\n        resp.raise_for_status()\n    except requests.RequestException as exc:\n        # Wrap network errors with more context\n        raise requests.RequestException(f'Failed GET {url}: {exc}') from exc\n\n    try:\n        body = resp.json()\n    except ValueError as exc:\n        raise ValueError(f'LCD response was not valid JSON: {exc}; raw={resp.text!r}') from exc\n\n    # The documented response shape is {'data': '<base64_bytes>'}\n    if 'data' not in body:\n        raise ValueError(f'Unexpected LCD response; missing data field: {body}')\n\n    return body",
	"decode_lcd_smart_query_response": "def decode_lcd_smart_query_response(lcd_response: Dict[str, Any]) -> Union[Any, bytes]:\n    '''\n    Decode the `data` field from the LCD smart query response.\n\n    The LCD returns a base64-encoded byte array under the `data` field.\n    CosmWasm smart contract queries typically encode JSON as UTF-8 bytes.\n\n    Args:\n        lcd_response: Dict returned by http_get_contract_smart_state.\n\n    Returns:\n        Parsed JSON object if the decoded bytes are valid UTF-8 JSON;\n        otherwise the raw bytes.\n\n    Raises:\n        KeyError if `data` is missing.\n        ValueError if the base64 payload cannot be decoded.\n    '''\n    if not isinstance(lcd_response, dict):\n        raise ValueError('lcd_response must be a dict')\n\n    if 'data' not in lcd_response:\n        raise KeyError('lcd_response is missing required data field')\n\n    b64_data = lcd_response['data']\n    if not isinstance(b64_data, str):\n        raise ValueError('data field must be a base64 string')\n\n    try:\n        raw_bytes = base64.b64decode(b64_data)\n    except (ValueError, TypeError) as exc:\n        raise ValueError(f'Failed to base64-decode LCD data field: {exc}') from exc\n\n    # Attempt to interpret as UTF-8 JSON, fallback to raw bytes if that fails.\n    try:\n        text = raw_bytes.decode('utf-8')\n        return json.loads(text)\n    except (UnicodeDecodeError, json.JSONDecodeError):\n        return raw_bytes",
	"execute_junod_cli_smart_query": "def execute_junod_cli_smart_query(\n    contract_address: str,\n    query: Dict[str, Any],\n    rpc_endpoint: Optional[str],\n    chain_id: Optional[str],\n    junod_binary: str = 'junod',\n) -> Dict[str, Any]:\n    '''\n    Optionally execute the smart query via the local `junod` CLI.\n\n    This is useful in environments where the CLI is installed and configured,\n    either as the primary query mechanism or to cross-check LCD results.\n\n    Args:\n        contract_address: Bech32 address of the CosmWasm contract.\n        query: Dict representing the JSON query (e.g. {'config': {}}).\n        rpc_endpoint: RPC endpoint to reach the node (e.g. 'http://localhost:26657').\n        chain_id: Target chain-id (e.g. 'juno-1').\n        junod_binary: Name or path of the junod binary.\n\n    Returns:\n        Parsed JSON output from the CLI (as a Python dict).\n\n    Raises:\n        RuntimeError if the CLI is not available or returns a non-zero exit code\n        or if the output cannot be parsed as JSON.\n        ValueError for obvious input issues.\n    '''\n    if not contract_address or not isinstance(contract_address, str):\n        raise ValueError('contract_address must be a non-empty string')\n\n    if not isinstance(query, dict):\n        raise ValueError('query must be a dict representing the JSON payload')\n\n    if not rpc_endpoint or not chain_id:\n        raise ValueError('rpc_endpoint and chain_id are required to run junod CLI queries')\n\n    try:\n        query_str = json.dumps(query, separators=(',', ':'), ensure_ascii=False)\n    except (TypeError, ValueError) as exc:\n        raise ValueError(f'query could not be serialized to JSON: {exc}') from exc\n\n    cmd = [\n        junod_binary,\n        'query',\n        'wasm',\n        'contract-state',\n        'smart',\n        contract_address,\n        query_str,\n        '--node',\n        rpc_endpoint,\n        '--chain-id',\n        chain_id,\n        '--output',\n        'json',\n    ]\n\n    try:\n        completed = subprocess.run(\n            cmd,\n            check=False,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError as exc:\n        raise RuntimeError(f'junod binary not found: {junod_binary}') from exc\n    except Exception as exc:\n        raise RuntimeError(f'Failed to execute junod CLI: {exc}') from exc\n\n    if completed.returncode != 0:\n        stderr = completed.stderr.strip()\n        stdout = completed.stdout.strip()\n        stdout_display = stdout or '<empty>'\n        stderr_display = stderr or '<empty>'\n        raise RuntimeError(\n            'junod query failed with exit code '\n            f'{completed.returncode}. '\n            f'STDOUT: {stdout_display} STDERR: {stderr_display}'\n        )\n\n    try:\n        cli_output = json.loads(completed.stdout)\n    except json.JSONDecodeError as exc:\n        raise RuntimeError(\n            f'Failed to parse junod JSON output: {exc}; raw={completed.stdout!r}'\n        ) from exc\n\n    return cli_output",
	"compare_cli_and_lcd_results": "def compare_cli_and_lcd_results(\n    lcd_decoded_result: Any,\n    lcd_raw_response: Dict[str, Any],\n    cli_response: Dict[str, Any],\n) -> Dict[str, Any]:\n    '''\n    Compare decoded LCD smart query result with parsed junod CLI response.\n\n    Args:\n        lcd_decoded_result: Output of decode_lcd_smart_query_response (inner contract result).\n        lcd_raw_response: Raw dict returned by http_get_contract_smart_state.\n        cli_response: Parsed JSON dict returned by execute_junod_cli_smart_query.\n\n    Returns:\n        Dict with keys:\n            'match': bool\n            'lcd': decoded LCD result\n            'cli': decoded CLI result (inner contract result)\n\n    Raises:\n        ValueError if the decoded inner results differ or if the CLI response is malformed.\n    '''\n    if not isinstance(cli_response, dict):\n        raise ValueError('cli_response must be a dict')\n\n    if 'data' not in cli_response:\n        raise ValueError(f'CLI response is missing data field: {cli_response}')\n\n    data_field = cli_response['data']\n    if not isinstance(data_field, str):\n        raise ValueError('data field of CLI response must be a base64 string')\n\n    try:\n        cli_bytes = base64.b64decode(data_field)\n    except (ValueError, TypeError) as exc:\n        raise ValueError(f'Failed to base64-decode CLI data field: {exc}') from exc\n\n    try:\n        cli_text = cli_bytes.decode('utf-8')\n        cli_decoded = json.loads(cli_text)\n    except (UnicodeDecodeError, json.JSONDecodeError):\n        cli_decoded = cli_bytes\n\n    if lcd_decoded_result != cli_decoded:\n        # Include both for debugging\n        raise ValueError(\n            'LCD and junod CLI smart query results differ. '\n            f'Decoded LCD result: {lcd_decoded_result!r} '\n            f'Decoded CLI result: {cli_decoded!r} '\n            f'Raw LCD response: {lcd_raw_response!r} '\n            f'Raw CLI response: {cli_response!r}'\n        )\n\n    return {\n        'match': True,\n        'lcd': lcd_decoded_result,\n        'cli': cli_decoded,\n    }",
	"detect_contract_project_root": "def detect_contract_project_root(start_dir: Optional[str] = None) -> Path:\n    # Determine the single-contract project root by searching upward for a\n    # Cargo.toml file that has a [package] section and does NOT declare [workspace].\n    start_path = Path(start_dir).resolve() if start_dir else Path.cwd().resolve()\n    current = start_path\n\n    # Walk up the directory tree until we find a suitable Cargo.toml.\n    for candidate in [current] + list(current.parents):\n        cargo_toml = candidate / 'Cargo.toml'\n        if cargo_toml.is_file():\n            try:\n                import tomllib  # Python 3.11+\n            except ModuleNotFoundError:\n                import tomli as tomllib  # type: ignore\n\n            with cargo_toml.open('rb') as f:\n                cargo_data = tomllib.load(f)\n\n            # Reject workspaces: these usually correspond to multi-contract repos.\n            if 'workspace' in cargo_data:\n                raise ProjectRootError(\n                    f'Found Cargo.toml at {cargo_toml}, but it defines a [workspace]. '\n                    'This helper expects to run inside a single-contract project. '\n                    'Please cd into the individual contract crate directory and retry.'\n                )\n\n            if 'package' not in cargo_data:\n                raise ProjectRootError(\n                    f'Cargo.toml at {cargo_toml} does not contain a [package] section. '\n                    'This does not look like a valid CosmWasm contract crate.'\n                )\n\n            return candidate\n\n    # No suitable Cargo.toml found.\n    raise ProjectRootError(\n        f'Could not locate a suitable Cargo.toml when walking up from {start_path}. '\n        'Ensure you are running this from within a CosmWasm single-contract project.'\n    )",
	"read_contract_name_from_cargo": "def read_contract_name_from_cargo(project_root: str) -> Tuple[str, Path]:\n    # Read the [package] name from Cargo.toml in the given project root and\n    # build the expected artifacts/<CONTRACT_NAME>.wasm path.\n    root = Path(project_root).resolve()\n    cargo_toml = root / 'Cargo.toml'\n\n    if not cargo_toml.is_file():\n        raise CargoReadError(f'Cargo.toml not found at {cargo_toml}')\n\n    try:\n        import tomllib  # Python 3.11+\n    except ModuleNotFoundError:\n        import tomli as tomllib  # type: ignore\n\n    try:\n        with cargo_toml.open('rb') as f:\n            cargo_data = tomllib.load(f)\n        package_table = cargo_data['package']\n        contract_name = package_table['name']\n    except KeyError as exc:\n        raise CargoReadError(\n            f'Cargo.toml at {cargo_toml} is missing the [package] name field.'\n        ) from exc\n\n    artifacts_dir = root / 'artifacts'\n    artifact_path = artifacts_dir / f'{contract_name}.wasm'\n\n    return contract_name, artifact_path",
	"run_rust_optimizer": "def run_rust_optimizer(\n    project_root: str,\n    use_docker: bool = True,\n    docker_image: str = 'cosmwasm/rust-optimizer:0.14.0',\n    timeout_seconds: Optional[int] = None,\n) -> Dict[str, Any]:\n    # Run the CosmWasm rust-optimizer against the given project root.\n    # By default this uses the official Docker image; set use_docker=False\n    # to instead run a local 'cargo wasm --locked --release' build.\n    root = Path(project_root).resolve()\n\n    if not (root / 'Cargo.toml').is_file():\n        raise RustOptimizerError(\n            f'No Cargo.toml found under {root}. Is this a valid CosmWasm contract project?'\n        )\n\n    if use_docker:\n        # Recommended path: use the official rust-optimizer Docker image.\n        target_dir = root / 'target'\n        cmd = [\n            'docker',\n            'run',\n            '--rm',\n            '-v',\n            f'{root}:/code',\n            '-v',\n            f'{target_dir}:/target',\n            '-v',\n            'rust-optimizer-cache:/usr/local/cargo/registry',\n            docker_image,\n        ]\n        working_dir = root\n    else:\n        # Fallback: run a local cargo build (requires wasm32 target and wasm-opt).\n        cmd = ['cargo', 'wasm', '--locked', '--release']\n        working_dir = root\n\n    try:\n        completed = subprocess.run(\n            cmd,\n            cwd=working_dir,\n            check=False,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            timeout=timeout_seconds,\n        )\n    except FileNotFoundError as exc:\n        # Binary (docker or cargo) not found on PATH.\n        raise RustOptimizerError(\n            f'Failed to execute {cmd[0]!r}. Ensure it is installed and available on PATH.'\n        ) from exc\n    except subprocess.TimeoutExpired as exc:\n        raise RustOptimizerError(\n            f'rust-optimizer command timed out after {timeout_seconds} seconds.'\n        ) from exc\n\n    if completed.returncode != 0:\n        # Attach stdout/stderr to the error so callers can surface logs to the UI.\n        raise RustOptimizerError(\n            'rust-optimizer command failed with non-zero exit code '\n            f'{completed.returncode}.\\n\\nSTDOUT:\\n{completed.stdout}\\n\\nSTDERR:\\n{completed.stderr}'\n        )\n\n    return {\n        'stdout': completed.stdout,\n        'stderr': completed.stderr,\n        'returncode': completed.returncode,\n        'command': cmd,\n    }",
	"verify_wasm_artifact": "def verify_wasm_artifact(\n    artifact_path: str,\n    optimizer_stdout: Optional[str] = None,\n    optimizer_stderr: Optional[str] = None,\n    run_wasm_validator: bool = True,\n    wasm_validator_cmd: Optional[list] = None,\n) -> Dict[str, Any]:\n    # Verify that the artifact exists, is non-empty, and looks like a valid wasm module.\n    path = Path(artifact_path).resolve()\n\n    if not path.is_file():\n        msg = f'WASM artifact not found at {path}.'\n        if optimizer_stdout or optimizer_stderr:\n            msg += '\\n\\nOptimizer STDOUT:\\n' + (optimizer_stdout or '')\n            msg += '\\n\\nOptimizer STDERR:\\n' + (optimizer_stderr or '')\n        raise WasmArtifactError(msg)\n\n    size = path.stat().st_size\n    if size == 0:\n        msg = f'WASM artifact at {path} is empty (0 bytes).'\n        if optimizer_stdout or optimizer_stderr:\n            msg += '\\n\\nOptimizer STDOUT:\\n' + (optimizer_stdout or '')\n            msg += '\\n\\nOptimizer STDERR:\\n' + (optimizer_stderr or '')\n        raise WasmArtifactError(msg)\n\n    # Check the wasm magic bytes: 0x00 0x61 0x73 0x6d ('\\0asm').\n    with path.open('rb') as f:\n        magic = f.read(4)\n\n    if magic != b'\\x00asm':\n        msg = (\n            f'File at {path} does not appear to be a valid WebAssembly module. '\n            f'Expected magic bytes 0x00 0x61 0x73 0x6d, got {magic!r}. '\n        )\n        if optimizer_stdout or optimizer_stderr:\n            msg += '\\n\\nOptimizer STDOUT:\\n' + (optimizer_stdout or '')\n            msg += '\\n\\nOptimizer STDERR:\\n' + (optimizer_stderr or '')\n        raise WasmArtifactError(msg)\n\n    validator_output: Dict[str, Any] = {}\n\n    if run_wasm_validator:\n        # Use wasm-tools wasm-validate by default if available.\n        cmd = wasm_validator_cmd or ['wasm-tools', 'validate', str(path)]\n\n        try:\n            completed = subprocess.run(\n                cmd,\n                check=False,\n                stdout=subprocess.PIPE,\n                stderr=subprocess.PIPE,\n                text=True,\n            )\n        except FileNotFoundError:\n            # External validator is optional; if missing, we just skip it.\n            validator_output = {\n                'validator_cmd': cmd,\n                'skipped': True,\n                'reason': f'Validator command {cmd[0]!r} not found on PATH; magic-byte validation passed.',\n            }\n        else:\n            if completed.returncode != 0:\n                msg = (\n                    f'External wasm validator failed for {path} with exit code {completed.returncode}. '\n                    f'Validator STDOUT:\\n{completed.stdout}\\nValidator STDERR:\\n{completed.stderr}'\n                )\n                if optimizer_stdout or optimizer_stderr:\n                    msg += '\\n\\nOptimizer STDOUT:\\n' + (optimizer_stdout or '')\n                    msg += '\\n\\nOptimizer STDERR:\\n' + (optimizer_stderr or '')\n                raise WasmArtifactError(msg)\n\n            validator_output = {\n                'validator_cmd': cmd,\n                'skipped': False,\n                'stdout': completed.stdout,\n                'stderr': completed.stderr,\n            }\n\n    return {\n        'artifact_path': str(path),\n        'size_bytes': size,\n        'magic_bytes': list(magic),\n        'validator': validator_output,\n    }",
	"build_smart_query_payload": "def build_smart_query_payload() -> str:\n    '''Construct the JSON payload with root field abcde and return it base64 encoded.\n\n    This base64 string is what the CosmWasm LCD smart query endpoint expects\n    in the query_data path parameter.\n    '''\n    query_msg: Dict[str, Any] = {'abcde': {}}\n\n    try:\n        json_bytes = json.dumps(query_msg, separators=(',', ':')).encode('utf-8')\n    except (TypeError, ValueError) as exc:\n        raise ValueError(f'Unable to serialize query message: {exc}') from exc\n\n    encoded = base64.b64encode(json_bytes).decode('ascii')\n    return encoded",
	"query_wasm_smart": "def query_wasm_smart(contract_address: str, query_data_b64: str, timeout: float = 10.0) -> Dict[str, Any]:\n    '''Query a CosmWasm contract using the LCD smart query endpoint.\n\n    :param contract_address: Bech32 contract address on Juno.\n    :param query_data_b64: Base64-encoded query payload (output of build_smart_query_payload).\n    :param timeout: Optional request timeout in seconds.\n    :returns: Parsed JSON response from the LCD.\n    :raises LCDQueryError: If the HTTP request fails or the response is invalid.\n    '''\n    if not contract_address:\n        raise LCDQueryError('contract_address must be provided')\n\n    if not query_data_b64:\n        raise LCDQueryError('query_data_b64 must be provided')\n\n    # Encode the base64 string so it is safe inside the URL path segment.\n    encoded_query_data = urllib.parse.quote(query_data_b64, safe='')\n\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{encoded_query_data}'\n\n    try:\n        response = requests.get(url, timeout=timeout)\n    except requests.RequestException as exc:\n        raise LCDQueryError(f'Error while calling LCD endpoint: {exc}') from exc\n\n    if response.status_code != 200:\n        raise LCDQueryError(\n            f'LCD returned status {response.status_code}: {response.text}'\n        )\n\n    try:\n        payload: Dict[str, Any] = response.json()\n    except ValueError as exc:\n        raise LCDQueryError(f'LCD response is not valid JSON: {exc}') from exc\n\n    if 'data' not in payload:\n        raise LCDQueryError('LCD response JSON does not contain required key data')\n\n    return payload",
	"_analyze_structure": "def _analyze_structure(obj: Any) -> Any:\n    '''Recursively analyze a JSON-compatible Python object to infer a simple schema.'''\n    if isinstance(obj, dict):\n        return {\n            'type': 'object',\n            'fields': {key: _analyze_structure(value) for key, value in obj.items()},\n        }\n    if isinstance(obj, list):\n        if not obj:\n            return {'type': 'array', 'items': 'unknown (empty array)'}\n        return {'type': 'array', 'items': _analyze_structure(obj[0])}\n    return {'type': type(obj).__name__}\n\n\ndef decode_and_analyze_contract_response(lcd_response: Dict[str, Any]) -> Dict[str, Any]:\n    '''Decode the base64-encoded data field from the LCD response and analyze its structure.\n\n    :param lcd_response: Parsed JSON object returned by query_wasm_smart.\n    :returns: Dictionary containing raw bytes, JSON text, parsed object, and inferred schema.\n    :raises ContractResponseDecodeError: On missing fields or decode or parse errors.\n    '''\n    if 'data' not in lcd_response:\n        raise ContractResponseDecodeError('LCD response does not contain key data')\n\n    data_field = lcd_response['data']\n\n    if not isinstance(data_field, str):\n        raise ContractResponseDecodeError('LCD data field must be a base64 string')\n\n    try:\n        raw_bytes = base64.b64decode(data_field)\n    except (binascii.Error, ValueError) as exc:\n        raise ContractResponseDecodeError(f'Failed to base64-decode data field: {exc}') from exc\n\n    try:\n        json_text = raw_bytes.decode('utf-8')\n    except UnicodeDecodeError as exc:\n        raise ContractResponseDecodeError(f'Decoded data is not valid UTF-8: {exc}') from exc\n\n    try:\n        parsed = json.loads(json_text)\n    except ValueError as exc:\n        raise ContractResponseDecodeError(f'Decoded data is not valid JSON: {exc}') from exc\n\n    schema = _analyze_structure(parsed)\n\n    return {\n        'raw_bytes': raw_bytes,\n        'json_text': json_text,\n        'parsed': parsed,\n        'inferred_schema': schema,\n    }",
	"parse_and_validate_amounts": "def parse_and_validate_amounts(coin_str: str, allowed_denoms: Optional[List[str]] = None) -> List[Dict[str, str]]:\n    '''Parse a human coin string like 100000ujunox,25000ujuno into a list of\n    {denom: <str>, amount: <str>} objects and validate them.\n\n    :param coin_str: Comma-separated coin string.\n    :param allowed_denoms: Optional whitelist of allowed denoms.\n    :return: List of dicts with keys denom and amount.\n    :raises AmountParseError: If the string is invalid.\n    '''\n    if not coin_str:\n        raise AmountParseError('Coin string must not be empty.')\n\n    # Default to common Juno denoms; extend this list in your app as needed.\n    if allowed_denoms is None:\n        allowed_denoms = ['ujuno', 'ujunox']\n\n    coins: List[Dict[str, str]] = []\n\n    for part in coin_str.split(','):\n        token = part.strip()\n        if not token:\n            continue\n\n        m = COIN_RE.match(token)\n        if not m:\n            raise AmountParseError(f'Invalid coin segment {token}. Expected format like 100000ujuno.')\n\n        amount_str, denom = m.groups()\n\n        # Amount must be positive integer and not have leading zeros unless it is exactly 0.\n        if not amount_str.isdigit():\n            raise AmountParseError(f'Amount {amount_str} in segment {token} is not a valid integer.')\n        if amount_str == '0':\n            raise AmountParseError('Amounts must be strictly positive.')\n        # Leading zeros check (e.g., 001 is not allowed)\n        if len(amount_str) > 1 and amount_str.startswith('0'):\n            raise AmountParseError(f'Amount {amount_str} must not contain leading zeros.')\n\n        if denom not in allowed_denoms:\n            raise AmountParseError(\n                f'Denom {denom} is not in the list of allowed Juno denoms: {allowed_denoms}.'\n            )\n\n        coins.append({'denom': denom, 'amount': amount_str})\n\n    if not coins:\n        raise AmountParseError('No valid coin segments were found in input.')\n\n    # Optionally, you can aggregate amounts by denom here if duplicates are possible.\n\n    return coins\n",
	"check_spendable_balances_for_sender": "def check_spendable_balances_for_sender(\n    sender_address: str,\n    required_funds: List[Dict[str, str]],\n    expected_fee_per_denom: Optional[Dict[str, int]] = None,\n    lcd_url: str = LCD_URL,\n) -> Dict[str, Dict[str, int]]:\n    '''Ensure that sender_address has at least required_funds plus expected_fee_per_denom\n    available as spendable balance.\n\n    :param sender_address: Bech32 Juno address of the sender.\n    :param required_funds: List of dicts with keys denom and amount from step 1.\n    :param expected_fee_per_denom: Optional dict mapping denom to extra units reserved for fees.\n    :param lcd_url: Base LCD URL.\n    :return: Dict containing a mapping of spendable balances.\n    :raises InsufficientBalanceError: If any denom is insufficient.\n    '''\n    if expected_fee_per_denom is None:\n        expected_fee_per_denom = {}\n\n    url = f'{lcd_url}/cosmos/bank/v1beta1/spendable_balances/{sender_address}'\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        try:\n            resp = await client.get(url)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise RuntimeError(f'Error querying spendable balances from LCD: {exc}') from exc\n\n    data = resp.json()\n    # Build a simple denom -> int amount map\n    spendable_map: Dict[str, int] = {}\n    for coin in data.get('balances', []):\n        denom = coin.get('denom')\n        amount_str = coin.get('amount', '0')\n        if denom is None:\n            continue\n        try:\n            spendable_map[denom] = int(amount_str)\n        except ValueError:\n            raise RuntimeError(f'LCD returned a non-integer amount {amount_str} for denom {denom}.')\n\n    # Check each required fund\n    for coin in required_funds:\n        denom = coin['denom']\n        raw_amount = coin['amount']\n        try:\n            required_amount = int(raw_amount)\n        except ValueError:\n            raise ValueError(f'Required amount {raw_amount} for denom {denom} is not a valid integer.')\n\n        fee_buffer = int(expected_fee_per_denom.get(denom, 0))\n        total_required = required_amount + fee_buffer\n        available = spendable_map.get(denom, 0)\n\n        if available < total_required:\n            raise InsufficientBalanceError(\n                f'Insufficient spendable balance for denom {denom}. '\n                f'Required including fees: {total_required}, available: {available}.'\n            )\n\n    return {'spendable_balances': spendable_map}\n",
	"build_execute_contract_msg_with_funds": "def build_execute_contract_msg_with_funds(\n    sender: str,\n    contract: str,\n    execute_msg: Dict,\n    funds: List[Dict[str, str]],\n) -> wasm_tx_pb2.MsgExecuteContract:\n    '''Build a MsgExecuteContract protobuf message including attached funds.\n\n    :param sender: Bech32 Juno address of the sender.\n    :param contract: Bech32 address of the target contract.\n    :param execute_msg: Python dict representing the contract execute message.\n    :param funds: List of dicts with keys denom and amount from step 1.\n    :return: MsgExecuteContract protobuf object.\n    '''\n    if not isinstance(execute_msg, dict):\n        raise ExecuteMsgBuildError('execute_msg must be a JSON-serializable dict.')\n\n    if not funds:\n        # It is technically valid to send no funds, but this helper is meant for cases with funds.\n        raise ExecuteMsgBuildError('funds must be a non-empty list when attaching tokens.')\n\n    try:\n        msg_bytes = json.dumps(execute_msg, separators=(',', ':'), ensure_ascii=False).encode('utf-8')\n    except (TypeError, ValueError) as exc:\n        raise ExecuteMsgBuildError(f'Failed to JSON-encode execute_msg: {exc}') from exc\n\n    proto_funds = []\n    for coin in funds:\n        denom = coin['denom']\n        amount = coin['amount']\n        # Basic validation; detailed checks were already done in step 1.\n        if not denom or not amount:\n            raise ExecuteMsgBuildError(f'Invalid fund entry: {coin}.')\n        proto_funds.append(coin_pb2.Coin(denom=denom, amount=str(amount)))\n\n    msg = wasm_tx_pb2.MsgExecuteContract(\n        sender=sender,\n        contract=contract,\n        msg=msg_bytes,\n        funds=proto_funds,\n    )\n\n    return msg\n",
	"_get_minimum_gas_price": "def _get_minimum_gas_price(lcd_url: str = LCD_URL) -> Tuple[Decimal, str]:\n    '''Fetch and parse minimum_gas_price from the node config endpoint.'''\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        resp = await client.get(f'{lcd_url}/cosmos/base/node/v1beta1/config')\n        resp.raise_for_status()\n\n    cfg = resp.json()\n    mgp = cfg.get('minimum_gas_price')\n    if not mgp:\n        raise TxConstructionError('LCD /config did not return minimum_gas_price.')\n\n    # Example format: 0.0025ujuno\n    i = 0\n    while i < len(mgp) and (mgp[i].isdigit() or mgp[i] == '.'):\n        i += 1\n    amount_str = mgp[:i]\n    denom = mgp[i:]\n    if not amount_str or not denom:\n        raise TxConstructionError(f'Could not parse minimum_gas_price value {mgp}.')\n\n    return Decimal(amount_str), denom\n\n\nasync def construct_execute_tx(\n    msg: wasm_tx_pb2.MsgExecuteContract,\n    public_key_bytes: bytes,\n    sequence: int,\n    gas_limit: int = 200_000,\n    gas_adjustment: float = 1.0,\n    lcd_url: str = LCD_URL,\n) -> Tuple[tx_pb2.Tx, int, coin_pb2.Coin]:\n    '''Wrap the MsgExecuteContract in a Tx with an initial gas limit and fee.\n\n    This creates an unsigned Tx (no signatures yet) that can be simulated in step 5.\n\n    :param msg: MsgExecuteContract protobuf message.\n    :param public_key_bytes: 33-byte compressed secp256k1 public key for the sender.\n    :param sequence: Account sequence for the sender.\n    :param gas_limit: Initial gas limit used before simulation.\n    :param gas_adjustment: Optional multiplier applied to gas_limit.\n    :param lcd_url: Base LCD URL used to fetch minimum_gas_price.\n    :return: Tuple of (unsigned_tx, effective_gas_limit, fee_coin).\n    '''\n    if gas_limit <= 0:\n        raise TxConstructionError('gas_limit must be positive.')\n    effective_gas_limit = int(gas_limit * gas_adjustment)\n\n    # Fetch minimum gas price (for example 0.0025ujuno) and compute fee = ceil(price * gas_limit)\n    try:\n        gas_price_amount, gas_price_denom = await _get_minimum_gas_price(lcd_url)\n    except httpx.HTTPError as exc:\n        raise TxConstructionError(f'Failed to fetch minimum_gas_price from LCD: {exc}') from exc\n\n    fee_decimal = (gas_price_amount * Decimal(effective_gas_limit)).to_integral_value(rounding=ROUND_UP)\n    fee_amount = int(fee_decimal)\n    fee_coin = coin_pb2.Coin(denom=gas_price_denom, amount=str(fee_amount))\n\n    # Pack MsgExecuteContract into an Any proto\n    msg_any = AnyProto(\n        type_url='/cosmwasm.wasm.v1.MsgExecuteContract',\n        value=msg.SerializeToString(),\n    )\n\n    tx_body = tx_pb2.TxBody(\n        messages=[msg_any],\n        memo='',\n        timeout_height=0,\n    )\n\n    # Signer info with direct sign mode\n    pubkey = keys_pb2.PubKey(key=public_key_bytes)\n    pubkey_any = AnyProto(\n        type_url='/cosmos.crypto.secp256k1.PubKey',\n        value=pubkey.SerializeToString(),\n    )\n\n    mode_info = tx_pb2.ModeInfo(\n        single=tx_pb2.ModeInfo.Single(mode=signing_pb2.SIGN_MODE_DIRECT)\n    )\n\n    signer_info = tx_pb2.SignerInfo(\n        public_key=pubkey_any,\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    auth_info = tx_pb2.AuthInfo(\n        signer_infos=[signer_info],\n        fee=tx_pb2.Fee(\n            amount=[fee_coin],\n            gas_limit=effective_gas_limit,\n            payer='',\n            granter='',\n        ),\n    )\n\n    unsigned_tx = tx_pb2.Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[],  # populated in step 6\n    )\n\n    return unsigned_tx, effective_gas_limit, fee_coin\n",
	"simulate_execute_tx": "def simulate_execute_tx(\n    unsigned_tx: tx_pb2.Tx,\n    gas_adjustment: float = 1.2,\n    lcd_url: str = LCD_URL,\n) -> Tuple[int, int]:\n    '''Simulate an unsigned transaction to estimate gas usage.\n\n    :param unsigned_tx: Tx object from step 4 (no signatures required for simulation).\n    :param gas_adjustment: Multiplier applied to gas_used to compute new gas_limit.\n    :param lcd_url: Base LCD URL.\n    :return: Tuple of (gas_used, adjusted_gas_limit).\n    '''\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive.')\n\n    tx_bytes = unsigned_tx.SerializeToString()\n    payload = {'tx_bytes': base64.b64encode(tx_bytes).decode('utf-8')}\n\n    async with httpx.AsyncClient(timeout=20.0) as client:\n        try:\n            resp = await client.post(f'{lcd_url}/cosmos/tx/v1beta1/simulate', json=payload)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise TxSimulationError(f'Error calling /cosmos/tx/v1beta1/simulate: {exc}') from exc\n\n    data = resp.json()\n    gas_info = data.get('gas_info') or {}\n    gas_used_str = gas_info.get('gas_used')\n    if gas_used_str is None:\n        raise TxSimulationError(f'Simulation response missing field gas_used: {data}')\n\n    try:\n        gas_used = int(gas_used_str)\n    except ValueError:\n        raise TxSimulationError(f'Simulation returned non-integer gas_used {gas_used_str}.')\n\n    adjusted_gas_limit = int(gas_used * gas_adjustment)\n\n    return gas_used, adjusted_gas_limit\n",
	"sign_and_broadcast_execute_tx": "def sign_and_broadcast_execute_tx(\n    unsigned_tx: tx_pb2.Tx,\n    privkey_hex: str,\n    account_number: int,\n    sequence: int,\n    chain_id: str,\n    lcd_url: str = LCD_URL,\n) -> Tuple[str, dict]:\n    '''Sign an execute transaction with the sender key and broadcast it via the LCD.\n\n    :param unsigned_tx: Tx object from step 4 (fee and gas_limit should already be set,\n                       optionally updated after step 5).\n    :param privkey_hex: Hex-encoded secp256k1 private key for the sender.\n    :param account_number: Sender account number on chain.\n    :param sequence: Sender sequence (nonce) on chain.\n    :param chain_id: Chain ID, for example juno-1 or uni-6.\n    :param lcd_url: Base LCD URL.\n    :return: Tuple of (txhash, full tx_response dict).\n    '''\n    key_hex = privkey_hex.lower().replace('0x', '')\n    if len(key_hex) != 64:\n        raise ValueError('Private key must be 32 bytes (64 hex characters).')\n\n    try:\n        privkey = PrivateKey(bytes.fromhex(key_hex))\n    except ValueError as exc:\n        raise ValueError(f'Invalid private key hex: {exc}') from exc\n\n    wallet = LocalWallet(privkey)\n\n    # cosmpy will create the SignDoc, sign it, and attach the signature to the Tx.\n    signed_tx: tx_pb2.Tx = wallet.sign_tx(\n        unsigned_tx,\n        account_number=account_number,\n        sequence=sequence,\n        chain_id=chain_id,\n    )\n\n    tx_bytes = signed_tx.SerializeToString()\n    payload = {\n        'tx_bytes': base64.b64encode(tx_bytes).decode('utf-8'),\n        'mode': 'BROADCAST_MODE_BLOCK',\n    }\n\n    async with httpx.AsyncClient(timeout=30.0) as client:\n        try:\n            resp = await client.post(f'{lcd_url}/cosmos/tx/v1beta1/txs', json=payload)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise TxBroadcastError(f'Error broadcasting transaction: {exc}') from exc\n\n    data = resp.json()\n    tx_response = data.get('tx_response') or {}\n    txhash = tx_response.get('txhash')\n\n    if not txhash:\n        raise TxBroadcastError(f'LCD did not return txhash. Full response: {data}')\n\n    code = tx_response.get('code', 0)\n    if code != 0:\n        raw_log = tx_response.get('raw_log', '')\n        raise TxBroadcastError(\n            f'Transaction failed with code {code}. txhash={txhash}, raw_log={raw_log}'\n        )\n\n    return txhash, tx_response\n",
	"_get_balance_by_denom": "def _get_balance_by_denom(\n    address: str,\n    denom: str,\n    lcd_url: str = LCD_URL,\n) -> int:\n    '''Helper to query /balances/{address}/by_denom for a single denom.'''\n    url = f'{lcd_url}/cosmos/bank/v1beta1/balances/{address}/by_denom'\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        resp = await client.get(url, params={'denom': denom})\n        resp.raise_for_status()\n\n    data = resp.json()\n    balance = data.get('balance') or {}\n    amount_str = balance.get('amount', '0')\n    try:\n        return int(amount_str)\n    except ValueError:\n        raise RuntimeError(f'LCD returned non-integer balance {amount_str} for {address} denom {denom}.')\n\n\nasync def verify_funds_transferred_to_contract(\n    contract_address: str,\n    sender_address: str,\n    attached_funds: List[Dict[str, str]],\n    before_contract_balances: Optional[Dict[str, int]] = None,\n    before_sender_balances: Optional[Dict[str, int]] = None,\n    lcd_url: str = LCD_URL,\n) -> Dict[str, Dict[str, int]]:\n    '''Verify that funds attached to the execute transaction have arrived in the contract account.\n\n    If before_contract_balances and before_sender_balances snapshots are provided, this will also\n    validate that the observed balance deltas match or exceed the attached_funds amounts.\n\n    :param contract_address: Bech32 contract address that received funds.\n    :param sender_address: Bech32 address of the sender.\n    :param attached_funds: List of dicts with keys denom and amount that were sent to the contract.\n    :param before_contract_balances: Optional mapping denom to amount (int) before the transaction.\n    :param before_sender_balances: Optional mapping denom to amount (int) before the transaction.\n    :param lcd_url: Base LCD URL.\n    :return: Dict summarizing pre and post balances and deltas.\n    :raises FundsVerificationError: If observed deltas do not match expectations.\n    '''\n    after_contract: Dict[str, int] = {}\n    after_sender: Dict[str, int] = {}\n\n    # Fetch fresh balances after the transaction\n    for coin in attached_funds:\n        denom = coin['denom']\n        after_contract[denom] = await _get_balance_by_denom(contract_address, denom, lcd_url)\n        after_sender[denom] = await _get_balance_by_denom(sender_address, denom, lcd_url)\n\n    # If before_* snapshots are provided, compute and validate deltas.\n    contract_deltas: Dict[str, int] = {}\n    sender_deltas: Dict[str, int] = {}\n\n    for coin in attached_funds:\n        denom = coin['denom']\n        sent_amount = int(coin['amount'])\n\n        if before_contract_balances is not None:\n            before_c = int(before_contract_balances.get(denom, 0))\n            delta_c = after_contract[denom] - before_c\n            contract_deltas[denom] = delta_c\n            if delta_c < sent_amount:\n                raise FundsVerificationError(\n                    f'Contract balance for {denom} increased by {delta_c}, '\n                    f'expected at least {sent_amount}.'\n                )\n\n        if before_sender_balances is not None:\n            before_s = int(before_sender_balances.get(denom, 0))\n            delta_s = after_sender[denom] - before_s\n            sender_deltas[denom] = delta_s\n            if delta_s > -sent_amount:\n                raise FundsVerificationError(\n                    f'Sender balance for {denom} decreased by {-delta_s}, '\n                    f'expected at least {sent_amount}.'\n                )\n\n    return {\n        'after_contract_balances': after_contract,\n        'after_sender_balances': after_sender,\n        'contract_deltas': contract_deltas,\n        'sender_deltas': sender_deltas,\n    }\n",
	"normalize_and_serialize_init_msg": "def normalize_and_serialize_init_msg(raw_init: Union[str, dict]) -> bytes:\n    '''Normalize and validate a CosmWasm init message and return UTF-8 bytes.'''\n    if isinstance(raw_init, str):\n        try:\n            obj = json.loads(raw_init)\n        except json.JSONDecodeError as e:\n            raise ValueError(f'Invalid JSON for init msg: {e}')\n    elif isinstance(raw_init, dict):\n        obj = raw_init\n    else:\n        raise TypeError('raw_init must be a JSON string or dict')\n\n    # Basic validation for the counter example: ensure count is an integer\n    if 'count' not in obj:\n        raise ValueError('init msg must contain a count field')\n    if not isinstance(obj['count'], int):\n        raise ValueError('count must be an integer')\n\n    # Canonical JSON: no extra spaces, sorted keys\n    normalized_str = json.dumps(obj, sort_keys=True, separators=(',', ':'))\n    return normalized_str.encode('utf-8')\n",
	"lcd_check_code_id_exists": "def lcd_check_code_id_exists(code_id: int) -> Dict[str, Any]:\n    '''Verify that a given CosmWasm code id exists on Juno.'''\n    try:\n        async with httpx.AsyncClient(base_url=BASE_URL, timeout=10.0) as client:\n            resp = await client.get(f'/cosmwasm/wasm/v1/code/{code_id}')\n    except httpx.RequestError as e:\n        raise RuntimeError(f'Network error while checking code id {code_id}: {e}') from e\n\n    if resp.status_code != 200:\n        raise ValueError(f'LCD returned status {resp.status_code} for code id {code_id}: {resp.text}')\n\n    data = resp.json()\n    code_info = data.get('code_info')\n    if not code_info or not code_info.get('code_id'):\n        raise ValueError(f'Code id {code_id} does not exist on Juno or LCD response is malformed')\n\n    return code_info\n",
	"lcd_check_spendable_balances": "def lcd_check_spendable_balances(address: str, denom: str, required_amount: int) -> int:\n    '''Ensure the sender has enough spendable balance in the given denom.'''\n    try:\n        async with httpx.AsyncClient(base_url=BASE_URL, timeout=10.0) as client:\n            resp = await client.get(f'/cosmos/bank/v1beta1/spendable_balances/{address}')\n    except httpx.RequestError as e:\n        raise RuntimeError(f'Network error while querying spendable balances: {e}') from e\n\n    if resp.status_code != 200:\n        raise ValueError(f'Failed to fetch spendable balances: HTTP {resp.status_code} {resp.text}')\n\n    data = resp.json()\n    balances = data.get('balances', []) or []\n\n    available = 0\n    for coin in balances:\n        if coin.get('denom') == denom:\n            try:\n                available = int(coin.get('amount', '0'))\n            except ValueError:\n                raise ValueError(f'Invalid amount value in balance for denom {denom}')\n            break\n\n    if available < required_amount:\n        raise ValueError(f'Insufficient funds in {denom}: required {required_amount}, available {available}')\n\n    return available\n",
	"bff_construct_instantiate_contract_tx": "def bff_construct_instantiate_contract_tx(\n    sender: str,\n    admin: Optional[str],\n    code_id: int,\n    label: str,\n    init_msg_bytes: bytes,\n    sequence: int,\n    gas_limit: int,\n    gas_price: float,\n    fee_denom: str,\n) -> Dict[str, Any]:\n    '''Construct an unsigned Tx for MsgInstantiateContract with provisional gas and fee.'''\n    if gas_limit <= 0:\n        raise ValueError('gas_limit must be positive')\n    if gas_price <= 0:\n        raise ValueError('gas_price must be positive')\n\n    # Build the CosmWasm instantiate message\n    msg = cosmwasm_tx.MsgInstantiateContract(\n        sender=sender,\n        admin=admin or '',\n        code_id=code_id,\n        label=label,\n        msg=init_msg_bytes,\n        funds=[],\n    )\n\n    msg_any = ProtoAny(type_url='/cosmwasm.wasm.v1.MsgInstantiateContract', value=msg.SerializeToString())\n\n    body = cosmos_tx.TxBody(messages=[msg_any], memo='')\n\n    fee_amount = int(gas_limit * gas_price)\n    if fee_amount <= 0:\n        raise ValueError('Computed fee_amount must be positive')\n\n    fee_coin = cosmos_coin.Coin(denom=fee_denom, amount=str(fee_amount))\n\n    mode_info = cosmos_tx.ModeInfo(single=cosmos_tx.ModeInfo.Single(mode=signing_pb2.SIGN_MODE_UNSPECIFIED))\n\n    signer_info = cosmos_tx.SignerInfo(\n        public_key=None,  # populated later before signing\n        mode_info=mode_info,\n        sequence=sequence,\n    )\n\n    auth_info = cosmos_tx.AuthInfo(\n        signer_infos=[signer_info],\n        fee=cosmos_tx.Fee(amount=[fee_coin], gas_limit=gas_limit, payer='', granter=''),\n    )\n\n    unsigned_tx = cosmos_tx.Tx(body=body, auth_info=auth_info, signatures=[])\n\n    body_bytes = body.SerializeToString()\n    auth_info_bytes = auth_info.SerializeToString()\n    unsigned_tx_bytes = unsigned_tx.SerializeToString()\n    unsigned_tx_b64 = base64.b64encode(unsigned_tx_bytes).decode()\n\n    return {\n        'body_bytes': body_bytes,\n        'auth_info_bytes': auth_info_bytes,\n        'unsigned_tx_bytes': unsigned_tx_bytes,\n        'unsigned_tx_b64': unsigned_tx_b64,\n        'gas_limit': gas_limit,\n        'gas_price': gas_price,\n        'fee_amount': fee_amount,\n        'fee_denom': fee_denom,\n        'sequence': sequence,\n    }\n",
	"bff_sign_instantiate_tx": "def bff_sign_instantiate_tx(\n    body_bytes: bytes,\n    auth_info_bytes: bytes,\n    account_number: int,\n    chain_id: str,\n    privkey_hex: str,\n    public_key_bytes: bytes,\n) -> Dict[str, Any]:\n    '''Sign the instantiate Tx using a local secp256k1 private key.'''\n    if not privkey_hex:\n        raise ValueError('privkey_hex must be provided')\n\n    # Decode TxBody and AuthInfo\n    body = cosmos_tx.TxBody()\n    auth_info = cosmos_tx.AuthInfo()\n    try:\n        body.ParseFromString(body_bytes)\n        auth_info.ParseFromString(auth_info_bytes)\n    except Exception as e:\n        raise ValueError(f'Failed to parse TxBody/AuthInfo: {e}') from e\n\n    if not auth_info.signer_infos:\n        raise ValueError('AuthInfo.signer_infos is empty; cannot attach signer')\n\n    # Attach the public key to the first signer\n    pubkey = secp256k1_keys.PubKey(key=public_key_bytes)\n    pubkey_any = ProtoAny(type_url='/cosmos.crypto.secp256k1.PubKey', value=pubkey.SerializeToString())\n    auth_info.signer_infos[0].public_key.CopyFrom(pubkey_any)\n\n    # Re-serialize AuthInfo now that it includes the public key\n    auth_info_bytes = auth_info.SerializeToString()\n\n    # Build SignDoc\n    sign_doc = cosmos_tx.SignDoc(\n        body_bytes=body_bytes,\n        auth_info_bytes=auth_info_bytes,\n        chain_id=chain_id,\n        account_number=account_number,\n    )\n\n    sign_bytes = sign_doc.SerializeToString()\n    digest = sha256(sign_bytes).digest()\n\n    try:\n        sk = SigningKey.from_string(bytes.fromhex(privkey_hex), curve=SECP256k1)\n    except Exception as e:\n        raise ValueError(f'Invalid privkey_hex: {e}') from e\n\n    signature = sk.sign_digest(digest, sigencode=ecdsa_util.sigencode_string_canonize)\n\n    tx = cosmos_tx.Tx(body=body, auth_info=auth_info, signatures=[signature])\n    tx_bytes = tx.SerializeToString()\n    tx_b64 = base64.b64encode(tx_bytes).decode()\n\n    return {\n        'tx_bytes': tx_bytes,\n        'tx_b64': tx_b64,\n    }\n",
	"lcd_parse_instantiate_events": "def lcd_parse_instantiate_events(txhash: str, tx_response: Optional[Dict[str, Any]] = None) -> str:\n    '''Extract the instantiated contract address from tx logs/events.'''\n    # If a tx_response is provided, ensure the transaction succeeded\n    if tx_response is not None:\n        code_val = tx_response.get('code')\n        try:\n            code_int = int(code_val)\n        except (TypeError, ValueError):\n            code_int = None\n        if code_int not in (None, 0):\n            raise ValueError(f'Transaction {txhash} failed with non-zero code {code_int}')\n\n    if not tx_response or not tx_response.get('logs'):\n        # Fetch full tx by hash if we do not have logs yet\n        try:\n            async with httpx.AsyncClient(base_url=BASE_URL, timeout=20.0) as client:\n                resp = await client.get(f'/cosmos/tx/v1beta1/txs/{txhash}')\n        except httpx.RequestError as e:\n            raise RuntimeError(f'Network error while fetching tx by hash {txhash}: {e}') from e\n\n        if resp.status_code != 200:\n            raise ValueError(f'Failed to fetch tx {txhash}: HTTP {resp.status_code} {resp.text}')\n\n        data = resp.json()\n        tx_response = data.get('tx_response') or {}\n        if not tx_response:\n            raise ValueError(f'LCD response for tx {txhash} did not contain tx_response')\n\n    logs = tx_response.get('logs') or []\n\n    for log in logs:\n        events = log.get('events') or []\n        for event in events:\n            ev_type = event.get('type')\n            if ev_type not in ('instantiate', 'wasm'):\n                continue\n            for attr in event.get('attributes') or []:\n                key = attr.get('key')\n                value = attr.get('value')\n                if key in ('_contract_address', 'contract_address') and value:\n                    return value\n\n    raise ValueError('Could not find instantiated contract address in tx events')\n",
	"lcd_verify_contract_info": "def lcd_verify_contract_info(contract_address: str, expected_code_id: int, expected_creator: str) -> Dict[str, Any]:\n    '''Verify that a contract exists on-chain and matches the expected code id and creator.'''\n    try:\n        async with httpx.AsyncClient(base_url=BASE_URL, timeout=20.0) as client:\n            resp = await client.get(f'/cosmwasm/wasm/v1/contract/{contract_address}')\n    except httpx.RequestError as e:\n        raise RuntimeError(f'Network error while fetching contract info: {e}') from e\n\n    if resp.status_code != 200:\n        raise ValueError(f'Failed to fetch contract info: HTTP {resp.status_code} {resp.text}')\n\n    data = resp.json()\n    contract_info = data.get('contract_info') or {}\n\n    if not contract_info:\n        raise ValueError('LCD response did not contain contract_info')\n\n    code_id_on_chain = str(contract_info.get('code_id', '')).strip()\n    expected_code_id_str = str(expected_code_id)\n    if code_id_on_chain != expected_code_id_str:\n        raise ValueError(f'Contract code_id mismatch: on-chain {code_id_on_chain}, expected {expected_code_id_str}')\n\n    creator_on_chain = contract_info.get('creator')\n    if creator_on_chain != expected_creator:\n        raise ValueError(f'Contract creator mismatch: on-chain {creator_on_chain}, expected {expected_creator}')\n\n    return contract_info\n",
	"check_junod_installed": "def check_junod_installed() -> Dict[str, str]:\n    '''\n    Ensure the 'junod' binary is installed by running 'junod version --long'.\n    Returns a dict with installation status and raw output.\n    Raises RuntimeError with a helpful message if the binary is missing or the command fails.\n    '''\n    try:\n        result = subprocess.run(\n            ['junod', 'version', '--long'],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found on the host system. '\n            'Install junod and make sure it is on the PATH before continuing.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod version --long failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    return {\n        'installed': True,\n        'output': result.stdout.strip(),\n    }\n",
	"set_junod_node": "def set_junod_node(node_url: str) -> Dict[str, str]:\n    '''\n    Configure junod to use the given node_url by running 'junod config node NODE_URL'.\n    node_url must include scheme and port, for example 'http://localhost:26657'.\n    '''\n    if not node_url or not isinstance(node_url, str):\n        raise ValueError('node_url must be a non-empty string')\n\n    try:\n        result = subprocess.run(\n            ['junod', 'config', 'node', node_url],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found. Run check_junod_installed() first and ensure junod is on the PATH.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod config node {node_url} failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    return {\n        'node_url': node_url,\n        'stdout': result.stdout.strip(),\n    }\n",
	"set_junod_chain_id": "def set_junod_chain_id(chain_id: str = 'uni-6') -> Dict[str, str]:\n    '''\n    Configure junod to use the provided chain_id (defaults to 'uni-6').\n    This wraps 'junod config chain-id <chain_id>'.\n    '''\n    if not chain_id or not isinstance(chain_id, str):\n        raise ValueError('chain_id must be a non-empty string')\n\n    try:\n        result = subprocess.run(\n            ['junod', 'config', 'chain-id', chain_id],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found. Run check_junod_installed() first and ensure junod is on the PATH.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod config chain-id {chain_id} failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    return {\n        'chain_id': chain_id,\n        'stdout': result.stdout.strip(),\n    }\n",
	"set_junod_output_json": "def set_junod_output_json() -> Dict[str, str]:\n    '''\n    Optionally configure junod to output json by default using 'junod config output json'.\n    This is useful if you plan to parse junod output programmatically.\n    '''\n    try:\n        result = subprocess.run(\n            ['junod', 'config', 'output', 'json'],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found. Run check_junod_installed() first and ensure junod is on the PATH.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod config output json failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    return {\n        'output_format': 'json',\n        'stdout': result.stdout.strip(),\n    }\n",
	"_extract_network_field": "def _extract_network_field(data: Any) -> str:\n    '''\n    Internal helper to robustly extract the network or chain-id field from various\n    possible junod status JSON layouts.\n    '''\n    if not isinstance(data, dict):\n        return ''\n\n    # Common layouts to try, in order\n    candidate_paths = [\n        ('node_info', 'network'),\n        ('NodeInfo', 'network'),\n        ('result', 'node_info', 'network'),\n        ('Result', 'node_info', 'network'),\n    ]\n\n    for path in candidate_paths:\n        cursor: Any = data\n        for key in path:\n            if isinstance(cursor, dict) and key in cursor:\n                cursor = cursor[key]\n            else:\n                cursor = None\n                break\n        if isinstance(cursor, str) and cursor:\n            return cursor\n\n    return ''\n\n\ndef test_junod_connectivity(node_url: str, expected_chain_id: str = 'uni-6') -> Dict[str, Any]:\n    '''\n    Run 'junod status --node NODE_URL', parse the JSON output, and confirm that\n    the node is reachable and its reported network or chain-id matches expected_chain_id.\n    Raises RuntimeError on connectivity issues, non-json output, or chain-id mismatch.\n    '''\n    if not node_url or not isinstance(node_url, str):\n        raise ValueError('node_url must be a non-empty string')\n\n    try:\n        result = subprocess.run(\n            ['junod', 'status', '--node', node_url],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except FileNotFoundError:\n        raise RuntimeError(\n            'The junod binary was not found. Run check_junod_installed() first and ensure junod is on the PATH.'\n        )\n    except subprocess.CalledProcessError as exc:\n        raise RuntimeError(\n            f'junod status --node {node_url} failed with exit code {exc.returncode}: {exc.stderr.strip()}'\n        )\n\n    raw = result.stdout.strip()\n    try:\n        status_json = json.loads(raw)\n    except json.JSONDecodeError as exc:\n        raise RuntimeError(\n            f'Failed to decode junod status output as json: {exc}. Raw output was: {raw}'\n        )\n\n    network = _extract_network_field(status_json)\n    if not network:\n        raise RuntimeError(\n            'Could not locate node_info.network or equivalent field in junod status output.'\n        )\n\n    if network != expected_chain_id:\n        raise RuntimeError(\n            f'Connected node reports chain-id {network}, but expected {expected_chain_id}.'\n        )\n\n    return {\n        'ok': True,\n        'node_url': node_url,\n        'reported_chain_id': network,\n        'raw_status': status_json,\n    }\n",
	"validate_tx_hash": "def validate_tx_hash(tx_hash: str) -> str:\n    \"\"\"Validate that tx_hash is a 64-character hex string.\n\n    Returns the normalized (lowercase) hash or raises TxValidationError.\n    \"\"\"\n    if not isinstance(tx_hash, str):\n        raise TxValidationError(\"Transaction hash must be a string.\")\n\n    normalized = tx_hash.strip()\n\n    # Must be exactly 64 hex characters (0-9, a-f, A-F)\n    if not re.fullmatch(r\"[0-9a-fA-F]{64}\", normalized):\n        raise TxValidationError(\n            \"Invalid transaction hash format. Expected a 64-character hex string.\"\n        )\n\n    return normalized.lower()\n",
	"fetch_tx_by_hash": "def fetch_tx_by_hash(tx_hash: str) -> Dict[str, Any]:\n    \"\"\"Fetch a transaction and its tx_response from the Juno LCD by hash.\n\n    This function validates the hash format and then performs an HTTP GET.\n    It returns a dict with keys `status_code` and `data` (parsed JSON body).\n    \"\"\"\n    # Reuse step 1 validation\n    normalized_hash = validate_tx_hash(tx_hash)\n\n    url = f\"{BASE_LCD_URL}/cosmos/tx/v1beta1/txs/{normalized_hash}\"\n\n    try:\n        response = requests.get(url, timeout=10)\n    except requests.RequestException as exc:\n        raise LcdRequestError(f\"Failed to reach LCD endpoint: {exc}\") from exc\n\n    try:\n        payload = response.json()\n    except ValueError as exc:\n        # Non-JSON or malformed response\n        raise LcdRequestError(\n            f\"LCD returned non-JSON response with status {response.status_code}.\"\n        ) from exc\n\n    return {\"status_code\": response.status_code, \"data\": payload}\n",
	"check_tx_found_and_success": "def check_tx_found_and_success(status_code: int, payload: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Validate LCD HTTP status and tx_response.code.\n\n    Returns the tx_response dict on success or raises TxQueryError otherwise.\n    \"\"\"\n    if status_code != 200:\n        # Include as much context as is reasonably safe\n        message = payload.get(\"message\") if isinstance(payload, dict) else None\n        raise TxQueryError(\n            f\"LCD query failed with HTTP status {status_code}. \"\n            f\"Message: {message or payload}\"\n        )\n\n    tx_response = payload.get(\"tx_response\") if isinstance(payload, dict) else None\n    if tx_response is None:\n        raise TxQueryError(\"LCD response missing 'tx_response' field.\")\n\n    code = tx_response.get(\"code\")\n    raw_log = tx_response.get(\"raw_log\", \"\")\n\n    if code is None:\n        raise TxQueryError(\"'tx_response.code' is missing in LCD response.\")\n\n    if code != 0:\n        # Non-zero code indicates on-chain failure; include raw_log if available\n        raise TxQueryError(\n            f\"Transaction execution failed with code {code}. raw_log: {raw_log}\"\n        )\n\n    return tx_response\n",
	"extract_code_id_from_events": "def extract_code_id_from_events(tx_response: Dict[str, Any]) -> List[Dict[str, Any]]:\n    \"\"\"Extract candidate code IDs from tx_response.logs events.\n\n    Looks for events of type 'store_code' or 'instantiate' with an attribute\n    whose key is exactly 'code_id'. Returns a list of dicts containing the\n    code_id and minimal context (event type and indices).\n    \"\"\"\n    candidates: List[Dict[str, Any]] = []\n\n    logs = tx_response.get(\"logs\") or []\n    if not isinstance(logs, list):\n        return candidates\n\n    for log_index, log in enumerate(logs):\n        events = log.get(\"events\") or []\n        if not isinstance(events, list):\n            continue\n\n        for event_index, event in enumerate(events):\n            event_type = event.get(\"type\")\n            if event_type not in (\"store_code\", \"instantiate\"):\n                continue\n\n            attributes = event.get(\"attributes\") or []\n            if not isinstance(attributes, list):\n                continue\n\n            for attribute_index, attr in enumerate(attributes):\n                key = attr.get(\"key\")\n                if key != \"code_id\":\n                    continue\n\n                value = attr.get(\"value\")\n                if value is None:\n                    continue\n\n                candidates.append(\n                    {\n                        \"code_id\": str(value),\n                        \"event_type\": event_type,\n                        \"log_index\": log_index,\n                        \"event_index\": event_index,\n                        \"attribute_index\": attribute_index,\n                    }\n                )\n\n    return candidates\n",
	"fallback_parse_raw_log_for_code_id": "def fallback_parse_raw_log_for_code_id(tx_response: Dict[str, Any]) -> Optional[str]:\n    \"\"\"Attempt to parse a code_id from tx_response.raw_log using regex.\n\n    This is used only when structured events do not expose a code_id.\n    Returns the extracted code_id string or None if no match is found.\n    \"\"\"\n    raw_log = tx_response.get(\"raw_log\", \"\")\n    if not raw_log or not isinstance(raw_log, str):\n        return None\n\n    # Regex is intentionally permissive to handle formats like:\n    # - \"code_id\":\"12\"\n    # - code_id: 12\n    # - code_id = \"12\"\n    pattern = re.compile(r\"code_id[\\\"']?\\s*[:=]\\s*\\\"?(\\d+)\\\"?\", re.IGNORECASE)\n    match = pattern.search(raw_log)\n\n    if not match:\n        return None\n\n    return match.group(1)\n",
	"return_code_id": "def return_code_id(\n    event_candidates: List[Dict[str, Any]],\n    fallback_code_id: Optional[str],\n) -> Dict[str, Any]:\n    \"\"\"Resolve code_id(s) from event candidates and fallback value.\n\n    - If one unique code_id is found in events, return {\"code_id\": <id>, \"source\": \"events\"}.\n    - If multiple distinct code_ids are found, return them with minimal context.\n    - If none in events but a fallback exists, return the fallback code_id.\n    - If no code_id can be found, raise CodeIdNotFoundError with an explicit message.\n    \"\"\"\n    # Deduplicate code_ids from events\n    unique_ids = list({c[\"code_id\"] for c in event_candidates})\n\n    if unique_ids:\n        if len(unique_ids) == 1:\n            return {\n                \"code_id\": unique_ids[0],\n                \"source\": \"events\",\n            }\n        else:\n            return {\n                \"code_ids\": unique_ids,\n                \"source\": \"events\",\n                \"details\": event_candidates,\n            }\n\n    # No event-based code_id, fall back to raw_log parsing\n    if fallback_code_id:\n        return {\n            \"code_id\": fallback_code_id,\n            \"source\": \"raw_log\",\n        }\n\n    # Nothing found at all\n    raise CodeIdNotFoundError(\n        \"This transaction does not include a CosmWasm store_code or \"\n        \"instantiate event exposing a code_id.\"\n    )\n\n\ndef get_code_id_from_tx_hash(tx_hash: str) -> Dict[str, Any]:\n    \"\"\"High-level helper that runs all steps 16 for a given transaction hash.\n\n    This function:\n    1. Validates the tx hash.\n    2. Fetches the transaction from the LCD.\n    3. Ensures the tx exists and succeeded (code == 0).\n    4. Extracts code_id candidates from structured events.\n    5. Optionally parses raw_log for a fallback code_id.\n    6. Returns a resolved code_id result or raises CodeIdNotFoundError.\n    \"\"\"\n    # Step 2: fetch from LCD (includes step 1 validation internally)\n    fetch_result = fetch_tx_by_hash(tx_hash)\n\n    # Step 3: ensure tx found and successful\n    tx_response = check_tx_found_and_success(\n        fetch_result[\"status_code\"], fetch_result[\"data\"]\n    )\n\n    # Step 4: extract from events\n    event_candidates = extract_code_id_from_events(tx_response)\n\n    # Step 5: fallback raw_log parsing only if no event-based code_id\n    fallback_code_id = None\n    if not event_candidates:\n        fallback_code_id = fallback_parse_raw_log_for_code_id(tx_response)\n\n    # Step 6: resolve result\n    return return_code_id(event_candidates, fallback_code_id)\n",
	"_load_toml": "def _load_toml(path: Path) -> dict:\n    '''Load a TOML file using tomllib if available.\n\n    Args:\n        path: Path to the TOML file.\n\n    Returns:\n        Parsed TOML as a dict.\n    '''\n    if not path.is_file():\n        raise FileNotFoundError(f'TOML file not found: {path}')\n\n    data = path.read_bytes()\n    if tomllib is None:\n        try:\n            import toml  # type: ignore\n        except ModuleNotFoundError as exc:\n            raise RuntimeError('No TOML parser available. Install toml or use Python 3.11+.') from exc\n        return toml.loads(data.decode('utf-8'))\n    return tomllib.loads(data.decode('utf-8'))\n\n\ndef detect_workspace_root(start_dir: Optional[str] = None) -> dict:\n    '''Locate the Cargo workspace root starting from start_dir and walking upwards.\n\n    A workspace root is defined as a directory containing Cargo.toml with a\n    top-level [workspace] section.\n\n    Args:\n        start_dir: Directory to start searching from. Defaults to current working directory.\n\n    Returns:\n        A JSON-serializable dict with the resolved workspace_root path.\n\n    Raises:\n        WorkspaceNotFoundError: If no workspace root can be located.\n        InvalidWorkspaceError: If a Cargo.toml is found but is not a workspace.\n    '''\n    if start_dir is None:\n        current = Path.cwd().resolve()\n    else:\n        current = Path(start_dir).expanduser().resolve()\n\n    for directory in [current] + list(current.parents):\n        cargo_toml = directory / 'Cargo.toml'\n        if not cargo_toml.is_file():\n            continue\n        try:\n            data = _load_toml(cargo_toml)\n        except Exception as exc:\n            raise RuntimeError(f'Failed to parse {cargo_toml}: {exc}') from exc\n\n        if 'workspace' in data:\n            # Found the workspace root\n            return {'workspace_root': str(directory)}\n        # If this Cargo.toml does not define a workspace, keep walking upward.\n\n    raise WorkspaceNotFoundError(f'No Cargo workspace root found starting from {current}')\n\n\nif __name__ == '__main__':\n    # Example CLI usage\n    try:\n        result = detect_workspace_root()\n        print(result['workspace_root'])\n    except Exception as e:\n        # Print to stderr to avoid interfering with JSON consumers\n        import sys\n        print(f'Error: {e}', file=sys.stderr)\n        sys.exit(1)\n",
	"_resolve_workspace_root": "def _resolve_workspace_root(workspace_root: Optional[str] = None) -> Path:\n    '''Resolve the workspace root directory, using detect_workspace_root if needed.\n\n    This helper builds on detect_workspace_root defined in step 1.\n    '''\n    if workspace_root:\n        root = Path(workspace_root).expanduser().resolve()\n    else:\n        info = detect_workspace_root()\n        root = Path(info['workspace_root']).resolve()\n\n    if not root.is_dir():\n        raise FileNotFoundError(f'Workspace root directory does not exist: {root}')\n    return root\n\n\ndef list_workspace_members(workspace_root: Optional[str] = None) -> dict:\n    '''Parse the workspace Cargo.toml and list member contract packages.\n\n    Each member is validated to ensure it has its own Cargo.toml and appears to\n    be a CosmWasm contract (lib.crate-type contains cdylib).\n\n    Args:\n        workspace_root: Optional explicit workspace root. If omitted, detect_workspace_root is used.\n\n    Returns:\n        Dict containing workspace_root, valid_members, and invalid_members.\n    '''\n    root = _resolve_workspace_root(workspace_root)\n    cargo_toml = root / 'Cargo.toml'\n\n    try:\n        data = _load_toml(cargo_toml)\n    except Exception as exc:\n        raise RuntimeError(f'Failed to parse root Cargo.toml at {cargo_toml}: {exc}') from exc\n\n    workspace = data.get('workspace')\n    if not isinstance(workspace, dict):\n        raise WorkspaceMemberError('Root Cargo.toml does not contain a valid [workspace] table.')\n\n    member_patterns = workspace.get('members', [])\n    if not isinstance(member_patterns, list) or not member_patterns:\n        raise WorkspaceMemberError('Workspace has no members defined under [workspace].')\n\n    valid_members: List[Dict[str, str]] = []\n    invalid_members: List[Dict[str, str]] = []\n\n    for pattern in member_patterns:\n        if not isinstance(pattern, str):\n            invalid_members.append(\n                {\n                    'pattern': repr(pattern),\n                    'reason': 'Workspace member pattern is not a string.',\n                }\n            )\n            continue\n\n        matches = list(root.glob(pattern))\n        if not matches:\n            invalid_members.append(\n                {\n                    'pattern': pattern,\n                    'reason': 'Workspace member pattern did not match any paths.',\n                }\n            )\n            continue\n\n        for member_dir in matches:\n            if not member_dir.is_dir():\n                invalid_members.append(\n                    {\n                        'path': str(member_dir),\n                        'reason': 'Matched workspace member is not a directory.',\n                    }\n                )\n                continue\n\n            member_cargo = member_dir / 'Cargo.toml'\n            if not member_cargo.is_file():\n                invalid_members.append(\n                    {\n                        'path': str(member_dir),\n                        'reason': 'Workspace member is missing Cargo.toml.',\n                    }\n                )\n                continue\n\n            try:\n                member_data = _load_toml(member_cargo)\n            except Exception as exc:\n                invalid_members.append(\n                    {\n                        'path': str(member_dir),\n                        'reason': f'Failed to parse Cargo.toml: {exc}',\n                    }\n                )\n                continue\n\n            pkg = member_data.get('package', {})\n            name = pkg.get('name', member_dir.name)\n\n            lib_cfg = member_data.get('lib')\n            is_valid_contract = False\n            failure_reason = ''\n\n            if isinstance(lib_cfg, dict):\n                crate_type = lib_cfg.get('crate-type') or lib_cfg.get('crate_type')\n                if isinstance(crate_type, list) and 'cdylib' in crate_type:\n                    is_valid_contract = True\n                else:\n                    failure_reason = 'lib.crate-type must contain cdylib for CosmWasm.'\n            else:\n                failure_reason = 'Missing [lib] section in contract Cargo.toml.'\n\n            if is_valid_contract:\n                valid_members.append(\n                    {\n                        'name': name,\n                        'path': str(member_dir),\n                    }\n                )\n            else:\n                invalid_members.append(\n                    {\n                        'name': name,\n                        'path': str(member_dir),\n                        'reason': failure_reason or 'Invalid CosmWasm contract configuration.',\n                    }\n                )\n\n    return {\n        'workspace_root': str(root),\n        'valid_members': valid_members,\n        'invalid_members': invalid_members,\n    }\n",
	"run_workspace_optimizer": "def run_workspace_optimizer(\n    workspace_root: Optional[str] = None,\n    optimizer_image: str = 'cosmwasm/workspace-optimizer:0.13.0',\n    timeout: int = 1800,\n) -> dict:\n    '''Run the CosmWasm workspace-optimizer Docker image for the workspace.\n\n    Args:\n        workspace_root: Optional explicit workspace root. If omitted, detect_workspace_root is used.\n        optimizer_image: Docker image name for the workspace optimizer.\n        timeout: Maximum time in seconds to wait for the optimizer to finish.\n\n    Returns:\n        Dict with workspace_root, optimizer_image, stdout, stderr, and return_code.\n\n    Raises:\n        OptimizerError: If Docker is unavailable or the optimizer fails.\n    '''\n    # Reuse helper from step 2 to resolve the workspace root.\n    root = _resolve_workspace_root(workspace_root)\n\n    # Verify that Docker is available before trying to run the container.\n    try:\n        docker_check = subprocess.run(\n            ['docker', '--version'],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            check=False,\n        )\n    except FileNotFoundError as exc:\n        raise OptimizerError('Docker is not installed or not available in PATH.') from exc\n    except Exception as exc:\n        raise OptimizerError(f'Failed to run docker --version: {exc}') from exc\n\n    if docker_check.returncode != 0:\n        raise OptimizerError(f'Docker is not available: {docker_check.stderr.strip()}')\n\n    cmd = [\n        'docker',\n        'run',\n        '--rm',\n        '-v',\n        f'{str(root)}:/code',\n        '--mount',\n        f'type=volume,source={root.name}_cache,target=/code/target',\n        '--mount',\n        'type=volume,source=registry_cache,target=/usr/local/cargo/registry',\n        optimizer_image,\n    ]\n\n    try:\n        completed = subprocess.run(\n            cmd,\n            cwd=str(root),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            timeout=timeout,\n            check=False,\n        )\n    except subprocess.TimeoutExpired as exc:\n        raise OptimizerError(f'workspace-optimizer timed out after {timeout} seconds.') from exc\n    except Exception as exc:\n        raise OptimizerError(f'workspace-optimizer failed to start: {exc}') from exc\n\n    if completed.returncode != 0:\n        raise OptimizerError(\n            'workspace-optimizer failed with exit code '\n            f'{completed.returncode}: {completed.stderr.strip()}'\n        )\n\n    return {\n        'workspace_root': str(root),\n        'optimizer_image': optimizer_image,\n        'stdout': completed.stdout,\n        'stderr': completed.stderr,\n        'return_code': completed.returncode,\n    }\n",
	"_is_valid_wasm": "def _is_valid_wasm(path: Path) -> bool:\n    '''Perform a basic sanity check on a wasm binary.\n\n    Checks that the file exists, is non-empty, and starts with the standard\n    WebAssembly magic header (0x00 0x61 0x73 0x6d).\n    '''\n    if not path.is_file():\n        return False\n    if path.stat().st_size == 0:\n        return False\n    try:\n        with path.open('rb') as f:\n            magic = f.read(4)\n        return magic == b'\\0asm'\n    except Exception:\n        return False\n\n\ndef collect_and_verify_wasm_outputs(\n    workspace_root: Optional[str] = None,\n    members: Optional[List[Dict[str, Any]]] = None,\n    artifacts_dir_name: str = 'artifacts',\n) -> dict:\n    '''Collect and validate wasm outputs for each workspace member.\n\n    Args:\n        workspace_root: Optional explicit workspace root. If omitted, detect_workspace_root is used.\n        members: Optional list of member metadata as returned by list_workspace_members.\n        artifacts_dir_name: Name of the directory under the workspace root where\n            optimized wasm artifacts are written.\n\n    Returns:\n        Dict with workspace_root, artifacts_dir, verified_contracts, failed_contracts.\n    '''\n    root = _resolve_workspace_root(workspace_root)\n    artifacts_dir = root / artifacts_dir_name\n\n    if not artifacts_dir.is_dir():\n        raise ArtifactVerificationError(f'Artifacts directory does not exist: {artifacts_dir}')\n\n    if members is None:\n        # Use helper from step 2 to discover members.\n        members_info = list_workspace_members(str(root))\n        members = members_info.get('valid_members', [])\n\n    verified: List[Dict[str, Any]] = []\n    failed: List[Dict[str, Any]] = []\n\n    for member in members:\n        name = member.get('name')\n        if not name:\n            failed.append({'member': member, 'reason': 'Missing contract name in member metadata.'})\n            continue\n\n        artifact_path = artifacts_dir / f'{name}.wasm'\n        if not artifact_path.is_file():\n            failed.append(\n                {\n                    'member': member,\n                    'artifact_path': str(artifact_path),\n                    'reason': 'Wasm artifact file is missing.',\n                }\n            )\n            continue\n\n        if not _is_valid_wasm(artifact_path):\n            failed.append(\n                {\n                    'member': member,\n                    'artifact_path': str(artifact_path),\n                    'reason': 'Wasm artifact failed basic validation (magic header or size).',\n                }\n            )\n            continue\n\n        verified.append(\n            {\n                'member': member,\n                'artifact_path': str(artifact_path),\n                'size_bytes': artifact_path.stat().st_size,\n            }\n        )\n\n    return {\n        'workspace_root': str(root),\n        'artifacts_dir': str(artifacts_dir),\n        'verified_contracts': verified,\n        'failed_contracts': failed,\n    }\n",
	"validate_contract_address_format": "def validate_contract_address_format(contract_address: str) -> str:\n    '''Validate that the contract address is a non-empty Juno bech32 address.\n\n    Args:\n        contract_address: The contract address string to validate.\n\n    Returns:\n        The original contract address if it is valid.\n\n    Raises:\n        ContractAddressValidationError: If the address is empty or invalid.\n    '''\n    if contract_address is None:\n        raise ContractAddressValidationError('Contract address is required.')\n\n    contract_address = contract_address.strip()\n    if not contract_address:\n        raise ContractAddressValidationError('Contract address cannot be empty or whitespace.')\n\n    # Basic bech32-style validation for Juno contract/account addresses.\n    # Juno addresses are lower-case and typically start with 'juno1'.\n    pattern = re.compile(r'^juno1[0-9a-z]{38}$')\n    if not pattern.fullmatch(contract_address):\n        raise ContractAddressValidationError(\n            'Invalid Juno contract address format. Expected a bech32 address starting with prefix juno1.'\n        )\n\n    return contract_address\n",
	"build_query_json_string": "def build_query_json_string(query: Union[str, dict]) -> str:\n    '''Normalize the high-level query into a compact JSON string.\n\n    The input can be either a JSON string or a Python dict; this helper\n    validates and normalizes it.\n    '''\n    try:\n        if isinstance(query, str):\n            # Validate JSON string and normalize formatting.\n            parsed = json.loads(query)\n        elif isinstance(query, dict):\n            parsed = query\n        else:\n            raise QueryBuildError('Query must be a dict or JSON string.')\n    except (json.JSONDecodeError, TypeError) as exc:\n        raise QueryBuildError(f'Invalid query JSON: {exc}') from exc\n\n    # Serialize without extra whitespace and keep UTF-8 characters intact.\n    return json.dumps(parsed, separators=(',', ':'), ensure_ascii=False)\n",
	"http_get_lcd_smart_query": "def http_get_lcd_smart_query(contract_address: str, encoded_query: str) -> dict:\n    '''Perform an HTTP GET to the Juno LCD smart query endpoint.\n\n    Args:\n        contract_address: Validated Juno contract address.\n        encoded_query: URL-safe base64 string produced from the JSON query.\n\n    Returns:\n        Parsed JSON body from the LCD response as a Python dict.\n\n    Raises:\n        SmartQueryHttpError: If the request fails or the response is invalid.\n    '''\n    if not contract_address or not encoded_query:\n        raise SmartQueryHttpError('Both contract_address and encoded_query are required.')\n\n    url = f'{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{encoded_query}'\n    headers = {\n        'Accept': 'application/json',\n    }\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            response = await client.get(url, headers=headers)\n    except httpx.RequestError as exc:\n        raise SmartQueryHttpError(f'Network error while querying LCD: {exc}') from exc\n\n    if response.status_code != 200:\n        # Include body text when possible to make debugging easier.\n        body_text = response.text\n        raise SmartQueryHttpError(\n            f'LCD smart query failed with status {response.status_code}: {body_text}'\n        )\n\n    try:\n        return response.json()\n    except ValueError as exc:\n        raise SmartQueryHttpError(f'Failed to parse LCD JSON response: {exc}') from exc\n",
	"parse_lcd_smart_query_response": "def parse_lcd_smart_query_response(response_json: t.Mapping[str, t.Any]) -> str:\n    '''Extract the base64-encoded contract response data from the LCD JSON body.\n\n    Args:\n        response_json: Parsed JSON returned from the LCD smart query endpoint.\n\n    Returns:\n        The base64-encoded data field representing the contract response.\n\n    Raises:\n        SmartQueryParseError: If the response is missing the data field or is malformed.\n    '''\n    if response_json is None:\n        raise SmartQueryParseError('LCD response JSON is required.')\n\n    if not isinstance(response_json, dict):\n        raise SmartQueryParseError('LCD response JSON must be a dict.')\n\n    if 'data' not in response_json:\n        raise SmartQueryParseError('LCD smart query response missing required field data.')\n\n    data_field = response_json['data']\n    if not isinstance(data_field, str) or not data_field:\n        raise SmartQueryParseError('LCD smart query data field must be a non-empty base64 string.')\n\n    return data_field\n",
	"decode_contract_response_data": "def decode_contract_response_data(data_b64: str) -> Any:\n    '''Decode base64 contract response bytes and parse them as UTF-8 JSON.\n\n    Args:\n        data_b64: Base64-encoded string taken from the LCD smart query response data field.\n\n    Returns:\n        Parsed Python object representing the contract query response.\n\n    Raises:\n        ContractResponseDecodeError: If decoding or JSON parsing fails.\n    '''\n    if not isinstance(data_b64, str) or not data_b64:\n        raise ContractResponseDecodeError('data_b64 must be a non-empty base64 string.')\n\n    try:\n        raw_bytes = base64.b64decode(data_b64)\n    except Exception as exc:\n        raise ContractResponseDecodeError(f'Failed to base64-decode contract data: {exc}') from exc\n\n    try:\n        text = raw_bytes.decode('utf-8')\n    except UnicodeDecodeError as exc:\n        raise ContractResponseDecodeError(f'Contract data is not valid UTF-8: {exc}') from exc\n\n    try:\n        return json.loads(text)\n    except json.JSONDecodeError as exc:\n        raise ContractResponseDecodeError(f'Contract data is not valid JSON: {exc}') from exc\n",
	"read_and_validate_wasm_artifact": "def read_and_validate_wasm_artifact(contract_name: str, artifacts_dir: str = \"artifacts\") -> bytes:\n    \"\"\"Read artifacts/CONTRACT_NAME.wasm and validate it is a proper wasm binary.\n\n    :param contract_name: Logical contract name (without .wasm extension).\n    :param artifacts_dir: Directory where wasm artifacts are stored.\n    :return: Raw wasm file bytes.\n    :raises WasmArtifactError: If file is missing, empty, or invalid.\n    \"\"\"\n    # Build path like artifacts/CONTRACT_NAME.wasm\n    wasm_path = Path(artifacts_dir) / f\"{contract_name}.wasm\"\n\n    if not wasm_path.exists() or not wasm_path.is_file():\n        raise WasmArtifactError(f\"Wasm artifact not found at {wasm_path!s}\")\n\n    try:\n        wasm_bytes = wasm_path.read_bytes()\n    except OSError as exc:\n        raise WasmArtifactError(f\"Failed to read wasm artifact: {exc}\") from exc\n\n    if not wasm_bytes:\n        raise WasmArtifactError(f\"Wasm artifact {wasm_path!s} is empty\")\n\n    # Validate magic bytes (first 4 bytes of a wasm module)\n    if wasm_bytes[:4] != WASM_MAGIC:\n        raise WasmArtifactError(\n            f\"Invalid wasm artifact {wasm_path!s}: missing magic bytes 0x00 0x61 0x73 0x6d\"\n        )\n\n    return wasm_bytes\n",
	"compute_wasm_checksum": "def compute_wasm_checksum(wasm_bytes: bytes) -> WasmChecksum:\n    \"\"\"Compute SHA-256 checksum for the wasm artifact.\n\n    :param wasm_bytes: Raw wasm bytes from the artifact.\n    :return: WasmChecksum containing digest bytes and hex string.\n    \"\"\"\n    if not isinstance(wasm_bytes, (bytes, bytearray)) or not wasm_bytes:\n        raise ValueError(\"wasm_bytes must be non-empty bytes\")\n\n    sha = hashlib.sha256()\n    sha.update(wasm_bytes)\n    digest = sha.digest()\n    hex_digest = sha.hexdigest()\n    return WasmChecksum(digest=digest, hex=hex_digest)\n",
	"get_chain_and_account_info": "def get_chain_and_account_info(address: str, lcd_url: str = LCD_URL) -> ChainAccountInfo:\n    \"\"\"Fetch chain-id and account metadata for the given Juno address.\n\n    This function performs two LCD calls:\n      1. /cosmos/base/tendermint/v1beta1/node_info -> chain-id (network)\n      2. /cosmos/auth/v1beta1/accounts/{address} -> account_number & sequence\n\n    :param address: Bech32 Juno address.\n    :param lcd_url: Base LCD endpoint.\n    :return: ChainAccountInfo with chain_id, account_number, sequence.\n    :raises ChainQueryError: On HTTP or decoding errors.\n    \"\"\"\n    async with httpx.AsyncClient(timeout=10) as client:\n        # (a) Fetch node_info to get chain-id\n        try:\n            node_resp = await client.get(f\"{lcd_url}/cosmos/base/tendermint/v1beta1/node_info\")\n            node_resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise ChainQueryError(f\"Failed to fetch node_info: {exc}\") from exc\n\n        node_data = node_resp.json()\n        try:\n            chain_id = node_data[\"default_node_info\"][\"network\"]\n        except (KeyError, TypeError) as exc:\n            raise ChainQueryError(f\"Unexpected node_info format: {node_data}\") from exc\n\n        # (b) Fetch account data to get account_number & sequence\n        try:\n            acct_resp = await client.get(f\"{lcd_url}/cosmos/auth/v1beta1/accounts/{address}\")\n            acct_resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise ChainQueryError(f\"Failed to fetch account info: {exc}\") from exc\n\n        acct_data = acct_resp.json()\n        try:\n            any_account = acct_data[\"account\"]\n            type_url = any_account[\"type_url\"]\n            value_b64 = any_account[\"value\"]\n        except (KeyError, TypeError) as exc:\n            raise ChainQueryError(f\"Unexpected account response format: {acct_data}\") from exc\n\n        # Decode the embedded BaseAccount proto from the Any.value field\n        try:\n            raw_bytes = base64.b64decode(value_b64)\n            base_account = auth_pb2.BaseAccount()\n            base_account.ParseFromString(raw_bytes)\n        except Exception as exc:  # protobuf or base64 errors\n            raise ChainQueryError(f\"Failed to decode BaseAccount from Any.value: {exc}\") from exc\n\n        return ChainAccountInfo(\n            chain_id=chain_id,\n            account_number=int(base_account.account_number),\n            sequence=int(base_account.sequence),\n        )\n",
	"construct_store_code_tx": "def construct_store_code_tx(\n    sender_address: str,\n    wasm_bytes: bytes,\n    gas_limit: int = 2_000_000,\n    fee_amount: str = \"500000\",\n    fee_denom: str = \"ujuno\",\n    memo: str = \"store wasm code\",\n) -> Tuple[cosmos_tx_pb2.Tx, str]:\n    \"\"\"Construct an unsigned Tx with a CosmWasm MsgStoreCode message.\n\n    :param sender_address: Bech32 address paying for the upload.\n    :param wasm_bytes: Raw wasm bytes of the contract.\n    :param gas_limit: Placeholder gas limit to be refined via simulation.\n    :param fee_amount: Placeholder fee amount in the given denom.\n    :param fee_denom: Fee denomination (Juno mainnet uses 'ujuno').\n    :param memo: Optional memo for the tx.\n    :return: (Tx protobuf object, base64-encoded tx bytes).\n    \"\"\"\n    if not wasm_bytes:\n        raise ValueError(\"wasm_bytes must be non-empty\")\n\n    # Build MsgStoreCode\n    msg = MsgStoreCode(\n        sender=sender_address,\n        wasm_byte_code=wasm_bytes,\n    )\n\n    msg_any = Any(\n        type_url=\"/cosmwasm.wasm.v1.MsgStoreCode\",\n        value=msg.SerializeToString(),\n    )\n\n    # Tx body with a single message\n    tx_body = cosmos_tx_pb2.TxBody(\n        messages=[msg_any],\n        memo=memo,\n    )\n\n    # Placeholder fee; gas_limit will be updated after simulation\n    fee_coin = coin_pb2.Coin(denom=fee_denom, amount=fee_amount)\n    fee = cosmos_tx_pb2.Fee(\n        amount=[fee_coin],\n        gas_limit=gas_limit,\n    )\n\n    # Leave signer_infos empty for now; this is an unsigned tx\n    auth_info = cosmos_tx_pb2.AuthInfo(fee=fee)\n\n    tx = cosmos_tx_pb2.Tx(\n        body=tx_body,\n        auth_info=auth_info,\n        signatures=[],  # will be filled after signing\n    )\n\n    tx_bytes = tx.SerializeToString()\n    tx_bytes_b64 = base64.b64encode(tx_bytes).decode()\n\n    return tx, tx_bytes_b64\n",
	"simulate_and_update_fee": "def simulate_and_update_fee(\n    tx: cosmos_tx_pb2.Tx,\n    lcd_url: str = LCD_URL,\n    gas_adjustment: float = 1.3,\n    gas_price_ujuno: Decimal = Decimal(\"0.075\"),  # 0.075 ujuno per gas (example)\n    fee_denom: str = \"ujuno\",\n) -> Tuple[cosmos_tx_pb2.Tx, int, int]:\n    \"\"\"Simulate the Tx to estimate gas and update fee/gas_limit accordingly.\n\n    :param tx: Unsigned Tx protobuf to simulate.\n    :param lcd_url: Base LCD URL.\n    :param gas_adjustment: Safety margin multiplier over gas_used.\n    :param gas_price_ujuno: Gas price (ujuno per unit gas) used to compute fee.\n    :param fee_denom: Denom used for paying fees.\n    :return: (updated_tx, gas_used, gas_limit).\n    :raises SimulationError: On HTTP or response errors.\n    \"\"\"\n    tx_bytes = tx.SerializeToString()\n    tx_b64 = base64.b64encode(tx_bytes).decode()\n\n    payload = {\"tx_bytes\": tx_b64}\n\n    async with httpx.AsyncClient(timeout=15) as client:\n        try:\n            resp = await client.post(f\"{lcd_url}/cosmos/tx/v1beta1/simulate\", json=payload)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise SimulationError(f\"Simulation HTTP error: {exc}\") from exc\n\n    data = resp.json()\n    try:\n        gas_used_str = data[\"gas_info\"][\"gas_used\"]\n        gas_used = int(gas_used_str)\n    except (KeyError, TypeError, ValueError) as exc:\n        raise SimulationError(f\"Unexpected simulate response: {data}\") from exc\n\n    # Apply safety margin\n    gas_limit = math.ceil(gas_used * gas_adjustment)\n\n    # Compute fee = gas_limit * gas_price_ujuno (rounded up to integer ujuno)\n    fee_amount_int = int((Decimal(gas_limit) * gas_price_ujuno).to_integral_value(rounding=ROUND_UP))\n    fee_coin = coin_pb2.Coin(denom=fee_denom, amount=str(fee_amount_int))\n\n    # Update tx.auth_info.fee\n    if not tx.auth_info.fee:\n        tx.auth_info.fee.CopyFrom(cosmos_tx_pb2.Fee())\n\n    tx.auth_info.fee.gas_limit = gas_limit\n    # Clear any previous amount entries and set the new one\n    tx.auth_info.fee.amount.clear()\n    tx.auth_info.fee.amount.append(fee_coin)\n\n    return tx, gas_used, gas_limit\n",
	"broadcast_signed_tx": "def broadcast_signed_tx(\n    signed_tx_base64: str,\n    lcd_url: str = LCD_URL,\n    mode: str = \"BROADCAST_MODE_BLOCK\",\n) -> dict:\n    \"\"\"Broadcast the signed tx using the /cosmos/tx/v1beta1/txs LCD endpoint.\n\n    :param signed_tx_base64: Base64-encoded signed tx bytes.\n    :param lcd_url: Base LCD base URL.\n    :param mode: Broadcast mode (BLOCK, SYNC, or ASYNC).\n    :return: tx_response JSON dict containing txhash, code, raw_log, etc.\n    :raises BroadcastError: If the HTTP call fails or response is malformed.\n    \"\"\"\n    payload = {\n        \"tx_bytes\": signed_tx_base64,\n        \"mode\": mode,\n    }\n\n    async with httpx.AsyncClient(timeout=30) as client:\n        try:\n            resp = await client.post(f\"{lcd_url}/cosmos/tx/v1beta1/txs\", json=payload)\n            resp.raise_for_status()\n        except httpx.HTTPError as exc:\n            raise BroadcastError(f\"Broadcast HTTP error: {exc}\") from exc\n\n    data = resp.json()\n    try:\n        tx_response = data[\"tx_response\"]\n        # Accessing these is safe if present; otherwise KeyError will be raised\n        _ = tx_response[\"txhash\"]\n        _ = tx_response[\"code\"]\n    except (KeyError, TypeError) as exc:\n        raise BroadcastError(f\"Unexpected broadcast response format: {data}\") from exc\n\n    return tx_response\n",
	"fetch_tx_and_extract_code_id": "def fetch_tx_and_extract_code_id(txhash: str, lcd_url: str = LCD_URL) -> str:\n    \"\"\"Fetch the tx by hash and scan events for the stored code_id.\n\n    This scans tx_response.logs[].events[] for an event of type 'store_code' or\n    'wasm' and looks for an attribute with key 'code_id'.\n\n    :param txhash: Hex-encoded transaction hash.\n    :param lcd_url: Base LCD URL.\n    :return: Extracted code_id as a string.\n    :raises CodeIdNotFoundError: If no code_id attribute is found.\n    :raises httpx.HTTPError: On network/HTTP failures.\n    \"\"\"\n    async with httpx.AsyncClient(timeout=15) as client:\n        resp = await client.get(f\"{lcd_url}/cosmos/tx/v1beta1/txs/{txhash}\")\n        resp.raise_for_status()\n\n    data = resp.json()\n    tx_response = data.get(\"tx_response\", {})\n    logs = tx_response.get(\"logs\", [])\n\n    # Iterate all events looking for a code_id attribute\n    for log in logs:\n        for event in log.get(\"events\", []):\n            ev_type = event.get(\"type\", \"\")\n            if ev_type not in (\"store_code\", \"wasm\"):\n                continue\n            for attr in event.get(\"attributes\", []):\n                # Depending on the node, key/value may be plain text or base64. Juno LCD\n                # returns them as plain text according to the provided schema.\n                if attr.get(\"key\") == \"code_id\":\n                    code_id = attr.get(\"value\")\n                    if code_id:\n                        return code_id\n\n    raise CodeIdNotFoundError(\n        f\"No code_id attribute found in tx events for txhash={txhash}. Response: {tx_response}\"\n    )\n",
	"verify_uploaded_code_hash": "def verify_uploaded_code_hash(\n    code_id: str,\n    local_checksum_bytes: bytes,\n    lcd_url: str = LCD_URL,\n) -> bool:\n    \"\"\"Verify that on-chain code_info.data_hash matches the local wasm checksum.\n\n    :param code_id: Code ID returned by the store-code tx events.\n    :param local_checksum_bytes: SHA-256 digest bytes computed from the local wasm.\n    :param lcd_url: Base LCD URL.\n    :return: True if hashes match.\n    :raises CodeHashMismatchError: If the hashes differ.\n    :raises httpx.HTTPError: On network/HTTP failures.\n    \"\"\"\n    if not local_checksum_bytes:\n        raise ValueError(\"local_checksum_bytes must be non-empty\")\n\n    async with httpx.AsyncClient(timeout=15) as client:\n        resp = await client.get(f\"{lcd_url}/cosmwasm/wasm/v1/code/{code_id}\")\n        resp.raise_for_status()\n\n    data = resp.json()\n    try:\n        code_info = data[\"code_info\"]\n        data_hash_b64 = code_info[\"data_hash\"]\n    except (KeyError, TypeError) as exc:\n        raise CodeHashMismatchError(f\"Unexpected code info response: {data}\") from exc\n\n    try:\n        onchain_hash = base64.b64decode(data_hash_b64)\n    except Exception as exc:\n        raise CodeHashMismatchError(f\"Failed to decode on-chain data_hash: {exc}\") from exc\n\n    if onchain_hash != local_checksum_bytes:\n        raise CodeHashMismatchError(\n            f\"On-chain data_hash ({onchain_hash.hex()}) does not match local checksum ({local_checksum_bytes.hex()})\"\n        )\n\n    return True\n",
	"ensure_cw_orch_dependency": "def ensure_cw_orch_dependency(doc, version: str):\n    '''\n    Ensure that the [dependencies] table contains an optional cw-orch\n    entry. Existing dependencies are left untouched.\n\n    Args:\n        doc: Parsed Cargo.toml document returned by load_cargo_toml.\n        version: cw-orch crate version to set if the dependency is missing\n                 (for example '0.21.0').\n    '''\n    if not isinstance(doc, MutableMapping):\n        raise TypeError('Expected a TOML document mapping for doc')\n\n    if 'dependencies' not in doc or doc['dependencies'] is None:\n        doc['dependencies'] = table()\n\n    deps = doc['dependencies']\n\n    if not isinstance(deps, MutableMapping):\n        raise TypeError('The [dependencies] section is not a table')\n\n    # Only add cw-orch if it is not already declared.\n    if 'cw-orch' not in deps:\n        deps['cw-orch'] = {\n            'version': version,\n            'optional': True,\n        }\n\n    return doc\n",
	"ensure_features_table_exists": "def ensure_features_table_exists(doc):\n    '''\n    Ensure that a [features] table exists in the Cargo.toml document.\n    Any existing feature definitions are preserved.\n    '''\n    if not isinstance(doc, MutableMapping):\n        raise TypeError('Expected a TOML document mapping for doc')\n\n    if 'features' not in doc or doc['features'] is None:\n        doc['features'] = table()\n    else:\n        features = doc['features']\n        if not isinstance(features, MutableMapping):\n            raise TypeError('The [features] section exists but is not a table')\n\n    return doc\n",
	"add_interface_feature_flag": "def add_interface_feature_flag(doc):\n    '''\n    Add or update the `interface` feature so that it enables the cw-orch\n    dependency: interface = ['dep:cw-orch'].\n    If `interface` already exists, merge 'dep:cw-orch' into the list\n    without removing existing items.\n    '''\n    if not isinstance(doc, MutableMapping):\n        raise TypeError('Expected a TOML document mapping for doc')\n\n    if 'features' not in doc or doc['features'] is None:\n        raise KeyError('No [features] table found; call ensure_features_table_exists first')\n\n    features = doc['features']\n    if not isinstance(features, MutableMapping):\n        raise TypeError('The [features] section is not a table')\n\n    if 'interface' not in features or features['interface'] is None:\n        vals = array()\n        vals.append('dep:cw-orch')\n        features['interface'] = vals\n    else:\n        vals = features['interface']\n        if not isinstance(vals, MutableSequence):\n            raise TypeError('features.interface must be an array of feature flags')\n\n        existing = [str(v) for v in vals]\n        if 'dep:cw-orch' not in existing:\n            vals.append('dep:cw-orch')\n\n    return doc\n",
	"ensure_default_includes_interface": "def ensure_default_includes_interface(doc):\n    '''\n    Ensure that the `default` feature list includes 'interface'. If the\n    `default` feature does not exist, it is created as ['interface'].\n    '''\n    if not isinstance(doc, MutableMapping):\n        raise TypeError('Expected a TOML document mapping for doc')\n\n    if 'features' not in doc or doc['features'] is None:\n        raise KeyError('No [features] table found; call ensure_features_table_exists first')\n\n    features = doc['features']\n    if not isinstance(features, MutableMapping):\n        raise TypeError('The [features] section is not a table')\n\n    if 'default' not in features or features['default'] is None:\n        vals = array()\n        vals.append('interface')\n        features['default'] = vals\n    else:\n        vals = features['default']\n        if not isinstance(vals, MutableSequence):\n            raise TypeError('features.default must be an array of feature flags')\n\n        existing = [str(v) for v in vals]\n        if 'interface' not in existing:\n            vals.append('interface')\n\n    return doc\n",
	"write_cargo_toml": "def write_cargo_toml(doc, path: str = 'Cargo.toml'):\n    '''\n    Serialize the modified TOML document back to Cargo.toml, preserving\n    formatting where possible, and overwrite the original file.\n    '''\n    cargo_path = Path(path)\n\n    try:\n        content = dumps(doc)\n        cargo_path.write_text(content, encoding='utf-8')\n    except OSError as exc:\n        raise RuntimeError(f'Failed to write {cargo_path}: {exc}') from exc\n\n    return str(cargo_path)\n",
	"cargo_check_with_interface_feature": "def cargo_check_with_interface_feature(project_root: str = '.'): \n    '''\n    Run `cargo check --features interface` in the given project root to\n    verify that enabling the `interface` feature compiles successfully.\n    Raises RuntimeError if cargo is missing or the check fails.\n    '''\n    root = Path(project_root)\n    if not root.is_dir():\n        raise NotADirectoryError(f'Not a directory: {root}')\n\n    cmd = ['cargo', 'check', '--features', 'interface']\n\n    try:\n        result = subprocess.run(\n            cmd,\n            cwd=str(root),\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            text=True,\n            check=False,\n        )\n    except FileNotFoundError as exc:\n        raise RuntimeError('cargo executable not found; ensure Rust is installed and on PATH') from exc\n    except Exception as exc:\n        raise RuntimeError(f'Failed to run cargo check: {exc}') from exc\n\n    if result.returncode != 0:\n        raise RuntimeError(\n            'cargo check --features interface failed with exit code '\n            f'{result.returncode}. STDOUT: {result.stdout} STDERR: {result.stderr}'\n        )\n\n    return {\n        'returncode': result.returncode,\n        'stdout': result.stdout,\n        'stderr': result.stderr,\n    }\n",
	"initialize_pagination_state": "def initialize_pagination_state(page_limit: int = PAGE_LIMIT_DEFAULT) -> PaginationState:\n    \"\"\"Initialize pagination with a configurable page size.\n\n    :param page_limit: Number of token IDs to request per page.\n    :raises ValueError: If page_limit is not a positive integer.\n    \"\"\"\n    if not isinstance(page_limit, int) or page_limit <= 0:\n        raise ValueError(\"page_limit must be a positive integer.\")\n\n    return PaginationState(page_limit=page_limit)\n",
	"build_all_tokens_query_json": "def build_all_tokens_query_json(page_limit: int, start_after: Optional[str] = None) -> Dict[str, Any]:\n    \"\"\"Build the CW721 all_tokens query JSON structure.\n\n    Example first page: {'all_tokens': {'limit': 100}}\n    Example next page:  {'all_tokens': {'limit': 100, 'start_after': 'last_token_id'}}\n    \"\"\"\n    if not isinstance(page_limit, int) or page_limit <= 0:\n        raise ValueError(\"page_limit must be a positive integer.\")\n\n    all_tokens: Dict[str, Any] = {\"limit\": page_limit}\n    if start_after:\n        all_tokens[\"start_after\"] = start_after\n\n    return {\"all_tokens\": all_tokens}\n",
	"lcd_smart_query_all_tokens": "def lcd_smart_query_all_tokens(contract_address: str, query_data_b64: str, timeout: float = 10.0) -> Dict[str, Any]:\n    \"\"\"Perform an HTTP GET to the Juno LCD CosmWasm smart query endpoint.\n\n    This calls:\n      GET /cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_data_b64}\n\n    :param contract_address: Validated Juno contract address.\n    :param query_data_b64: Base64-encoded JSON query string for all_tokens.\n    :param timeout: HTTP timeout in seconds.\n    :returns: Parsed JSON response from the LCD.\n    :raises RuntimeError: On HTTP or JSON errors, or if the LCD returns a non-2xx code.\n    \"\"\"\n    url = f\"{LCD_BASE_URL}/cosmwasm/wasm/v1/contract/{contract_address}/smart/{query_data_b64}\"\n\n    try:\n        async with httpx.AsyncClient(timeout=timeout) as client:\n            response = await client.get(url)\n        response.raise_for_status()\n    except httpx.HTTPStatusError as e:\n        # The LCD returned a non-success status code.\n        raise RuntimeError(\n            f\"LCD smart query failed with status {e.response.status_code}: {e.response.text}\"\n        ) from e\n    except httpx.RequestError as e:\n        # Network or connection-level error.\n        raise RuntimeError(f\"Network error while calling LCD: {e}\") from e\n\n    try:\n        data = response.json()\n    except ValueError as e:\n        raise RuntimeError(f\"Failed to parse LCD response as JSON: {e}\") from e\n\n    if \"data\" not in data:\n        # According to the schema, the smart query result is returned under 'data' (base64-encoded).\n        raise RuntimeError(f\"LCD response missing 'data' field: {data}\")\n\n    return data\n",
	"decode_all_tokens_response": "def decode_all_tokens_response(lcd_response: Dict[str, Any]) -> List[str]:\n    \"\"\"Decode the 'data' field from the LCD smart query response and extract token IDs.\n\n    The LCD response has the form: {'data': '<base64-encoded-bytes>'}.\n    Those bytes should decode to JSON like: {'tokens': ['id1', 'id2', ...]}.\n    \"\"\"\n    if \"data\" not in lcd_response:\n        raise KeyError(\"LCD response dict does not contain 'data' field.\")\n\n    b64_data = lcd_response[\"data\"]\n    if not isinstance(b64_data, str):\n        raise TypeError(\"'data' field must be a base64-encoded string.\")\n\n    try:\n        # Support both standard and URL-safe base64\n        # First try standard, then urlsafe as a fallback.\n        try:\n            raw_bytes = base64.b64decode(b64_data)\n        except Exception:\n            raw_bytes = base64.urlsafe_b64decode(b64_data)\n    except Exception as e:\n        raise ValueError(f\"Failed to base64-decode response 'data': {e}\") from e\n\n    try:\n        decoded_json = json.loads(raw_bytes.decode(\"utf-8\"))\n    except (UnicodeDecodeError, json.JSONDecodeError) as e:\n        raise ValueError(f\"Failed to decode response JSON: {e}\") from e\n\n    # For CW721 all_tokens, we expect a structure like {\"tokens\": [\"token1\", \"token2\", ...]}\n    if not isinstance(decoded_json, dict):\n        raise TypeError(f\"Decoded response JSON is not an object: {decoded_json}\")\n\n    tokens = decoded_json.get(\"tokens\")\n    if tokens is None:\n        raise KeyError(f\"Decoded response does not contain 'tokens' field: {decoded_json}\")\n\n    if not isinstance(tokens, list) or not all(isinstance(t, str) for t in tokens):\n        raise TypeError(f\"'tokens' must be a list of strings, got: {tokens}\")\n\n    return tokens\n",
	"fetch_all_cw721_token_ids": "def fetch_all_cw721_token_ids(contract_address: str, page_limit: int = PAGE_LIMIT_DEFAULT) -> List[str]:\n    \"\"\"Fetch all CW721 token IDs for a contract by paginating the all_tokens query.\n\n    Pagination rule:\n      * If the number of token IDs returned in a page == page_limit,\n        set start_after to the last token ID and continue.\n      * If fewer than page_limit are returned, stop (final page).\n    \"\"\"\n    # Validate the contract address before making any network calls.\n    validate_contract_address(contract_address)\n\n    state = initialize_pagination_state(page_limit=page_limit)\n\n    while True:\n        # Build the all_tokens query for the current page.\n        query_json = build_all_tokens_query_json(\n            page_limit=state.page_limit,\n            start_after=state.start_after,\n        )\n\n        # Encode query JSON to base64 for the LCD smart endpoint.\n        query_b64 = encode_query_to_base64(query_json)\n\n        # Call the LCD smart query endpoint.\n        lcd_response = await lcd_smart_query_all_tokens(\n            contract_address=contract_address,\n            query_data_b64=query_b64,\n        )\n\n        # Decode token IDs from the LCD response.\n        page_tokens = decode_all_tokens_response(lcd_response)\n\n        if not page_tokens:\n            # No results in this page; we're done.\n            break\n\n        # Aggregate token IDs.\n        state.token_ids.extend(page_tokens)\n\n        # If fewer than page_limit were returned, this is the final page.\n        if len(page_tokens) < state.page_limit:\n            break\n\n        # Otherwise, set start_after to the last token ID and fetch the next page.\n        state.start_after = page_tokens[-1]\n\n    return state.token_ids\n",
	"get_all_token_ids": "def get_all_token_ids(contract_address: str, page_limit: int = PAGE_LIMIT_DEFAULT) -> dict:\n    \"\"\"HTTP endpoint that returns all CW721 token IDs for a contract.\n\n    Query params:\n      - contract_address: Juno CW721 contract address (path param).\n      - page_limit: page size used for pagination (optional, default=100).\n    \"\"\"\n    try:\n        token_ids: List[str] = await fetch_all_cw721_token_ids(\n            contract_address=contract_address,\n            page_limit=page_limit,\n        )\n    except InvalidContractAddress as e:\n        # Bad user input -> 400\n        raise HTTPException(status_code=400, detail=str(e)) from e\n    except Exception as e:\n        # Unexpected errors -> 500\n        raise HTTPException(status_code=500, detail=str(e)) from e\n\n    return {\n        \"contract_address\": contract_address,\n        \"page_limit\": page_limit,\n        \"token_ids\": token_ids,\n    }\n",
	"validate_juno_address_format": "def validate_juno_address_format(address: str, expected_prefix: str = \"juno\") -> Dict[str, str]:\n    \"\"\"Validate that 'address' is a proper Juno bech32 account address.\n\n    Returns a dict with:\n      - is_valid: \"true\" or \"false\" (as strings for JSON friendliness)\n      - error: error message when invalid, empty string when valid\n\n    This function only checks format, prefix, and checksum; it does not\n    check on-chain existence of the account.\n    \"\"\"\n    result = {\"is_valid\": \"false\", \"error\": \"\"}\n\n    if not isinstance(address, str) or not address:\n        result[\"error\"] = \"Address must be a non-empty string.\"\n        return result\n\n    # Basic length sanity check (Cosmos addresses are usually ~45 chars)\n    if len(address) < 10 or len(address) > 90:\n        result[\"error\"] = \"Address length is not within the expected range.\"\n        return result\n\n    try:\n        hrp, data = bech32_decode(address)\n    except Exception as e:  # bech32_decode is usually safe, but we guard anyway\n        result[\"error\"] = f\"Invalid bech32 encoding: {e}\"\n        return result\n\n    # bech32_decode returns (None, None) on invalid input in most implementations\n    if hrp is None or data is None:\n        result[\"error\"] = \"Invalid bech32 address or checksum.\"\n        return result\n\n    if hrp != expected_prefix:\n        result[\"error\"] = f\"Invalid address prefix: expected '{expected_prefix}', got '{hrp}'.\"\n        return result\n\n    # Optionally, enforce a minimum data length to avoid obviously malformed addresses\n    if len(data) == 0:\n        result[\"error\"] = \"Bech32 data part is empty; address is malformed.\"\n        return result\n\n    # If we reach here, the address is considered valid\n    result[\"is_valid\"] = \"true\"\n    result[\"error\"] = \"\"\n    return result\n",
	"query_junox_balance_before_faucet": "def query_junox_balance_before_faucet(address: str, denom: str = \"ujunox\", lcd_base: str = LCD_BASE) -> Dict:\n    \"\"\"Query the JUNOX balance for 'address' before using the faucet.\n\n    Uses the endpoint:\n      GET {LCD_BASE}/cosmos/bank/v1beta1/balances/{address}/by_denom?denom=ujunox\n\n    Returns a dict:\n      {\n        \"address\": str,\n        \"denom\": str,\n        \"amount\": int,  # micro-denom units (e.g., ujunox)\n      }\n\n    Raises RuntimeError on network or protocol errors.\n    \"\"\"\n    if not address:\n        raise ValueError(\"Address is required to query balance.\")\n\n    url = f\"{lcd_base}/cosmos/bank/v1beta1/balances/{address}/by_denom\"\n    params = {\"denom\": denom}\n\n    try:\n        async with httpx.AsyncClient(timeout=10.0) as client:\n            resp = await client.get(url, params=params)\n    except httpx.RequestError as e:\n        raise RuntimeError(f\"Error querying Juno LCD: {e}\") from e\n\n    if resp.status_code != 200:\n        raise RuntimeError(\n            f\"LCD returned HTTP {resp.status_code} when querying balance: {resp.text}\"\n        )\n\n    data = resp.json()\n    balance = data.get(\"balance\")\n\n    # If no balance object is present, treat as zero\n    if balance is None:\n        amount_str = \"0\"\n        resp_denom = denom\n    else:\n        amount_str = balance.get(\"amount\", \"0\")\n        resp_denom = balance.get(\"denom\", denom)\n\n    if resp_denom != denom:\n        raise RuntimeError(f\"Unexpected denom in LCD response: {resp_denom} (expected {denom})\")\n\n    try:\n        amount_int = int(amount_str)\n    except ValueError as e:\n        raise RuntimeError(f\"Invalid amount format in LCD response: {amount_str}\") from e\n\n    return {\n        \"address\": address,\n        \"denom\": denom,\n        \"amount\": amount_int,\n    }\n",
	"poll_faucet_tx_until_final": "def poll_faucet_tx_until_final(\n    tx_hash: str,\n    lcd_base: str = LCD_BASE,\n    timeout_seconds: float = 60.0,\n    poll_interval_seconds: float = 2.0,\n) -> Dict[str, Any]:\n    \"\"\"Poll the LCD /cosmos/tx/v1beta1/txs/{hash} endpoint for a faucet tx.\n\n    Returns a dict of the form:\n      {\n        \"status\": \"success\" | \"failed\" | \"timeout\",\n        \"response\": <last LCD JSON or error info>,\n      }\n\n    - status == \"success\" when tx_response.code == 0\n    - status == \"failed\"  when tx_response.code != 0\n    - status == \"timeout\" when no final result was observed before timeout\n    \"\"\"\n    if not tx_hash:\n        raise ValueError(\"tx_hash is required to poll transaction status.\")\n\n    url = f\"{lcd_base}/cosmos/tx/v1beta1/txs/{tx_hash}\"\n    end_time = asyncio.get_event_loop().time() + timeout_seconds\n\n    last_response: Any = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            try:\n                resp = await client.get(url)\n            except httpx.RequestError as e:\n                # Network or connectivity error; record and continue polling until timeout\n                last_response = {\"error\": f\"Request error: {e}\"}\n            else:\n                if resp.status_code == 200:\n                    data = resp.json()\n                    last_response = data\n                    tx_resp = data.get(\"tx_response\")\n\n                    # If the tx is not yet indexed, tx_response may be missing\n                    if tx_resp is not None:\n                        try:\n                            code = int(tx_resp.get(\"code\", 0))\n                        except (TypeError, ValueError):\n                            code = 0\n\n                        if code == 0:\n                            return {\"status\": \"success\", \"response\": data}\n                        else:\n                            return {\"status\": \"failed\", \"response\": data}\n                else:\n                    # 404 or other non-200 status might mean the tx is not yet known\n                    last_response = {\n                        \"http_status\": resp.status_code,\n                        \"body\": resp.text,\n                    }\n\n            if asyncio.get_event_loop().time() >= end_time:\n                return {\"status\": \"timeout\", \"response\": last_response}\n\n            await asyncio.sleep(poll_interval_seconds)\n",
	"_query_junox_balance": "def _query_junox_balance(address: str, denom: str = \"ujunox\", lcd_base: str = LCD_BASE) -> int:\n    \"\"\"Internal helper to query the JUNOX balance and return the amount as int.\"\"\"\n    url = f\"{lcd_base}/cosmos/bank/v1beta1/balances/{address}/by_denom\"\n    params = {\"denom\": denom}\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        resp = await client.get(url, params=params)\n\n    if resp.status_code != 200:\n        raise RuntimeError(\n            f\"LCD returned HTTP {resp.status_code} when querying balance: {resp.text}\"\n        )\n\n    data = resp.json()\n    balance = data.get(\"balance\")\n\n    if balance is None:\n        amount_str = \"0\"\n        resp_denom = denom\n    else:\n        amount_str = balance.get(\"amount\", \"0\")\n        resp_denom = balance.get(\"denom\", denom)\n\n    if resp_denom != denom:\n        raise RuntimeError(f\"Unexpected denom in LCD response: {resp_denom} (expected {denom})\")\n\n    try:\n        return int(amount_str)\n    except ValueError as e:\n        raise RuntimeError(f\"Invalid amount format in LCD response: {amount_str}\") from e\n\n\nasync def compare_junox_balance_after_faucet(\n    address: str,\n    pre_faucet_amount: int,\n    denom: str = \"ujunox\",\n    lcd_base: str = LCD_BASE,\n) -> Dict:\n    \"\"\"Query JUNOX balance after faucet and compare with pre-faucet amount.\n\n    Args:\n      address: Juno bech32 address.\n      pre_faucet_amount: The amount (int, micro-denom) recorded before faucet.\n\n    Returns:\n      {\n        \"address\": str,\n        \"denom\": str,\n        \"pre_amount\": int,\n        \"post_amount\": int,\n        \"delta\": int,  # tokens added (may be 0 if faucet failed)\n      }\n    \"\"\"\n    if pre_faucet_amount is None:\n        raise ValueError(\"pre_faucet_amount must be provided (from step 2).\")\n\n    post_amount = await _query_junox_balance(address, denom=denom, lcd_base=lcd_base)\n    delta = post_amount - int(pre_faucet_amount)\n\n    return {\n        \"address\": address,\n        \"denom\": denom,\n        \"pre_amount\": int(pre_faucet_amount),\n        \"post_amount\": post_amount,\n        \"delta\": delta,\n    }\n",
	"retrieve_last_tx_output": "def retrieve_last_tx_output(raw_output: str) -> dict:\n    '''Parse the JSON output string from the last transaction command.\n\n    Args:\n        raw_output: JSON string printed by the CLI or SDK after broadcasting a tx\n            (for example, a wasm store transaction response).\n\n    Returns:\n        Parsed transaction output as a Python dictionary.\n\n    Raises:\n        ValueError: If the input is empty or not valid JSON.\n    '''\n    if not raw_output or not raw_output.strip():\n        raise ValueError('raw_output is empty; provide the JSON string from the last transaction.')\n\n    try:\n        tx_output = json.loads(raw_output)\n    except json.JSONDecodeError as exc:\n        raise ValueError(f'Failed to parse transaction JSON output: {exc}') from exc\n\n    # Basic sanity check: ensure we at least have a dict\n    if not isinstance(tx_output, dict):\n        raise ValueError('Parsed transaction output is not a JSON object (dict).')\n\n    return tx_output\n",
	"parse_code_id_from_output": "def parse_code_id_from_output(tx_output: dict) -> str:\n    '''Extract the numeric code_id from a transaction output dict.\n\n    This supports:\n    - a direct top-level 'code_id' field, or\n    - Cosmos SDK tx_response.logs events (e.g. after MsgStoreCode).\n\n    Raises:\n        ValueError: If code_id cannot be found or is not numeric.\n    '''\n    if not isinstance(tx_output, dict):\n        raise ValueError('tx_output must be a dictionary.')\n\n    code_id = None\n\n    # Case 1: direct field\n    if 'code_id' in tx_output:\n        code_id = tx_output['code_id']\n\n    # Case 2: typical Cosmos SDK tx_response logs\n    if not code_id:\n        tx_response = tx_output.get('tx_response') or tx_output.get('result') or {}\n        logs = tx_response.get('logs') or []\n        for log in logs:\n            events = log.get('events') or []\n            for event in events:\n                if event.get('type') == 'store_code':\n                    for attr in event.get('attributes') or []:\n                        key = attr.get('key')\n                        if key in ('code_id', 'codeID'):\n                            code_id = attr.get('value')\n                            break\n                if code_id:\n                    break\n            if code_id:\n                break\n\n    if code_id is None:\n        raise ValueError('Could not find code_id in transaction output; ensure this is a wasm store transaction JSON.')\n\n    code_id_str = str(code_id).strip()\n    if not code_id_str.isdigit():\n        raise ValueError(f'Extracted code_id {code_id_str} is not purely numeric.')\n\n    return code_id_str\n",
	"export_shell_variable_CODE_ID": "def export_shell_variable_CODE_ID(code_id: str) -> str:\n    '''Return a shell export command for the given code_id.\n\n    This does not modify the current process environment; instead it returns\n    a string like 'export CODE_ID=12' that a shell script can eval.\n    '''\n    if not code_id or not str(code_id).strip().isdigit():\n        raise ValueError('code_id must be a non-empty numeric string.')\n\n    sanitized = str(code_id).strip()\n    return f'export CODE_ID={sanitized}'\n",
	"select_juno_chain_key_params": "def select_juno_chain_key_params() -> Dict[str, Any]:\n    \"\"\"Return standard key parameters for Juno (BIP-44 coin type 118 and bech32 'juno').\n\n    These values are used by later steps to derive keys and addresses consistently.\n    \"\"\"\n    return {\n        \"chain_id\": \"juno-1\",  # Juno mainnet chain-id; adjust if targeting a testnet\n        \"bip44_coin_type\": 118,  # Cosmos ecosystem coin type\n        \"derivation_path\": \"m/44'/118'/0'/0/0\",  # Account 0, external chain, index 0\n        \"bech32_prefix\": \"juno\",  # Bech32 human-readable prefix for Juno addresses\n    }\n",
	"generate_bip39_mnemonic": "def generate_bip39_mnemonic(words: int = 24) -> str:\n    \"\"\"Generate a new BIP-39 mnemonic using a cryptographically secure RNG.\n\n    :param words: Number of words in the mnemonic (12 or 24).\n    :return: The mnemonic sentence as a space-separated string.\n\n    SECURITY NOTE: Do *not* log this mnemonic. Only return it to the caller\n    over a secure channel (e.g. HTTPS) and instruct users to store it offline.\n    \"\"\"\n    if words not in (12, 24):\n        raise ValueError(\"words must be either 12 or 24.\")\n\n    try:\n        words_num = Bip39WordsNum.WORDS_NUM_12 if words == 12 else Bip39WordsNum.WORDS_NUM_24\n        mnemonic = Bip39MnemonicGenerator().FromWordsNumber(words_num)\n    except Exception as exc:  # pragma: no cover - defensive catch\n        raise RuntimeError(\"Failed to generate mnemonic using BIP-39 generator.\") from exc\n\n    # IMPORTANT: Do NOT log the mnemonic here.\n    return str(mnemonic)\n",
	"derive_hd_key_from_mnemonic": "def derive_hd_key_from_mnemonic(mnemonic: str, derivation_path: str = \"m/44'/118'/0'/0/0\") -> bytes:\n    \"\"\"Derive a hierarchical deterministic (HD) private key from a BIP-39 mnemonic.\n\n    This uses BIP-39 to turn the mnemonic into a seed, and BIP-32/BIP-44 logic\n    (SLIP-0010 secp256k1) to derive a private key at the provided path.\n\n    :param mnemonic: BIP-39 mnemonic sentence.\n    :param derivation_path: BIP-32/BIP-44 derivation path, e.g. \"m/44'/118'/0'/0/0\".\n    :return: 32-byte secp256k1 private key.\n    \"\"\"\n    if not isinstance(mnemonic, str) or not mnemonic.strip():\n        raise ValueError(\"mnemonic must be a non-empty string.\")\n    if not isinstance(derivation_path, str) or not derivation_path.startswith(\"m/\"):\n        raise ValueError(\"derivation_path must be a BIP-32 style string starting with 'm/'.\")\n\n    # 1. Convert mnemonic to seed (BIP-39).\n    try:\n        seed_bytes = Bip39SeedGenerator(mnemonic).Generate()\n    except Exception as exc:  # pragma: no cover - defensive\n        raise ValueError(\"Failed to convert mnemonic to seed; is the mnemonic valid BIP-39?\") from exc\n\n    # 2. Derive HD private key using BIP-32/SLIP-0010 secp256k1.\n    try:\n        root = Bip32Slip10Secp256k1.FromSeed(seed_bytes)\n        derived = root.DerivePath(derivation_path)\n        private_key_bytes = derived.PrivateKey().Raw().ToBytes()\n    except Exception as exc:  # pragma: no cover - defensive\n        raise RuntimeError(f\"Failed to derive private key for path {derivation_path}.\") from exc\n\n    if len(private_key_bytes) != 32:\n        raise RuntimeError(\"Derived private key is not 32 bytes; derivation may be incorrect.\")\n\n    # SECURITY NOTE: The caller must ensure this key is protected in memory and at rest.\n    return private_key_bytes\n",
	"derive_public_key_and_address": "def derive_public_key_and_address(\n    private_key: bytes,\n    bech32_prefix: str = \"juno\",\n) -> Dict[str, Any]:\n    \"\"\"Derive the compressed secp256k1 public key and Juno address from a private key.\n\n    :param private_key: 32-byte secp256k1 private key.\n    :param bech32_prefix: Bech32 human-readable prefix (\"juno\" for the Juno chain).\n    :return: Dict with 'public_key_bytes', 'public_key_hex', and 'address'.\n    \"\"\"\n    if not isinstance(private_key, (bytes, bytearray)):\n        raise TypeError(\"private_key must be bytes.\")\n    if len(private_key) != 32:\n        raise ValueError(\"private_key must be exactly 32 bytes for secp256k1.\")\n\n    # 1. Derive compressed public key from private key.\n    try:\n        sk = SigningKey.from_string(bytes(private_key), curve=SECP256k1)\n        try:\n            # ecdsa>=0.17 supports compressed format directly.\n            public_key_bytes = sk.get_verifying_key().to_string(\"compressed\")\n        except TypeError:\n            # Fallback: compress manually from uncompressed (x||y).\n            vk = sk.get_verifying_key()\n            uncompressed = vk.to_string()  # 64 bytes: x(32) || y(32)\n            x_bytes, y_bytes = uncompressed[:32], uncompressed[32:]\n            prefix = b\"\\x02\" if (y_bytes[-1] % 2 == 0) else b\"\\x03\"\n            public_key_bytes = prefix + x_bytes\n    except Exception as exc:  # pragma: no cover - defensive\n        raise RuntimeError(\"Failed to derive public key from private key.\") from exc\n\n    # 2. Cosmos-style address derivation: RIPEMD160(SHA256(pubkey_bytes)).\n    sha256_digest = hashlib.sha256(public_key_bytes).digest()\n    ripemd160 = RIPEMD160.new()\n    ripemd160.update(sha256_digest)\n    pubkey_hash = ripemd160.digest()  # 20 bytes\n\n    # 3. Encode as bech32 address with the given prefix.\n    data5 = convertbits(pubkey_hash, 8, 5, True)\n    if data5 is None:\n        raise RuntimeError(\"Failed to convert pubkey hash to 5-bit words for bech32 encoding.\")\n\n    address = bech32_encode(bech32_prefix, data5)\n    if address is None:\n        raise RuntimeError(\"bech32_encode returned None; invalid data or prefix.\")\n\n    # SECURITY NOTE: Do not log the private key or mnemonic anywhere.\n    return {\n        \"public_key_bytes\": public_key_bytes,\n        \"public_key_hex\": public_key_bytes.hex(),\n        \"address\": address,\n    }\n",
	"_get_fernet": "def _get_fernet() -> Fernet:\n    \"\"\"Construct a Fernet instance from the WALLET_ENCRYPTION_KEY env variable.\n\n    Generate a key once with:\n        >>> from cryptography.fernet import Fernet\n        >>> print(Fernet.generate_key().decode())\n\n    Then set WALLET_ENCRYPTION_KEY to that value in your backend environment.\n    \"\"\"\n    key = os.environ.get(\"WALLET_ENCRYPTION_KEY\")\n    if not key:\n        raise RuntimeError(\n            \"WALLET_ENCRYPTION_KEY environment variable must be set to a Fernet key.\"\n        )\n    try:\n        return Fernet(key.encode(\"utf-8\"))\n    except Exception as exc:  # pragma: no cover - defensive\n        raise RuntimeError(\n            \"Invalid WALLET_ENCRYPTION_KEY; expected a value from Fernet.generate_key().\"\n        ) from exc\n\n\ndef persist_wallet_metadata(\n    wallet_name: str,\n    address: str,\n    public_key_hex: str,\n    private_key: bytes,\n) -> Dict[str, Any]:\n    \"\"\"Persist wallet metadata and an encrypted private key in a backend keyring.\n\n    :param wallet_name: Human-readable name for the wallet (e.g. \"MyWalletName\").\n    :param address: Juno bech32 address.\n    :param public_key_hex: Hex-encoded compressed secp256k1 public key.\n    :param private_key: Raw 32-byte secp256k1 private key.\n    :return: Stored wallet metadata (without revealing the raw private key).\n\n    SECURITY NOTES:\n    - The mnemonic is *not* stored here.\n    - The private key is encrypted at rest using Fernet.\n    - For production, replace this file-based store with a stronger KMS/HSM solution.\n    \"\"\"\n    if not wallet_name:\n        raise ValueError(\"wallet_name is required.\")\n    if not address:\n        raise ValueError(\"address is required.\")\n    if not isinstance(private_key, (bytes, bytearray)) or len(private_key) != 32:\n        raise ValueError(\"private_key must be a 32-byte value.\")\n\n    fernet = _get_fernet()\n    encrypted_private_key = fernet.encrypt(bytes(private_key)).decode(\"utf-8\")\n\n    record: Dict[str, Any] = {\n        \"wallet_name\": wallet_name,\n        \"address\": address,\n        \"public_key_hex\": public_key_hex,\n        \"encrypted_private_key\": encrypted_private_key,\n    }\n\n    # Load existing keyring file (if any).\n    try:\n        if os.path.exists(WALLET_STORE_PATH):\n            with open(WALLET_STORE_PATH, \"r\", encoding=\"utf-8\") as f:\n                store = json.load(f)\n        else:\n            store = {}\n    except (OSError, json.JSONDecodeError) as exc:\n        raise RuntimeError(f\"Failed to load wallet store from {WALLET_STORE_PATH}.\") from exc\n\n    if address in store:\n        raise RuntimeError(f\"A wallet with address {address} already exists in the keyring.\")\n\n    store[address] = record\n\n    try:\n        with open(WALLET_STORE_PATH, \"w\", encoding=\"utf-8\") as f:\n            json.dump(store, f, indent=2)\n    except OSError as exc:\n        raise RuntimeError(f\"Failed to persist wallet metadata to {WALLET_STORE_PATH}.\") from exc\n\n    # Return metadata without any secret material.\n    return record\n",
	"optional_verify_address_on_chain": "def optional_verify_address_on_chain(expected_network: str = \"juno-1\") -> Dict[str, Any]:\n    \"\"\"Query Juno's node_info endpoint to confirm LCD connectivity and network name.\n\n    The newly created address will *not* appear in on-chain account queries\n    until it receives funds; this function only verifies network information.\n\n    :param expected_network: Expected chain-id (e.g. \"juno-1\").\n    :return: Dict containing the raw response, network name, and a boolean flag.\n    \"\"\"\n    url = f\"{LCD_BASE_URL}/cosmos/base/tendermint/v1beta1/node_info\"\n    try:\n        response = httpx.get(url, timeout=10.0)\n        response.raise_for_status()\n    except httpx.HTTPError as exc:\n        raise RuntimeError(f\"Failed to reach Juno LCD at {url}: {exc}\") from exc\n\n    try:\n        data = response.json()\n    except ValueError as exc:\n        raise RuntimeError(\"LCD node_info response was not valid JSON.\") from exc\n\n    default_info = data.get(\"default_node_info\", {}) or {}\n    network = default_info.get(\"network\")\n    matches_expected = expected_network is None or network == expected_network\n\n    return {\n        \"raw\": data,\n        \"network\": network,\n        \"matches_expected\": matches_expected,\n    }\n",
	"create_juno_wallet": "def create_juno_wallet(\n    wallet_name: str = \"MyWalletName\",\n    words: int = 24,\n    verify_network: bool = False,\n) -> Dict[str, Any]:\n    \"\"\"Create a new Juno wallet and return its details to the caller.\n\n    This function orchestrates:\n      1. Selecting Juno chain key parameters.\n      2. Generating a BIP-39 mnemonic.\n      3. Deriving the HD private key.\n      4. Deriving the public key and Juno address.\n      5. Persisting wallet metadata with an encrypted private key.\n      6. Optionally verifying LCD connectivity and network id.\n\n    The mnemonic is returned *once* and is not stored by this function. Callers\n    must ensure they only transmit it over secure channels (HTTPS) and never\n    log it in plaintext.\n\n    :param wallet_name: Label for the wallet in your backend keyring.\n    :param words: Number of mnemonic words (12 or 24).\n    :param verify_network: If True, also call the LCD node_info endpoint.\n    :return: Dict with wallet_name, address, mnemonic, and optional network_info.\n    \"\"\"\n    # Step 1: chain key parameters for Juno.\n    params = select_juno_chain_key_params()\n\n    # Step 2: generate a new mnemonic.\n    mnemonic = generate_bip39_mnemonic(words=words)\n\n    # Step 3: derive HD private key from mnemonic and derivation path.\n    private_key = derive_hd_key_from_mnemonic(mnemonic, params[\"derivation_path\"])\n\n    # Step 4: derive public key and Juno address from private key.\n    key_info = derive_public_key_and_address(private_key, params[\"bech32_prefix\"])\n    address = key_info[\"address\"]\n    public_key_hex = key_info[\"public_key_hex\"]\n\n    # Step 5: persist wallet metadata (but *not* the mnemonic).\n    persist_wallet_metadata(wallet_name, address, public_key_hex, private_key)\n\n    # Step 6: optionally verify LCD connectivity and chain-id.\n    network_info: Any = None\n    if verify_network:\n        try:\n            network_info = optional_verify_address_on_chain(expected_network=params[\"chain_id\"])\n        except Exception as exc:  # pragma: no cover - defensive\n            # Network verification issues should not prevent wallet creation.\n            network_info = {\"error\": str(exc)}\n\n    # Step 7: return wallet details to the caller (mnemonic shown once).\n    return {\n        \"wallet_name\": wallet_name,\n        \"address\": address,\n        \"mnemonic\": mnemonic,\n        \"network_info\": network_info,\n        \"warning\": (\n            \"Store this mnemonic offline and never share it. \"\n            \"Anyone with the mnemonic can control your funds.\"\n        ),\n    }\n",
	"get_minimum_gas_price": "def get_minimum_gas_price():\n    '''\n    Query the node configuration and parse the minimum_gas_price field.\n\n    Returns a dict with:\n      - raw: original minimum_gas_price string from the node\n      - amount: numeric amount part as a string (e.g. '0.025')\n      - denom: denom part (e.g. 'ujuno')\n    '''\n    url = f'{LCD_BASE_URL}/cosmos/base/node/v1beta1/config'\n    try:\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException as exc:\n        raise LCDQueryError(f'Failed to query node config: {exc}') from exc\n\n    data = response.json()\n    minimum_gas_price = data.get('minimum_gas_price')\n    if not minimum_gas_price:\n        raise LCDQueryError('minimum_gas_price field missing in LCD response')\n\n    # The field can contain multiple comma-separated entries; use the first one\n    first_entry = minimum_gas_price.split(',')[0].strip()\n\n    # Split numeric amount from denom, e.g. '0.025ujuno' -> ('0.025', 'ujuno')\n    split_index = 0\n    while split_index < len(first_entry) and (\n        first_entry[split_index].isdigit() or first_entry[split_index] == '.'\n    ):\n        split_index += 1\n\n    if split_index == 0 or split_index == len(first_entry):\n        raise LCDQueryError(\n            f'Unexpected minimum_gas_price format: {first_entry!r}'\n        )\n\n    amount = first_entry[:split_index]\n    denom = first_entry[split_index:]\n\n    return {\n        'raw': minimum_gas_price,\n        'amount': amount,\n        'denom': denom,\n    }\n",
	"get_chain_id": "def get_chain_id():\n    '''\n    Query node_info (and optionally blocks/latest) to determine the chain-id.\n\n    Returns:\n        Chain ID string, e.g. 'juno-1'.\n    '''\n    node_info_url = f'{LCD_BASE_URL}/cosmos/base/tendermint/v1beta1/node_info'\n    try:\n        response = requests.get(node_info_url, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException as exc:\n        raise LCDQueryError(f'Failed to query node_info: {exc}') from exc\n\n    data = response.json()\n    default_node_info = data.get('default_node_info') or {}\n    chain_id = default_node_info.get('network')\n\n    if chain_id:\n        return chain_id\n\n    # Fallback: derive chain-id from latest block header.chain_id\n    latest_block_url = f'{LCD_BASE_URL}/cosmos/base/tendermint/v1beta1/blocks/latest'\n    try:\n        response = requests.get(latest_block_url, timeout=10)\n        response.raise_for_status()\n    except requests.RequestException as exc:\n        raise LCDQueryError(\n            f'Failed to query latest block for chain-id fallback: {exc}'\n        ) from exc\n\n    block_data = response.json()\n    header = (block_data.get('block') or {}).get('header') or {}\n    chain_id = header.get('chain_id')\n\n    if not chain_id:\n        raise LCDQueryError('Could not determine chain-id from LCD responses')\n\n    return chain_id\n",
	"build_txflags_string": "def build_txflags_string(\n    minimum_gas_price: str,\n    chain_id: str,\n    gas_adjustment: float = 1.3,\n    rpc_endpoint: str = 'https://rpc.junonetwork.io',\n) -> str:\n    '''\n    Construct a TXFLAGS string suitable for reuse with junod CLI commands.\n\n    Args:\n        minimum_gas_price: Gas price string like '0.025ujuno'.\n        chain_id: Chain identifier, e.g. 'juno-1'.\n        gas_adjustment: Multiplier applied when using --gas=auto.\n        rpc_endpoint: RPC endpoint URL that junod should talk to.\n\n    Returns:\n        A flags string, for example:\n        '--gas=auto --gas-adjustment=1.3 --gas-prices=0.025ujuno --chain-id=juno-1 --node=https://rpc.junonetwork.io'\n    '''\n    if not minimum_gas_price or not chain_id:\n        raise ValueError('minimum_gas_price and chain_id must be non-empty')\n\n    if gas_adjustment <= 0:\n        raise ValueError('gas_adjustment must be positive')\n\n    flags = (\n        f'--gas=auto '\n        f'--gas-adjustment={gas_adjustment} '\n        f'--gas-prices={minimum_gas_price} '\n        f'--chain-id={chain_id} '\n        f'--node={rpc_endpoint}'\n    )\n\n    return flags\n",
	"set_txflags_env": "def set_txflags_env(txflags: str) -> None:\n    '''\n    Set the TXFLAGS environment variable in the current process, so any\n    subsequent junod CLI calls from this process will automatically include\n    the configured gas and chain settings.\n    '''\n    if not txflags or not txflags.strip():\n        raise ValueError('txflags must be a non-empty string')\n\n    os.environ['TXFLAGS'] = txflags\n",
	"test_junod_tx_with_txflags": "def test_junod_tx_with_txflags(\n    from_identifier: str,\n    amount: str = '1',\n    denom: str = 'ujuno',\n    simulate_only: bool = True,\n    home: Optional[str] = None,\n) -> Dict[str, Any]:\n    '''\n    Execute a harmless junod transaction using the TXFLAGS environment\n    variable to verify that gas settings are accepted by the node.\n\n    Args:\n        from_identifier: Local key name or bech32 address used as both sender\n            and recipient for a self-send.\n        amount: Token amount to send (as a string, default '1').\n        denom: Token denom to send (default 'ujuno').\n        simulate_only: If True, adds --dry-run so the tx is not broadcast.\n        home: Optional junod --home directory.\n\n    Returns:\n        A dict with the executed command, stdout, stderr, and returncode.\n    '''\n    txflags = os.environ.get('TXFLAGS')\n    if not txflags:\n        raise JunodTxTestError(\n            'TXFLAGS environment variable is not set. Call set_txflags_env(...) first.'\n        )\n\n    base_cmd = (\n        f'junod tx bank send {from_identifier} {from_identifier} '\n        f'{amount}{denom} --from {from_identifier} --yes'\n    )\n\n    if simulate_only:\n        base_cmd += ' --dry-run'\n\n    if home:\n        base_cmd += f' --home {home}'\n\n    full_cmd = f'{base_cmd} {txflags}'\n\n    try:\n        completed = subprocess.run(\n            shlex.split(full_cmd),\n            capture_output=True,\n            text=True,\n            check=False,\n        )\n    except OSError as exc:\n        raise JunodTxTestError(\n            f'Failed to execute junod command: {exc}'\n        ) from exc\n\n    result: Dict[str, Any] = {\n        'command': full_cmd,\n        'stdout': completed.stdout,\n        'stderr': completed.stderr,\n        'returncode': completed.returncode,\n    }\n\n    if completed.returncode != 0:\n        raise JunodTxTestError(\n            f'junod tx command failed with code {completed.returncode}: '\n            f\"{completed.stderr or completed.stdout}\"\n        )\n\n    return result\n",
	"validate_juno_address": "def validate_juno_address(address: str) -> str:\n    '''Validate that a string is a well-formed Juno bech32 address.\n\n    Returns the address if valid, otherwise raises InvalidJunoAddressError.\n    '''\n    if not isinstance(address, str):\n        raise InvalidJunoAddressError('Address must be a string.')\n\n    address = address.strip()\n    if not address:\n        raise InvalidJunoAddressError('Address must not be empty.')\n\n    # Basic prefix check first for clearer error messages\n    if not address.startswith('juno1'):\n        raise InvalidJunoAddressError('Address must start with prefix juno1.')\n\n    # Full bech32 decoding to verify checksum and HRP\n    hrp, data = bech32_decode(address)\n    if hrp != 'juno' or data is None:\n        raise InvalidJunoAddressError('Invalid Juno bech32 address: bad checksum or wrong prefix.')\n\n    return address\n",
	"fetch_all_balances": "def fetch_all_balances(address: str) -> Dict[str, Any]:\n    '''Query /cosmos/bank/v1beta1/balances/{address} on the Juno LCD and\n    return the combined balances (across pagination pages).\n\n    This function assumes validate_juno_address has already been called.\n    '''\n    url = f'{BASE_LCD_URL}/cosmos/bank/v1beta1/balances/{address}'\n    balances: List[Dict[str, Any]] = []\n    next_key: str | None = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            params: Dict[str, Any] = {}\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                response = await client.get(url, params=params)\n                response.raise_for_status()\n            except httpx.HTTPError as exc:\n                # Wrap HTTP errors so callers can handle them uniformly\n                raise RuntimeError(f'Error querying Juno LCD balances: {exc}') from exc\n\n            data = response.json() or {}\n            balances.extend(data.get('balances', []))\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return {'balances': balances}\n",
	"fetch_spendable_balances": "def fetch_spendable_balances(address: str) -> Dict[str, Any]:\n    '''Query /cosmos/bank/v1beta1/spendable_balances/{address} on the Juno LCD\n    and return the combined spendable balances (across pagination pages).\n\n    This function assumes validate_juno_address has already been called.\n    '''\n    url = f'{BASE_LCD_URL}/cosmos/bank/v1beta1/spendable_balances/{address}'\n    balances: List[Dict[str, Any]] = []\n    next_key: str | None = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            params: Dict[str, Any] = {}\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                response = await client.get(url, params=params)\n                response.raise_for_status()\n            except httpx.HTTPError as exc:\n                raise RuntimeError(f'Error querying Juno LCD spendable balances: {exc}') from exc\n\n            data = response.json() or {}\n            balances.extend(data.get('balances', []))\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return {'balances': balances}\n",
	"fetch_denoms_metadata": "def fetch_denoms_metadata() -> Dict[str, Any]:\n    '''Query /cosmos/bank/v1beta1/denoms_metadata on the Juno LCD and return\n    all denom metadata records (handling pagination).\n    '''\n    url = f'{BASE_LCD_URL}/cosmos/bank/v1beta1/denoms_metadata'\n    metadatas: List[Dict[str, Any]] = []\n    next_key: str | None = None\n\n    async with httpx.AsyncClient(timeout=10.0) as client:\n        while True:\n            params: Dict[str, Any] = {}\n            if next_key:\n                params['pagination.key'] = next_key\n\n            try:\n                response = await client.get(url, params=params)\n                response.raise_for_status()\n            except httpx.HTTPError as exc:\n                raise RuntimeError(f'Error querying Juno LCD denoms metadata: {exc}') from exc\n\n            data = response.json() or {}\n            metadatas.extend(data.get('metadatas', []))\n\n            pagination = data.get('pagination') or {}\n            next_key = pagination.get('next_key')\n            if not next_key:\n                break\n\n    return {'metadatas': metadatas}\n",
	"junoNetwork": "export const junoNetwork = {\n  chainId: 'juno-1',\n  // Use the documented LCD archive endpoint for Juno.\n  lcdEndpoint:\n    process.env.JUNO_LCD_ENDPOINT || 'https://lcd-archive.junonetwork.io',\n  // RPC endpoint is intentionally left to be provided via environment.\n  // See https://cosmos.directory/juno/nodes for public nodes or run your own.\n  rpcEndpoint: process.env.JUNO_RPC_ENDPOINT || 'http://localhost:26657',\n};\n",
	"openJunoFaucetUI": "export const openJunoFaucetUI = (faucetUrl) => {\n  // 'faucetUrl' should be configured in your environment, e.g.\n  // process.env.NEXT_PUBLIC_JUNO_UNI6_FAUCET_URL\n  if (typeof window === 'undefined') {\n    throw new Error('Cannot open faucet UI: window is not available (are you on the server?).');\n  }\n\n  if (!faucetUrl || typeof faucetUrl !== 'string') {\n    throw new Error('Faucet URL is not configured or is invalid.');\n  }\n\n  try {\n    const newWindow = window.open(faucetUrl, '_blank', 'noopener,noreferrer');\n\n    if (!newWindow) {\n      // Pop-up may be blocked by the browser\n      throw new Error('Failed to open the faucet UI. Please allow pop-ups for this site.');\n    }\n  } catch (err) {\n    console.error('Error opening Juno faucet UI:', err);\n    throw err;\n  }\n};\n",
	"instructUserToRequestFaucetTokens": "export const instructUserToRequestFaucetTokens = (address, denomLabel = 'JUNOX') => {\n  if (typeof window === 'undefined') {\n    throw new Error('Cannot show faucet instructions: window is not available (are you on the server?).');\n  }\n\n  if (!address || typeof address !== 'string') {\n    throw new Error('A valid Juno address is required before requesting faucet tokens.');\n  }\n\n  // This function does not attempt to automate the official faucet UI,\n  // because it is a separate web application and its implementation\n  // can change. Instead, we give clear instructions to the user.\n  const message = [\n    'A faucet window/tab should now be open.',\n    `1. Paste this address into the faucet address field: ${address}`,\n    `2. Select the token type (e.g., ${denomLabel}).`,\n    '3. Submit the request and wait for the faucet to confirm or show an error.',\n    '4. If you see errors such as rate limiting or daily limits, follow the faucet instructions or try again later.'\n  ].join('\\n');\n\n  // You can replace this alert with rendering a modal or in-app message.\n  window.alert(message);\n};\n"
}