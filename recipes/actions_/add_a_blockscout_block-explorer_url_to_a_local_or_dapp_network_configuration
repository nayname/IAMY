{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Locate the first network configuration file that contains Cosmos-related metadata such as `chainId`, `rpc`, or `explorer` by recursively walking the project directory.",
            "code": "# network_config_utils.py\n\nimport os\nimport json\nfrom typing import Optional\n\n\ndef find_network_config(root_dir: str = \".\") -> Optional[str]:\n    \"\"\"Recursively search *root_dir* for a probable network configuration file.\n\n    A file is considered a match if it:\n      \u2022 Has a JSON extension **and** contains keys like `chainId`, `rpc`, `explorer`, or `chain_name`.\n      \u2022 OR (for *.js, *.ts, *.yaml, *.yml, *.env*) contains the strings `chain-registry`, `walletConnect`, or `explorer`.\n\n    Returns the full path of the first match, or *None* if nothing is found.\n    \"\"\"\n    for dirpath, _, filenames in os.walk(root_dir):\n        for filename in filenames:\n            ext = os.path.splitext(filename)[1].lower()\n            if ext not in {\".json\", \".js\", \".ts\", \".yaml\", \".yml\", \".env\"}:\n                continue\n            full_path = os.path.join(dirpath, filename)\n            try:\n                if ext == \".json\":\n                    with open(full_path, \"r\", encoding=\"utf-8\") as f:\n                        data = json.load(f)\n                    if isinstance(data, dict) and any(k in data for k in (\"chainId\", \"rpc\", \"explorer\", \"chain_name\")):\n                        return full_path\n                else:\n                    with open(full_path, \"r\", encoding=\"utf-8\") as f:\n                        content = f.read()\n                    if any(keyword in content for keyword in (\"chain-registry\", \"walletConnect\", \"explorer\", \"rpc\")):\n                        return full_path\n            except Exception:\n                # Ignore parse errors and keep searching\n                continue\n    return None\n\n\nif __name__ == \"__main__\":\n    path = find_network_config()\n    if path:\n        print(f\"Found network config file at: {path}\")\n    else:\n        print(\"No network config file found.\")",
            "usage": "python network_config_utils.py  # prints the path, or\n\nfrom network_config_utils import find_network_config\nconfig_path = find_network_config('.')"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Insert or update the `explorer` field in the previously located configuration file so Blockscout becomes the default block explorer.",
            "code": "# update_blockscout_url.py\n\nimport json\nimport shutil\nimport sys\nfrom pathlib import Path\nfrom typing import Union\n\nDEFAULT_BLOCKSCOUT_URL = \"https://blockscout.evmos.org\"\n\n\ndef insert_blockscout_url(config_path: Union[str, Path], blockscout_url: str = DEFAULT_BLOCKSCOUT_URL) -> None:\n    \"\"\"Add or update an `explorer` key in a JSON config file.\n\n    A *.bak* backup is written before overwriting the original file.\n    \"\"\"\n    config_path = Path(config_path)\n    if not config_path.exists():\n        raise FileNotFoundError(f\"{config_path} not found\")\n\n    # Backup original\n    backup = config_path.with_suffix(config_path.suffix + \".bak\")\n    shutil.copyfile(config_path, backup)\n    print(f\"Backup created at {backup}\")\n\n    # Load JSON and mutate\n    with open(config_path, \"r\", encoding=\"utf-8\") as f:\n        data = json.load(f)\n\n    if not isinstance(data, dict):\n        raise ValueError(\"Expected top-level JSON object in config file\")\n\n    previous = data.get(\"explorer\")\n    data[\"explorer\"] = blockscout_url\n\n    with open(config_path, \"w\", encoding=\"utf-8\") as f:\n        json.dump(data, f, indent=2)\n\n    action = \"updated\" if previous else \"inserted\"\n    print(f\"`explorer` field {action} -> {blockscout_url}\")\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Usage: python update_blockscout_url.py <config_path> [blockscout_url]\")\n        sys.exit(1)\n\n    cfg = sys.argv[1]\n    url = sys.argv[2] if len(sys.argv) > 2 else DEFAULT_BLOCKSCOUT_URL\n    insert_blockscout_url(cfg, url)",
            "usage": "python update_blockscout_url.py ./path/to/config.json  # uses default Blockscout URL\n\n# or programmatically:\nfrom update_blockscout_url import insert_blockscout_url\ninsert_blockscout_url(config_path, \"https://blockscout.evmos.org\")"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Clear build caches and restart the local dev server so the new explorer setting is loaded by the dApp.",
            "code": "// propagate_config.js\n\n/**\n * Removes common cache directories and (re)starts the dev server.\n * Works for npm or yarn projects. Assumes a script named `dev` exists.\n */\n\nconst { execSync, spawn } = require(\"child_process\");\n\nfunction propagateConfig() {\n  try {\n    console.log(\"Stopping existing dev servers (if any)...\");\n    execSync('pkill -f \"npm run dev\" || true', { stdio: \"inherit\" });\n  } catch (_) {\n    /* It is fine if no process was found */\n  }\n\n  try {\n    console.log(\"Clearing build/cache directories...\");\n    execSync(\"rm -rf .next cache dist node_modules/.cache || true\", { stdio: \"inherit\" });\n  } catch (err) {\n    console.warn(\"Cache cleanup warning:\", err.message);\n  }\n\n  console.log(\"Starting dev server...\");\n  const cmd = process.env.USE_YARN ? \"yarn\" : \"npm\";\n  const child = spawn(cmd, [\"run\", \"dev\"], { stdio: \"inherit\" });\n\n  child.on(\"close\", (code) => {\n    console.log(`Dev server exited with code ${code}`);\n  });\n}\n\nif (require.main === module) {\n  propagateConfig();\n}\n\nmodule.exports = propagateConfig;",
            "usage": "node propagate_config.js  # clears cache & restarts `npm run dev` or `yarn dev`"
        }
    ]
}