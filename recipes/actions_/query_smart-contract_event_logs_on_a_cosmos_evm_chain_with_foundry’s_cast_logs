{
    "label": "query_contract",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Expose a FastAPI route that returns the correct JSON-RPC / WebSocket endpoint for a supported Cosmos EVM chain. The actual URLs live in environment variables so no secrets are leaked to the client.",
            "code": "from fastapi import FastAPI, HTTPException\nimport os\n\napp = FastAPI()\n\n# Map chain identifiers to ENV names holding their RPC endpoints\nCHAIN_RPC_ENV_MAP = {\n    \"evmos\": \"RPC_ENDPOINT_EVMOS\",   # example \u2192 https://evmos-rpc.publicnode.com\n    \"cronos\": \"RPC_ENDPOINT_CRONOS\", # example \u2192 https://rpc.cronos.org\n    \"kava\": \"RPC_ENDPOINT_KAVA\",     # example \u2192 https://evm.kava.io\n    \"cudos\": \"RPC_ENDPOINT_CUDOS\"    # example \u2192 https://rpc.cudos.org\n}\n\n@app.get(\"/api/rpc-endpoint\")\ndef get_rpc_endpoint(chain_id: str):\n    \"\"\"Return the RPC endpoint for a given EVM-compatible Cosmos chain.\"\"\"\n    env_key = CHAIN_RPC_ENV_MAP.get(chain_id.lower())\n    if env_key is None:\n        raise HTTPException(status_code=404, detail=f\"Unsupported chain_id '{chain_id}'.\")\n\n    endpoint = os.getenv(env_key)\n    if not endpoint:\n        raise HTTPException(status_code=500, detail=f\"Environment variable '{env_key}' is not set.\")\n\n    return {\"chain_id\": chain_id, \"rpc_endpoint\": endpoint}",
            "usage": "const rpcInfo = await fetch('/api/rpc-endpoint?chain_id=evmos').then(r => r.json());\nconsole.log(rpcInfo.rpc_endpoint);"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Add a route that validates an EVM contract address and returns its checksummed form, guaranteeing downstream correctness.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom web3 import Web3\n\napp = FastAPI()\n\n@app.get(\"/api/validate-address\")\ndef validate_address(address: str):\n    \"\"\"Verify that `address` is a valid EVM address and return its checksum version.\"\"\"\n    if not Web3.isAddress(address):\n        raise HTTPException(status_code=400, detail=\"Address is not a valid hex EVM address.\")\n\n    checksum_address = Web3.toChecksumAddress(address)\n    return {\"checksum_address\": checksum_address}",
            "usage": "const { checksum_address } = await fetch(`/api/validate-address?address=${rawAddr}`).then(r => r.json());"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Provide a POST route that downloads a contract\u2019s ABI JSON from a given URL (or GitHub raw link) and stores it locally so later steps can decode events.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport requests, os, json\n\napp = FastAPI()\n\nABI_DIR = os.getenv(\"ABI_DIR\", \"abis\")\nos.makedirs(ABI_DIR, exist_ok=True)\n\nclass AbiRequest(BaseModel):\n    source_url: str       # e.g. https://raw.githubusercontent.com/\u2026/MyContract.json\n    contract_name: str    # used as filename prefix\n\n@app.post(\"/api/abi\")\ndef download_abi(req: AbiRequest):\n    \"\"\"Download and persist the ABI JSON so other endpoints can reuse it.\"\"\"\n    try:\n        res = requests.get(req.source_url)\n        res.raise_for_status()\n        abi_json = res.json()\n    except Exception as err:\n        raise HTTPException(status_code=400, detail=f\"Failed to fetch/parse ABI: {err}\")\n\n    file_path = os.path.join(ABI_DIR, f\"{req.contract_name}.abi.json\")\n    with open(file_path, \"w\") as fp:\n        json.dump(abi_json, fp, indent=2)\n\n    return {\"saved_to\": file_path}",
            "usage": "await fetch('/api/abi', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    source_url: 'https://raw.githubusercontent.com/myrepo/MyContract.json',\n    contract_name: 'MyContract'\n  })\n}).then(r => r.json());"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Expose a POST route that queries on-chain logs for the contract between two block heights and (optionally) filters by topics. It uses Web3.py to avoid shelling out to `cast` and returns raw logs that the frontend can render.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List, Union\nfrom web3 import Web3\nimport os, json\n\napp = FastAPI()\n\nABI_DIR = os.getenv(\"ABI_DIR\", \"abis\")\nCHAIN_RPC_ENV_MAP = {\n    \"evmos\": \"RPC_ENDPOINT_EVMOS\",\n    \"cronos\": \"RPC_ENDPOINT_CRONOS\",\n    \"kava\": \"RPC_ENDPOINT_KAVA\",\n    \"cudos\": \"RPC_ENDPOINT_CUDOS\"\n}\n\nclass LogRequest(BaseModel):\n    chain_id: str           # evmos / cronos / \u2026\n    contract_name: str      # must match the filename saved in Step 3\n    address: str            # checksummed or not\n    from_block: Union[int, str]\n    to_block:   Union[int, str] = \"latest\"\n    topics:     List[str] = []\n\n@app.post(\"/api/logs\")\ndef fetch_logs(req: LogRequest):\n    \"\"\"Return raw logs for the requested filter; decode can be done client-side if desired.\"\"\"\n    env_key = CHAIN_RPC_ENV_MAP.get(req.chain_id.lower())\n    if env_key is None:\n        raise HTTPException(status_code=404, detail=f\"Unsupported chain_id '{req.chain_id}'.\")\n\n    rpc_endpoint = os.getenv(env_key)\n    if not rpc_endpoint:\n        raise HTTPException(status_code=500, detail=f\"Environment variable '{env_key}' is not set.\")\n\n    w3 = Web3(Web3.HTTPProvider(rpc_endpoint))\n    if not w3.isConnected():\n        raise HTTPException(status_code=502, detail=\"Could not connect to RPC endpoint.\")\n\n    if not Web3.isAddress(req.address):\n        raise HTTPException(status_code=400, detail=\"Invalid contract address.\")\n    checksum_address = Web3.toChecksumAddress(req.address)\n\n    # Ensure ABI exists (even if we don\u2019t decode here, caller likely uploaded it)\n    abi_path = os.path.join(ABI_DIR, f\"{req.contract_name}.abi.json\")\n    if not os.path.exists(abi_path):\n        raise HTTPException(status_code=400, detail=f\"ABI file not found: {abi_path}\")\n\n    filter_params = {\n        \"fromBlock\": req.from_block,\n        \"toBlock\":   req.to_block,\n        \"address\":   checksum_address,\n        \"topics\":    req.topics if req.topics else None\n    }\n\n    try:\n        raw_logs = w3.eth.get_logs(filter_params)\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=f\"get_logs failed: {err}\")\n\n    # Transform HexBytes \u2192 hex strings for JSON friendliness\n    parsed_logs = []\n    for log in raw_logs:\n        parsed_logs.append({\n            \"blockNumber\": log.blockNumber,\n            \"transactionHash\": log.transactionHash.hex(),\n            \"address\": log.address,\n            \"data\": log.data,\n            \"topics\": [t.hex() for t in log.topics]\n        })\n\n    return {\"total\": len(parsed_logs), \"logs\": parsed_logs}",
            "usage": "const logs = await fetch('/api/logs', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    chain_id: 'evmos',\n    contract_name: 'MyContract',\n    address: checksumAddress,\n    from_block: 1000000,\n    to_block: 'latest',\n    topics: ['0xddf252ad\u2026']\n  })\n}).then(r => r.json());\nconsole.log(logs);"
        }
    ]
}