{
    "label": "execute",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Ensure the user\u2019s browser wallet (e.g., Keplr) is connected and return the active bech32 address that will be the proposal\u2019s proposer.",
            "code": "/* utils/wallet.js */\nexport const ensureWalletConnected = async () => {\n  try {\n    const chainId = 'cosmoshub-4';            // \u203c\ufe0f Replace with your target chain\n    if (!window.keplr) {\n      throw new Error('Keplr extension not found. Please install Keplr and refresh.');\n    }\n\n    // Request wallet connection\n    await window.keplr.enable(chainId);\n\n    // Get an OfflineSigner and extract the first account address\n    const signer = window.getOfflineSigner(chainId);\n    const [account] = await signer.getAccounts();\n\n    if (!account?.address) {\n      throw new Error('Unable to fetch wallet address.');\n    }\n\n    return account.address; // Bech32 address of the proposer\n  } catch (error) {\n    console.error('[ensureWalletConnected] \u274c', error);\n    throw error;\n  }\n};",
            "usage": "import { ensureWalletConnected } from './utils/wallet';\n\nconst proposerAddress = await ensureWalletConnected();\nconsole.log('\u2705 Proposer address:', proposerAddress);"
        },
        {
            "step": 2,
            "label": "frontend",
            "introduction": "Collect proposal metadata (title, description, summary, deposit) from user input and return it as a validated JavaScript object.",
            "code": "/* utils/metadata.js */\nexport const gatherProposalMetadata = ({\n  title,\n  description,\n  summary,\n  depositAmount,\n  depositDenom\n}) => {\n  // Basic validation\n  if (!title || !description || !summary) {\n    throw new Error('Title, description, and summary are required.');\n  }\n  if (!/^[0-9]+$/.test(depositAmount)) {\n    throw new Error('Deposit amount must be an integer string (micro-denom).');\n  }\n  if (!depositDenom) {\n    throw new Error('Deposit denom is required (e.g., \"uatom\").');\n  }\n\n  return {\n    title: title.trim(),\n    description: description.trim(),\n    summary: summary.trim(),\n    deposit_amount: depositAmount.trim(),\n    deposit_denom: depositDenom.trim()\n  };\n};",
            "usage": "import { gatherProposalMetadata } from './utils/metadata';\n\nconst meta = gatherProposalMetadata({\n  title: 'Increase Community Pool',\n  description: 'A proposal to increase the community pool by 1 ATOM.',\n  summary: 'Increase ATOM community pool',\n  depositAmount: '1000000', // 1 ATOM in uatom\n  depositDenom: 'uatom'\n});"
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "Send the collected metadata and proposer address to the backend for message construction, signing, and broadcasting.",
            "code": "/* services/proposal.js */\nexport const submitTextProposal = async ({ proposerAddress, metadata }) => {\n  try {\n    const res = await fetch('/api/proposal/submit', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ proposer_address: proposerAddress, ...metadata })\n    });\n\n    if (!res.ok) {\n      const err = await res.text();\n      throw new Error(`Backend error: ${err}`);\n    }\n\n    const data = await res.json();\n    /* data = {\n         tx_hash: 'ABC123...',\n         proposal_id: 42\n       }\n    */\n    return data;\n  } catch (error) {\n    console.error('[submitTextProposal] \u274c', error);\n    throw error;\n  }\n};",
            "usage": "import { submitTextProposal } from './services/proposal';\n\nconst { tx_hash, proposal_id } = await submitTextProposal({\n  proposerAddress,\n  metadata: meta\n});\nconsole.log('\u2705 Tx broadcasted:', tx_hash, 'Proposal ID:', proposal_id);"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "FastAPI route that builds a MsgSubmitProposal (TextProposal), signs it with a server-side key (read from an environment variable), and broadcasts the transaction using cosmpy.",
            "code": "# backend/routes/proposal.py\nimport os\nimport logging\nfrom fastapi import APIRouter, HTTPException\nfrom pydantic import BaseModel, Field\nfrom cosmpy.aerial.client import LedgerClient, NetworkConfig\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.wallet import LocalWallet\nfrom cosmpy.protos.cosmos.gov.v1beta1.tx_pb2 import MsgSubmitProposal\nfrom cosmpy.protos.cosmos.gov.v1beta1.gov_pb2 import TextProposal\nfrom cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin\nfrom google.protobuf.any_pb2 import Any as Any_pb2\n\nrouter = APIRouter(prefix=\"/api/proposal\")\nlogger = logging.getLogger(\"proposal\")\n\n# ---------- Pydantic Schema ---------- #\nclass SubmitProposalBody(BaseModel):\n    proposer_address: str = Field(..., description=\"Bech32 address of the proposer\")\n    title: str\n    description: str\n    summary: str\n    deposit_amount: str = Field(..., regex=r\"^\\d+$\", description=\"Micro-denom amount as string\")\n    deposit_denom: str\n\n# ---------- Helpers ---------- #\n\ndef _get_network() -> NetworkConfig:\n    return NetworkConfig(\n        chain_id=os.getenv(\"CHAIN_ID\", \"cosmoshub-4\"),\n        url=os.getenv(\"GRPC_ENDPOINT\", \"grpc+https://cosmoshub.grpc.polkachu.com:443\"),\n    )\n\ndef _get_wallet() -> LocalWallet:\n    mnemonic = os.getenv(\"PROPOSER_MNEMONIC\")\n    if not mnemonic:\n        raise RuntimeError(\"PROPOSER_MNEMONIC env var is missing\")\n    return LocalWallet.from_mnemonic(mnemonic)\n\n# ---------- Route ---------- #\n@router.post(\"/submit\")\nasync def submit_text_proposal(body: SubmitProposalBody):\n    try:\n        # 1. Init network + wallet\n        network = _get_network()\n        client = LedgerClient(network)\n        wallet = _get_wallet()\n\n        if wallet.address() != body.proposer_address:\n            raise HTTPException(status_code=400, detail=\"Server wallet address \u2260 proposer address.\")\n\n        # 2. Build TextProposal content\n        text_content = TextProposal(title=body.title, description=body.description)\n        any_content = Any_pb2()\n        any_content.Pack(text_content)\n        any_content.type_url = \"/cosmos.gov.v1beta1.TextProposal\"\n\n        # 3. Build MsgSubmitProposal\n        msg = MsgSubmitProposal(\n            content=any_content,\n            proposer=wallet.address(),\n            initial_deposit=[Coin(amount=body.deposit_amount, denom=body.deposit_denom)],\n        )\n\n        # 4. Create & sign tx\n        tx = Transaction()\n        tx.add_message(msg)\n        tx.with_gas(200000)  # heuristic; adjust as needed\n        tx.with_fee(3000)    # micro-denom fee\n        tx.with_memo(body.summary)\n\n        signed_tx = wallet.sign_transaction(tx)\n\n        # 5. Broadcast and wait for inclusion\n        result = client.broadcast_tx_block(signed_tx)\n        if result.code != 0:\n            logger.error(\"Broadcast failed %s\", result.raw_log)\n            raise HTTPException(status_code=500, detail=f\"Broadcast error: {result.raw_log}\")\n\n        # Extract proposal ID from logs (gov module emits it)\n        proposal_id = None\n        for event in result.events:\n            if event[\"type\"] == \"submit_proposal\":\n                for attr in event[\"attributes\"]:\n                    if attr[\"key\"] == \"proposal_id\":\n                        proposal_id = int(attr[\"value\"])\n                        break\n        if proposal_id is None:\n            raise HTTPException(status_code=500, detail=\"Unable to parse proposal_id from tx logs\")\n\n        return {\n            \"tx_hash\": result.tx_hash,\n            \"proposal_id\": proposal_id\n        }\n    except HTTPException:\n        raise\n    except Exception as err:\n        logger.exception(\"submit_text_proposal failed\")\n        raise HTTPException(status_code=500, detail=str(err))",
            "usage": "curl -X POST http://localhost:8000/api/proposal/submit \\\n     -H 'Content-Type: application/json' \\\n     -d '{\n           \"proposer_address\": \"<bech32-address>\",\n           \"title\": \"Increase Community Pool\",\n           \"description\": \"A proposal to increase the community pool by 1 ATOM.\",\n           \"summary\": \"Increase ATOM community pool\",\n           \"deposit_amount\": \"1000000\",\n           \"deposit_denom\": \"uatom\"\n         }'"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Provide an endpoint that queries the on-chain proposal state by ID to verify it entered VotingPeriod (or other status).",
            "code": "# backend/routes/proposal_status.py\nimport os\nimport requests\nfrom fastapi import APIRouter, HTTPException\n\nrouter = APIRouter(prefix=\"/api/proposal\")\nREST_ENDPOINT = os.getenv(\"REST_ENDPOINT\", \"https://api.cosmos.network\")\n\n@router.get(\"/{proposal_id}\")\nasync def get_proposal_status(proposal_id: int):\n    try:\n        url = f\"{REST_ENDPOINT}/cosmos/gov/v1beta1/proposals/{proposal_id}\"\n        r = requests.get(url, timeout=10)\n        if r.status_code != 200:\n            raise HTTPException(status_code=r.status_code, detail=r.text)\n        json_data = r.json()\n        status = json_data[\"proposal\"][\"status\"]\n        return {\n            \"proposal_id\": proposal_id,\n            \"status\": status,\n            \"raw\": json_data\n        }\n    except HTTPException:\n        raise\n    except Exception as err:\n        raise HTTPException(status_code=500, detail=str(err))",
            "usage": "fetch('/api/proposal/42')\n  .then((res) => res.json())\n  .then((data) => console.log('\ud83d\uddf3\ufe0f Proposal status:', data.status));"
        }
    ]
}