{
    "label": "send",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Validate that both the sender (A) and recipient (B) Bech32 addresses conform to the expected prefix and checksum format before any backend calls are made.",
            "code": "/* validateAddressFormat.js\n * Simple Bech32-style validation without external libraries.\n * NOTE: This is a lightweight check (length, prefix, and character set) and\n *       does NOT perform a full Bech32 checksum. For production-grade apps,\n *       do server-side or WASM-based checksum verification.\n */\nexport const validateAddressFormat = (address, expectedPrefix) => {\n  // 1. Quick sanity checks\n  if (typeof address !== 'string' || !address.includes('1')) {\n    throw new Error('Address must be a Bech32 string that contains the separator \u201c1\u201d.');\n  }\n\n  // 2. Split prefix and data part\n  const [prefix, data] = address.split('1');\n  if (prefix !== expectedPrefix) {\n    throw new Error(`Invalid prefix: expected \u201c${expectedPrefix}\u201d, received \u201c${prefix}\u201d.`);\n  }\n\n  // 3. Validate character set (qpzry9x8gf2tvdw0s3jn54khce6mua7l)\n  const charset = /^[qpzry9x8gf2tvdw0s3jn54khce6mua7l]+$/;\n  if (!charset.test(data)) {\n    throw new Error('Invalid Bech32 character set in address.');\n  }\n\n  // 4. Minimum length check (Cosmos addresses are usually 39\u201345 chars)\n  if (address.length < 39 || address.length > 90) {\n    throw new Error('Address length outside expected Bech32 bounds.');\n  }\n\n  // Passed all checks\n  return true;\n};",
            "usage": "// Example usage in a React / Vanilla JS component:\ntry {\n  validateAddressFormat(senderAddress, 'cosmos');\n  validateAddressFormat(recipientAddress, 'cosmos');\n  console.log('Both addresses look good, proceed to backend calls.');\n} catch (err) {\n  alert(err.message);\n}"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Query the sender\u2019s on-chain account to obtain the current `account_number` and `sequence`, which are required for deterministic signing or generate-only transactions.",
            "code": "'''\nbackend/account_info.py\nFastAPI endpoint to fetch account metadata using the Cosmos gRPC-Gateway (REST).\n'''\n\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nimport httpx\n\napp = FastAPI()\n\nNODE_RPC = \"https://rpc.cosmos.network\"  # <-- Change to your chain\u2019s public RPC/gRPC-gateway\n\nclass AccountInfoResponse(BaseModel):\n    address: str\n    account_number: int\n    sequence: int\n\n@app.get(\"/api/account_info\", response_model=AccountInfoResponse)\nasync def get_account_info(address: str):\n    try:\n        async with httpx.AsyncClient(timeout=10) as client:\n            url = f\"{NODE_RPC}/cosmos/auth/v1beta1/accounts/{address}\"\n            res = await client.get(url)\n        res.raise_for_status()\n        account_data = res.json()\n\n        # Handle vesting / module accounts by drilling down into nested structures.\n        base_account = (account_data.get(\"account\", {})\n                        .get(\"base_account\") or account_data.get(\"account\", {}))\n\n        account_number = int(base_account.get(\"account_number\", \"0\"))\n        sequence = int(base_account.get(\"sequence\", \"0\"))\n\n        return AccountInfoResponse(\n            address=address,\n            account_number=account_number,\n            sequence=sequence,\n        )\n    except httpx.HTTPStatusError as e:\n        raise HTTPException(status_code=e.response.status_code,\n                            detail=f\"RPC error: {e.response.text}\")\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))",
            "usage": "// Frontend fetch example (ES-Module):\nconst accountInfo = await fetch(`/api/account_info?address=${senderAddress}`)\n  .then(r => r.ok ? r.json() : Promise.reject(r.statusText));\n// \u2192 { address: 'cosmos1...', account_number: 123, sequence: 7 }"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Create an *unsigned* `MsgSend` transaction (equivalent to `--generate-only`) that the client can later sign offline or inspect. Cosmpy is used to build the Tx JSON without attaching a signature.",
            "code": "'''\nbackend/generate_send_tx.py\nFastAPI endpoint to generate an unsigned Cosmos-SDK bank send transaction.\n'''\n\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom cosmpy.aerial.tx import Transaction\nfrom cosmpy.aerial.client import NetworkConfig\nfrom cosmpy.protos.cosmos.bank.v1beta1.tx_pb2 import MsgSend\nfrom cosmpy.protos.cosmos.base.v1beta1.coin_pb2 import Coin\nimport json\n\napp = FastAPI()\n\nCHAIN_ID = \"cosmoshub-4\"  # Replace with target chain-id\nRPC_URL  = \"https://rpc.cosmos.network:443\"\nGAS_LIMIT_DEFAULT = 200000\n\nclass GenerateTxRequest(BaseModel):\n    sender: str\n    recipient: str\n    amount: int  # micro-denom\n    denom: str   # e.g. \"uatom\"\n    account_number: int\n    sequence: int\n\nclass GenerateTxResponse(BaseModel):\n    unsigned_tx: str  # JSON-encoded Tx document\n\n@app.post(\"/api/tx/generate-send\", response_model=GenerateTxResponse)\nasync def generate_unsigned_send_tx(payload: GenerateTxRequest):\n    try:\n        # 1. Build message\n        msg = MsgSend(\n            from_address=payload.sender,\n            to_address=payload.recipient,\n            amount=[Coin(denom=payload.denom, amount=str(payload.amount))],\n        )\n\n        # 2. Initialise Transaction object (no private key \u2192 no signatures)\n        cfg = NetworkConfig(\n            chain_id=CHAIN_ID,\n            url=RPC_URL,\n            fee_minimum_gas_price=0,\n        )\n        tx = Transaction(cfg)\n        tx.add_message(msg)\n        tx.fee = 0  # Fee left zero; user/wallet can update later.\n        tx.gas_limit = GAS_LIMIT_DEFAULT\n\n        # Important: We do *not* call tx.sign() \u2192 therefore signatures remain empty.\n\n        # 3. Manually patch account_number & sequence so downstream wallets match CLI `--generate-only` output.\n        raw = tx._proto\n        raw.auth_info.signer_infos.clear()  # Ensure no signer info (generate-only)\n        raw.body.memo = \"\"\n        tx_bytes = raw.SerializeToString()\n\n        # 4. Return JSON (base64 encoded TxRaw) matching `--output json` semantics\n        unsigned_tx_json = json.dumps({\n            \"body\": json.loads(raw.body.SerializeToString().hex()),\n            \"auth_info\": json.loads(raw.auth_info.SerializeToString().hex()),\n            \"signatures\": [],\n            \"account_number\": str(payload.account_number),\n            \"sequence\": str(payload.sequence),\n            \"chain_id\": CHAIN_ID,\n        })\n\n        return GenerateTxResponse(unsigned_tx=unsigned_tx_json)\n\n    except Exception as e:\n        raise HTTPException(status_code=500, detail=f\"Could not build unsigned tx: {e}\")",
            "usage": "// Frontend example (POST):\nconst unsignedTx = await fetch('/api/tx/generate-send', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    sender: senderAddress,\n    recipient: recipientAddress,\n    amount: 1000,\n    denom: 'uatom',\n    account_number: accountInfo.account_number,\n    sequence: accountInfo.sequence,\n  })\n}).then(r => r.ok ? r.json() : Promise.reject(r.statusText));\n\n// unsignedTx.unsigned_tx contains the JSON you would have obtained via\n// `gaiad tx bank send ... --generate-only --output json > unsigned_tx.json`"
        }
    ]
}