{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Locate the Cosmos node\u2019s app.toml file inside the chosen home directory.",
            "code": "import os\nfrom pathlib import Path\n\n\ndef locate_config_file(node_home: str) -> str:\n    '''\n    Locate the app.toml file inside a Cosmos-SDK node home directory.\n\n    Args:\n        node_home (str): Absolute path to the node's home (e.g. '/home/ubuntu/.appd')\n    Returns:\n        str: Absolute path string to app.toml\n    Raises:\n        FileNotFoundError: If the file cannot be found\n    '''\n    config_path = Path(node_home) / 'config' / 'app.toml'\n    if not config_path.exists():\n        raise FileNotFoundError(f'Configuration file not found at {config_path}')\n    return str(config_path)\n",
            "usage": "config_path = locate_config_file(os.path.expanduser('~/.appd'))"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Read the located TOML file into a Python dictionary so it can be modified in-memory.",
            "code": "import os\n\n\ndef load_config_file(file_path: str) -> dict:\n    '''\n    Load a TOML configuration file and return its contents as a Python dict.\n    Prefers the built-in `tomllib` (Python 3.11+); falls back to the external\n    `toml` package when necessary.\n    '''\n    try:\n        import tomllib  # Python 3.11+\n        with open(file_path, 'rb') as fp:\n            return tomllib.load(fp)\n    except ModuleNotFoundError:\n        try:\n            import toml  # type: ignore\n        except ModuleNotFoundError as exc:\n            raise ModuleNotFoundError('`toml` library required. Install via `pip install toml`.') from exc\n        with open(file_path, 'r', encoding='utf-8') as fp:\n            return toml.load(fp)\n",
            "usage": "config_data = load_config_file(config_path)"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Modify the in-memory configuration so `minimum-gas-prices` equals `0.01token`.",
            "code": "def update_toml_value(config_data: dict, key: str = 'minimum-gas-prices', value: str = '0.01token') -> dict:\n    '''\n    Update (or add) a key in the TOML configuration dictionary.\n    '''\n    config_data[key] = value\n    return config_data\n",
            "usage": "updated_config = update_toml_value(config_data, value='0.01token')"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Write the updated configuration back to app.toml on disk.",
            "code": "def save_file(config_data: dict, file_path: str) -> None:\n    '''\n    Persist the in-memory TOML dictionary back to disk.\n    Uses the `toml` library for serialization.\n    '''\n    try:\n        import toml  # type: ignore\n    except ModuleNotFoundError as exc:\n        raise ModuleNotFoundError('`toml` library required. Install via `pip install toml`.') from exc\n\n    with open(file_path, 'w', encoding='utf-8') as fp:\n        toml.dump(config_data, fp)\n",
            "usage": "save_file(updated_config, config_path)"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Restart the node process so the new gas-price floor is picked up.",
            "code": "import subprocess\n\n\ndef restart_node_process(service_name: str) -> None:\n    '''\n    Restart the Cosmos-SDK node systemd service so configuration changes take effect.\n    '''\n    try:\n        subprocess.run(['systemctl', 'restart', service_name], check=True, capture_output=True)\n        print(f'[\u2713] Service {service_name} restarted')\n    except subprocess.CalledProcessError as err:\n        stderr = err.stderr.decode() if err.stderr else str(err)\n        raise RuntimeError(f'Failed to restart {service_name}: {stderr}') from err\n",
            "usage": "restart_node_process('appd')"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Confirm via the CLI that the running node reports the new minimum-gas-prices value.",
            "code": "import json\nimport subprocess\nimport time\n\n\ndef verify_config_value(binary: str, expected_value: str = '0.01token', retries: int = 5, delay: int = 3) -> bool:\n    '''\n    Poll the node CLI until it reports the desired minimum-gas-prices value.\n    '''\n    for attempt in range(1, retries + 1):\n        try:\n            result = subprocess.run([binary, 'status'], capture_output=True, text=True, check=True)\n            data = json.loads(result.stdout)\n\n            mgp = (\n                data.get('MinimumGasPrices')\n                or data.get('minimum_gas_prices')\n                or data.get('NodeInfo', {}).get('minimum_gas_price')\n            )\n\n            if mgp == expected_value:\n                print(f'[\u2713] minimum-gas-prices verified as {mgp}')\n                return True\n\n            print(f'[Attempt {attempt}] Current value {mgp} != expected {expected_value}')\n\n        except Exception as exc:\n            print(f'[Attempt {attempt}] Error verifying min gas price: {exc}')\n\n        time.sleep(delay)\n\n    raise RuntimeError('Unable to confirm minimum-gas-prices change after multiple attempts')\n",
            "usage": "verify_config_value('appd', '0.01token')"
        }
    ]
}