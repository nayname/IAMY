{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Gracefully shuts down a running process by sending it a SIGINT signal or, optionally, stopping a systemd service. This triggers deferred cleanup logic such as `pprof.StopCPUProfile()` inside a Cosmos SDK node.",
            "code": "import os\nimport signal\nimport subprocess\nfrom typing import Optional\n\n\ndef graceful_shutdown(pid: Optional[int] = None, *, use_systemctl: bool = False, service_name: Optional[str] = None) -> None:\n    \"\"\"Send a graceful shutdown signal.\n\n    Args:\n        pid (int, optional): The PID of the running process. Required if `use_systemctl` is False.\n        use_systemctl (bool): Whether to stop a systemd service instead of sending SIGINT.\n        service_name (str, optional): Name of the systemd service. Required if `use_systemctl` is True.\n\n    Raises:\n        ValueError: If required arguments are missing.\n        RuntimeError: If the shutdown command fails.\n    \"\"\"\n    if use_systemctl:\n        if not service_name:\n            raise ValueError(\"'service_name' is required when 'use_systemctl' is True\")\n        try:\n            result = subprocess.run([\"systemctl\", \"stop\", service_name], check=True, capture_output=True, text=True)\n            print(result.stdout.strip())\n        except subprocess.CalledProcessError as err:\n            raise RuntimeError(f\"Failed to stop service '{service_name}': {err.stderr.strip()}\") from err\n    else:\n        if pid is None:\n            raise ValueError(\"'pid' is required when 'use_systemctl' is False\")\n        try:\n            os.kill(pid, signal.SIGINT)\n            print(f\"Sent SIGINT to PID {pid} \u2026\")\n        except ProcessLookupError:\n            raise RuntimeError(f\"Process with PID {pid} does not exist.\")\n        except PermissionError:\n            raise RuntimeError(f\"Permission denied to signal PID {pid}.\")",
            "usage": "# Stop by PID\n# graceful_shutdown(pid=12345)\n\n# Or stop a systemd service\n# graceful_shutdown(use_systemctl=True, service_name=\"gaiad.service\")"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Polls the target process until it has completely exited and optionally searches a log file for the 'stopping CPU profiler' message.",
            "code": "import os\nimport time\nfrom pathlib import Path\nfrom typing import Optional\n\n\ndef wait_for_exit(pid: int, *, log_path: Optional[str] = None, timeout: int = 120, poll_interval: float = 1.0) -> None:\n    \"\"\"Wait for a process to exit and confirm profiler stop message.\n\n    Args:\n        pid (int): The PID to monitor.\n        log_path (str, optional): Path to the application log file.\n        timeout (int): Maximum seconds to wait before giving up.\n        poll_interval (float): Seconds between checks.\n\n    Raises:\n        TimeoutError: If the process is still running after the timeout period.\n    \"\"\"\n    start_time = time.time()\n    profiler_msg_found = False\n\n    log_file: Optional[Path] = Path(log_path) if log_path else None\n    log_offset = log_file.stat().st_size if log_file and log_file.exists() else 0\n\n    while True:\n        # Check if the process has exited\n        if not os.path.exists(f\"/proc/{pid}\"):\n            print(f\"PID {pid} has exited.\")\n            break\n\n        # Optionally scan new log output for profiler message\n        if log_file and log_file.exists():\n            with log_file.open(\"r\") as lf:\n                lf.seek(log_offset)\n                for line in lf:\n                    if \"stopping CPU profiler\" in line:\n                        profiler_msg_found = True\n                        print(\"Detected 'stopping CPU profiler' in logs.\")\n                        break\n                log_offset = lf.tell()\n\n        if time.time() - start_time > timeout:\n            raise TimeoutError(f\"Process {pid} did not exit within {timeout}s.\")\n\n        time.sleep(poll_interval)\n\n    if log_file and not profiler_msg_found:\n        print(\"Warning: 'stopping CPU profiler' not found in logs. The node may not have flushed the profile correctly.\")",
            "usage": "# Example usage assuming the node writes to /var/log/node.log\n# wait_for_exit(pid=12345, log_path=\"/var/log/node.log\")"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Verifies that the CPU profile file (`cpu.prof`) exists on disk and is non-empty, ensuring that profiling data was successfully flushed.",
            "code": "from pathlib import Path\n\n\ndef verify_profile_file(profile_path: str = \"cpu.prof\") -> int:\n    \"\"\"Validate the profiler output file.\n\n    Args:\n        profile_path (str): Location of the profile file.\n\n    Returns:\n        int: Size of the profile file in bytes.\n\n    Raises:\n        FileNotFoundError: If the file is missing.\n        ValueError: If the file is empty.\n    \"\"\"\n    file_path = Path(profile_path)\n\n    if not file_path.exists():\n        raise FileNotFoundError(f\"Profile file not found: {profile_path}\")\n\n    size = file_path.stat().st_size\n    if size == 0:\n        raise ValueError(f\"Profile file is empty: {profile_path}\")\n\n    print(f\"Profile file '{profile_path}' verified with size {size} bytes.\")\n    return size",
            "usage": "# Ensure the profile exists and is non-empty\n# size = verify_profile_file(\"/var/lib/node/cpu.prof\")"
        }
    ]
}