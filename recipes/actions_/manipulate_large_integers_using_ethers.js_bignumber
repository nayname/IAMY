{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Step 1 defines a lightweight Python BigNumber utility class that mimics ethers.js BigNumber behavior using Python's Decimal for arbitrary-precision arithmetic.",
            "code": "# big_number.py\nfrom decimal import Decimal, getcontext\nfrom typing import Union\n\n\nclass BigNumber:\n    '''A minimal BigNumber implementation using Python Decimal for arbitrary precision arithmetic.'''\n\n    def __init__(self, value: Union[str, int, float]):\n        if isinstance(value, (int, float)):\n            value = str(value)\n        if not isinstance(value, str):\n            raise TypeError('BigNumber value must be str, int, or float')\n        # Increase precision to handle very large numbers\n        getcontext().prec = max(len(value) * 2, 50)\n        self._value = Decimal(value)\n\n    def add(self, other: 'BigNumber') -> 'BigNumber':\n        return BigNumber(str(self._value + other._value))\n\n    def sub(self, other: 'BigNumber') -> 'BigNumber':\n        return BigNumber(str(self._value - other._value))\n\n    def mul(self, other: 'BigNumber') -> 'BigNumber':\n        return BigNumber(str(self._value * other._value))\n\n    def div(self, other: 'BigNumber') -> 'BigNumber':\n        if other._value == 0:\n            raise ZeroDivisionError('Division by zero is not allowed.')\n        return BigNumber(str(self._value / other._value))\n\n    def pow(self, exponent: int) -> 'BigNumber':\n        if not isinstance(exponent, int):\n            raise TypeError('Exponent must be an integer.')\n        return BigNumber(str(self._value ** exponent))\n\n    def __str__(self) -> str:\n        value_str = format(self._value, 'f')\n        return value_str.rstrip('0').rstrip('.') if '.' in value_str else value_str\n\n    def to_int(self) -> int:\n        return int(self._value)\n\n    def to_decimal(self) -> Decimal:\n        return self._value\n",
            "usage": "from big_number import BigNumber\nbn = BigNumber('1000000000000000000')\nprint(str(bn))  # '1000000000000000000'"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Step 2 exposes a FastAPI endpoint that lets the frontend create BigNumber instances on the backend.",
            "code": "from fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom big_number import BigNumber\n\napp = FastAPI()\n\nclass CreateRequest(BaseModel):\n    value: str\n\nclass CreateResponse(BaseModel):\n    big_number: str\n\n@app.post('/api/bignumber/create', response_model=CreateResponse)\nasync def create_bignumber(req: CreateRequest):\n    '''Instantiate a BigNumber from a given string, int, or float.'''\n    try:\n        bn = BigNumber(req.value)\n    except (TypeError, ValueError) as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    return {'big_number': str(bn)}\n",
            "usage": "const resp = await fetch('/api/bignumber/create', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ value: '1000000000000000000' })\n});\nconst data = await resp.json();\nconsole.log(data.big_number); // '1000000000000000000'"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Step 3 adds another endpoint to perform safe arithmetic operations (add, sub, mul, div, pow) between BigNumber values.",
            "code": "from enum import Enum\nfrom typing import Optional\nfrom fastapi import FastAPI, HTTPException\nfrom pydantic import BaseModel\nfrom big_number import BigNumber\n\napp = FastAPI()\n\nclass Operation(str, Enum):\n    add = 'add'\n    sub = 'sub'\n    mul = 'mul'\n    div = 'div'\n    pow = 'pow'\n\nclass OperateRequest(BaseModel):\n    a: str\n    b: Optional[str] = None\n    operation: Operation\n    exponent: Optional[int] = None\n\nclass OperateResponse(BaseModel):\n    result: str\n\n@app.post('/api/bignumber/operate', response_model=OperateResponse)\nasync def operate(req: OperateRequest):\n    '''Perform arithmetic operations between BigNumber values or exponentiation.'''\n    try:\n        a_bn = BigNumber(req.a)\n        if req.operation == Operation.pow:\n            if req.exponent is None:\n                raise HTTPException(status_code=400, detail='Missing exponent for pow operation')\n            result_bn = a_bn.pow(req.exponent)\n        else:\n            if req.b is None:\n                raise HTTPException(status_code=400, detail='Parameter b is required for the selected operation')\n            b_bn = BigNumber(req.b)\n            if req.operation == Operation.add:\n                result_bn = a_bn.add(b_bn)\n            elif req.operation == Operation.sub:\n                result_bn = a_bn.sub(b_bn)\n            elif req.operation == Operation.mul:\n                result_bn = a_bn.mul(b_bn)\n            elif req.operation == Operation.div:\n                result_bn = a_bn.div(b_bn)\n            else:\n                raise HTTPException(status_code=400, detail='Unsupported operation')\n    except (TypeError, ValueError, ZeroDivisionError) as e:\n        raise HTTPException(status_code=400, detail=str(e))\n\n    return {'result': str(result_bn)}\n",
            "usage": "const resp = await fetch('/api/bignumber/operate', {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ a: '1000000000000000000', b: '250000000000000000', operation: 'sub' })\n});\nconst data = await resp.json();\nconsole.log(data.result); // '750000000000000000'"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Step 4 exposes an endpoint to format raw BigNumber values into human-readable strings, similar to ethers.utils.formatUnits.",
            "code": "from decimal import Decimal, ROUND_DOWN\nfrom fastapi import FastAPI, HTTPException, Query\nfrom pydantic import BaseModel\nfrom big_number import BigNumber\n\napp = FastAPI()\n\nclass FormatResponse(BaseModel):\n    formatted: str\n\n@app.get('/api/bignumber/format', response_model=FormatResponse)\nasync def format_bignumber(value: str = Query(..., description='Raw big number value as string'),\n                           decimals: int = Query(18, description='Number of token decimals')):\n    '''Convert a raw integer amount into a human-readable decimal representation.'''\n    try:\n        raw_bn = BigNumber(value)\n        divisor_bn = BigNumber(10 ** decimals)\n        human_value = raw_bn.div(divisor_bn)\n        # Ensure fixed decimal places without scientific notation\n        quantize_str = '1.' + '0' * decimals\n        formatted = Decimal(str(human_value)).quantize(Decimal(quantize_str), rounding=ROUND_DOWN).normalize()\n    except (TypeError, ValueError, ZeroDivisionError) as e:\n        raise HTTPException(status_code=400, detail=str(e))\n    return {'formatted': format(formatted, 'f')}\n",
            "usage": "const resp = await fetch('/api/bignumber/format?value=1500000000000000000&decimals=18');\nconst data = await resp.json();\nconsole.log(data.formatted); // '1.5'"
        }
    ]
}