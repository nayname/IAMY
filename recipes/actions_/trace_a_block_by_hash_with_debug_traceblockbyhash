{
    "label": "others",
    "workflow": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Creates a small helper that receives the node\u2019s JSON-RPC URL and the desired block hash from the UI, then forwards both values to a backend API that performs the heavy JSON-RPC call.",
            "code": "/* eslint-disable no-undef */\n// src/utils/traceBlock.js\n// Helper to request an EVM block trace from the backend\nexport const traceBlockByHash = async ({ rpcUrl, blockHash }) => {\n  // Basic argument validation\n  if (!rpcUrl) throw new Error('Parameter \"rpcUrl\" is required');\n  if (!blockHash || !blockHash.startsWith('0x')) {\n    throw new Error('Parameter \"blockHash\" must be a 0x-prefixed hash');\n  }\n\n  // Send the request to the backend-for-frontend (BFF)\n  const res = await fetch('/api/traceBlockByHash', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify({ rpc_url: rpcUrl, block_hash: blockHash })\n  });\n\n  // Handle network-level errors\n  if (!res.ok) {\n    const { error } = await res.json().catch(() => ({ error: 'Unknown error' }));\n    throw new Error(error || 'Backend returned a non-200 status');\n  }\n\n  // Parse and return the trace result\n  const { trace } = await res.json();\n  return trace;\n};",
            "usage": "import { traceBlockByHash } from '../utils/traceBlock';\n\n(async () => {\n  try {\n    const trace = await traceBlockByHash({\n      rpcUrl: 'http://localhost:8545',\n      blockHash: '0xabc123\u2026' // replace with a real hash\n    });\n    console.log('EVM execution trace:', trace);\n  } catch (err) {\n    console.error('Trace failed:', err.message);\n  }\n})();"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Implements an API endpoint (`/api/traceBlockByHash`) that receives the RPC URL and block hash, performs the `debug_traceBlockByHash` JSON-RPC call, and returns the trace to the frontend.",
            "code": "############################################\n# file: app.py (Flask backend for Mintlify) #\n############################################\nimport os\nimport json\nimport requests\nfrom flask import Flask, request, jsonify\n\napp = Flask(__name__)\n\n@app.route('/api/traceBlockByHash', methods=['POST'])\ndef api_trace_block_by_hash():\n    \"\"\"Proxy for EVM `debug_traceBlockByHash`.\"\"\"\n    data = request.get_json(force=True)\n    rpc_url: str | None = data.get('rpc_url')\n    block_hash: str | None = data.get('block_hash')\n\n    # -------------------------\n    # Basic input validation\n    # -------------------------\n    if not rpc_url or not rpc_url.startswith(('http://', 'https://')):\n        return jsonify({'error': 'Valid rpc_url is required'}), 400\n\n    if not block_hash or not block_hash.startswith('0x') or len(block_hash) != 66:\n        return jsonify({'error': 'block_hash must be a 0x-prefixed 32-byte hash'}), 400\n\n    payload = {\n        'method': 'debug_traceBlockByHash',\n        'params': [block_hash, {}],  # Empty tracer object \u2192 default parity-style trace\n        'id': 1,\n        'jsonrpc': '2.0'\n    }\n\n    try:\n        # Forward the request to the given RPC endpoint\n        res = requests.post(rpc_url, json=payload, timeout=20)\n        res.raise_for_status()\n        body = res.json()\n\n        # Check for JSON-RPC error objects\n        if 'error' in body:\n            return jsonify({'error': body['error']}), 502  # Bad gateway\n\n        return jsonify({'trace': body['result']}), 200\n\n    except requests.exceptions.RequestException as err:\n        # Network-level or HTTP-level error\n        return jsonify({'error': str(err)}), 502\n\n\nif __name__ == '__main__':\n    # Bind on 0.0.0.0 so Mintlify can expose the port\n    app.run(host='0.0.0.0', port=int(os.getenv('PORT', 8000)))",
            "usage": "Start the backend (e.g. `python app.py`). The frontend will POST to `/api/traceBlockByHash` automatically via the helper from Step 1."
        }
    ]
}