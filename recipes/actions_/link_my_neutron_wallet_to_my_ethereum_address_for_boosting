{
    "tools": [
        {
            "step": 1,
            "label": "frontend",
            "introduction": "Retrieves the current user\u2019s Neutron bech32 address from the browser wallet.",
            "function": "getUserWalletAddress()",
            "usage": "const neutronAddr = await getUserWalletAddress();"
        },
        {
            "step": 2,
            "label": "frontend",
            "introduction": "Prompts the user for (or pastes) their destination Ethereum EOA address.",
            "function": "getUserEvmAddressInput()",
            "usage": "const ethAddr = getUserEvmAddressInput();"
        },
        {
            "step": 3,
            "label": "frontend",
            "introduction": "No implemented function was found to create an Ethereum signature in the current codebase.",
            "function": "undef",
            "usage": "undef"
        },
        {
            "step": 4,
            "label": "frontend",
            "introduction": "Builds a MsgExecuteContract object that carries the `{ link: { \u2026 } }` payload to the linking contract.",
            "function": "constructTxWasmExecute(senderAddress, contractAddress, msg, funds)",
            "usage": "const executeMsg = constructTxWasmExecute(neutronAddr, linkContract, { link: { eth_address: ethAddr, signature: sig } }, []);"
        },
        {
            "step": 5,
            "label": "frontend",
            "introduction": "Signs the execute message with the user\u2019s Neutron wallet and hands it to the backend for broadcasting.",
            "function": "signAndBroadcast(signer, senderAddress, messages, fee, memo)",
            "usage": "const txHash = await signAndBroadcast(signer, neutronAddr, [executeMsg], 'auto');"
        }
    ],
    "frontend": [
        "const neutronAddr = await getUserWalletAddress();//step: 1 Tool: get_user_wallet_address Desciption: Capture the user\u2019s Neutron address to be linked.",
        "const ethAddr = getUserEvmAddressInput();//step: 2 Tool: get_user_ethereum_address Desciption: Capture the user\u2019s Ethereum address (MetaMask or other EOA).",
        "undef//step: 3 Tool: generate_eth_signature Desciption: Have the user sign the message `\"Link:<NeutronAddr>\"` with their Ethereum private key (EIP-191) to prove ownership.",
        "const executeMsg = constructTxWasmExecute(neutronAddr, linkContract, { link: { eth_address: ethAddr, signature: sig } }, []);//step: 4 Tool: construct_wasm_execute_link_address Desciption: Create `{ \"link\": { \"eth_address\": \"<0x\u2026>\", \"signature\": \"<sig>\" } }` for the BTC-Summer address-linking contract.",
        "const txHash = await signAndBroadcast(signer, neutronAddr, [executeMsg], 'auto');//step: 5 Tool: sign_and_broadcast_tx Desciption: Sign with the Neutron wallet and broadcast the linking transaction."
    ],
    "backend": [],
    "intent": "Link my Neutron wallet to my Ethereum address for boosting",
    "workflow": [
        {
            "step": 1,
            "tool": "get_user_wallet_address",
            "description": "Capture the user\u2019s Neutron address to be linked."
        },
        {
            "step": 2,
            "tool": "get_user_ethereum_address",
            "description": "Capture the user\u2019s Ethereum address (MetaMask or other EOA)."
        },
        {
            "step": 3,
            "tool": "generate_eth_signature",
            "description": "Have the user sign the message `\"Link:<NeutronAddr>\"` with their Ethereum private key (EIP-191) to prove ownership."
        },
        {
            "step": 4,
            "tool": "construct_wasm_execute_link_address",
            "description": "Create `{ \"link\": { \"eth_address\": \"<0x\u2026>\", \"signature\": \"<sig>\" } }` for the BTC-Summer address-linking contract."
        },
        {
            "step": 5,
            "tool": "sign_and_broadcast_tx",
            "description": "Sign with the Neutron wallet and broadcast the linking transaction."
        }
    ],
    "outcome_checks": [
        "Transaction committed successfully.",
        "Query the linking contract: `linked(NeutronAddr) == EthereumAddr` and status `verified = true`."
    ]
}