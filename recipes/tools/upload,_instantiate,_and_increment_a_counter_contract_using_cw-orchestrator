{
    "tools": [
        {
            "step": 1,
            "label": "backend",
            "introduction": "Loads the deployer\u2019s mnemonic from environment variables so subsequent transactions can be signed.",
            "function": "load_signing_key()",
            "usage": "signing_key = load_signing_key()"
        },
        {
            "step": 2,
            "label": "backend",
            "introduction": "Compiles the CosmWasm contract and produces an optimised `.wasm` binary in the artifacts folder.",
            "function": "compile_wasm_contract(contract_dir)",
            "usage": "wasm_path = compile_wasm_contract(\"./contracts/counter\")"
        },
        {
            "step": 3,
            "label": "backend",
            "introduction": "Parses the StoreCode transaction response to obtain the newly assigned `code_id`.",
            "function": "extract_code_id_from_tx(response)",
            "usage": "code_id = extract_code_id_from_tx(store_tx_response)"
        },
        {
            "step": 4,
            "label": "backend",
            "introduction": "Constructs a MsgInstantiateContract transaction for the Counter contract using the returned `code_id`.",
            "function": "build_instantiate_tx(client, code_id, init_msg, label, admin=None)",
            "usage": "tx = build_instantiate_tx(client, code_id, {\"start\": 0}, \"counter\")"
        },
        {
            "step": 5,
            "label": "backend",
            "introduction": "Signs and broadcasts the prepared execute (increment) transaction to the chain.",
            "function": "sign_and_broadcast(tx, client)",
            "usage": "result = sign_and_broadcast(tx, client)"
        },
        {
            "step": 6,
            "label": "backend",
            "introduction": "Queries the deployed contract with a custom message to verify the updated counter value.",
            "function": "query_contract_state(client, contract_address, query_msg)",
            "usage": "count = query_contract_state(client, contract_addr, {\"get_count\": {}})"
        }
    ],
    "frontend": [],
    "backend": [
        "signing_key = load_signing_key()#step: 1 Tool: load_env Desciption: Read `.env` for `RPC_ENDPOINT`, `CHAIN_ID`, `DEPLOYER_MNEMONIC` and `GAS_PRICES` so cw-orch can sign and send transactions.",
        "wasm_path = compile_wasm_contract(\"./contracts/counter\")#step: 2 Tool: optimize_wasm Desciption: Run `cargo wasm && docker run --rm -v $(pwd):/code cosmtrek/wasm:optimizer .` to produce an optimized `.wasm` binary in `artifacts/`.",
        "code_id = extract_code_id_from_tx(store_tx_response)#step: 3 Tool: cw_orch_store_code Desciption: Inside a Rust script or test, call `deployer.upload_file(\"artifacts/counter.wasm\")?` to broadcast the `StoreCode` tx and retrieve the resulting `code_id`.",
        "tx = build_instantiate_tx(client, code_id, {\"start\": 0}, \"counter\")#step: 4 Tool: cw_orch_instantiate Desciption: Use `CounterContract::instantiate(code_id, \"counter\", &InstantiateMsg { start: 0 }, None, &[])?` to create the contract; capture the returned `contract_addr`.",
        "result = sign_and_broadcast(tx, client)#step: 5 Tool: cw_orch_execute Desciption: Execute `CounterContract::increment()` against `contract_addr` and await the tx result.",
        "count = query_contract_state(client, contract_addr, {\"get_count\": {}})#step: 6 Tool: cw_orch_query Desciption: Query the contract with `CounterContract::get_count()` (or equivalent) to verify the new counter value."
    ],
    "intent": "Upload, instantiate, and increment a counter contract using cw-orchestrator",
    "workflow": [
        {
            "step": 1,
            "tool": "load_env",
            "description": "Read `.env` for `RPC_ENDPOINT`, `CHAIN_ID`, `DEPLOYER_MNEMONIC` and `GAS_PRICES` so cw-orch can sign and send transactions."
        },
        {
            "step": 2,
            "tool": "optimize_wasm",
            "description": "Run `cargo wasm && docker run --rm -v $(pwd):/code cosmtrek/wasm:optimizer .` to produce an optimized `.wasm` binary in `artifacts/`."
        },
        {
            "step": 3,
            "tool": "cw_orch_store_code",
            "description": "Inside a Rust script or test, call `deployer.upload_file(\"artifacts/counter.wasm\")?` to broadcast the `StoreCode` tx and retrieve the resulting `code_id`."
        },
        {
            "step": 4,
            "tool": "cw_orch_instantiate",
            "description": "Use `CounterContract::instantiate(code_id, \"counter\", &InstantiateMsg { start: 0 }, None, &[])?` to create the contract; capture the returned `contract_addr`."
        },
        {
            "step": 5,
            "tool": "cw_orch_execute",
            "description": "Execute `CounterContract::increment()` against `contract_addr` and await the tx result."
        },
        {
            "step": 6,
            "tool": "cw_orch_query",
            "description": "Query the contract with `CounterContract::get_count()` (or equivalent) to verify the new counter value."
        }
    ],
    "outcome_checks": [
        "StoreCode tx included in a block and a non-zero code_id returned.",
        "Instantiate tx returns a contract address in `events[\"instantiate\"][\"_contract_address\"]`.",
        "Query after increment returns `count == 1`."
    ]
}